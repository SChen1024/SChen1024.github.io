{"meta":{"title":"東木 - 随笔","subtitle":"相信自己的每一分努力终将有所收获","description":"相信自己的每一分努力终将有所收获","author":"SChen1024","url":"https://schen1024.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2023-01-01T13:25:24.179Z","updated":"2023-01-01T13:25:24.179Z","comments":true,"path":"404.html","permalink":"https://schen1024.github.io/404.html","excerpt":"","text":"404很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"},{"title":"About Schen","date":"2019-01-25T09:26:45.000Z","updated":"2023-01-01T13:25:24.791Z","comments":true,"path":"about/index.html","permalink":"https://schen1024.github.io/about/index.html","excerpt":"","text":"关于本站每次尝试 blog 的时候 总是开始十分兴奋, 但是自己慢慢做着做着就放弃了, 导致自己越来越没兴趣去做这个了,但是,自己又经常有很多的想法想着能够发布,但是之后会慢慢花时间去填满这个 blog 吧, 作为自己的一个固定的技术 blog 吧,慢慢的总会更好的 , 加油! 本站目前存在的意义就是时不时的完成系统的构建 关于自己每次尝试 blog 的时候 总是开始十分兴奋, 但是自己慢慢做着做着就放弃了, 导致自己越来越没兴趣去做这个了,但是,自己又经常有很多的想法想着能够发布,但是之后会慢慢花时间去填满这个 blog 吧, 作为自己的一个固定的技术 blog 吧,慢慢的总会更好的 , 加油! 又是一次新的开始, 希望自己能再坚持就一点, 2022-1-29 新坑再2023-0101 的时候又再次想起了自己曾经的那些想法和计划， 想着重新捡起来， 做一些新的不同的东西， 那就继续加油， 继续坚持一下吧 2023-01-01 个人简历之后这边会附上自己作出的部分成果慢慢的添加自己的简历"},{"title":"所有分类","date":"2018-02-14T22:16:53.000Z","updated":"2023-01-01T13:25:24.792Z","comments":false,"path":"categories/index.html","permalink":"https://schen1024.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-01-01T13:25:24.792Z","updated":"2023-01-01T13:25:24.792Z","comments":true,"path":"friends/index.html","permalink":"https://schen1024.github.io/friends/index.html","excerpt":"","text":"日常学习过程中， 总会遇到各种人做的blog ， 我很喜欢这些写博客的人， 所以我会将看到的感觉有意思的blog 都 记录下来， 希望他们都能坚持下去， 我也能坚持下去， 一起加油。 在这里评论, 我会加入友情链接的….."},{"title":"所有标签","date":"2018-02-14T22:16:53.000Z","updated":"2023-01-01T13:25:24.806Z","comments":false,"path":"tags/index.html","permalink":"https://schen1024.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"去紫边算法","slug":"去紫边算法","date":"2020-08-12T09:56:45.000Z","updated":"2023-01-01T13:25:24.782Z","comments":true,"path":"2020/08-12/去紫边算法.html","link":"","permalink":"https://schen1024.github.io/2020/08-12/%E5%8E%BB%E7%B4%AB%E8%BE%B9%E7%AE%97%E6%B3%95.html","excerpt":"紫边成因相机原因color fringing 彩色边缘Chromatic Aberration 色差 相机的镜头和相机的传感器导致了紫边的出现，使得光产生衍射，出现绿、紫等色差，尤其在大光圈的情况下很容易出现。 https://zhuanlan.zhihu.com/p/55029984","text":"紫边成因相机原因color fringing 彩色边缘Chromatic Aberration 色差 相机的镜头和相机的传感器导致了紫边的出现，使得光产生衍射，出现绿、紫等色差，尤其在大光圈的情况下很容易出现。 https://zhuanlan.zhihu.com/p/55029984 触发条件高反差， 大背光图像时候容易出现， 焦前紫边，焦后绿边 解决方法LightRoom 去除修改照片 -&gt; 镜头校正 -&gt; 手动 -&gt; 去边 效果图展示 算法处理原理算法实现https://github.com/mjambon/purple-fringe从原始图像中的蓝色分量产生模糊的蒙版。使用以下约束，根据模糊蒙版中发现的强度从原始图像中减去一些蓝色和红色：蓝色电平可能不会低于绿色电平。红色电平可能不会低于绿色电平。红色：蓝色比率可能不会降至某个常数以下。 仅在比原始紫色成分亮的地方减去紫色蒙版。仅从有些紫色的区域中减去紫色，最多直到它们看起来为灰色为止。例如，从像（红色= 0.3，绿色= 0.1，蓝色= 0.3）这样的暗紫色像素中，我们可以考虑使用（0.25、0、0.25）的紫色条纹蒙版。如果直接减去此蒙版，我们将得到（0.05，0.1，0.05），现在像素会变绿！我们通过确保在最坏的情况下将像素变成灰色来避免这种情况。在这种情况下，我们得到的像素将是（0.1，0.1，0.1），这是深灰色而不是不希望的深绿色。 算法效果https://mjambon.github.io/mjambon2016/purple-fringe/examples.html","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"depurple","slug":"depurple","permalink":"https://schen1024.github.io/tags/depurple/"}]},{"title":"新硬盘入手","slug":"新硬盘入手","date":"2020-07-19T15:37:35.000Z","updated":"2023-01-01T13:25:24.788Z","comments":true,"path":"2020/07-19/新硬盘入手.html","link":"","permalink":"https://schen1024.github.io/2020/07-19/%E6%96%B0%E7%A1%AC%E7%9B%98%E5%85%A5%E6%89%8B.html","excerpt":"开始 在张大妈上看到的这款硬盘有优惠, https://www.smzdm.com/p/23057560/ 在小米有品上 https://www.xiaomiyoupin.com/detail?gid=121497&amp;source=smzdm_514_0_184__35d5f288db49ca2a_3.smzdm.514_0_184__35d5f288db49ca2a.1595749103578 购买的商品 顺丰到家, 拆机","text":"开始 在张大妈上看到的这款硬盘有优惠, https://www.smzdm.com/p/23057560/ 在小米有品上 https://www.xiaomiyoupin.com/detail?gid=121497&amp;source=smzdm_514_0_184__35d5f288db49ca2a_3.smzdm.514_0_184__35d5f288db49ca2a.1595749103578 购买的商品 顺丰到家, 拆机 根据 https://www.iplaysoft.com/disk-benchmark-tools.html 给出的软件进行硬件测试 这里有一个相关参数的内容信息, 够用就好 https://post.smzdm.com/p/626598/ 总结硬盘总体上比较垃圾, 但是够用就好.","categories":[{"name":"Person","slug":"Person","permalink":"https://schen1024.github.io/categories/Person/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://schen1024.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://schen1024.github.io/tags/blog/"},{"name":"cnblogs","slug":"cnblogs","permalink":"https://schen1024.github.io/tags/cnblogs/"},{"name":"csdn","slug":"csdn","permalink":"https://schen1024.github.io/tags/csdn/"}]},{"title":"神秘海域系列","slug":"神秘海域系列","date":"2020-06-26T18:20:09.000Z","updated":"2023-01-01T13:25:24.789Z","comments":true,"path":"2020/06-26/神秘海域系列.html","link":"","permalink":"https://schen1024.github.io/2020/06-26/%E7%A5%9E%E7%A7%98%E6%B5%B7%E5%9F%9F%E7%B3%BB%E5%88%97.html","excerpt":"游戏前准备 百度会员购买 https://detail.tmall.com/item.htm?id=586287059156&amp;ali_trackid=2:mm_121879788_43102803_282058237:1593166791_151_1837085262&amp;spm=a2e2e.10720394/brand2.90100100.002&amp;pvid=25089348&amp;ak=25089348 【福禄网络】您购买的百度网盘超级会员月卡活动激活码为:pyxp6sf2g9d42v9d，激活地址:https://url.cn/5wxMFXi，请在2020.6.28晚24点前激活使用，激活前请核对登录账号是否正确！ 游戏网盘链接： https://pan.baidu.com/share/link?shareid=1102752313&amp;uk=839856656#list/path=%2F 游戏内容","text":"游戏前准备 百度会员购买 https://detail.tmall.com/item.htm?id=586287059156&amp;ali_trackid=2:mm_121879788_43102803_282058237:1593166791_151_1837085262&amp;spm=a2e2e.10720394/brand2.90100100.002&amp;pvid=25089348&amp;ak=25089348 【福禄网络】您购买的百度网盘超级会员月卡活动激活码为:pyxp6sf2g9d42v9d，激活地址:https://url.cn/5wxMFXi，请在2020.6.28晚24点前激活使用，激活前请核对登录账号是否正确！ 游戏网盘链接： https://pan.baidu.com/share/link?shareid=1102752313&amp;uk=839856656#list/path=%2F 游戏内容","categories":[{"name":"Person","slug":"Person","permalink":"https://schen1024.github.io/categories/Person/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://schen1024.github.io/tags/blog/"},{"name":"game","slug":"game","permalink":"https://schen1024.github.io/tags/game/"}]},{"title":"opencv-13-直方图计算","slug":"opencv-13-直方图计算","date":"2020-05-21T00:36:37.000Z","updated":"2023-01-01T13:25:24.775Z","comments":true,"path":"2020/05-21/opencv-13-直方图计算.html","link":"","permalink":"https://schen1024.github.io/2020/05-21/opencv-13-%E7%9B%B4%E6%96%B9%E5%9B%BE%E8%AE%A1%E7%AE%97.html","excerpt":"开始之前在进行更多的算法操作之前， 有一个很有意思的数据或者工具需要我们提前学习，那就是 直方图 目录[toc] 本文目标 介绍直方图及其原理 算法实现直方图统计 将统计结果进行展示应用 实现基于直方图的图像均衡化 正文直方图原理与实现这是一个统计数据， 由基础可知，灰度一共分为256个层级， 给出一副灰度图，我们能够统计不同灰度等级的像素一共有多少个， 或者进一步的我们能够得到 总结其他","text":"开始之前在进行更多的算法操作之前， 有一个很有意思的数据或者工具需要我们提前学习，那就是 直方图 目录[toc] 本文目标 介绍直方图及其原理 算法实现直方图统计 将统计结果进行展示应用 实现基于直方图的图像均衡化 正文直方图原理与实现这是一个统计数据， 由基础可知，灰度一共分为256个层级， 给出一副灰度图，我们能够统计不同灰度等级的像素一共有多少个， 或者进一步的我们能够得到 总结其他","categories":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/categories/opencv/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/tags/opencv/"},{"name":"c++","slug":"c","permalink":"https://schen1024.github.io/tags/c/"},{"name":"histograms","slug":"histograms","permalink":"https://schen1024.github.io/tags/histograms/"}]},{"title":"opencv-12-高斯滤波-双边滤波(附C++代码实现)","slug":"opencv-12-filter","date":"2020-05-10T10:08:27.000Z","updated":"2023-01-01T13:25:24.774Z","comments":true,"path":"2020/05-10/opencv-12-filter.html","link":"","permalink":"https://schen1024.github.io/2020/05-10/opencv-12-filter.html","excerpt":"开始之前这几天由于自己的原因没有写, 一个是因为自己懒了, 一个是感觉这里遇到点问题不想往下写了, 我们先努力结束这个章节吧, 之前介绍了比较常用而且比较好理解的均值和中值滤波, 但是呢,在例程Smoothing Images, 还有给出的其他的滤波方式, 主要是高斯滤波和双边滤波, 我们这一次完结掉滤波与平滑的这个部分, 写的有点多了,反而不想再写了, 加油 目录[toc] 本文目标本文主要是介绍 高斯滤波 双边滤波 和之前介绍的一样, 我们仍然还是 介绍一下原理, 给出一下具体的形式, 然后使用 opencv 进行一下实现的过程, 最后使用我们之前的图像进行测试 进行算法的分析与总结. 正文高斯滤波(Gaussian Filter)我们在之前介绍了中值滤波是统计排序的结果, 属于非线性的结果, 均值滤波是使用模板核进行的操作, 我们在的文章中也提到了均值滤波在计算的过程中必须要考虑权重的问题, 进而提出了加权的均值滤波的操作, 比如最常见的加权均值滤波的操作核.$$M = \\frac{1}{16} \\left [ \\begin{array}{c} 1 &amp; 2 &amp; 1 \\ 2&amp; 4 &amp; 2 \\ 1 &amp; 2 &amp; 1 \\end{array}\\right ]$$ 其实呢,这个核也就是高斯滤波器在 3*3窗口的离散取整的结果值, 最明显的特点就是模板的系数随着距离模板中心的距离而变换, 能够有效的抑制噪声,平滑图像, 相比均值滤波能够更好的平滑图像, 保留图像边缘. 高斯滤波原理由于我们的图像是二维的, 但是高斯分布是一维的, 那我们先考虑一维的高斯分布, 就是我们常用的正太分布曲线,$$G(x) = \\frac{1}{\\sqrt{2\\pi \\sigma}} e^{-\\frac{x^2}{2\\sigma^2}}$$ 对于二维的高斯分布其实可以考虑成两个方向的运算相叠加的得到的结果$$G(x,y) = \\frac{1}{2\\pi \\sigma^2} e^{-\\frac{x^2+y^2}{2\\sigma^2}} = G(x)*G(y)$$ 考虑到图像的计算实际上是离散的座标, 对于窗口大小为 $(2k + 1) \\times (2k + 1)$ 模板, 我们可以表示成$$G{i,j} = \\frac{1}{2\\pi \\sigma ^ 2}e ^{-\\frac{(i - k - 1)^2 + (j - k - 1)^2}{2 \\sigma ^ 2}}$$ 可以参考图像处理基础(4)：高斯滤波器详解里面给出的方法, 使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127void generateGaussianTemplate(double window[][11], int ksize, double sigma)&#123; static const double pi = 3.1415926; int center = ksize / 2; // 模板的中心位置，也就是坐标的原点 double x2, y2; for (int i = 0; i &lt; ksize; i++) &#123; x2 = pow(i - center, 2); for (int j = 0; j &lt; ksize; j++) &#123; y2 = pow(j - center, 2); double g = exp(-(x2 + y2) / (2 * sigma * sigma)); g /= 2 * pi * sigma*sigma; // window[i][j] = g; &#125; &#125; double k = 1 / window[0][0]; // 将左上角的系数归一化为1 for (int i = 0; i &lt; ksize; i++) &#123; for (int j = 0; j &lt; ksize; j++) &#123; window[i][j] *= k; &#125; &#125;&#125;``` 生成了$3 \\times 3, \\sigma = 0.8$ 的高斯模板, 对应的将其取整就得到了$$M = \\frac&#123;1&#125;&#123;16&#125; \\left [ \\begin&#123;array&#125;&#123;c&#125; 1 &amp; 2 &amp; 1 \\\\ 2&amp; 4 &amp; 2 \\\\ 1 &amp; 2 &amp; 1 \\end&#123;array&#125;\\right ]$$上面给出的文章同样的详细介绍了 $\\sigma$ 在统计学中的意义, 可以去参考学习不过根据高中的知识, 我们可以看到 正态分布的曲线![正态分布曲线](https://gitee.com/schen00/BlogImage/raw/master/image/1589099908845.png)#### C++ 实现在我们之前提到的[图像处理基础(4)：高斯滤波器详解](https://www.cnblogs.com/wangguchangqing/p/6407717.html) 这里给出了基于 opencv 的代码实现, 这里是$O(m*n*k^2)$ 的算法实现```cpp// 来源链接: https://www.cnblogs.com/wangguchangqing/p/6407717.htmlvoid GaussianFilter(const Mat &amp;src, Mat &amp;dst, int ksize, double sigma)&#123; CV_Assert(src.channels() || src.channels() == 3); // 只处理单通道或者三通道图像 const static double pi = 3.1415926; // 根据窗口大小和sigma生成高斯滤波器模板 // 申请一个二维数组，存放生成的高斯模板矩阵 double **templateMatrix = new double*[ksize]; for (int i = 0; i &lt; ksize; i++) templateMatrix[i] = new double[ksize]; int origin = ksize / 2; // 以模板的中心为原点 double x2, y2; double sum = 0; for (int i = 0; i &lt; ksize; i++) &#123; x2 = pow(i - origin, 2); for (int j = 0; j &lt; ksize; j++) &#123; y2 = pow(j - origin, 2); // 高斯函数前的常数可以不用计算，会在归一化的过程中给消去 double g = exp(-(x2 + y2) / (2 * sigma * sigma)); sum += g; templateMatrix[i][j] = g; &#125; &#125; for (int i = 0; i &lt; ksize; i++) &#123; for (int j = 0; j &lt; ksize; j++) &#123; templateMatrix[i][j] /= sum; cout &lt;&lt; templateMatrix[i][j] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; // 将模板应用到图像中 int border = ksize / 2; copyMakeBorder(src, dst, border, border, border, border, BorderTypes::BORDER_REFLECT); int channels = dst.channels(); int rows = dst.rows - border; int cols = dst.cols - border; for (int i = border; i &lt; rows; i++) &#123; for (int j = border; j &lt; cols; j++) &#123; double sum[3] = &#123; 0 &#125;; for (int a = -border; a &lt;= border; a++) &#123; for (int b = -border; b &lt;= border; b++) &#123; if (channels == 1) &#123; sum[0] += templateMatrix[border + a][border + b] * dst.at&lt;uchar&gt;(i + a, j + b); &#125; else if (channels == 3) &#123; Vec3b rgb = dst.at&lt;Vec3b&gt;(i + a, j + b); auto k = templateMatrix[border + a][border + b]; sum[0] += k * rgb[0]; sum[1] += k * rgb[1]; sum[2] += k * rgb[2]; &#125; &#125; &#125; for (int k = 0; k &lt; channels; k++) &#123; if (sum[k] &lt; 0) sum[k] = 0; else if (sum[k] &gt; 255) sum[k] = 255; &#125; if (channels == 1) dst.at&lt;uchar&gt;(i, j) = static_cast&lt;uchar&gt;(sum[0]); else if (channels == 3) &#123; Vec3b rgb = &#123; static_cast&lt;uchar&gt;(sum[0]), static_cast&lt;uchar&gt;(sum[1]), static_cast&lt;uchar&gt;(sum[2]) &#125;; dst.at&lt;Vec3b&gt;(i, j) = rgb; &#125; &#125; &#125; // 释放模板数组 for (int i = 0; i &lt; ksize; i++) delete[] templateMatrix[i]; delete[] templateMatrix;&#125;然后同样的给出了分离的实现, 将图像进行水平运算之后再进行竖直运算, 计算的时间上会有一定的速度提升123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// 来源链接: https://www.cnblogs.com/wangguchangqing/p/6407717.html// 分离的计算void separateGaussianFilter(const Mat &amp;src, Mat &amp;dst, int ksize, double sigma)&#123; CV_Assert(src.channels()==1 || src.channels() == 3); // 只处理单通道或者三通道图像 // 生成一维的高斯滤波模板 double *matrix = new double[ksize]; double sum = 0; int origin = ksize / 2; for (int i = 0; i &lt; ksize; i++) &#123; // 高斯函数前的常数可以不用计算，会在归一化的过程中给消去 double g = exp(-(i - origin) * (i - origin) / (2 * sigma * sigma)); sum += g; matrix[i] = g; &#125; // 归一化 for (int i = 0; i &lt; ksize; i++) matrix[i] /= sum; // 将模板应用到图像中 int border = ksize / 2; copyMakeBorder(src, dst, border, border, border, border, BorderTypes::BORDER_REFLECT); int channels = dst.channels(); int rows = dst.rows - border; int cols = dst.cols - border; // 水平方向 for (int i = border; i &lt; rows; i++) &#123; for (int j = border; j &lt; cols; j++) &#123; double sum[3] = &#123; 0 &#125;; for (int k = -border; k &lt;= border; k++) &#123; if (channels == 1) &#123; sum[0] += matrix[border + k] * dst.at&lt;uchar&gt;(i, j + k); // 行不变，列变化；先做水平方向的卷积 &#125; else if (channels == 3) &#123; Vec3b rgb = dst.at&lt;Vec3b&gt;(i, j + k); sum[0] += matrix[border + k] * rgb[0]; sum[1] += matrix[border + k] * rgb[1]; sum[2] += matrix[border + k] * rgb[2]; &#125; &#125; for (int k = 0; k &lt; channels; k++) &#123; if (sum[k] &lt; 0) sum[k] = 0; else if (sum[k] &gt; 255) sum[k] = 255; &#125; if (channels == 1) dst.at&lt;uchar&gt;(i, j) = static_cast&lt;uchar&gt;(sum[0]); else if (channels == 3) &#123; Vec3b rgb = &#123; static_cast&lt;uchar&gt;(sum[0]), static_cast&lt;uchar&gt;(sum[1]), static_cast&lt;uchar&gt;(sum[2]) &#125;; dst.at&lt;Vec3b&gt;(i, j) = rgb; &#125; &#125; &#125; // 竖直方向 for (int i = border; i &lt; rows; i++) &#123; for (int j = border; j &lt; cols; j++) &#123; double sum[3] = &#123; 0 &#125;; for (int k = -border; k &lt;= border; k++) &#123; if (channels == 1) &#123; sum[0] += matrix[border + k] * dst.at&lt;uchar&gt;(i + k, j); // 列不变，行变化；竖直方向的卷积 &#125; else if (channels == 3) &#123; Vec3b rgb = dst.at&lt;Vec3b&gt;(i + k, j); sum[0] += matrix[border + k] * rgb[0]; sum[1] += matrix[border + k] * rgb[1]; sum[2] += matrix[border + k] * rgb[2]; &#125; &#125; for (int k = 0; k &lt; channels; k++) &#123; if (sum[k] &lt; 0) sum[k] = 0; else if (sum[k] &gt; 255) sum[k] = 255; &#125; if (channels == 1) dst.at&lt;uchar&gt;(i, j) = static_cast&lt;uchar&gt;(sum[0]); else if (channels == 3) &#123; Vec3b rgb = &#123; static_cast&lt;uchar&gt;(sum[0]), static_cast&lt;uchar&gt;(sum[1]), static_cast&lt;uchar&gt;(sum[2]) &#125;; dst.at&lt;Vec3b&gt;(i, j) = rgb; &#125; &#125; &#125; delete[] matrix;&#125; 这里的算法都是 上面提到的https://www.cnblogs.com/wangguchangqing/p/6407717.html 这篇文章, 具体可以去看内容 opencv 高斯滤波其实这篇文章图像处理–高斯滤波写的很好其实主要的结构也就是他给出的过程 其实整个高斯滤波的过程就是创建高斯核, 然后使用 filter2D 的方法进行的滤波操作, 具体要深入的话可以看函数的调用图, 实现起来也是一样的思路, 很简单的操作, 我们之后测试一下效果..1234// /modules\\imgproc\\src\\smooth.dispatch.cpp:600void GaussianBlur(InputArray _src, OutputArray _dst, Size ksize, double sigma1, double sigma2, int borderType) src ‪输入图像 dst 输出图像 ksize 核的尺寸 奇数 sigmaX x 方向 的 sigma 值 sigmaY ‪y 方向 的 sigma 值 borderType 边界处理的方式 高斯滤波效果对比我们还是使用之前的高椒盐噪声图像, 然后直接进行算法滤波, 计算结果就好, 跟之前的测试图像很相似, 这里 这里的四张图分别对应 高噪声图像, 直接高斯滤波的结果, 分离xy方向进行滤波结果,以及opencv 自带的高斯滤波效果图, 这里是预览图像, 实际的检测结果就是上面给出的参数值, 实际上效果只能说一般, 我们之后再进行算法层面的对比. 1234image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353image-noise: psnr:26.3155, mssim: B:0.584585 G:0.617172 R:0.812303image-noise: psnr:26.1721, mssim: B:0.574719 G:0.607494 R:0.809844image-noise: psnr:26.4206, mssim: B:0.598176 G:0.630657 R:0.819658 双边滤波(Bilateral Filter)双边滤波原理我们在上面提出了高斯滤波的原理是对于距离模板中心 距离不同给予不同的权重, 而双边滤波则不仅考虑图像的空间距离, 还要考虑其灰度距离, 对于越接近中间灰度值的点权重越高, 灰度值相差大的则权重更小. 双边滤波的原理可以参考双边滤波（Bilateral Filter）详解,可以参考Bilateral Filtering for Gray and Color Images 在文章图像处理基础(5)：双边滤波器详细介绍了双边滤波其实跟上面给出的滤波演示一致, 都是在保证图像边缘信息的情况下进行噪声的滤波.. 可以参考bilateral filter双边滤波器的通俗理解 给出的双边滤波的数学表达$$g(x,y) = \\frac{\\sum_{kl}f(k,l)w(i,j,k,l)}{\\sum_{kl}w(i,j,k,l)}$$ 对于不同的模板系数又有两个部分, 主要是 空间域模板权值 $w_d$ 和 灰度域 模板权值 $w_r$,$$\\begin{array}{rl}w_d(i,j,k,l) &amp;= e^{-\\frac{(i-k)^2 +(j-l)^2}{2\\sigma_d^2}} \\w_r(i,j,k,l) &amp;= e^{-\\frac{\\left | f(i,j) - f(k,l) \\right |} {2\\sigma_r^2}} \\w &amp;= w_d * w_r\\end{array}$$ 其中，$q(i,j)$ 为模板窗口的其他系数的坐标，$f(i,j)$ 表示图像在点$q(i,j)$ 处的像素值；$p(k,l)$ 为模板窗口的中心坐标点，对应的像素值为$f(k,l)$ ；$\\sigma_r$ 为高斯函数的标准差。 C++ 实现 双边滤波感觉这里写的挺好的 图像处理基础(5)：双边滤波器, 手动实现了双边滤波, 我们可以详细的参考, 这里 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// 参考来源: https://www.cnblogs.com/wangguchangqing/p/6416401.htmlvoid myBilateralFilter(const Mat &amp;src, Mat &amp;dst, int ksize, double space_sigma, double color_sigma)&#123; int channels = src.channels(); CV_Assert(channels == 1 || channels == 3); double space_coeff = -0.5 / (space_sigma * space_sigma); double color_coeff = -0.5 / (color_sigma * color_sigma); int radius = ksize / 2; Mat temp; copyMakeBorder(src, temp, radius, radius, radius, radius, BorderTypes::BORDER_REFLECT); vector&lt;double&gt; _color_weight(channels * 256); // 存放差值的平方 vector&lt;double&gt; _space_weight(ksize * ksize); // 空间模板系数 vector&lt;int&gt; _space_ofs(ksize * ksize); // 模板窗口的坐标 double *color_weight = &amp;_color_weight[0]; double *space_weight = &amp;_space_weight[0]; int *space_ofs = &amp;_space_ofs[0]; for (int i = 0; i &lt; channels * 256; i++) color_weight[i] = exp(i * i * color_coeff); // 生成空间模板 int maxk = 0; for (int i = -radius; i &lt;= radius; i++) &#123; for (int j = -radius; j &lt;= radius; j++) &#123; double r = sqrt(i*i + j * j); if (r &gt; radius) continue; space_weight[maxk] = exp(r * r * space_coeff); // 存放模板系数 space_ofs[maxk++] = i * temp.step + j * channels; // 存放模板的位置，和模板系数相对应 &#125; &#125; // 滤波过程 for (int i = 0; i &lt; src.rows; i++) &#123; const uchar *sptr = temp.data + (i + radius) * temp.step + radius * channels; uchar *dptr = dst.data + i * dst.step; if (channels == 1) &#123; for (int j = 0; j &lt; src.cols; j++) &#123; double sum = 0, wsum = 0; int val0 = sptr[j]; // 模板中心位置的像素 for (int k = 0; k &lt; maxk; k++) &#123; int val = sptr[j + space_ofs[k]]; double w = space_weight[k] * color_weight[abs(val - val0)]; // 模板系数 = 空间系数 * 灰度值系数 sum += val * w; wsum += w; &#125; dptr[j] = (uchar)cvRound(sum / wsum); &#125; &#125; else if (channels == 3) &#123; for (int j = 0; j &lt; src.cols * 3; j+=3) &#123; double sum_b = 0, sum_g = 0, sum_r = 0, wsum = 0; int b0 = sptr[j]; int g0 = sptr[j + 1]; int r0 = sptr[j + 2]; for (int k = 0; k &lt; maxk; k++) &#123; const uchar *sptr_k = sptr + j + space_ofs[k]; int b = sptr_k[0]; int g = sptr_k[1]; int r = sptr_k[2]; double w = space_weight[k] * color_weight[abs(b - b0) + abs(g - g0) + abs(r - r0)]; sum_b += b * w; sum_g += g * w; sum_r += r * w; wsum += w; &#125; wsum = 1.0f / wsum; b0 = cvRound(sum_b * wsum); g0 = cvRound(sum_g * wsum); r0 = cvRound(sum_r * wsum); dptr[j] = (uchar)b0; dptr[j + 1] = (uchar)g0; dptr[j + 2] = (uchar)r0; &#125; &#125; &#125;&#125; opencv 实现 双边滤波123void bilateralFilter( InputArray _src, OutputArray _dst, int d, double sigmaColor, double sigmaSpace, int borderType ) InputArray src: 输入图像，可以是Mat类型，图像必须是8位或浮点型单通道、三通道的图像。 OutputArray dst: 输出图像，和原图像有相同的尺寸和类型。 int d: 表示在过滤过程中每个像素邻域的直径范围。如果这个值是非正数，则函数会从第五个参数sigmaSpace计算该值。 double sigmaColor: 颜色空间过滤器的sigma值，这个参数的值月大，表明该像素邻域内有越宽广的颜色会被混合到一起，产生较大的半相等颜色区域。 （这个参数可以理解为值域核的） double sigmaSpace: 坐标空间中滤波器的sigma值，如果该值较大，则意味着越远的像素将相互影响，从而使更大的区域中足够相似的颜色获取相同的颜色。当d&gt;0时，d指定了邻域大小且与sigmaSpace无关，否则d正比于sigmaSpace. （这个参数可以理解为空间域核的） int borderType=BORDER_DEFAULT: 用于推断图像外部像素的某种边界模式，有默认值BORDER_DEFAULT. 双边滤波算法对比一开始的时候看双边滤波真的搞不懂, 也不知道这么做有什么目的, 最终的结果又代表什么, 我们按照之前的方法去测试我们的图像, 结果真的是几种算法中最差的了, 但是这只是说不适用于我们的图像结果, 在实际使用过程中还是要进行测试之后才能得出结论 测试结果如下: 对应原始图和 手动实现的结果以及 opencv 的结果 都使用的 是3 的窗口, sigma 的值 为 255, 这篇文章https://blog.csdn.net/Jfuck/article/details/8932978 讲的很好, 介绍了参数对滤波的影响, 可以学习一下..123image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353image-noise: psnr:24.4502, mssim: B:0.538774 G:0.570666 R:0.776195image-noise: psnr:24.4691, mssim: B:0.539177 G:0.571087 R:0.776461 总结其实个人使用双边滤波真的不算很多, 在之前研究导向滤波的时候才了解过很多, 这里写的比较差吧, 只能说勉强能看, 强烈推荐 https://www.cnblogs.com/wangguchangqing/category/740760.html 这个系列, 将的很详细, 很多都是博文里面的内容, 可以参考学习, 高斯滤波就比较简单了, 其实复杂的滤波过程主要是理解算法, 然后根据算法的思路进行代码的实现过程, 最后做一定的程序上的优化就好, 理解第一, 实现其次.. 希望带给读者一点点启发.. 我这里一开始不准备写这么多的, 结果越写越多, 导致自己收不住了, 很多自己说不上很了解的地方, 这一次也是深入的了解了一下, 但是还是很僵硬, 只能说能用而已, 这里还是推荐看我给出的链接或者自己去查阅相关的内容, 我这里只是给出一个大略的介绍, 如果有错误还请指名, 十分感谢 参考链接 《快速高斯滤波、高斯模糊、高斯平滑(二维卷积分步为一维卷积)人工智能青城山小和尚-CSDN博客》. 见于 2020年5月10日. https://blog.csdn.net/qq_36359022/article/details/80188873. 《双边滤波 - 旗亭涉的博客 | Qitingshe Blog》. 见于 2020年5月10日. https://qitingshe.github.io/2018/06/14/%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2/. 《双边滤波（Bilateral Filter）详解_人工智能_Jfuck的专栏-CSDN博客》. 见于 2020年5月10日. https://blog.csdn.net/Jfuck/article/details/8932978. 《雙邊濾波器》. 收入 维基百科，自由的百科全书, 2019年11月16日. https://zh.wikipedia.org/w/index.php?title=%E9%9B%99%E9%82%8A%E6%BF%BE%E6%B3%A2%E5%99%A8&amp;oldid=56898678. 《图像处理–高斯滤波_网络_L-inYi的专栏-CSDN博客》. 见于 2020年5月10日. https://blog.csdn.net/L_inYi/article/details/8915116. 《图像处理基础(4)：高斯滤波器详解 - Brook_icv - 博客园》. 见于 2020年5月10日. https://www.cnblogs.com/wangguchangqing/p/6407717.html. 《图像处理基础(5)：双边滤波器 - Brook_icv - 博客园》. 见于 2020年5月10日. https://www.cnblogs.com/wangguchangqing/p/6416401.html. 《图像处理－线性滤波－3 高斯滤波器 - Tony Ma - 博客园》. 见于 2020年5月10日. https://www.cnblogs.com/pegasus/archive/2011/05/20/2052031.html. 《【转】高斯图像滤波原理及其编程离散化实现方法_Smile_Gogo_新浪博客》. 见于 2020年5月10日. http://blog.sina.com.cn/s/blog_640577ed0100yz8v.html. 《bilateral filter双边滤波器的通俗理解_网络_pan_jinquan的博客-CSDN博客》. 见于 2020年5月10日. https://blog.csdn.net/guyuealian/article/details/82660826. 《Bilateral Filtering》. 见于 2020年5月10日. http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html. 《Cv图像处理 - OpenCV China ：图像处理,计算机视觉库,Image Processing, Computer Vision》. 见于 2020年5月10日. http://wiki.opencv.org.cn/index.php/Cv%e5%9b%be%e5%83%8f%e5%a4%84%e7%90%86. 《o(1)复杂度之双边滤波算法的原理、流程、实现及效果。 - 云+社区 - 腾讯云》. 见于 2020年5月10日. https://cloud.tencent.com/developer/article/1011738.","text":"开始之前这几天由于自己的原因没有写, 一个是因为自己懒了, 一个是感觉这里遇到点问题不想往下写了, 我们先努力结束这个章节吧, 之前介绍了比较常用而且比较好理解的均值和中值滤波, 但是呢,在例程Smoothing Images, 还有给出的其他的滤波方式, 主要是高斯滤波和双边滤波, 我们这一次完结掉滤波与平滑的这个部分, 写的有点多了,反而不想再写了, 加油 目录[toc] 本文目标本文主要是介绍 高斯滤波 双边滤波 和之前介绍的一样, 我们仍然还是 介绍一下原理, 给出一下具体的形式, 然后使用 opencv 进行一下实现的过程, 最后使用我们之前的图像进行测试 进行算法的分析与总结. 正文高斯滤波(Gaussian Filter)我们在之前介绍了中值滤波是统计排序的结果, 属于非线性的结果, 均值滤波是使用模板核进行的操作, 我们在的文章中也提到了均值滤波在计算的过程中必须要考虑权重的问题, 进而提出了加权的均值滤波的操作, 比如最常见的加权均值滤波的操作核.$$M = \\frac{1}{16} \\left [ \\begin{array}{c} 1 &amp; 2 &amp; 1 \\ 2&amp; 4 &amp; 2 \\ 1 &amp; 2 &amp; 1 \\end{array}\\right ]$$ 其实呢,这个核也就是高斯滤波器在 3*3窗口的离散取整的结果值, 最明显的特点就是模板的系数随着距离模板中心的距离而变换, 能够有效的抑制噪声,平滑图像, 相比均值滤波能够更好的平滑图像, 保留图像边缘. 高斯滤波原理由于我们的图像是二维的, 但是高斯分布是一维的, 那我们先考虑一维的高斯分布, 就是我们常用的正太分布曲线,$$G(x) = \\frac{1}{\\sqrt{2\\pi \\sigma}} e^{-\\frac{x^2}{2\\sigma^2}}$$ 对于二维的高斯分布其实可以考虑成两个方向的运算相叠加的得到的结果$$G(x,y) = \\frac{1}{2\\pi \\sigma^2} e^{-\\frac{x^2+y^2}{2\\sigma^2}} = G(x)*G(y)$$ 考虑到图像的计算实际上是离散的座标, 对于窗口大小为 $(2k + 1) \\times (2k + 1)$ 模板, 我们可以表示成$$G{i,j} = \\frac{1}{2\\pi \\sigma ^ 2}e ^{-\\frac{(i - k - 1)^2 + (j - k - 1)^2}{2 \\sigma ^ 2}}$$ 可以参考图像处理基础(4)：高斯滤波器详解里面给出的方法, 使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127void generateGaussianTemplate(double window[][11], int ksize, double sigma)&#123; static const double pi = 3.1415926; int center = ksize / 2; // 模板的中心位置，也就是坐标的原点 double x2, y2; for (int i = 0; i &lt; ksize; i++) &#123; x2 = pow(i - center, 2); for (int j = 0; j &lt; ksize; j++) &#123; y2 = pow(j - center, 2); double g = exp(-(x2 + y2) / (2 * sigma * sigma)); g /= 2 * pi * sigma*sigma; // window[i][j] = g; &#125; &#125; double k = 1 / window[0][0]; // 将左上角的系数归一化为1 for (int i = 0; i &lt; ksize; i++) &#123; for (int j = 0; j &lt; ksize; j++) &#123; window[i][j] *= k; &#125; &#125;&#125;``` 生成了$3 \\times 3, \\sigma = 0.8$ 的高斯模板, 对应的将其取整就得到了$$M = \\frac&#123;1&#125;&#123;16&#125; \\left [ \\begin&#123;array&#125;&#123;c&#125; 1 &amp; 2 &amp; 1 \\\\ 2&amp; 4 &amp; 2 \\\\ 1 &amp; 2 &amp; 1 \\end&#123;array&#125;\\right ]$$上面给出的文章同样的详细介绍了 $\\sigma$ 在统计学中的意义, 可以去参考学习不过根据高中的知识, 我们可以看到 正态分布的曲线![正态分布曲线](https://gitee.com/schen00/BlogImage/raw/master/image/1589099908845.png)#### C++ 实现在我们之前提到的[图像处理基础(4)：高斯滤波器详解](https://www.cnblogs.com/wangguchangqing/p/6407717.html) 这里给出了基于 opencv 的代码实现, 这里是$O(m*n*k^2)$ 的算法实现```cpp// 来源链接: https://www.cnblogs.com/wangguchangqing/p/6407717.htmlvoid GaussianFilter(const Mat &amp;src, Mat &amp;dst, int ksize, double sigma)&#123; CV_Assert(src.channels() || src.channels() == 3); // 只处理单通道或者三通道图像 const static double pi = 3.1415926; // 根据窗口大小和sigma生成高斯滤波器模板 // 申请一个二维数组，存放生成的高斯模板矩阵 double **templateMatrix = new double*[ksize]; for (int i = 0; i &lt; ksize; i++) templateMatrix[i] = new double[ksize]; int origin = ksize / 2; // 以模板的中心为原点 double x2, y2; double sum = 0; for (int i = 0; i &lt; ksize; i++) &#123; x2 = pow(i - origin, 2); for (int j = 0; j &lt; ksize; j++) &#123; y2 = pow(j - origin, 2); // 高斯函数前的常数可以不用计算，会在归一化的过程中给消去 double g = exp(-(x2 + y2) / (2 * sigma * sigma)); sum += g; templateMatrix[i][j] = g; &#125; &#125; for (int i = 0; i &lt; ksize; i++) &#123; for (int j = 0; j &lt; ksize; j++) &#123; templateMatrix[i][j] /= sum; cout &lt;&lt; templateMatrix[i][j] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; // 将模板应用到图像中 int border = ksize / 2; copyMakeBorder(src, dst, border, border, border, border, BorderTypes::BORDER_REFLECT); int channels = dst.channels(); int rows = dst.rows - border; int cols = dst.cols - border; for (int i = border; i &lt; rows; i++) &#123; for (int j = border; j &lt; cols; j++) &#123; double sum[3] = &#123; 0 &#125;; for (int a = -border; a &lt;= border; a++) &#123; for (int b = -border; b &lt;= border; b++) &#123; if (channels == 1) &#123; sum[0] += templateMatrix[border + a][border + b] * dst.at&lt;uchar&gt;(i + a, j + b); &#125; else if (channels == 3) &#123; Vec3b rgb = dst.at&lt;Vec3b&gt;(i + a, j + b); auto k = templateMatrix[border + a][border + b]; sum[0] += k * rgb[0]; sum[1] += k * rgb[1]; sum[2] += k * rgb[2]; &#125; &#125; &#125; for (int k = 0; k &lt; channels; k++) &#123; if (sum[k] &lt; 0) sum[k] = 0; else if (sum[k] &gt; 255) sum[k] = 255; &#125; if (channels == 1) dst.at&lt;uchar&gt;(i, j) = static_cast&lt;uchar&gt;(sum[0]); else if (channels == 3) &#123; Vec3b rgb = &#123; static_cast&lt;uchar&gt;(sum[0]), static_cast&lt;uchar&gt;(sum[1]), static_cast&lt;uchar&gt;(sum[2]) &#125;; dst.at&lt;Vec3b&gt;(i, j) = rgb; &#125; &#125; &#125; // 释放模板数组 for (int i = 0; i &lt; ksize; i++) delete[] templateMatrix[i]; delete[] templateMatrix;&#125;然后同样的给出了分离的实现, 将图像进行水平运算之后再进行竖直运算, 计算的时间上会有一定的速度提升123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// 来源链接: https://www.cnblogs.com/wangguchangqing/p/6407717.html// 分离的计算void separateGaussianFilter(const Mat &amp;src, Mat &amp;dst, int ksize, double sigma)&#123; CV_Assert(src.channels()==1 || src.channels() == 3); // 只处理单通道或者三通道图像 // 生成一维的高斯滤波模板 double *matrix = new double[ksize]; double sum = 0; int origin = ksize / 2; for (int i = 0; i &lt; ksize; i++) &#123; // 高斯函数前的常数可以不用计算，会在归一化的过程中给消去 double g = exp(-(i - origin) * (i - origin) / (2 * sigma * sigma)); sum += g; matrix[i] = g; &#125; // 归一化 for (int i = 0; i &lt; ksize; i++) matrix[i] /= sum; // 将模板应用到图像中 int border = ksize / 2; copyMakeBorder(src, dst, border, border, border, border, BorderTypes::BORDER_REFLECT); int channels = dst.channels(); int rows = dst.rows - border; int cols = dst.cols - border; // 水平方向 for (int i = border; i &lt; rows; i++) &#123; for (int j = border; j &lt; cols; j++) &#123; double sum[3] = &#123; 0 &#125;; for (int k = -border; k &lt;= border; k++) &#123; if (channels == 1) &#123; sum[0] += matrix[border + k] * dst.at&lt;uchar&gt;(i, j + k); // 行不变，列变化；先做水平方向的卷积 &#125; else if (channels == 3) &#123; Vec3b rgb = dst.at&lt;Vec3b&gt;(i, j + k); sum[0] += matrix[border + k] * rgb[0]; sum[1] += matrix[border + k] * rgb[1]; sum[2] += matrix[border + k] * rgb[2]; &#125; &#125; for (int k = 0; k &lt; channels; k++) &#123; if (sum[k] &lt; 0) sum[k] = 0; else if (sum[k] &gt; 255) sum[k] = 255; &#125; if (channels == 1) dst.at&lt;uchar&gt;(i, j) = static_cast&lt;uchar&gt;(sum[0]); else if (channels == 3) &#123; Vec3b rgb = &#123; static_cast&lt;uchar&gt;(sum[0]), static_cast&lt;uchar&gt;(sum[1]), static_cast&lt;uchar&gt;(sum[2]) &#125;; dst.at&lt;Vec3b&gt;(i, j) = rgb; &#125; &#125; &#125; // 竖直方向 for (int i = border; i &lt; rows; i++) &#123; for (int j = border; j &lt; cols; j++) &#123; double sum[3] = &#123; 0 &#125;; for (int k = -border; k &lt;= border; k++) &#123; if (channels == 1) &#123; sum[0] += matrix[border + k] * dst.at&lt;uchar&gt;(i + k, j); // 列不变，行变化；竖直方向的卷积 &#125; else if (channels == 3) &#123; Vec3b rgb = dst.at&lt;Vec3b&gt;(i + k, j); sum[0] += matrix[border + k] * rgb[0]; sum[1] += matrix[border + k] * rgb[1]; sum[2] += matrix[border + k] * rgb[2]; &#125; &#125; for (int k = 0; k &lt; channels; k++) &#123; if (sum[k] &lt; 0) sum[k] = 0; else if (sum[k] &gt; 255) sum[k] = 255; &#125; if (channels == 1) dst.at&lt;uchar&gt;(i, j) = static_cast&lt;uchar&gt;(sum[0]); else if (channels == 3) &#123; Vec3b rgb = &#123; static_cast&lt;uchar&gt;(sum[0]), static_cast&lt;uchar&gt;(sum[1]), static_cast&lt;uchar&gt;(sum[2]) &#125;; dst.at&lt;Vec3b&gt;(i, j) = rgb; &#125; &#125; &#125; delete[] matrix;&#125; 这里的算法都是 上面提到的https://www.cnblogs.com/wangguchangqing/p/6407717.html 这篇文章, 具体可以去看内容 opencv 高斯滤波其实这篇文章图像处理–高斯滤波写的很好其实主要的结构也就是他给出的过程 其实整个高斯滤波的过程就是创建高斯核, 然后使用 filter2D 的方法进行的滤波操作, 具体要深入的话可以看函数的调用图, 实现起来也是一样的思路, 很简单的操作, 我们之后测试一下效果..1234// /modules\\imgproc\\src\\smooth.dispatch.cpp:600void GaussianBlur(InputArray _src, OutputArray _dst, Size ksize, double sigma1, double sigma2, int borderType) src ‪输入图像 dst 输出图像 ksize 核的尺寸 奇数 sigmaX x 方向 的 sigma 值 sigmaY ‪y 方向 的 sigma 值 borderType 边界处理的方式 高斯滤波效果对比我们还是使用之前的高椒盐噪声图像, 然后直接进行算法滤波, 计算结果就好, 跟之前的测试图像很相似, 这里 这里的四张图分别对应 高噪声图像, 直接高斯滤波的结果, 分离xy方向进行滤波结果,以及opencv 自带的高斯滤波效果图, 这里是预览图像, 实际的检测结果就是上面给出的参数值, 实际上效果只能说一般, 我们之后再进行算法层面的对比. 1234image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353image-noise: psnr:26.3155, mssim: B:0.584585 G:0.617172 R:0.812303image-noise: psnr:26.1721, mssim: B:0.574719 G:0.607494 R:0.809844image-noise: psnr:26.4206, mssim: B:0.598176 G:0.630657 R:0.819658 双边滤波(Bilateral Filter)双边滤波原理我们在上面提出了高斯滤波的原理是对于距离模板中心 距离不同给予不同的权重, 而双边滤波则不仅考虑图像的空间距离, 还要考虑其灰度距离, 对于越接近中间灰度值的点权重越高, 灰度值相差大的则权重更小. 双边滤波的原理可以参考双边滤波（Bilateral Filter）详解,可以参考Bilateral Filtering for Gray and Color Images 在文章图像处理基础(5)：双边滤波器详细介绍了双边滤波其实跟上面给出的滤波演示一致, 都是在保证图像边缘信息的情况下进行噪声的滤波.. 可以参考bilateral filter双边滤波器的通俗理解 给出的双边滤波的数学表达$$g(x,y) = \\frac{\\sum_{kl}f(k,l)w(i,j,k,l)}{\\sum_{kl}w(i,j,k,l)}$$ 对于不同的模板系数又有两个部分, 主要是 空间域模板权值 $w_d$ 和 灰度域 模板权值 $w_r$,$$\\begin{array}{rl}w_d(i,j,k,l) &amp;= e^{-\\frac{(i-k)^2 +(j-l)^2}{2\\sigma_d^2}} \\w_r(i,j,k,l) &amp;= e^{-\\frac{\\left | f(i,j) - f(k,l) \\right |} {2\\sigma_r^2}} \\w &amp;= w_d * w_r\\end{array}$$ 其中，$q(i,j)$ 为模板窗口的其他系数的坐标，$f(i,j)$ 表示图像在点$q(i,j)$ 处的像素值；$p(k,l)$ 为模板窗口的中心坐标点，对应的像素值为$f(k,l)$ ；$\\sigma_r$ 为高斯函数的标准差。 C++ 实现 双边滤波感觉这里写的挺好的 图像处理基础(5)：双边滤波器, 手动实现了双边滤波, 我们可以详细的参考, 这里 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// 参考来源: https://www.cnblogs.com/wangguchangqing/p/6416401.htmlvoid myBilateralFilter(const Mat &amp;src, Mat &amp;dst, int ksize, double space_sigma, double color_sigma)&#123; int channels = src.channels(); CV_Assert(channels == 1 || channels == 3); double space_coeff = -0.5 / (space_sigma * space_sigma); double color_coeff = -0.5 / (color_sigma * color_sigma); int radius = ksize / 2; Mat temp; copyMakeBorder(src, temp, radius, radius, radius, radius, BorderTypes::BORDER_REFLECT); vector&lt;double&gt; _color_weight(channels * 256); // 存放差值的平方 vector&lt;double&gt; _space_weight(ksize * ksize); // 空间模板系数 vector&lt;int&gt; _space_ofs(ksize * ksize); // 模板窗口的坐标 double *color_weight = &amp;_color_weight[0]; double *space_weight = &amp;_space_weight[0]; int *space_ofs = &amp;_space_ofs[0]; for (int i = 0; i &lt; channels * 256; i++) color_weight[i] = exp(i * i * color_coeff); // 生成空间模板 int maxk = 0; for (int i = -radius; i &lt;= radius; i++) &#123; for (int j = -radius; j &lt;= radius; j++) &#123; double r = sqrt(i*i + j * j); if (r &gt; radius) continue; space_weight[maxk] = exp(r * r * space_coeff); // 存放模板系数 space_ofs[maxk++] = i * temp.step + j * channels; // 存放模板的位置，和模板系数相对应 &#125; &#125; // 滤波过程 for (int i = 0; i &lt; src.rows; i++) &#123; const uchar *sptr = temp.data + (i + radius) * temp.step + radius * channels; uchar *dptr = dst.data + i * dst.step; if (channels == 1) &#123; for (int j = 0; j &lt; src.cols; j++) &#123; double sum = 0, wsum = 0; int val0 = sptr[j]; // 模板中心位置的像素 for (int k = 0; k &lt; maxk; k++) &#123; int val = sptr[j + space_ofs[k]]; double w = space_weight[k] * color_weight[abs(val - val0)]; // 模板系数 = 空间系数 * 灰度值系数 sum += val * w; wsum += w; &#125; dptr[j] = (uchar)cvRound(sum / wsum); &#125; &#125; else if (channels == 3) &#123; for (int j = 0; j &lt; src.cols * 3; j+=3) &#123; double sum_b = 0, sum_g = 0, sum_r = 0, wsum = 0; int b0 = sptr[j]; int g0 = sptr[j + 1]; int r0 = sptr[j + 2]; for (int k = 0; k &lt; maxk; k++) &#123; const uchar *sptr_k = sptr + j + space_ofs[k]; int b = sptr_k[0]; int g = sptr_k[1]; int r = sptr_k[2]; double w = space_weight[k] * color_weight[abs(b - b0) + abs(g - g0) + abs(r - r0)]; sum_b += b * w; sum_g += g * w; sum_r += r * w; wsum += w; &#125; wsum = 1.0f / wsum; b0 = cvRound(sum_b * wsum); g0 = cvRound(sum_g * wsum); r0 = cvRound(sum_r * wsum); dptr[j] = (uchar)b0; dptr[j + 1] = (uchar)g0; dptr[j + 2] = (uchar)r0; &#125; &#125; &#125;&#125; opencv 实现 双边滤波123void bilateralFilter( InputArray _src, OutputArray _dst, int d, double sigmaColor, double sigmaSpace, int borderType ) InputArray src: 输入图像，可以是Mat类型，图像必须是8位或浮点型单通道、三通道的图像。 OutputArray dst: 输出图像，和原图像有相同的尺寸和类型。 int d: 表示在过滤过程中每个像素邻域的直径范围。如果这个值是非正数，则函数会从第五个参数sigmaSpace计算该值。 double sigmaColor: 颜色空间过滤器的sigma值，这个参数的值月大，表明该像素邻域内有越宽广的颜色会被混合到一起，产生较大的半相等颜色区域。 （这个参数可以理解为值域核的） double sigmaSpace: 坐标空间中滤波器的sigma值，如果该值较大，则意味着越远的像素将相互影响，从而使更大的区域中足够相似的颜色获取相同的颜色。当d&gt;0时，d指定了邻域大小且与sigmaSpace无关，否则d正比于sigmaSpace. （这个参数可以理解为空间域核的） int borderType=BORDER_DEFAULT: 用于推断图像外部像素的某种边界模式，有默认值BORDER_DEFAULT. 双边滤波算法对比一开始的时候看双边滤波真的搞不懂, 也不知道这么做有什么目的, 最终的结果又代表什么, 我们按照之前的方法去测试我们的图像, 结果真的是几种算法中最差的了, 但是这只是说不适用于我们的图像结果, 在实际使用过程中还是要进行测试之后才能得出结论 测试结果如下: 对应原始图和 手动实现的结果以及 opencv 的结果 都使用的 是3 的窗口, sigma 的值 为 255, 这篇文章https://blog.csdn.net/Jfuck/article/details/8932978 讲的很好, 介绍了参数对滤波的影响, 可以学习一下..123image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353image-noise: psnr:24.4502, mssim: B:0.538774 G:0.570666 R:0.776195image-noise: psnr:24.4691, mssim: B:0.539177 G:0.571087 R:0.776461 总结其实个人使用双边滤波真的不算很多, 在之前研究导向滤波的时候才了解过很多, 这里写的比较差吧, 只能说勉强能看, 强烈推荐 https://www.cnblogs.com/wangguchangqing/category/740760.html 这个系列, 将的很详细, 很多都是博文里面的内容, 可以参考学习, 高斯滤波就比较简单了, 其实复杂的滤波过程主要是理解算法, 然后根据算法的思路进行代码的实现过程, 最后做一定的程序上的优化就好, 理解第一, 实现其次.. 希望带给读者一点点启发.. 我这里一开始不准备写这么多的, 结果越写越多, 导致自己收不住了, 很多自己说不上很了解的地方, 这一次也是深入的了解了一下, 但是还是很僵硬, 只能说能用而已, 这里还是推荐看我给出的链接或者自己去查阅相关的内容, 我这里只是给出一个大略的介绍, 如果有错误还请指名, 十分感谢 参考链接 《快速高斯滤波、高斯模糊、高斯平滑(二维卷积分步为一维卷积)人工智能青城山小和尚-CSDN博客》. 见于 2020年5月10日. https://blog.csdn.net/qq_36359022/article/details/80188873. 《双边滤波 - 旗亭涉的博客 | Qitingshe Blog》. 见于 2020年5月10日. https://qitingshe.github.io/2018/06/14/%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2/. 《双边滤波（Bilateral Filter）详解_人工智能_Jfuck的专栏-CSDN博客》. 见于 2020年5月10日. https://blog.csdn.net/Jfuck/article/details/8932978. 《雙邊濾波器》. 收入 维基百科，自由的百科全书, 2019年11月16日. https://zh.wikipedia.org/w/index.php?title=%E9%9B%99%E9%82%8A%E6%BF%BE%E6%B3%A2%E5%99%A8&amp;oldid=56898678. 《图像处理–高斯滤波_网络_L-inYi的专栏-CSDN博客》. 见于 2020年5月10日. https://blog.csdn.net/L_inYi/article/details/8915116. 《图像处理基础(4)：高斯滤波器详解 - Brook_icv - 博客园》. 见于 2020年5月10日. https://www.cnblogs.com/wangguchangqing/p/6407717.html. 《图像处理基础(5)：双边滤波器 - Brook_icv - 博客园》. 见于 2020年5月10日. https://www.cnblogs.com/wangguchangqing/p/6416401.html. 《图像处理－线性滤波－3 高斯滤波器 - Tony Ma - 博客园》. 见于 2020年5月10日. https://www.cnblogs.com/pegasus/archive/2011/05/20/2052031.html. 《【转】高斯图像滤波原理及其编程离散化实现方法_Smile_Gogo_新浪博客》. 见于 2020年5月10日. http://blog.sina.com.cn/s/blog_640577ed0100yz8v.html. 《bilateral filter双边滤波器的通俗理解_网络_pan_jinquan的博客-CSDN博客》. 见于 2020年5月10日. https://blog.csdn.net/guyuealian/article/details/82660826. 《Bilateral Filtering》. 见于 2020年5月10日. http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html. 《Cv图像处理 - OpenCV China ：图像处理,计算机视觉库,Image Processing, Computer Vision》. 见于 2020年5月10日. http://wiki.opencv.org.cn/index.php/Cv%e5%9b%be%e5%83%8f%e5%a4%84%e7%90%86. 《o(1)复杂度之双边滤波算法的原理、流程、实现及效果。 - 云+社区 - 腾讯云》. 见于 2020年5月10日. https://cloud.tencent.com/developer/article/1011738.","categories":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/categories/opencv/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/tags/opencv/"},{"name":"c++","slug":"c","permalink":"https://schen1024.github.io/tags/c/"},{"name":"qt","slug":"qt","permalink":"https://schen1024.github.io/tags/qt/"}]},{"title":"opencv-11-中值滤波及自适应中值滤波","slug":"opencv-11-中值滤波","date":"2020-05-02T14:37:12.000Z","updated":"2023-01-01T13:25:24.774Z","comments":true,"path":"2020/05-02/opencv-11-中值滤波.html","link":"","permalink":"https://schen1024.github.io/2020/05-02/opencv-11-%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2.html","excerpt":"开始之前在上一篇我们实现了读取噪声图像, 然后 进行三种形式的均值滤波得到结果, 由于我们自己写的均值滤波未作边缘处理, 所以效果有一定的下降, 但是总体来说, 我们得到的结果能够说明我们的算法执行之后得到的图像噪声更低, 图像更清晰. 但是也会造成图像的模糊, 导致部分细节丢失. 在这一章中,我们介绍一下中值滤波及其实现 摘要首先介绍了中值滤波的原理, 给出其实现思路,并根据思路实现了 C++ 的代码, 然后 同样测试 opencv 自带的中值滤波, 同样的测试图像, 得到对比结果, 分析代码的实现过程, . 正文中值滤波原理中值滤波(Media Filter)就是对于图像的每一个点计算其邻域窗口的像素序列中值, 可以表示为:$$g(x,y) = meida_{(i,j) \\in S}f(i,j)$$核心就是将相应窗口内的像素值进行排列, 我们之前也说过, 我们选择的窗口为奇数尺寸, 所以我们能够保证窗口内的像素个数也是奇数个, 这样我们可以保证取得唯一的中值, 相应的设置为该点的目标值就行了. C++ 实现中值滤波我们来实现一下, 这方面还是能够找到不少结果的, 感觉这个博主写的还是很不错的,有兴趣的可以看下数字图像处理——中值滤波,还有图像处理之中值滤波介绍及C实现, 或者 中值滤波器（Median filter）特性及其实现, 这里我就不再造轮子了, 我们来看下 C++的实现, 主要参考 第一篇文章, 可以看下效果 这里有一点点需要讨论的, 对于彩色图像的三个通道怎么处理, 自己的思路就是分成三个通道进行处理, 然后分别得到三个图之后进行合并三个通道, 得到结果图像. 查了下 目测大家都是这么做的, 可以看OpenCV 彩色图像的自适应中值滤波 C++ 和 彩色图像空间滤波（MATLAB） 这两篇文章, 思路都是一样的, 我们来实现一下. 123456789101112131415161718192021222324252627282930//中值滤波：C++ 代码实现 // 处理单通道图像 // 参考 https://www.cnblogs.com/ranjiewen/p/5699395.htmlcv::Mat medianFilterGray(const cv::Mat &amp;src, int ksize = 3)&#123; cv::Mat dst = src.clone(); //0. 准备：获取图片的宽，高和像素信息， const int num = ksize * ksize; std::vector&lt;uchar&gt; pixel(num); //相对于中心点，3*3领域中的点需要偏移的位置 int delta[3 * 3][2] = &#123; &#123; -1, -1 &#125;, &#123; -1, 0 &#125;, &#123; -1, 1 &#125;, &#123; 0, -1 &#125;, &#123; 0, 0 &#125;, &#123; 0, 1 &#125;, &#123; 1, -1 &#125;, &#123; 1, 0 &#125;, &#123;1, 1&#125; &#125;; //1. 中值滤波，没有考虑边缘 for (int i = 1; i &lt; src.rows - 1; ++i) &#123; for (int j = 1; j &lt; src.cols - 1; ++j) &#123; //1.1 提取领域值 // 使用数组 这样处理 8邻域值 不适合更大窗口 for (int k = 0; k &lt; num; ++k) &#123; pixel[k] = src.at&lt;uchar&gt;(i+delta[k][0], j+ delta[k][1]); &#125; //1.2 排序 // 使用自带的库及排序即可 std::sort(pixel.begin(), pixel.end()); //1.3 获取该中心点的值 dst.at&lt;uchar&gt;(i, j) = pixel[num / 2]; &#125; &#125; return dst;&#125; 思路还是那个思路, 不过在写的过程中, 我在想, 能不能直接处理彩色的图像呢, 对于彩色图像最麻烦的地方就是排序了, 我们没办法考虑颜色的高低值, 所以 那我们自定义一个比较函数应该就行了吧. 我们使用三个颜色的和值 做比较这里使用了C++ 的sort 自定义函数的方法, 这边采用的比较函数的方式, 还有别的方式实现两个元素的比较, 可以参考c++中vector自定义排序的问题1234567891011121314151617181920212223242526272829303132333435// 自定义两个像素的比较函数, // 使用和值 排序bool comp(const cv::Vec3b &amp;p1, const cv::Vec3b &amp;p2)&#123; return (p1[0] + p1[1] + p1[2]) &lt; (p2[0] + p2[1] + p2[2]);&#125;// 尝试彩色图像, 中值排序使用三个通道的和排序cv::Mat medianFilterColor(const cv::Mat &amp;src, int ksize = 3)&#123; cv::Mat dst = src.clone(); //0. 准备：获取图片的宽，高和像素信息， const int num = ksize * ksize; std::vector&lt;cv::Vec3b&gt; pixel(num); //相对于中心点，3*3领域中的点需要偏移的位置 int delta[3 * 3][2] = &#123; &#123; -1, -1 &#125;, &#123; -1, 0 &#125;, &#123; -1, 1 &#125;, &#123; 0, -1 &#125;, &#123; 0, 0 &#125;, &#123; 0, 1 &#125;, &#123; 1, -1 &#125;, &#123; 1, 0 &#125;, &#123;1, 1&#125; &#125;; //1. 中值滤波，没有考虑边缘 for (int i = 1; i &lt; src.rows - 1; ++i) &#123; for (int j = 1; j &lt; src.cols - 1; ++j) &#123; //1.1 提取领域值 // 使用数组 这样处理 8邻域值 不适合更大窗口 for (int k = 0; k &lt; num; ++k) &#123; pixel[k] = src.at&lt;cv::Vec3b&gt;(i + delta[k][0], j + delta[k][1]); &#125; //1.2 排序 // 使用自定义的排序函数排序彩色图像 std::sort(pixel.begin(),pixel.end(),comp); //1.3 获取该中心点的值 dst.at&lt;cv::Vec3b&gt;(i, j) = pixel[num / 2]; &#125; &#125; return dst;&#125; opencv 中值滤波这里还是之前的方法, 一样的接口, 实现起来很简单, opencv 提供的 函数还是很丰富的, 很厉害1234567// opencv 中值滤波cv::Mat mediaFilterDefault(const cv::Mat &amp;src, int ksize = 3)&#123; cv::Mat dst; cv::medianBlur(src, dst, ksize); return dst;&#125; 中值滤波算法对比我们这里就跟之前均值算法的计算很相似了, 我们已经写了三种算法的实现, 然后测试就好了, 趁着功夫, 将上一章一直重复的两个图比较并输出参数的部分写成了一个函数12345678910111213141516171819// 对比两个图像 然后输出 参数信息QString compareImages(const cv::Mat &amp;I1, const cv::Mat &amp;I2, const QString str = \"noise\", const QString str_temp = \"image-%1: psnr:%2, mssim: B:%3 G:%4 R:%5\")&#123; double psnr_ = getPSNR(I1, I2); cv::Scalar mssim_ = getMSSIM(I1, I2); // 根据 输出模板 生成参数信息 QString res_str = str_temp.arg(str) .arg(psnr_) .arg(mssim_.val[0]) .arg(mssim_.val[1]) .arg(mssim_.val[2]); return res_str; // cv::imwrite(IMAGE_DIR + \"dst_\" + std::to_string(i + 1) + \".png\", dst[i]);&#125;没什么难度, 就是用来拼接一个字符串, 用来显示在界面上, 或者 输出输出来, 这样的我们就能很容易的去写测试的函数了, 三种方法依次去实现, 比较麻烦的是第一种, 需要将彩色图像分成三个通道的灰度图像, 然后分别进行中值滤波, 最后合并结果,得到结果图像. 1234567891011121314151617181920212223242526272829303132333435void MainWindow::testFunc2(void)&#123; // 测试 中值 滤波 三种方式的不同 const int TEST = 1; // 使用统一的图进行测试 暂时使用 高 椒盐噪声图像 QString res_str; // 噪声图像的参数值 res_str = compareImages(gSrcImg, gNoiseImg[TEST]); ui-&gt;pt_log-&gt;appendPlainText(res_str); cv::Mat test_img = gNoiseImg[TEST]; cv::Mat dst[3]; // 测试 中值滤波 拆分三个通道进行中值滤波然后合并图像 std::vector&lt;cv::Mat&gt; bgr(3); cv::split(test_img, bgr); bgr[0] = medianFilterGray(bgr[0]); bgr[1] = medianFilterGray(bgr[1]); bgr[2] = medianFilterGray(bgr[2]); cv::merge(bgr, dst[0]); // 第一种方式 dst[1] = medianFilterColor(test_img); // 第二种 彩色直接 计算中值滤波 dst[2] = mediaFilterDefault(test_img); // opencv 实现 中值滤波 // 分别计算三种方式得到的滤波的效果 (结果图与 原始图比较) for(int i=0;i&lt;3;i++) &#123; res_str = compareImages(gSrcImg, dst[i]); // 噪声的参数值 ui-&gt;pt_log-&gt;appendPlainText(res_str); cv::imwrite(IMAGE_DIR + \"dst_media_\" + std::to_string(i+1)+\".png\",dst[i]); &#125;&#125; 我们仍然选择高椒盐噪声图像用于测试, 先看下结果, 分别对应噪声图的参数, 以及三种方法进行的参数结果.第三行的结果就是我们进行自定义排序的图像处理, 1234image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353image-noise: psnr:33.3725, mssim: B:0.896859 G:0.915976 R:0.912563image-noise: psnr:31.2668, mssim: B:0.866162 G:0.901717 R:0.879337image-noise: psnr:34.3125, mssim: B:0.902338 G:0.921419 R:0.91531 我们看一下结果图像, 原始图像可以看 https://gitee.com/schen00/BlogImage/raw/master/image/1588468343599.png 这里, gitee 限制了 1M 以上的图的显示, 所以有需要的去看这个就好. 最近一直用的图拼接使用的 做好图 在线拼接图片 主要是懒得自己写了, http://www.zuohaotu.com/image-merge.aspx 链接在这里了 有需要自取 这里的第一副图是噪声图像, 第二副是我们拆分通道处理后拼接起来了的, 没有处理边缘的细节问题, 第三章图就是我们进行自定义中值排序得到的图, 部分点处理不掉 甚至还复制了出来, 不过整体效果还是不错的, 第四章图就是opencv 自带的中值滤波的处理. 中值滤波算法优化类似均值滤波, 处理的时候考虑变化了的边界就好了, 那中值滤波怎么优化呢, 感觉这一块做的人还挺多, 中值滤波的优化主要是使用自适应中值滤波, 和在中值滤波的方法上进行加速运算, 自适应中值滤波可以参考自适应中值滤波及实现, 我感觉介绍的还是比较详细的, 主要的思路就是如果噪声比较严重时, 窗口获取到的中值可能是噪声值, 这时候增大窗口, 然后重新进行中值滤波,直到找到比较符合的中值.引用他给出的部分叙述 在自适应中值滤波算法中，A步骤里面会先判断是否满足 $Zmin&lt;Zmed&lt;ZmaxZmin&lt;Zmed&lt;Zmax$。这一步骤实质是判断当前区域的中值点是否是噪声点，通常来说是满足 $Zmin&lt;Zmed&lt;ZmaxZmin&lt;Zmed&lt;Zmax$ 这个条件的，此时中值点不是噪声点，跳转到B；考虑一些特殊情况，如果 $Zmed=ZminZmed=Zmin或者Zmed=ZmaxZmed=Zmax$ ，则认为是噪声点，应该扩大窗口尺寸，在一个更大的范围内寻找一个合适的非噪声点，随后再跳转到B，否则输出的中值点是噪声点；接下来考虑跳转到B之后的情况：判断中心点的像素值是否是噪声点，判断条件为 $Zmin&lt;Zxy&lt;ZmaxZmin&lt;Zxy&lt;Zmax$，原理同上，因为如果$Zxy=ZminZxy=Zmin$或者$Zxy=ZmaxZxy=Zmax$，则认为是噪声点。如果不是噪声点，我们可以保留当前像素点的灰度值；如果是噪声点，则使用中值替代原始灰度值，滤去噪声。 同样的, 图像处理基础(2)：自适应中值滤波器(基于OpenCV实现), 这篇文章写的更好一点, 并给出了 opencv 的实现代码, 我们来看一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 自适应中值滤波窗口实现 // 图像 计算座标, 窗口尺寸和 最大尺寸uchar adaptiveProcess(const Mat &amp;im, int row, int col, int kernelSize, int maxSize)&#123; std::vector&lt;uchar&gt; pixels; for (int a = -kernelSize / 2; a &lt;= kernelSize / 2; a++) for (int b = -kernelSize / 2; b &lt;= kernelSize / 2; b++) &#123; pixels.push_back(im.at&lt;uchar&gt;(row + a, col + b)); &#125; sort(pixels.begin(), pixels.end()); auto min = pixels[0]; auto max = pixels[kernelSize * kernelSize - 1]; auto med = pixels[kernelSize * kernelSize / 2]; auto zxy = im.at&lt;uchar&gt;(row, col); if (med &gt; min &amp;&amp; med &lt; max) &#123; // to B if (zxy &gt; min &amp;&amp; zxy &lt; max) return zxy; else return med; &#125; else &#123; kernelSize += 2; if (kernelSize &lt;= maxSize) return adaptiveProcess(im, row, col, kernelSize, maxSize); // 增大窗口尺寸，继续A过程。 else return med; &#125;&#125;// 自适应均值滤波cv::Mat adaptiveMediaFilter(const cv::Mat &amp;src, int ksize = 3)&#123; int minSize = 3; // 滤波器窗口的起始尺寸 int maxSize = 7; // 滤波器窗口的最大尺寸 cv::Mat dst; // 扩展图像的边界 cv::copyMakeBorder(src, dst, maxSize / 2, maxSize / 2, maxSize / 2, maxSize / 2, cv::BorderTypes::BORDER_REFLECT); // 图像循环 for (int j = maxSize / 2; j &lt; dst.rows - maxSize / 2; j++) &#123; for (int i = maxSize / 2; i &lt; dst.cols * dst.channels() - maxSize / 2; i++) &#123; dst.at&lt;uchar&gt;(j, i) = adaptiveProcess(dst, j, i, minSize, maxSize); &#125; &#125; cv::Rect r = cv::Rect(cv::Point(maxSize / 2, maxSize / 2), cv::Point(dst.rows-maxSize / 2, dst.rows-maxSize / 2)); cv::Mat res = dst(r); return res;&#125; 我们这里还是使用的分离三个通道然后进行自适应均值滤波, 参数就使用默认的3, 最大窗口设为7, 我们测试还是跑的之前的高椒盐噪声图像, 下面给出的最后一行就是我们使用自适应中值滤波得到的结果, 至少从 psnr 的参数上我们能看到图像质量的提升, 我们给出图像结果, 肉眼上能看出稍微一点的区别, 对比之前的已经完全不存在白点了, 图像已经比较接近真实图像了..12345// 拆分三个通道 计算自适应中值滤波cv::split(test_img, bgr);for (int i = 0; i &lt; 3; i++)truebgr[i] = adaptiveMediaFilter(bgr[i]);cv::merge(bgr, dst[3]); 12345image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353image-noise: psnr:33.3725, mssim: B:0.896859 G:0.915976 R:0.912563image-noise: psnr:31.2655, mssim: B:0.86636 G:0.901517 R:0.879384image-noise: psnr:34.3125, mssim: B:0.902338 G:0.921419 R:0.91531image-noise: psnr:37.4024, mssim: B:0.946158 G:0.958146 R:0.953884 中值滤波计算加速由于中值滤波无论多大的窗口都是用来将窗口内的像素进行排序, 这里的优化有两个方向 一个是窗口的优化, 一个计算的加速, 我真的 imageshop 的这篇文章 任意半径中值滤波（扩展至百分比滤波器）O(1)时间复杂度算法的原理、实现及效果。已经写的比较完全了, 我都不想在写了, 再从中值滤波的快速算法 偷一张图, 感兴趣的可以看一下的链接OpenCV源码分析（四）：中值滤波 这里详细介绍了 opencv 中怎么实现的 中值滤波 总结算是从中值滤波的基础上做了一个开始, 介绍了一下中值滤波的原理, 然后根据原理使用C++ 进行了实现, 之后再进行 opencv 的实现, 然后我们根据之前的程序上加入了中值滤波的实现效果, 最后在中值滤波的基础上进行优化, 做了自适应中值滤波的实现,测试发现结果还要更好, 最后我稍微提了一下中值滤波的优化加速, 这一块做的很多, 可以去参考里面去找, 算是完成了中值滤波的章节, 如果这里搞懂了我再来完善这一章节.. 参考 《绘制函数调用图（call graph）（4）：doxygen + graphviz_运维_许振坪的专栏-CSDN博客》. 见于 2020年5月2日. https://blog.csdn.net/benkaoya/article/details/79763668. 《任意半径中值滤波（扩展至百分比滤波器）O(1)时间复杂度算法的原理、实现及效果。 - Imageshop - 博客园》. 见于 2020年5月3日. https://www.cnblogs.com/Imageshop/archive/2013/04/26/3045672.html. 《数字图像处理——中值滤波 - ranjiewen - 博客园》. 见于 2020年5月2日. https://www.cnblogs.com/ranjiewen/p/5699395.html. 《【算法随记三】小半径中值模糊的急速实现（16MB图7.5ms实现） + Photoshop中蒙尘和划痕算法解读。 - Imageshop - 博客园》. 见于 2020年5月3日. https://www.cnblogs.com/Imageshop/p/11087804.html. 《图像处理基础(2)：自适应中值滤波器(基于OpenCV实现) - Brook_icv - 博客园》. 见于 2020年5月3日. https://www.cnblogs.com/wangguchangqing/p/6379646.html. 《图像处理之原理 - 中值滤波 - tanfy - 博客园》. 见于 2020年5月2日. https://www.cnblogs.com/tanfy/p/median_filter.html. 《图像处理之中值滤波介绍及C实现 - 淇淇宝贝 - 博客园》. 见于 2020年5月2日. https://www.cnblogs.com/qiqibaby/p/5281743.html. 《中值滤波的快速算法_网络_LinJM-机器视觉-CSDN博客》. 见于 2020年5月3日. https://blog.csdn.net/linj_m/article/details/35780163. 《中值滤波器》. 收入 维基百科，自由的百科全书, 2017年9月8日. https://zh.wikipedia.org/w/index.php?title=%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%99%A8&amp;oldid=46098815. 《中值滤波器（Median filter）特性及其实现_人工智能_Ivan 的专栏-CSDN博客》. 见于 2020年5月2日. https://blog.csdn.net/liyuanbhu/article/details/48502005. 《自适应中值滤波及实现_人工智能_hongbin_xu的博客-CSDN博客》. 见于 2020年5月3日. https://blog.csdn.net/hongbin_xu/article/details/79780967. GitHub. 《ARM-Software/ComputeLibrary》. 见于 2020年5月3日. https://github.com/ARM-software/ComputeLibrary. 《c++中vector自定义排序的问题_C/C++_Stone_Sky-CSDN博客》. 见于 2020年5月2日. https://blog.csdn.net/aastoneaa/article/details/8471722. 《OpenCV 彩色图像的自适应中值滤波 C++_人工智能_cyf15238622067的博客-CSDN博客》. 见于 2020年5月3日. https://blog.csdn.net/cyf15238622067/article/details/88718615. 《‪opencv: ‪Image Filtering》. 见于 2020年5月3日. http://schen.xyz:89/opencv/d4/d86/group__imgproc__filter.html#gad7c87bbc46b97e7eafa71357916ab568. 知乎专栏. 《OpenCV图像处理专栏九 | 基于直方图的快速中值滤波算法》. 见于 2020年5月3日. https://zhuanlan.zhihu.com/p/98092747. 简书. 《OpenCV源码分析（四）：中值滤波》. 见于 2020年5月2日. https://www.jianshu.com/p/eb0b856286f2.","text":"开始之前在上一篇我们实现了读取噪声图像, 然后 进行三种形式的均值滤波得到结果, 由于我们自己写的均值滤波未作边缘处理, 所以效果有一定的下降, 但是总体来说, 我们得到的结果能够说明我们的算法执行之后得到的图像噪声更低, 图像更清晰. 但是也会造成图像的模糊, 导致部分细节丢失. 在这一章中,我们介绍一下中值滤波及其实现 摘要首先介绍了中值滤波的原理, 给出其实现思路,并根据思路实现了 C++ 的代码, 然后 同样测试 opencv 自带的中值滤波, 同样的测试图像, 得到对比结果, 分析代码的实现过程, . 正文中值滤波原理中值滤波(Media Filter)就是对于图像的每一个点计算其邻域窗口的像素序列中值, 可以表示为:$$g(x,y) = meida_{(i,j) \\in S}f(i,j)$$核心就是将相应窗口内的像素值进行排列, 我们之前也说过, 我们选择的窗口为奇数尺寸, 所以我们能够保证窗口内的像素个数也是奇数个, 这样我们可以保证取得唯一的中值, 相应的设置为该点的目标值就行了. C++ 实现中值滤波我们来实现一下, 这方面还是能够找到不少结果的, 感觉这个博主写的还是很不错的,有兴趣的可以看下数字图像处理——中值滤波,还有图像处理之中值滤波介绍及C实现, 或者 中值滤波器（Median filter）特性及其实现, 这里我就不再造轮子了, 我们来看下 C++的实现, 主要参考 第一篇文章, 可以看下效果 这里有一点点需要讨论的, 对于彩色图像的三个通道怎么处理, 自己的思路就是分成三个通道进行处理, 然后分别得到三个图之后进行合并三个通道, 得到结果图像. 查了下 目测大家都是这么做的, 可以看OpenCV 彩色图像的自适应中值滤波 C++ 和 彩色图像空间滤波（MATLAB） 这两篇文章, 思路都是一样的, 我们来实现一下. 123456789101112131415161718192021222324252627282930//中值滤波：C++ 代码实现 // 处理单通道图像 // 参考 https://www.cnblogs.com/ranjiewen/p/5699395.htmlcv::Mat medianFilterGray(const cv::Mat &amp;src, int ksize = 3)&#123; cv::Mat dst = src.clone(); //0. 准备：获取图片的宽，高和像素信息， const int num = ksize * ksize; std::vector&lt;uchar&gt; pixel(num); //相对于中心点，3*3领域中的点需要偏移的位置 int delta[3 * 3][2] = &#123; &#123; -1, -1 &#125;, &#123; -1, 0 &#125;, &#123; -1, 1 &#125;, &#123; 0, -1 &#125;, &#123; 0, 0 &#125;, &#123; 0, 1 &#125;, &#123; 1, -1 &#125;, &#123; 1, 0 &#125;, &#123;1, 1&#125; &#125;; //1. 中值滤波，没有考虑边缘 for (int i = 1; i &lt; src.rows - 1; ++i) &#123; for (int j = 1; j &lt; src.cols - 1; ++j) &#123; //1.1 提取领域值 // 使用数组 这样处理 8邻域值 不适合更大窗口 for (int k = 0; k &lt; num; ++k) &#123; pixel[k] = src.at&lt;uchar&gt;(i+delta[k][0], j+ delta[k][1]); &#125; //1.2 排序 // 使用自带的库及排序即可 std::sort(pixel.begin(), pixel.end()); //1.3 获取该中心点的值 dst.at&lt;uchar&gt;(i, j) = pixel[num / 2]; &#125; &#125; return dst;&#125; 思路还是那个思路, 不过在写的过程中, 我在想, 能不能直接处理彩色的图像呢, 对于彩色图像最麻烦的地方就是排序了, 我们没办法考虑颜色的高低值, 所以 那我们自定义一个比较函数应该就行了吧. 我们使用三个颜色的和值 做比较这里使用了C++ 的sort 自定义函数的方法, 这边采用的比较函数的方式, 还有别的方式实现两个元素的比较, 可以参考c++中vector自定义排序的问题1234567891011121314151617181920212223242526272829303132333435// 自定义两个像素的比较函数, // 使用和值 排序bool comp(const cv::Vec3b &amp;p1, const cv::Vec3b &amp;p2)&#123; return (p1[0] + p1[1] + p1[2]) &lt; (p2[0] + p2[1] + p2[2]);&#125;// 尝试彩色图像, 中值排序使用三个通道的和排序cv::Mat medianFilterColor(const cv::Mat &amp;src, int ksize = 3)&#123; cv::Mat dst = src.clone(); //0. 准备：获取图片的宽，高和像素信息， const int num = ksize * ksize; std::vector&lt;cv::Vec3b&gt; pixel(num); //相对于中心点，3*3领域中的点需要偏移的位置 int delta[3 * 3][2] = &#123; &#123; -1, -1 &#125;, &#123; -1, 0 &#125;, &#123; -1, 1 &#125;, &#123; 0, -1 &#125;, &#123; 0, 0 &#125;, &#123; 0, 1 &#125;, &#123; 1, -1 &#125;, &#123; 1, 0 &#125;, &#123;1, 1&#125; &#125;; //1. 中值滤波，没有考虑边缘 for (int i = 1; i &lt; src.rows - 1; ++i) &#123; for (int j = 1; j &lt; src.cols - 1; ++j) &#123; //1.1 提取领域值 // 使用数组 这样处理 8邻域值 不适合更大窗口 for (int k = 0; k &lt; num; ++k) &#123; pixel[k] = src.at&lt;cv::Vec3b&gt;(i + delta[k][0], j + delta[k][1]); &#125; //1.2 排序 // 使用自定义的排序函数排序彩色图像 std::sort(pixel.begin(),pixel.end(),comp); //1.3 获取该中心点的值 dst.at&lt;cv::Vec3b&gt;(i, j) = pixel[num / 2]; &#125; &#125; return dst;&#125; opencv 中值滤波这里还是之前的方法, 一样的接口, 实现起来很简单, opencv 提供的 函数还是很丰富的, 很厉害1234567// opencv 中值滤波cv::Mat mediaFilterDefault(const cv::Mat &amp;src, int ksize = 3)&#123; cv::Mat dst; cv::medianBlur(src, dst, ksize); return dst;&#125; 中值滤波算法对比我们这里就跟之前均值算法的计算很相似了, 我们已经写了三种算法的实现, 然后测试就好了, 趁着功夫, 将上一章一直重复的两个图比较并输出参数的部分写成了一个函数12345678910111213141516171819// 对比两个图像 然后输出 参数信息QString compareImages(const cv::Mat &amp;I1, const cv::Mat &amp;I2, const QString str = \"noise\", const QString str_temp = \"image-%1: psnr:%2, mssim: B:%3 G:%4 R:%5\")&#123; double psnr_ = getPSNR(I1, I2); cv::Scalar mssim_ = getMSSIM(I1, I2); // 根据 输出模板 生成参数信息 QString res_str = str_temp.arg(str) .arg(psnr_) .arg(mssim_.val[0]) .arg(mssim_.val[1]) .arg(mssim_.val[2]); return res_str; // cv::imwrite(IMAGE_DIR + \"dst_\" + std::to_string(i + 1) + \".png\", dst[i]);&#125;没什么难度, 就是用来拼接一个字符串, 用来显示在界面上, 或者 输出输出来, 这样的我们就能很容易的去写测试的函数了, 三种方法依次去实现, 比较麻烦的是第一种, 需要将彩色图像分成三个通道的灰度图像, 然后分别进行中值滤波, 最后合并结果,得到结果图像. 1234567891011121314151617181920212223242526272829303132333435void MainWindow::testFunc2(void)&#123; // 测试 中值 滤波 三种方式的不同 const int TEST = 1; // 使用统一的图进行测试 暂时使用 高 椒盐噪声图像 QString res_str; // 噪声图像的参数值 res_str = compareImages(gSrcImg, gNoiseImg[TEST]); ui-&gt;pt_log-&gt;appendPlainText(res_str); cv::Mat test_img = gNoiseImg[TEST]; cv::Mat dst[3]; // 测试 中值滤波 拆分三个通道进行中值滤波然后合并图像 std::vector&lt;cv::Mat&gt; bgr(3); cv::split(test_img, bgr); bgr[0] = medianFilterGray(bgr[0]); bgr[1] = medianFilterGray(bgr[1]); bgr[2] = medianFilterGray(bgr[2]); cv::merge(bgr, dst[0]); // 第一种方式 dst[1] = medianFilterColor(test_img); // 第二种 彩色直接 计算中值滤波 dst[2] = mediaFilterDefault(test_img); // opencv 实现 中值滤波 // 分别计算三种方式得到的滤波的效果 (结果图与 原始图比较) for(int i=0;i&lt;3;i++) &#123; res_str = compareImages(gSrcImg, dst[i]); // 噪声的参数值 ui-&gt;pt_log-&gt;appendPlainText(res_str); cv::imwrite(IMAGE_DIR + \"dst_media_\" + std::to_string(i+1)+\".png\",dst[i]); &#125;&#125; 我们仍然选择高椒盐噪声图像用于测试, 先看下结果, 分别对应噪声图的参数, 以及三种方法进行的参数结果.第三行的结果就是我们进行自定义排序的图像处理, 1234image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353image-noise: psnr:33.3725, mssim: B:0.896859 G:0.915976 R:0.912563image-noise: psnr:31.2668, mssim: B:0.866162 G:0.901717 R:0.879337image-noise: psnr:34.3125, mssim: B:0.902338 G:0.921419 R:0.91531 我们看一下结果图像, 原始图像可以看 https://gitee.com/schen00/BlogImage/raw/master/image/1588468343599.png 这里, gitee 限制了 1M 以上的图的显示, 所以有需要的去看这个就好. 最近一直用的图拼接使用的 做好图 在线拼接图片 主要是懒得自己写了, http://www.zuohaotu.com/image-merge.aspx 链接在这里了 有需要自取 这里的第一副图是噪声图像, 第二副是我们拆分通道处理后拼接起来了的, 没有处理边缘的细节问题, 第三章图就是我们进行自定义中值排序得到的图, 部分点处理不掉 甚至还复制了出来, 不过整体效果还是不错的, 第四章图就是opencv 自带的中值滤波的处理. 中值滤波算法优化类似均值滤波, 处理的时候考虑变化了的边界就好了, 那中值滤波怎么优化呢, 感觉这一块做的人还挺多, 中值滤波的优化主要是使用自适应中值滤波, 和在中值滤波的方法上进行加速运算, 自适应中值滤波可以参考自适应中值滤波及实现, 我感觉介绍的还是比较详细的, 主要的思路就是如果噪声比较严重时, 窗口获取到的中值可能是噪声值, 这时候增大窗口, 然后重新进行中值滤波,直到找到比较符合的中值.引用他给出的部分叙述 在自适应中值滤波算法中，A步骤里面会先判断是否满足 $Zmin&lt;Zmed&lt;ZmaxZmin&lt;Zmed&lt;Zmax$。这一步骤实质是判断当前区域的中值点是否是噪声点，通常来说是满足 $Zmin&lt;Zmed&lt;ZmaxZmin&lt;Zmed&lt;Zmax$ 这个条件的，此时中值点不是噪声点，跳转到B；考虑一些特殊情况，如果 $Zmed=ZminZmed=Zmin或者Zmed=ZmaxZmed=Zmax$ ，则认为是噪声点，应该扩大窗口尺寸，在一个更大的范围内寻找一个合适的非噪声点，随后再跳转到B，否则输出的中值点是噪声点；接下来考虑跳转到B之后的情况：判断中心点的像素值是否是噪声点，判断条件为 $Zmin&lt;Zxy&lt;ZmaxZmin&lt;Zxy&lt;Zmax$，原理同上，因为如果$Zxy=ZminZxy=Zmin$或者$Zxy=ZmaxZxy=Zmax$，则认为是噪声点。如果不是噪声点，我们可以保留当前像素点的灰度值；如果是噪声点，则使用中值替代原始灰度值，滤去噪声。 同样的, 图像处理基础(2)：自适应中值滤波器(基于OpenCV实现), 这篇文章写的更好一点, 并给出了 opencv 的实现代码, 我们来看一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 自适应中值滤波窗口实现 // 图像 计算座标, 窗口尺寸和 最大尺寸uchar adaptiveProcess(const Mat &amp;im, int row, int col, int kernelSize, int maxSize)&#123; std::vector&lt;uchar&gt; pixels; for (int a = -kernelSize / 2; a &lt;= kernelSize / 2; a++) for (int b = -kernelSize / 2; b &lt;= kernelSize / 2; b++) &#123; pixels.push_back(im.at&lt;uchar&gt;(row + a, col + b)); &#125; sort(pixels.begin(), pixels.end()); auto min = pixels[0]; auto max = pixels[kernelSize * kernelSize - 1]; auto med = pixels[kernelSize * kernelSize / 2]; auto zxy = im.at&lt;uchar&gt;(row, col); if (med &gt; min &amp;&amp; med &lt; max) &#123; // to B if (zxy &gt; min &amp;&amp; zxy &lt; max) return zxy; else return med; &#125; else &#123; kernelSize += 2; if (kernelSize &lt;= maxSize) return adaptiveProcess(im, row, col, kernelSize, maxSize); // 增大窗口尺寸，继续A过程。 else return med; &#125;&#125;// 自适应均值滤波cv::Mat adaptiveMediaFilter(const cv::Mat &amp;src, int ksize = 3)&#123; int minSize = 3; // 滤波器窗口的起始尺寸 int maxSize = 7; // 滤波器窗口的最大尺寸 cv::Mat dst; // 扩展图像的边界 cv::copyMakeBorder(src, dst, maxSize / 2, maxSize / 2, maxSize / 2, maxSize / 2, cv::BorderTypes::BORDER_REFLECT); // 图像循环 for (int j = maxSize / 2; j &lt; dst.rows - maxSize / 2; j++) &#123; for (int i = maxSize / 2; i &lt; dst.cols * dst.channels() - maxSize / 2; i++) &#123; dst.at&lt;uchar&gt;(j, i) = adaptiveProcess(dst, j, i, minSize, maxSize); &#125; &#125; cv::Rect r = cv::Rect(cv::Point(maxSize / 2, maxSize / 2), cv::Point(dst.rows-maxSize / 2, dst.rows-maxSize / 2)); cv::Mat res = dst(r); return res;&#125; 我们这里还是使用的分离三个通道然后进行自适应均值滤波, 参数就使用默认的3, 最大窗口设为7, 我们测试还是跑的之前的高椒盐噪声图像, 下面给出的最后一行就是我们使用自适应中值滤波得到的结果, 至少从 psnr 的参数上我们能看到图像质量的提升, 我们给出图像结果, 肉眼上能看出稍微一点的区别, 对比之前的已经完全不存在白点了, 图像已经比较接近真实图像了..12345// 拆分三个通道 计算自适应中值滤波cv::split(test_img, bgr);for (int i = 0; i &lt; 3; i++)truebgr[i] = adaptiveMediaFilter(bgr[i]);cv::merge(bgr, dst[3]); 12345image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353image-noise: psnr:33.3725, mssim: B:0.896859 G:0.915976 R:0.912563image-noise: psnr:31.2655, mssim: B:0.86636 G:0.901517 R:0.879384image-noise: psnr:34.3125, mssim: B:0.902338 G:0.921419 R:0.91531image-noise: psnr:37.4024, mssim: B:0.946158 G:0.958146 R:0.953884 中值滤波计算加速由于中值滤波无论多大的窗口都是用来将窗口内的像素进行排序, 这里的优化有两个方向 一个是窗口的优化, 一个计算的加速, 我真的 imageshop 的这篇文章 任意半径中值滤波（扩展至百分比滤波器）O(1)时间复杂度算法的原理、实现及效果。已经写的比较完全了, 我都不想在写了, 再从中值滤波的快速算法 偷一张图, 感兴趣的可以看一下的链接OpenCV源码分析（四）：中值滤波 这里详细介绍了 opencv 中怎么实现的 中值滤波 总结算是从中值滤波的基础上做了一个开始, 介绍了一下中值滤波的原理, 然后根据原理使用C++ 进行了实现, 之后再进行 opencv 的实现, 然后我们根据之前的程序上加入了中值滤波的实现效果, 最后在中值滤波的基础上进行优化, 做了自适应中值滤波的实现,测试发现结果还要更好, 最后我稍微提了一下中值滤波的优化加速, 这一块做的很多, 可以去参考里面去找, 算是完成了中值滤波的章节, 如果这里搞懂了我再来完善这一章节.. 参考 《绘制函数调用图（call graph）（4）：doxygen + graphviz_运维_许振坪的专栏-CSDN博客》. 见于 2020年5月2日. https://blog.csdn.net/benkaoya/article/details/79763668. 《任意半径中值滤波（扩展至百分比滤波器）O(1)时间复杂度算法的原理、实现及效果。 - Imageshop - 博客园》. 见于 2020年5月3日. https://www.cnblogs.com/Imageshop/archive/2013/04/26/3045672.html. 《数字图像处理——中值滤波 - ranjiewen - 博客园》. 见于 2020年5月2日. https://www.cnblogs.com/ranjiewen/p/5699395.html. 《【算法随记三】小半径中值模糊的急速实现（16MB图7.5ms实现） + Photoshop中蒙尘和划痕算法解读。 - Imageshop - 博客园》. 见于 2020年5月3日. https://www.cnblogs.com/Imageshop/p/11087804.html. 《图像处理基础(2)：自适应中值滤波器(基于OpenCV实现) - Brook_icv - 博客园》. 见于 2020年5月3日. https://www.cnblogs.com/wangguchangqing/p/6379646.html. 《图像处理之原理 - 中值滤波 - tanfy - 博客园》. 见于 2020年5月2日. https://www.cnblogs.com/tanfy/p/median_filter.html. 《图像处理之中值滤波介绍及C实现 - 淇淇宝贝 - 博客园》. 见于 2020年5月2日. https://www.cnblogs.com/qiqibaby/p/5281743.html. 《中值滤波的快速算法_网络_LinJM-机器视觉-CSDN博客》. 见于 2020年5月3日. https://blog.csdn.net/linj_m/article/details/35780163. 《中值滤波器》. 收入 维基百科，自由的百科全书, 2017年9月8日. https://zh.wikipedia.org/w/index.php?title=%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%99%A8&amp;oldid=46098815. 《中值滤波器（Median filter）特性及其实现_人工智能_Ivan 的专栏-CSDN博客》. 见于 2020年5月2日. https://blog.csdn.net/liyuanbhu/article/details/48502005. 《自适应中值滤波及实现_人工智能_hongbin_xu的博客-CSDN博客》. 见于 2020年5月3日. https://blog.csdn.net/hongbin_xu/article/details/79780967. GitHub. 《ARM-Software/ComputeLibrary》. 见于 2020年5月3日. https://github.com/ARM-software/ComputeLibrary. 《c++中vector自定义排序的问题_C/C++_Stone_Sky-CSDN博客》. 见于 2020年5月2日. https://blog.csdn.net/aastoneaa/article/details/8471722. 《OpenCV 彩色图像的自适应中值滤波 C++_人工智能_cyf15238622067的博客-CSDN博客》. 见于 2020年5月3日. https://blog.csdn.net/cyf15238622067/article/details/88718615. 《‪opencv: ‪Image Filtering》. 见于 2020年5月3日. http://schen.xyz:89/opencv/d4/d86/group__imgproc__filter.html#gad7c87bbc46b97e7eafa71357916ab568. 知乎专栏. 《OpenCV图像处理专栏九 | 基于直方图的快速中值滤波算法》. 见于 2020年5月3日. https://zhuanlan.zhihu.com/p/98092747. 简书. 《OpenCV源码分析（四）：中值滤波》. 见于 2020年5月2日. https://www.jianshu.com/p/eb0b856286f2.","categories":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/categories/opencv/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/tags/opencv/"},{"name":"c++","slug":"c","permalink":"https://schen1024.github.io/tags/c/"},{"name":"qt","slug":"qt","permalink":"https://schen1024.github.io/tags/qt/"}]},{"title":"opencv-10-图像滤波-噪声添加与均值滤波-含opencv C++ 代码实现","slug":"opencv-10-图像滤波","date":"2020-04-29T17:02:57.000Z","updated":"2023-01-01T13:25:24.773Z","comments":true,"path":"2020/04-29/opencv-10-图像滤波.html","link":"","permalink":"https://schen1024.github.io/2020/04-29/opencv-10-%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2.html","excerpt":"开始之前再说上一篇文章中, 我们想按照噪声产生, 然后将降噪的, 但是限于篇幅, 我就放在这一篇里面了,说起图像的噪声问题就又回到了我们上一章的内容, 把噪声当作信号处理, 实际上数字图像处理实际上也是在进行数字信号的处理过程, 我们这一章就是将滤除信号的过程, 根据上一章的方式, 我们对图像添加噪声, 然后计算 PSNR 与 SSIM 参数, 然后通过降噪, 再从新计算参数值, 比较我们算法的效果 对比我们的算法效果, 看正文吧 目录[toc] 正文我们在上一章给出了两种噪声的添加方式, 可以根据我们的需求添加椒盐噪声和高斯噪声, 但是由于我们的噪声添加使用了随机数 , 导致我们在每次进行的结果可能不一致, 所以我们提前设计好噪声情况, 将图片存储起来, 后面我们进行滤波的时候, 都使用一样的照片, 这样我们能够保证每次的结果是一致的, 这样就能进行算法的对比了, 生成噪声图像我们在上一章给出了不同噪声情况下图像结果, 也给出了一个链接, 对比了更多情况下的图像噪声情况, 可以参考, 所以我们考虑五种情况吧 分别是低椒盐噪声, 高椒盐噪声,低高斯噪声, 高高斯噪声,低椒盐混合低高斯噪声, 高椒盐混合高高斯噪声. 我们分别将图片进行存储便能够得到结果 说明一下: 之前的算法使用的 lena 图像 忘记从那搞来的了, 今天对比了一下, 发现图像不太对, 我现在找到opencv的一个标准图像Lena.jpg, 我下载下来了, 转换成了 lena.png 的图像, 可以见lena.png 这幅图, 可以直接访问链接 https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588298950276.png 直接下载即可.. 这里的处理算法比较简单, 我们来看代码1234567891011121314151617181920212223242526272829303132333435363738394041424344void MainWindow::testFunc1(void)&#123; // 用于生成 测试图像 一共6幅图像 std::vector&lt;cv::Mat&gt; noise_img(6); // 初始化为原始图像 for(auto &amp;m: noise_img) m = gSrcImg.clone(); // 分别添加 低, 高, 低混合, 高混合 共6幅图像 addSaltNoise(noise_img[0],1000); addSaltNoise(noise_img[1],10000); addGaussianNoise(noise_img[2],0,1); addGaussianNoise(noise_img[3],100,10); addSaltNoise(noise_img[4],1000); addGaussianNoise(noise_img[4],0,1); addSaltNoise(noise_img[5],10000); addGaussianNoise(noise_img[5],100,10); // 计算 6幅图像的 psnr 和 ssim 然后存储结果值 std::vector&lt;double&gt; psnr(6); std::vector&lt;cv::Scalar&gt; mssim(6); QString res_temp = \"image-%1: psnr:%2, mssim: B:%3 G:%4 R:%5 \"; QString res_str; // 计算每个图像的 参数值, 然后存储起来 for(int i=0;i&lt;6;i++) &#123; psnr[i] = getPSNR(gSrcImg, noise_img[i]); mssim[i] = getMSSIM(gSrcImg, noise_img[i]); res_str = res_temp.arg(i+1) .arg(psnr[i]) .arg(mssim[i].val[0]) .arg(mssim[i].val[1]) .arg(mssim[i].val[2]); ui-&gt;pt_log-&gt;appendPlainText(res_str); cv::imwrite(\"../testimages/noise/lena-\" + std::to_string(i+1) + \".png\", noise_img[i]); &#125;&#125;我们将图片输出, 然后输出了每幅图的参数, 同时将结果图存储下来, 由于我们在实际进行图像处理的时候会有很多123456image-1: psnr:29.4922, mssim: B:0.880587 G:0.888243 R:0.944992 image-2: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353 image-3: psnr:46.8705, mssim: B:0.991138 G:0.991732 R:0.991185 image-4: psnr:9.15966, mssim: B:0.492354 G:0.482311 R:0.680167 image-5: psnr:29.2807, mssim: B:0.874794 G:0.881488 R:0.935624 image-6: psnr:8.92587, mssim: B:0.392531 G:0.393254 R:0.655795我这里使用之前提到的 图像”拼接” 的方式将图像拼接起来, 这样我们可以更为直观的比较, 图像尺寸都是 $512*512$, 如果需要可以裁剪出来, CSDN 上传会自己转存图片, 上传资源比较麻烦, 懒得搞, 我这边的图片都存在了 gitee 的图床上, 原图存储的 , 有需要的可以自己取用 传统图像降噪算法及其对比之前提到过的【技术综述】一文道尽传统图像降噪方法 这篇文章讲的还比较详细, 大概的给我们讲了一下传统的降噪的方法, 这里我想将各种滤波分开进行实现, 但是比较麻烦, 我就直接在一篇文章中写了吧.. 目前常用的降噪的方法主要可以分为空域降噪与频域降噪, 空域滤波也是我们常用的使用空间处理的方式,计算量小, 简单易用. 频域比较难理解,计算量也比较大, 但是在很多情况结果比较有效.. 所以我们主要的部分也是空间域处理的方式, 也比较直观. opencv 的例程中Smoothing Images 章节大概讲了一下目前使用的模糊方式, 其实模糊是相对的, 也是进行降噪的一个有利手段, 在处理掉噪声的同时, 会导致原始图像的细节模糊, 进而丢失一部分图像信息,我们之后看下图像测试结果. 同时在例程中还提到了一本书Computer Vision: Algorithms and Applications, 1st ed. 有中译版本, 内容还不错, 可以学习 opencv 核表示的算法操作在之前的内容中, 我们介绍了 opencv 核操作的方式, 对于图像的每个像素点的领域操作都可以使用 opencv 提供的 filter2D 方式进行指定核的运算, 我们能够很容易核的操作, 也就是说我们将图像的算法操作都可以转换成图像的矩阵相乘的运算, 可以表示成$$g(x,y) = M \\cdot f(x,y)$$$g(x,y)$ 用来表示结果图像, $f(x,y)$ 表示原始图像, (x,y) 表示 列行座标, M 就是我们的图像运算矩阵,我们后续都不再重复这些默认的操作, 希望能够明白 一般来说, 我们进行矩阵运算的时候都会选择方阵, 这样不会由于矩阵的方向性导致的处理结果不同, 所以我们在一般情况下都会选择方阵, 比如上面进行的滤波 采用的就是 $3x3$ 尺寸的图像, 而且由于我们的图像都是离散的, 所以 实际山采用的滤波的窗口边长也是奇数值, 类似于 $3,5,7,9…(2k+1)$ 的形式 均值滤波及C++ 代码实现算术均值滤波均值滤波(Mean Filter)的算法就是对于每一个像素点, 将其设定为取其邻域窗口内的所有像素的平均值我们考虑一般形式的均值滤波器$$g(x,y) = \\frac{1}{mn} \\sum_{(i,j) \\in S_{xy}} f(i,j)$$ 那我们开始转换一下, 则可以得到下相应的 均值滤波的矩阵$$M = \\frac{1}{9} \\left [ \\begin{array}{c} 1 &amp; 1 &amp; 1 \\ 1&amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 \\end{array}\\right ]$$ 加权均值滤波上面给出的均值滤波让人容易的就会想一个问题, 对于不同的像素位置, 应该要赋予不同的权重值, 靠近中间的位置我们必须要考虑权重的问题, 这就是我们使用加权的均值滤波了, 一般来说我们最常用的矩阵为$$M = \\frac{1}{16} \\left [ \\begin{array}{c} 1 &amp; 2 &amp; 1 \\ 2&amp; 4 &amp; 2 \\ 1 &amp; 2 &amp; 1 \\end{array}\\right ]$$ 这种矩阵对于中心元素的权重更高, 边缘的较弱, 符合人的感觉, 具体的参数值可以自己调整, 前面的系数为矩阵内各个元素的总和, 是为了保证系数的归一. 其实均值滤波器还有很多, 有兴趣的推荐看图像处理基础(3)：均值滤波器及其变种 这篇文章, 写的很好,介绍的很详细, C++手动实现均值滤波我们这里还是使用基础的 算术均值滤波, 实现起来简单一点, 边界问题也不考虑, 这样的话,我们处理的图像区域就稍微内缩小一个像素(1,1)- (m-2,n-2), 至于边界问题, 处理起来还是要看看起来还是比较简单的, 我们按照给出的方法写一下 123456789101112131415161718192021222324252627282930313233// 默认 尺寸为3的 均值滤波 // 自定义实现 暂时不考虑参数异常等 处理cv::Mat meanFilter(const cv::Mat src, int ksize = 3)&#123; // 边界不处理, 直接忽略掉 使用原始图, 拷贝, 避免直接修改 cv::Mat dst = src.clone(); // 直接出, 强制向下取整, // 暴力计算每一个 邻域区间的值 int k0 = ksize/2; int sum[3] = &#123;0,0,0&#125;; for(int i=k0;i&lt;dst.rows-k0-1;i++) &#123; for(int j=k0;j&lt;dst.cols-k0-1;j++) &#123; // 清空 和数组 memset(sum,0, sizeof(sum)); // 计算三个通道的结果 和值 并计算 均值写入目标图像 for(int c = 0;c&lt;3;c++) &#123; for(int m = 0;m&lt;ksize;m++) &#123; for (int n=0;n&lt;ksize;n++) &#123; sum[c] += src.at&lt;cv::Vec3b&gt;(i-k0+m,j-k0+n)[c]; &#125; &#125; // 计算均值写入 dst.at&lt;cv::Vec3b&gt;(i,j)[c] = cv::saturate_cast&lt;uchar&gt;((float)sum[c] /(ksize*ksize)); &#125; &#125; &#125; return dst;&#125; 中间部分写的比较暴力,直接计算的窗口的和值, 然后进行均值得到的结果, 其实这里如果要考虑窗口的和值, 我们没必要重复计算一次, 每次计我们移动窗口后变化的两个边界差值即可, 这样计算上的一点点速度优化, 我们这里实现的只是一个 小小的demo , 有一定的效果即可 opencv 实现均值滤波我们在之前的章节提到了 使用 filter2D 代替普通操作的方法,在这里自然而然的想到怎么去实现, 我们还是一样的构造一个核, 然后计算结果即可, 这里使用的核还是 上面提到的 算术均值滤波的核 123456789// filter2D 实现 meanfiltercv::Mat meanFilterByFilter2D(const cv::Mat src, int ksize = 3)&#123; cv::Mat kernel = (cv::Mat_&lt;float&gt;(ksize,ksize) &lt;&lt; 1,1,1,1,1,1,1,1,1); kernel = kernel / 9.0f; cv::Mat dst; cv::filter2D(src,dst,src.depth(),kernel); return dst;&#125; 这里实现起来真的很简单, 这里的 Mat 可以直接进行矩阵的操作, 每个元素都除以了9,这样就简单很多了, 接下来呢, opencv 对于这种基础且常见的算法肯定自己去在做了实现呀, 在我们上面也提到了opencv 的例程Smoothing Images, 提到了 一个模糊的函数, cv::blur, 这个函数可以调用盒式滤波器, 其实也就是均值滤波的通用形式, 前面的系数不一定而已, 我们先实现一下看下效果, 这里跟上面写成一样的形式, 看起来好看一点, 其实只需要一句话便可以实现了 没什么难度, 至于效果, 我们马上来对比1234567// 使用 blur 均值滤波cv::Mat meanFilterByBlur(const cv::Mat src, int ksize = 3)&#123; cv::Mat dst; cv::blur(src,dst,cv::Size(ksize,ksize)); return dst;&#125; 均值滤波算法对比我们上面提到了构造噪声图像, 然后我们存储了起来, 这里我们选择了一副图像进行直接给结果, 这里我们选择 高椒盐噪声的图像进行测试, 然后先看结果, 第一行表示噪声图像与原始图像的参数值, 后面的三行依次是我们进行上面提到的三种实现出来的滤波方式得到的图像与原始图像进行的对比分析, 这里还是能看到比较明显的结果的, 1234image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353 image-1: psnr:26.505, mssim: B:0.603292 G:0.63888 R:0.806963 image-2: psnr:26.7208, mssim: B:0.605704 G:0.641344 R:0.809115 image-3: psnr:26.7208, mssim: B:0.605704 G:0.641344 R:0.809115 我们看一下测试的代码, 还是之前的界面里面的第二个按钮执行的函数, 这里我们第一个按钮是去读取我们之前存储的噪声图像, 按名称读取,然后结果的时候, 我们是按照每幅图像进行的, 这里暂时 高椒盐噪声的图像, 可以在上面给出的图中看到12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 全局 噪声图像数组, psnr 数组 mssim 数组const std::string IMAGE_DIR =\"../testimages/noise/\";std::vector&lt;cv::Mat&gt; gNoiseImg(6);double psnr[6];cv::Scalar mssim[6];void MainWindow::testFunc1(void)&#123; // 用于读取 测试图片 for(int i=0;i&lt;6;i++) &#123; gNoiseImg[i] = cv::imread(IMAGE_DIR + \"lena-\" + std::to_string(i+1) + \".png\"); &#125; qDebug(\"ReadOK\");&#125;void MainWindow::testFunc2(void)&#123; QString res_temp = \"image-%1: psnr:%2, mssim: B:%3 G:%4 R:%5 \"; QString res_str; // 测试 均值滤波 三种方式的不同 const int TEST = 1; // 使用统一的图进行测试 暂时使用 高 椒盐噪声图像 psnr[TEST] = getPSNR(gSrcImg, gNoiseImg[TEST]); mssim[TEST] = getMSSIM(gSrcImg,gNoiseImg[TEST]); res_str = res_temp.arg(\"noise\") .arg(psnr[TEST]) .arg(mssim[TEST].val[0]) .arg(mssim[TEST].val[1]) .arg(mssim[TEST].val[2]); // 噪声的参数值 ui-&gt;pt_log-&gt;appendPlainText(res_str); cv::Mat dst[3]; dst[0] = meanFilter(gNoiseImg[TEST]); dst[1] = meanFilterByFilter2D(gNoiseImg[TEST]); dst[2] = meanFilterByBlur(gNoiseImg[TEST]); // 分别计算三种方式得到的滤波的效果 (结果图与 原始图比较) for(int i=0;i&lt;3;i++) &#123; psnr[TEST] = getPSNR(gSrcImg, dst[i]); mssim[TEST] = getMSSIM(gSrcImg,dst[i]); res_str = res_temp.arg(i+1) .arg(psnr[TEST]) .arg(mssim[TEST].val[0]) .arg(mssim[TEST].val[1]) .arg(mssim[TEST].val[2]); // 噪声的参数值 ui-&gt;pt_log-&gt;appendPlainText(res_str); cv::imwrite(IMAGE_DIR + \"dst_\" + std::to_string(i+1)+\".png\",dst[i]); &#125;&#125; 从上面的参数也能看出来, 后面两种方法得到的结果图像是一模一样的, 我们就不再进行展示, 先看 我们实现的均值滤波与自带的均值滤波的图像区别 其实吧, 总体的结果上是看不出来区别的, 主要是我们的算法上没有进行边界的处理部分, 能在图的中间部分看到稍微的几个噪声点没有处理掉, 这可能也是我们的结果参数要稍微小一点的原因, 总体来说, 我们的算法还是能够进行均值滤波的, 而且跟自带的处理结果也是一致的. 我这里就有了一个疑问, 为什么我们后面的结果就一模一样了呢,blur 去调用了 filter2D? 然后我去看两个函数的调用图, 感觉问题应该是出在 cv::FilterEngine::apply 函数上,在后面就没去研究了 其实这里看了好久, 看得不是很懂, 就不再叙述了, 给出这两张函数的调用图 有兴趣的自己去看 总结其实这里原本是计划一起写完的, 但是真的太伤了, 慢慢来吧, 中间容易跑偏, 因为这边还要做比较多的东西, 所以写的越来越慢, 不过至少目前兴致还是很高的 , 昨天发在博客园的文章还被 ImageShop 大佬点赞, 还是很开心的, 其实越写感觉自己越虚, 很多深入的东西自己都不能说摸透了, 还是要深入去研究了 但是写的深入了看得就少了一点, 其实我尽量写的浅一点, 因为很多人最开始就是搜索 blog 找答案的, 能看懂就行,我会在后面将常用的都给写完的, 尽量更新的快, 现在每天要花大量的时间去查, 去看还要写, 希望我还能坚持下去, 加油. 广告就是我这里还有之前的 函数调用图都是自己使用 doxygen 和graphiz 参考绘制函数调用图（call graph）（4）：doxygen + graphviz 自己重新生成的opencv 的文档图, 至少在用起来还是比较简单的 这个就是一个静态的网页, 我把它放在了我的 服务器上, 这样别人也能访问有需要的可以看下, 基于 opencv 4.3.0 版本的文档图 http://schen.xyz:89/opencv 没有备案, 也没有做防护, 别搞我 参考 《高斯噪声_百度百科》. 见于 2020年4月30日. https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0. 《绘制函数调用图（call graph）（4）：doxygen + graphviz_运维_许振坪的专栏-CSDN博客》. 见于 2020年5月2日. https://blog.csdn.net/benkaoya/article/details/79763668. 知乎专栏. 《【技术综述】一文道尽传统图像降噪方法》. 见于 2020年4月29日. https://zhuanlan.zhihu.com/p/51403693. 知乎专栏. 《可复现的图像降噪算法总结》. 见于 2020年4月29日. https://zhuanlan.zhihu.com/p/32502816. 《图像噪声的成因分类与常见图像去噪算法简介_Java_qq_27606639的博客-CSDN博客》. 见于 2020年4月30日. https://blog.csdn.net/qq_27606639/article/details/80912071. 《最小均方滤波器》. 收入 维基百科，自由的百科全书, 2018年3月9日. https://zh.wikipedia.org/w/index.php?title=%E6%9C%80%E5%B0%8F%E5%9D%87%E6%96%B9%E6%BB%A4%E6%B3%A2%E5%99%A8&amp;oldid=48602322. 《Computer Vision: Algorithms and Applications, 1st ed.》 见于 2020年5月1日. http://szeliski.org/Book/. 《OpenCV: Smoothing Images》. 见于 2020年5月1日. https://docs.opencv.org/4.3.0/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html. 《openCV之中值滤波&amp;均值滤波（及代码实现）人工智能林小默-CSDN博客》. 见于 2020年5月1日. https://blog.csdn.net/weixin_37720172/article/details/72627543.","text":"开始之前再说上一篇文章中, 我们想按照噪声产生, 然后将降噪的, 但是限于篇幅, 我就放在这一篇里面了,说起图像的噪声问题就又回到了我们上一章的内容, 把噪声当作信号处理, 实际上数字图像处理实际上也是在进行数字信号的处理过程, 我们这一章就是将滤除信号的过程, 根据上一章的方式, 我们对图像添加噪声, 然后计算 PSNR 与 SSIM 参数, 然后通过降噪, 再从新计算参数值, 比较我们算法的效果 对比我们的算法效果, 看正文吧 目录[toc] 正文我们在上一章给出了两种噪声的添加方式, 可以根据我们的需求添加椒盐噪声和高斯噪声, 但是由于我们的噪声添加使用了随机数 , 导致我们在每次进行的结果可能不一致, 所以我们提前设计好噪声情况, 将图片存储起来, 后面我们进行滤波的时候, 都使用一样的照片, 这样我们能够保证每次的结果是一致的, 这样就能进行算法的对比了, 生成噪声图像我们在上一章给出了不同噪声情况下图像结果, 也给出了一个链接, 对比了更多情况下的图像噪声情况, 可以参考, 所以我们考虑五种情况吧 分别是低椒盐噪声, 高椒盐噪声,低高斯噪声, 高高斯噪声,低椒盐混合低高斯噪声, 高椒盐混合高高斯噪声. 我们分别将图片进行存储便能够得到结果 说明一下: 之前的算法使用的 lena 图像 忘记从那搞来的了, 今天对比了一下, 发现图像不太对, 我现在找到opencv的一个标准图像Lena.jpg, 我下载下来了, 转换成了 lena.png 的图像, 可以见lena.png 这幅图, 可以直接访问链接 https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588298950276.png 直接下载即可.. 这里的处理算法比较简单, 我们来看代码1234567891011121314151617181920212223242526272829303132333435363738394041424344void MainWindow::testFunc1(void)&#123; // 用于生成 测试图像 一共6幅图像 std::vector&lt;cv::Mat&gt; noise_img(6); // 初始化为原始图像 for(auto &amp;m: noise_img) m = gSrcImg.clone(); // 分别添加 低, 高, 低混合, 高混合 共6幅图像 addSaltNoise(noise_img[0],1000); addSaltNoise(noise_img[1],10000); addGaussianNoise(noise_img[2],0,1); addGaussianNoise(noise_img[3],100,10); addSaltNoise(noise_img[4],1000); addGaussianNoise(noise_img[4],0,1); addSaltNoise(noise_img[5],10000); addGaussianNoise(noise_img[5],100,10); // 计算 6幅图像的 psnr 和 ssim 然后存储结果值 std::vector&lt;double&gt; psnr(6); std::vector&lt;cv::Scalar&gt; mssim(6); QString res_temp = \"image-%1: psnr:%2, mssim: B:%3 G:%4 R:%5 \"; QString res_str; // 计算每个图像的 参数值, 然后存储起来 for(int i=0;i&lt;6;i++) &#123; psnr[i] = getPSNR(gSrcImg, noise_img[i]); mssim[i] = getMSSIM(gSrcImg, noise_img[i]); res_str = res_temp.arg(i+1) .arg(psnr[i]) .arg(mssim[i].val[0]) .arg(mssim[i].val[1]) .arg(mssim[i].val[2]); ui-&gt;pt_log-&gt;appendPlainText(res_str); cv::imwrite(\"../testimages/noise/lena-\" + std::to_string(i+1) + \".png\", noise_img[i]); &#125;&#125;我们将图片输出, 然后输出了每幅图的参数, 同时将结果图存储下来, 由于我们在实际进行图像处理的时候会有很多123456image-1: psnr:29.4922, mssim: B:0.880587 G:0.888243 R:0.944992 image-2: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353 image-3: psnr:46.8705, mssim: B:0.991138 G:0.991732 R:0.991185 image-4: psnr:9.15966, mssim: B:0.492354 G:0.482311 R:0.680167 image-5: psnr:29.2807, mssim: B:0.874794 G:0.881488 R:0.935624 image-6: psnr:8.92587, mssim: B:0.392531 G:0.393254 R:0.655795我这里使用之前提到的 图像”拼接” 的方式将图像拼接起来, 这样我们可以更为直观的比较, 图像尺寸都是 $512*512$, 如果需要可以裁剪出来, CSDN 上传会自己转存图片, 上传资源比较麻烦, 懒得搞, 我这边的图片都存在了 gitee 的图床上, 原图存储的 , 有需要的可以自己取用 传统图像降噪算法及其对比之前提到过的【技术综述】一文道尽传统图像降噪方法 这篇文章讲的还比较详细, 大概的给我们讲了一下传统的降噪的方法, 这里我想将各种滤波分开进行实现, 但是比较麻烦, 我就直接在一篇文章中写了吧.. 目前常用的降噪的方法主要可以分为空域降噪与频域降噪, 空域滤波也是我们常用的使用空间处理的方式,计算量小, 简单易用. 频域比较难理解,计算量也比较大, 但是在很多情况结果比较有效.. 所以我们主要的部分也是空间域处理的方式, 也比较直观. opencv 的例程中Smoothing Images 章节大概讲了一下目前使用的模糊方式, 其实模糊是相对的, 也是进行降噪的一个有利手段, 在处理掉噪声的同时, 会导致原始图像的细节模糊, 进而丢失一部分图像信息,我们之后看下图像测试结果. 同时在例程中还提到了一本书Computer Vision: Algorithms and Applications, 1st ed. 有中译版本, 内容还不错, 可以学习 opencv 核表示的算法操作在之前的内容中, 我们介绍了 opencv 核操作的方式, 对于图像的每个像素点的领域操作都可以使用 opencv 提供的 filter2D 方式进行指定核的运算, 我们能够很容易核的操作, 也就是说我们将图像的算法操作都可以转换成图像的矩阵相乘的运算, 可以表示成$$g(x,y) = M \\cdot f(x,y)$$$g(x,y)$ 用来表示结果图像, $f(x,y)$ 表示原始图像, (x,y) 表示 列行座标, M 就是我们的图像运算矩阵,我们后续都不再重复这些默认的操作, 希望能够明白 一般来说, 我们进行矩阵运算的时候都会选择方阵, 这样不会由于矩阵的方向性导致的处理结果不同, 所以我们在一般情况下都会选择方阵, 比如上面进行的滤波 采用的就是 $3x3$ 尺寸的图像, 而且由于我们的图像都是离散的, 所以 实际山采用的滤波的窗口边长也是奇数值, 类似于 $3,5,7,9…(2k+1)$ 的形式 均值滤波及C++ 代码实现算术均值滤波均值滤波(Mean Filter)的算法就是对于每一个像素点, 将其设定为取其邻域窗口内的所有像素的平均值我们考虑一般形式的均值滤波器$$g(x,y) = \\frac{1}{mn} \\sum_{(i,j) \\in S_{xy}} f(i,j)$$ 那我们开始转换一下, 则可以得到下相应的 均值滤波的矩阵$$M = \\frac{1}{9} \\left [ \\begin{array}{c} 1 &amp; 1 &amp; 1 \\ 1&amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 \\end{array}\\right ]$$ 加权均值滤波上面给出的均值滤波让人容易的就会想一个问题, 对于不同的像素位置, 应该要赋予不同的权重值, 靠近中间的位置我们必须要考虑权重的问题, 这就是我们使用加权的均值滤波了, 一般来说我们最常用的矩阵为$$M = \\frac{1}{16} \\left [ \\begin{array}{c} 1 &amp; 2 &amp; 1 \\ 2&amp; 4 &amp; 2 \\ 1 &amp; 2 &amp; 1 \\end{array}\\right ]$$ 这种矩阵对于中心元素的权重更高, 边缘的较弱, 符合人的感觉, 具体的参数值可以自己调整, 前面的系数为矩阵内各个元素的总和, 是为了保证系数的归一. 其实均值滤波器还有很多, 有兴趣的推荐看图像处理基础(3)：均值滤波器及其变种 这篇文章, 写的很好,介绍的很详细, C++手动实现均值滤波我们这里还是使用基础的 算术均值滤波, 实现起来简单一点, 边界问题也不考虑, 这样的话,我们处理的图像区域就稍微内缩小一个像素(1,1)- (m-2,n-2), 至于边界问题, 处理起来还是要看看起来还是比较简单的, 我们按照给出的方法写一下 123456789101112131415161718192021222324252627282930313233// 默认 尺寸为3的 均值滤波 // 自定义实现 暂时不考虑参数异常等 处理cv::Mat meanFilter(const cv::Mat src, int ksize = 3)&#123; // 边界不处理, 直接忽略掉 使用原始图, 拷贝, 避免直接修改 cv::Mat dst = src.clone(); // 直接出, 强制向下取整, // 暴力计算每一个 邻域区间的值 int k0 = ksize/2; int sum[3] = &#123;0,0,0&#125;; for(int i=k0;i&lt;dst.rows-k0-1;i++) &#123; for(int j=k0;j&lt;dst.cols-k0-1;j++) &#123; // 清空 和数组 memset(sum,0, sizeof(sum)); // 计算三个通道的结果 和值 并计算 均值写入目标图像 for(int c = 0;c&lt;3;c++) &#123; for(int m = 0;m&lt;ksize;m++) &#123; for (int n=0;n&lt;ksize;n++) &#123; sum[c] += src.at&lt;cv::Vec3b&gt;(i-k0+m,j-k0+n)[c]; &#125; &#125; // 计算均值写入 dst.at&lt;cv::Vec3b&gt;(i,j)[c] = cv::saturate_cast&lt;uchar&gt;((float)sum[c] /(ksize*ksize)); &#125; &#125; &#125; return dst;&#125; 中间部分写的比较暴力,直接计算的窗口的和值, 然后进行均值得到的结果, 其实这里如果要考虑窗口的和值, 我们没必要重复计算一次, 每次计我们移动窗口后变化的两个边界差值即可, 这样计算上的一点点速度优化, 我们这里实现的只是一个 小小的demo , 有一定的效果即可 opencv 实现均值滤波我们在之前的章节提到了 使用 filter2D 代替普通操作的方法,在这里自然而然的想到怎么去实现, 我们还是一样的构造一个核, 然后计算结果即可, 这里使用的核还是 上面提到的 算术均值滤波的核 123456789// filter2D 实现 meanfiltercv::Mat meanFilterByFilter2D(const cv::Mat src, int ksize = 3)&#123; cv::Mat kernel = (cv::Mat_&lt;float&gt;(ksize,ksize) &lt;&lt; 1,1,1,1,1,1,1,1,1); kernel = kernel / 9.0f; cv::Mat dst; cv::filter2D(src,dst,src.depth(),kernel); return dst;&#125; 这里实现起来真的很简单, 这里的 Mat 可以直接进行矩阵的操作, 每个元素都除以了9,这样就简单很多了, 接下来呢, opencv 对于这种基础且常见的算法肯定自己去在做了实现呀, 在我们上面也提到了opencv 的例程Smoothing Images, 提到了 一个模糊的函数, cv::blur, 这个函数可以调用盒式滤波器, 其实也就是均值滤波的通用形式, 前面的系数不一定而已, 我们先实现一下看下效果, 这里跟上面写成一样的形式, 看起来好看一点, 其实只需要一句话便可以实现了 没什么难度, 至于效果, 我们马上来对比1234567// 使用 blur 均值滤波cv::Mat meanFilterByBlur(const cv::Mat src, int ksize = 3)&#123; cv::Mat dst; cv::blur(src,dst,cv::Size(ksize,ksize)); return dst;&#125; 均值滤波算法对比我们上面提到了构造噪声图像, 然后我们存储了起来, 这里我们选择了一副图像进行直接给结果, 这里我们选择 高椒盐噪声的图像进行测试, 然后先看结果, 第一行表示噪声图像与原始图像的参数值, 后面的三行依次是我们进行上面提到的三种实现出来的滤波方式得到的图像与原始图像进行的对比分析, 这里还是能看到比较明显的结果的, 1234image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353 image-1: psnr:26.505, mssim: B:0.603292 G:0.63888 R:0.806963 image-2: psnr:26.7208, mssim: B:0.605704 G:0.641344 R:0.809115 image-3: psnr:26.7208, mssim: B:0.605704 G:0.641344 R:0.809115 我们看一下测试的代码, 还是之前的界面里面的第二个按钮执行的函数, 这里我们第一个按钮是去读取我们之前存储的噪声图像, 按名称读取,然后结果的时候, 我们是按照每幅图像进行的, 这里暂时 高椒盐噪声的图像, 可以在上面给出的图中看到12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 全局 噪声图像数组, psnr 数组 mssim 数组const std::string IMAGE_DIR =\"../testimages/noise/\";std::vector&lt;cv::Mat&gt; gNoiseImg(6);double psnr[6];cv::Scalar mssim[6];void MainWindow::testFunc1(void)&#123; // 用于读取 测试图片 for(int i=0;i&lt;6;i++) &#123; gNoiseImg[i] = cv::imread(IMAGE_DIR + \"lena-\" + std::to_string(i+1) + \".png\"); &#125; qDebug(\"ReadOK\");&#125;void MainWindow::testFunc2(void)&#123; QString res_temp = \"image-%1: psnr:%2, mssim: B:%3 G:%4 R:%5 \"; QString res_str; // 测试 均值滤波 三种方式的不同 const int TEST = 1; // 使用统一的图进行测试 暂时使用 高 椒盐噪声图像 psnr[TEST] = getPSNR(gSrcImg, gNoiseImg[TEST]); mssim[TEST] = getMSSIM(gSrcImg,gNoiseImg[TEST]); res_str = res_temp.arg(\"noise\") .arg(psnr[TEST]) .arg(mssim[TEST].val[0]) .arg(mssim[TEST].val[1]) .arg(mssim[TEST].val[2]); // 噪声的参数值 ui-&gt;pt_log-&gt;appendPlainText(res_str); cv::Mat dst[3]; dst[0] = meanFilter(gNoiseImg[TEST]); dst[1] = meanFilterByFilter2D(gNoiseImg[TEST]); dst[2] = meanFilterByBlur(gNoiseImg[TEST]); // 分别计算三种方式得到的滤波的效果 (结果图与 原始图比较) for(int i=0;i&lt;3;i++) &#123; psnr[TEST] = getPSNR(gSrcImg, dst[i]); mssim[TEST] = getMSSIM(gSrcImg,dst[i]); res_str = res_temp.arg(i+1) .arg(psnr[TEST]) .arg(mssim[TEST].val[0]) .arg(mssim[TEST].val[1]) .arg(mssim[TEST].val[2]); // 噪声的参数值 ui-&gt;pt_log-&gt;appendPlainText(res_str); cv::imwrite(IMAGE_DIR + \"dst_\" + std::to_string(i+1)+\".png\",dst[i]); &#125;&#125; 从上面的参数也能看出来, 后面两种方法得到的结果图像是一模一样的, 我们就不再进行展示, 先看 我们实现的均值滤波与自带的均值滤波的图像区别 其实吧, 总体的结果上是看不出来区别的, 主要是我们的算法上没有进行边界的处理部分, 能在图的中间部分看到稍微的几个噪声点没有处理掉, 这可能也是我们的结果参数要稍微小一点的原因, 总体来说, 我们的算法还是能够进行均值滤波的, 而且跟自带的处理结果也是一致的. 我这里就有了一个疑问, 为什么我们后面的结果就一模一样了呢,blur 去调用了 filter2D? 然后我去看两个函数的调用图, 感觉问题应该是出在 cv::FilterEngine::apply 函数上,在后面就没去研究了 其实这里看了好久, 看得不是很懂, 就不再叙述了, 给出这两张函数的调用图 有兴趣的自己去看 总结其实这里原本是计划一起写完的, 但是真的太伤了, 慢慢来吧, 中间容易跑偏, 因为这边还要做比较多的东西, 所以写的越来越慢, 不过至少目前兴致还是很高的 , 昨天发在博客园的文章还被 ImageShop 大佬点赞, 还是很开心的, 其实越写感觉自己越虚, 很多深入的东西自己都不能说摸透了, 还是要深入去研究了 但是写的深入了看得就少了一点, 其实我尽量写的浅一点, 因为很多人最开始就是搜索 blog 找答案的, 能看懂就行,我会在后面将常用的都给写完的, 尽量更新的快, 现在每天要花大量的时间去查, 去看还要写, 希望我还能坚持下去, 加油. 广告就是我这里还有之前的 函数调用图都是自己使用 doxygen 和graphiz 参考绘制函数调用图（call graph）（4）：doxygen + graphviz 自己重新生成的opencv 的文档图, 至少在用起来还是比较简单的 这个就是一个静态的网页, 我把它放在了我的 服务器上, 这样别人也能访问有需要的可以看下, 基于 opencv 4.3.0 版本的文档图 http://schen.xyz:89/opencv 没有备案, 也没有做防护, 别搞我 参考 《高斯噪声_百度百科》. 见于 2020年4月30日. https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0. 《绘制函数调用图（call graph）（4）：doxygen + graphviz_运维_许振坪的专栏-CSDN博客》. 见于 2020年5月2日. https://blog.csdn.net/benkaoya/article/details/79763668. 知乎专栏. 《【技术综述】一文道尽传统图像降噪方法》. 见于 2020年4月29日. https://zhuanlan.zhihu.com/p/51403693. 知乎专栏. 《可复现的图像降噪算法总结》. 见于 2020年4月29日. https://zhuanlan.zhihu.com/p/32502816. 《图像噪声的成因分类与常见图像去噪算法简介_Java_qq_27606639的博客-CSDN博客》. 见于 2020年4月30日. https://blog.csdn.net/qq_27606639/article/details/80912071. 《最小均方滤波器》. 收入 维基百科，自由的百科全书, 2018年3月9日. https://zh.wikipedia.org/w/index.php?title=%E6%9C%80%E5%B0%8F%E5%9D%87%E6%96%B9%E6%BB%A4%E6%B3%A2%E5%99%A8&amp;oldid=48602322. 《Computer Vision: Algorithms and Applications, 1st ed.》 见于 2020年5月1日. http://szeliski.org/Book/. 《OpenCV: Smoothing Images》. 见于 2020年5月1日. https://docs.opencv.org/4.3.0/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html. 《openCV之中值滤波&amp;均值滤波（及代码实现）人工智能林小默-CSDN博客》. 见于 2020年5月1日. https://blog.csdn.net/weixin_37720172/article/details/72627543.","categories":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/categories/opencv/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/tags/opencv/"},{"name":"c++","slug":"c","permalink":"https://schen1024.github.io/tags/c/"},{"name":"qt","slug":"qt","permalink":"https://schen1024.github.io/tags/qt/"}]},{"title":"opencv-9-图像噪声以及评估指标 PSNR 与SSIM","slug":"opencv-9-noise","date":"2020-04-28T19:10:26.000Z","updated":"2023-01-01T13:25:24.778Z","comments":true,"path":"2020/04-28/opencv-9-noise.html","link":"","permalink":"https://schen1024.github.io/2020/04-28/opencv-9-noise.html","excerpt":"开始之前我们在将 opencv 的图像显示在了 qt 的label 上, 我们能够将图显示在label 上, 用于显示我们的算法,我们在 opencv 上一篇文章中介绍了 opencv 的核操作, 我们这里就要进入一个很重要的章节了,图像滤波操作, 也是图像核操作应用的一个很重要的章节, 那我们就从降噪的角度完整的讲一下, 并通过 opencv 核的方式进行图像算法操作, 【技术综述】一文道尽传统图像降噪方法 这篇文章写的还算比较完整, 也是传统的算法的一个综述过程, 目录[toc] 前言数字成像过程中由于电噪声以及其他因素, 导致我们获取到的图像存在噪声,噪声出现在输入部分, 在后续的每个步骤都会受到影响, 所以在数字图像处理的前面必须要进行的一个步骤就是 图像降噪 每个做信号处理的都会接触到一类问题 , 信号降噪, 让人最头疼的一门课,真是感谢老师给过, 但是后面自己用到的时候反而感觉真的好用, 原来是这样, 然后就慢慢学会了怎么使用吧..(感觉还是弱鸡)知乎可复现的图像降噪算法总结这篇文章列出了一个能够复现的图像降噪操作算法列表, 近年来实现了的算法可以见reproducible-image-denoising-state-of-the-art, 之后使用相应的文章进行算法实现吧.( 又立了一个 flag ) 图像降噪理论基础图像降噪主要的目的是在进行去除图像噪声的同时保留尽可能多的主要特征, 对于人眼来说, 区分噪声还算比较容易, 但是对于计算机来说,输入的都是数据, 我怎么区分哪个是噪声, 哪个不是噪声呢, 这里就要引入噪声的理论基础了 图像噪声的产生我们在之前的章节介绍了图像的程序系统, 实际上在成像过程中可能由于点噪声, 量化过程等造成噪声,实际上的噪声主要分为三种: 加性噪声: 与输入无关, $f(x,y) = g(x,y) +n(x,y)$ 乘性噪声: 与输入信号有关, $f(x,y) = g(x,y) + n(x,y) \\cdot g(x,y)$ 量化噪声: 与输入无关, 在图像量化过程噪声的量化误差导致的噪声, 实际上后两种很难解决, 目前处理的都是以 加性噪声为主, 属于随机的噪声信号, 根据统计学的观点, 噪声在无限长时间窗内的噪声和为0, 在第一类中的 $n(x,y)$ 随着时间存在正负信号的不确定变化. 上图所示虚线代表真实信号，红蓝线表示的就是随机噪声信号，所有的随机噪声信号求和后结果为0。 这里关于噪声的说明可以参考图像去噪算法简介 噪声在理论上可以定义为“不可预测，只能用概率统计方法来认识的随机误差”。因此将图像噪声看成是多维随机过程是合适的，因而描述噪声的方法完全可以借用随机过程的描述，即用其概率分布函数和概率密度分布函数。但在很多情况下，这样的描述方法是很复杂的，甚至是不可能的。而实际应用往往也不必要。通常是用其数字特征，即均值方差，相关函数等。因为这些数字特征都可以从某些方面反映出噪声的特征。 我认为图像噪声的成因分类与常见图像去噪算法简介这篇文章关于噪声的分类部分讲的还比较细, 可以参考 图像噪声的模型由于我们认为噪声在时间尺度的随机性, 但是我们可以使用噪声的概率分布与概率密度函数进行描述, 那么我们就能将噪声根据其分布特点进行分类,我们稍微介绍一下常见的噪声模型吧 噪声模型主要可以分为: 高斯噪声，高斯噪声模型经常被用于实践中。 脉冲噪声（椒盐噪声），图像上一个个点，也可称为散粒和尖峰噪声。 伽马噪声 瑞利噪声 指数分布噪声 均匀分布噪声 这里能查到的资料很多, 可以看我们的参考部分, 内容都一样, 再写只是浪费时间和精力, 有兴趣的可以自己翻阅 图像降噪操作其实吧, 我就不应该讲那么多, 直接开始图像处理部分就行了, 为了开始进行图像处理, 我们要先进行一点小工作, 我们要按造以下步骤进行降噪算法的比较, 选择标准图像— lena.png 添加噪声 量化噪声 降噪操作 量化结果值 比较结果 在我们进行算法比对之前, 我们选择的是 lena 的图像, 加入随机噪声, 然后计算出来 一个噪声的比例, 进行降噪操作, 再次计算以下噪声参数, 看下效果值. 如果是进行算法比较的时候, 最好选择现有的降噪的数据集进行比较, 比如, Kodak , BSD 噪声添加我们认为噪声是随机的, 我们生成随机数加在原始图像上便能够得到噪声图像, opencv 没有提供相应的实现, 但是知道原理了, 写起来都比较简单, 我比较喜欢图像处理基础(1)：噪声的添加和过滤 使用的方法, 他使用的是 梅森旋转算法 来实现的伪随机算法, 其实吧这里我也不懂, 但是随机数能用就行了, 我又不是数学家, 然后看到了 谈谈梅森旋转：算法及其爆破 这里就不重复造轮子了, 直接复制他给出的代码就好,12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 添加椒盐噪声 // 生成 随机 num 个 白点void addSaltNoise(Mat &amp;m, int num)&#123;true// 随机数产生器truestd::random_device rd; //种子truestd::mt19937 gen(rd()); // 随机数引擎trueauto cols = m.cols * m.channels();truefor (int i = 0; i &lt; num; i++)true&#123;truetrueauto row = static_cast&lt;int&gt;(gen() % m.rows);truetrueauto col = static_cast&lt;int&gt;(gen() % cols);truetrueauto p = m.ptr&lt;uchar&gt;(row);truetruep[col++] = 255;truetruep[col++] = 255;truetruep[col] = 255;true&#125;&#125;// 添加Gussia噪声// 使用指针访问void addGaussianNoise(Mat &amp;m, int mu, int sigma)&#123;true// 产生高斯分布随机数发生器truestd::random_device rd;truestd::mt19937 gen(rd());truestd::normal_distribution&lt;&gt; d(mu, sigma);trueauto rows = m.rows; // 行数trueauto cols = m.cols * m.channels(); // 列数truefor (int i = 0; i &lt; rows; i++)true&#123;truetrueauto p = m.ptr&lt;uchar&gt;(i); // 取得行首指针truetruefor (int j = 0; j &lt; cols; j++)truetrue&#123;truetruetrueauto tmp = p[j] + d(gen);truetruetruetmp = tmp &gt; 255 ? 255 : tmp;truetruetruetmp = tmp &lt; 0 ? 0 : tmp;truetruetruep[j] = tmp;truetrue&#125;true&#125;&#125; 噪声量化方法这里其实涉及到图像质量评估的领域,可以参考图像质量评价概述（评估指标、传统检测方法）介绍的方法, 存在太多的计算方式, 我们必须选择一个量化噪声的方式进行图像质量的评估, 一般进行噪声评估手段就是噪声比(Signal to Noise Ratio,SNR),峰值信噪比(Peak Signal to Noise Ratio, PSNR) , 均方差值(Mean Square Error, MSE), 结构相似性(Structural SIMilarity, SSIM), 我们一个一个来看, 均方差值是用于比较两幅图像 K, I 的均方差值$$MSE=\\frac{1}{mn}\\sum_{i=0}^{n-1}\\sum_{j=0}^{m-1}\\parallel K(i,j)-I(i,j)\\parallel^{2}$$ 峰值信噪比PSNR衡量图像失真或是噪声水平的客观标准。2个图像之间PSNR值越大，则越相似。普遍基准为30dB，30dB以下的图像劣化较为明显。定义为，$$PSNR=10log_{10}(\\frac{MAX^{2}}{MSE})$$其中$MAX^2$ 为图片可能的最大像素值。如果每个像素都由 8 位二进制来表示，那么就为 255。 SNR用于描述信号与噪声的比值$$SNR (dB)=10 log_{10}\\left[\\frac{\\sum_{x=0}^{m-1} \\sum_{y=0}^{n-1}(f(x, y))^{2}}{\\sum_{x=0}^{m-1} \\sum_{y=0}^{n-1}(f(x, y)-\\hat{f}(x, y))^{2}}\\right]$$ SSIM 描述两个图像的相似性, 通过三个进行比较, 亮度,对比度和结构, 参考图像质量评价指标之 PSNR 和 SSIM $$l(x, y)=\\frac{2 \\mu_{x} \\mu_{y}+c_{1}}{\\mu_{x}^{2}+\\mu_{y}^{2}+c_{1}} c(x, y)=\\frac{2 \\sigma_{x} \\sigma_{y}+c_{2}}{\\sigma_{x}^{2}+\\sigma_{y}^{2}+c_{2}} s(x, y)=\\frac{\\sigma_{x y}+c_{3}}{\\sigma_{x} \\sigma_{y}+c_{3}}$$ $$\\operatorname{SSIM}(x, y)=\\frac{\\left(2 \\mu_{x} \\mu_{y}+c_{1}\\right)\\left(2 \\sigma_{x y}+c_{2}\\right)}{\\left(\\mu_{x}^{2}+\\mu_{y}^{2}+c_{1}\\right)\\left(\\sigma_{x}^{2}+\\sigma_{y}^{2}+c_{2}\\right)}$$一般取$c_3 = \\frac{c_2}{2}$。$u_x$ 为 $x$ 的均值$u_y$ 为 $y$ 的均值$\\sigma_x^2$ 为$x$ 的方差$\\sigma_y^2$ 为$y$ 的方差$\\sigma_{xy}$ 为$x$ 和$y$ 的协方差$c_1 = (k_1 L)^2, c_2=(k_2 L)^2$ 为两个常数，避免除零$L$ 为像素值的范围，$(0,255)$$k_1 = 0.01, k_2 = 0.03$ 为默认值默认参数$\\alpha = 1, \\beta = 1, \\gamma = 1$ opencv 计算 PSNR 和 SSIM本来不想写这么多的, 但是 opencv 给出了一个例程Similarity check (PNSR and SSIM) on the GPU, 提供了计算的方法, 自己不用去写了, 岂不是很爽, 所以上面就详细介绍了各个方法的使用.官方给出了普通版本以及 GPU 加速的版本, 我们暂时只使用基础的版本就好,PSNR返回一个浮点数，如果两个输入在30到50之间相似（越高越好）。SSIM返回图像的MSSIM。这也是一个介于零和一之间的浮点数（越高越好），但是每个通道都有一个浮点数。因此，我们返回一个Scalar OpenCV数据结构：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354double getPSNR(const Mat&amp; I1, const Mat&amp; I2)&#123; Mat s1; absdiff(I1, I2, s1); // |I1 - I2| s1.convertTo(s1, CV_32F); // cannot make a square on 8 bits s1 = s1.mul(s1); // |I1 - I2|^2 Scalar s = sum(s1); // sum elements per channel double sse = s.val[0] + s.val[1] + s.val[2]; // sum channels if( sse &lt;= 1e-10) // for small values return zero return 0; else &#123; double mse =sse /(double)(I1.channels() * I1.total()); double psnr = 10.0*log10((255*255)/mse); return psnr; &#125;&#125;Scalar getMSSIM( const Mat&amp; i1, const Mat&amp; i2)&#123; const double C1 = 6.5025, C2 = 58.5225; /***************************** INITS **********************************/ int d = CV_32F; Mat I1, I2; i1.convertTo(I1, d); // cannot calculate on one byte large values i2.convertTo(I2, d); Mat I2_2 = I2.mul(I2); // I2^2 Mat I1_2 = I1.mul(I1); // I1^2 Mat I1_I2 = I1.mul(I2); // I1 * I2 /*************************** END INITS **********************************/ Mat mu1, mu2; // PRELIMINARY COMPUTING GaussianBlur(I1, mu1, Size(11, 11), 1.5); GaussianBlur(I2, mu2, Size(11, 11), 1.5); Mat mu1_2 = mu1.mul(mu1); Mat mu2_2 = mu2.mul(mu2); Mat mu1_mu2 = mu1.mul(mu2); Mat sigma1_2, sigma2_2, sigma12; GaussianBlur(I1_2, sigma1_2, Size(11, 11), 1.5); sigma1_2 -= mu1_2; GaussianBlur(I2_2, sigma2_2, Size(11, 11), 1.5); sigma2_2 -= mu2_2; GaussianBlur(I1_I2, sigma12, Size(11, 11), 1.5); sigma12 -= mu1_mu2; Mat t1, t2, t3; t1 = 2 * mu1_mu2 + C1; t2 = 2 * sigma12 + C2; t3 = t1.mul(t2); // t3 = ((2*mu1_mu2 + C1).*(2*sigma12 + C2)) t1 = mu1_2 + mu2_2 + C1; t2 = sigma1_2 + sigma2_2 + C2; t1 = t1.mul(t2); // t1 =((mu1_2 + mu2_2 + C1).*(sigma1_2 + sigma2_2 + C2)) Mat ssim_map; divide(t3, t1, ssim_map); // ssim_map = t3./t1; Scalar mssim = mean( ssim_map ); // mssim = average of ssim map return mssim;&#125; 算法噪声数据我们完成了噪声添加以及噪声的量化, 我们来试一下, 给图像随机添加一定的噪声, 然后看下相应的参数变化情况对比来看就好 椒盐噪声测试我们先来测试椒盐噪声 分别计算没有噪声的图, 以及添加了 1000个 和10000个噪声的数据结果, 并将后面两个显示出来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void MainWindow::testFunc1(void)&#123; // 添加椒盐噪声 并计算 PSNR和 SSIM cv::Mat salt_img; double psnr = 0; cv::Scalar mssim; QString res_temp = \"Salt-%1 : psnr:%2, mssim: B:%3 G:%4 R:%5 \"; QString res_str; // 计算三组图像的参数 0, 1000, 10000 // 复制原始图像, 添加噪声, 计算 psnr和ssim 显示在 ui上 salt_img = gSrcImg.clone(); addSaltNoise(salt_img,0); psnr = getPSNR(gSrcImg, salt_img); mssim = getMSSIM(gSrcImg,salt_img); res_str = res_temp.arg(0) .arg(psnr) .arg(mssim.val[0]) .arg(mssim.val[1]) .arg(mssim.val[2]); ui-&gt;pt_log-&gt;appendPlainText(res_str); salt_img = gSrcImg.clone(); addSaltNoise(salt_img,1000); psnr = getPSNR(gSrcImg, salt_img); mssim = getMSSIM(gSrcImg,salt_img); res_str = res_temp.arg(1000) .arg(psnr) .arg(mssim.val[0]) .arg(mssim.val[1]) .arg(mssim.val[2]); ui-&gt;pt_log-&gt;appendPlainText(res_str); // 左侧显示 1000 噪声 右侧显示 10000 噪声 ShowMatOnQtLabel(salt_img,ui-&gt;lb_src); salt_img = gSrcImg.clone(); addSaltNoise(salt_img,10000); psnr = getPSNR(gSrcImg, salt_img); mssim = getMSSIM(gSrcImg,salt_img); res_str = res_temp.arg(10000) .arg(psnr) .arg(mssim.val[0]) .arg(mssim.val[1]) .arg(mssim.val[2]); ui-&gt;pt_log-&gt;appendPlainText(res_str); ShowMatOnQtLabel(salt_img,ui-&gt;lb_dst);&#125; 我们可以直接计算得到椒盐噪声 psnr 和 ssim 都是越大越好的, 可以明显的看到图像质量退化 123Salt-0 : psnr:0, mssim: B:1 G:1 R:1 Salt-1000 : psnr:27.7528, mssim: B:0.865341 G:0.870555 R:0.914122 Salt-10000 : psnr:17.8062, mssim: B:0.311999 G:0.327485 R:0.493874 高斯噪声测试高斯噪声我们测试了四组 分别使用参数(0,1) (0,10)(10,1)(10,10) 作为高斯参数, 最终得到后面的图, 然后计算得到的结果, 我们做的结果比较简单, 可以参考数字图像处理——添加高斯噪声&amp;椒盐噪声, 给出了很多的图, 可以参考学 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465void MainWindow::testFunc2(void)&#123; // 添加高斯噪声 并计算 PSNR和 SSIM cv::Mat guass_img; double psnr = 0; cv::Scalar mssim; QString res_temp = \"gauss-%1- %2 : psnr:%3, mssim: B:%4 G:%5 R:%6 \"; QString res_str; // 计算三组图像的参数 (0,1) (0,10), (10,1), (10,10) // 复制原始图像, 添加噪声, 计算 psnr和ssim 显示在 ui上 guass_img = gSrcImg.clone(); addGaussianNoise(guass_img,0,1); psnr = getPSNR(gSrcImg, guass_img); mssim = getMSSIM(gSrcImg,guass_img); res_str = res_temp.arg(0) .arg(1) .arg(psnr) .arg(mssim.val[0]) .arg(mssim.val[1]) .arg(mssim.val[2]); ui-&gt;pt_log-&gt;appendPlainText(res_str); guass_img = gSrcImg.clone(); addGaussianNoise(guass_img,0,10); psnr = getPSNR(gSrcImg, guass_img); mssim = getMSSIM(gSrcImg,guass_img); res_str = res_temp.arg(0) .arg(10) .arg(psnr) .arg(mssim.val[0]) .arg(mssim.val[1]) .arg(mssim.val[2]); ui-&gt;pt_log-&gt;appendPlainText(res_str); guass_img = gSrcImg.clone(); addGaussianNoise(guass_img,10,1); psnr = getPSNR(gSrcImg, guass_img); mssim = getMSSIM(gSrcImg,guass_img); res_str = res_temp.arg(10) .arg(1) .arg(psnr) .arg(mssim.val[0]) .arg(mssim.val[1]) .arg(mssim.val[2]); ui-&gt;pt_log-&gt;appendPlainText(res_str); guass_img = gSrcImg.clone(); addGaussianNoise(guass_img,10,10); psnr = getPSNR(gSrcImg, guass_img); mssim = getMSSIM(gSrcImg,guass_img); res_str = res_temp.arg(10) .arg(10) .arg(psnr) .arg(mssim.val[0]) .arg(mssim.val[1]) .arg(mssim.val[2]); ui-&gt;pt_log-&gt;appendPlainText(res_str);&#125; 1234gauss-0- 1 : psnr:46.8791, mssim: B:0.991811 G:0.991622 R:0.992751 gauss-0- 10 : psnr:28.1229, mssim: B:0.614219 G:0.608773 R:0.648285 gauss-10- 1 : psnr:28.5293, mssim: B:0.978448 G:0.980308 R:0.987926 gauss-10- 10 : psnr:25.3511, mssim: B:0.605665 G:0.600491 R:0.646768 总结原本想把滤波一起做了的, 但是越写越, 就不做太多的处理了, 我们算是介绍了噪声的来源, 噪声的模型, 以及个噪声的量化方式,然后介绍了图像添加噪声的方法 我们分别给图像添加椒盐噪声与高斯噪声, 然后分别量化了噪声的结果值, 进行对比展示, 示例的图不是很多, 程序是在代码库里面的, 可以直接去自己实现, 然后进行 进行更多图的展示 参考 《高斯噪声_百度百科》. 见于 2020年4月30日. https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0. 知乎专栏. 《【技术综述】一文道尽传统图像降噪方法》. 见于 2020年4月29日. https://zhuanlan.zhihu.com/p/51403693. 知乎专栏. 《可复现的图像降噪算法总结》. 见于 2020年4月29日. https://zhuanlan.zhihu.com/p/32502816. 《梅森旋转算法》. 收入 维基百科，自由的百科全书, 2019年11月4日. https://zh.wikipedia.org/w/index.php?title=%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95&amp;oldid=56745942. 《实现灰度图像峰值信噪比计算人工智能松子茶的专栏-CSDN博客》. 见于 2020年4月30日. https://blog.csdn.net/songzitea/article/details/17529445. 《数字图像处理-噪声 - Mohanson》. 见于 2020年4月30日. http://accu.cc/content/pil/noise/. 《图像处理基础(1)：噪声的添加和过滤 - Brook_icv - 博客园》. 见于 2020年4月30日. https://www.cnblogs.com/wangguchangqing/p/6372025.html. 《图像处理PSNR及其计算（OpenCV和matlab实现）人工智能无机器不学习-加大码的分享-CSDN博客》. 见于 2020年4月30日. https://blog.csdn.net/laoxuan2011/article/details/51519062. 《图像的 SNR 和 PSNR 的计算 - rldts - 博客园》. 见于 2020年4月30日. https://www.cnblogs.com/qrlozte/p/5340216.html. 《图像去噪算法简介 - InfantSorrow - 博客园》. 见于 2020年4月29日. https://www.cnblogs.com/CCBB/archive/2011/01/06/1929033.html. 《图像噪声的成因分类与常见图像去噪算法简介_Java_qq_27606639的博客-CSDN博客》. 见于 2020年4月30日. https://blog.csdn.net/qq_27606639/article/details/80912071. 《图像质量评估指标 SSIM / PSNR / MSE_人工智能_兔角与禅-CSDN博客》. 见于 2020年4月30日. https://blog.csdn.net/edogawachia/article/details/78756680. 《图像质量评价概述（评估指标、传统检测方法）_人工智能_qq_23304241的博客-CSDN博客》. 见于 2020年4月30日. https://blog.csdn.net/qq_23304241/article/details/80953613. 《影像降噪》. 收入 维基百科，自由的百科全书, 2018年9月20日. https://zh.wikipedia.org/w/index.php?title=%E5%BD%B1%E5%83%8F%E9%99%8D%E5%99%AA&amp;oldid=51354600.","text":"开始之前我们在将 opencv 的图像显示在了 qt 的label 上, 我们能够将图显示在label 上, 用于显示我们的算法,我们在 opencv 上一篇文章中介绍了 opencv 的核操作, 我们这里就要进入一个很重要的章节了,图像滤波操作, 也是图像核操作应用的一个很重要的章节, 那我们就从降噪的角度完整的讲一下, 并通过 opencv 核的方式进行图像算法操作, 【技术综述】一文道尽传统图像降噪方法 这篇文章写的还算比较完整, 也是传统的算法的一个综述过程, 目录[toc] 前言数字成像过程中由于电噪声以及其他因素, 导致我们获取到的图像存在噪声,噪声出现在输入部分, 在后续的每个步骤都会受到影响, 所以在数字图像处理的前面必须要进行的一个步骤就是 图像降噪 每个做信号处理的都会接触到一类问题 , 信号降噪, 让人最头疼的一门课,真是感谢老师给过, 但是后面自己用到的时候反而感觉真的好用, 原来是这样, 然后就慢慢学会了怎么使用吧..(感觉还是弱鸡)知乎可复现的图像降噪算法总结这篇文章列出了一个能够复现的图像降噪操作算法列表, 近年来实现了的算法可以见reproducible-image-denoising-state-of-the-art, 之后使用相应的文章进行算法实现吧.( 又立了一个 flag ) 图像降噪理论基础图像降噪主要的目的是在进行去除图像噪声的同时保留尽可能多的主要特征, 对于人眼来说, 区分噪声还算比较容易, 但是对于计算机来说,输入的都是数据, 我怎么区分哪个是噪声, 哪个不是噪声呢, 这里就要引入噪声的理论基础了 图像噪声的产生我们在之前的章节介绍了图像的程序系统, 实际上在成像过程中可能由于点噪声, 量化过程等造成噪声,实际上的噪声主要分为三种: 加性噪声: 与输入无关, $f(x,y) = g(x,y) +n(x,y)$ 乘性噪声: 与输入信号有关, $f(x,y) = g(x,y) + n(x,y) \\cdot g(x,y)$ 量化噪声: 与输入无关, 在图像量化过程噪声的量化误差导致的噪声, 实际上后两种很难解决, 目前处理的都是以 加性噪声为主, 属于随机的噪声信号, 根据统计学的观点, 噪声在无限长时间窗内的噪声和为0, 在第一类中的 $n(x,y)$ 随着时间存在正负信号的不确定变化. 上图所示虚线代表真实信号，红蓝线表示的就是随机噪声信号，所有的随机噪声信号求和后结果为0。 这里关于噪声的说明可以参考图像去噪算法简介 噪声在理论上可以定义为“不可预测，只能用概率统计方法来认识的随机误差”。因此将图像噪声看成是多维随机过程是合适的，因而描述噪声的方法完全可以借用随机过程的描述，即用其概率分布函数和概率密度分布函数。但在很多情况下，这样的描述方法是很复杂的，甚至是不可能的。而实际应用往往也不必要。通常是用其数字特征，即均值方差，相关函数等。因为这些数字特征都可以从某些方面反映出噪声的特征。 我认为图像噪声的成因分类与常见图像去噪算法简介这篇文章关于噪声的分类部分讲的还比较细, 可以参考 图像噪声的模型由于我们认为噪声在时间尺度的随机性, 但是我们可以使用噪声的概率分布与概率密度函数进行描述, 那么我们就能将噪声根据其分布特点进行分类,我们稍微介绍一下常见的噪声模型吧 噪声模型主要可以分为: 高斯噪声，高斯噪声模型经常被用于实践中。 脉冲噪声（椒盐噪声），图像上一个个点，也可称为散粒和尖峰噪声。 伽马噪声 瑞利噪声 指数分布噪声 均匀分布噪声 这里能查到的资料很多, 可以看我们的参考部分, 内容都一样, 再写只是浪费时间和精力, 有兴趣的可以自己翻阅 图像降噪操作其实吧, 我就不应该讲那么多, 直接开始图像处理部分就行了, 为了开始进行图像处理, 我们要先进行一点小工作, 我们要按造以下步骤进行降噪算法的比较, 选择标准图像— lena.png 添加噪声 量化噪声 降噪操作 量化结果值 比较结果 在我们进行算法比对之前, 我们选择的是 lena 的图像, 加入随机噪声, 然后计算出来 一个噪声的比例, 进行降噪操作, 再次计算以下噪声参数, 看下效果值. 如果是进行算法比较的时候, 最好选择现有的降噪的数据集进行比较, 比如, Kodak , BSD 噪声添加我们认为噪声是随机的, 我们生成随机数加在原始图像上便能够得到噪声图像, opencv 没有提供相应的实现, 但是知道原理了, 写起来都比较简单, 我比较喜欢图像处理基础(1)：噪声的添加和过滤 使用的方法, 他使用的是 梅森旋转算法 来实现的伪随机算法, 其实吧这里我也不懂, 但是随机数能用就行了, 我又不是数学家, 然后看到了 谈谈梅森旋转：算法及其爆破 这里就不重复造轮子了, 直接复制他给出的代码就好,12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 添加椒盐噪声 // 生成 随机 num 个 白点void addSaltNoise(Mat &amp;m, int num)&#123;true// 随机数产生器truestd::random_device rd; //种子truestd::mt19937 gen(rd()); // 随机数引擎trueauto cols = m.cols * m.channels();truefor (int i = 0; i &lt; num; i++)true&#123;truetrueauto row = static_cast&lt;int&gt;(gen() % m.rows);truetrueauto col = static_cast&lt;int&gt;(gen() % cols);truetrueauto p = m.ptr&lt;uchar&gt;(row);truetruep[col++] = 255;truetruep[col++] = 255;truetruep[col] = 255;true&#125;&#125;// 添加Gussia噪声// 使用指针访问void addGaussianNoise(Mat &amp;m, int mu, int sigma)&#123;true// 产生高斯分布随机数发生器truestd::random_device rd;truestd::mt19937 gen(rd());truestd::normal_distribution&lt;&gt; d(mu, sigma);trueauto rows = m.rows; // 行数trueauto cols = m.cols * m.channels(); // 列数truefor (int i = 0; i &lt; rows; i++)true&#123;truetrueauto p = m.ptr&lt;uchar&gt;(i); // 取得行首指针truetruefor (int j = 0; j &lt; cols; j++)truetrue&#123;truetruetrueauto tmp = p[j] + d(gen);truetruetruetmp = tmp &gt; 255 ? 255 : tmp;truetruetruetmp = tmp &lt; 0 ? 0 : tmp;truetruetruep[j] = tmp;truetrue&#125;true&#125;&#125; 噪声量化方法这里其实涉及到图像质量评估的领域,可以参考图像质量评价概述（评估指标、传统检测方法）介绍的方法, 存在太多的计算方式, 我们必须选择一个量化噪声的方式进行图像质量的评估, 一般进行噪声评估手段就是噪声比(Signal to Noise Ratio,SNR),峰值信噪比(Peak Signal to Noise Ratio, PSNR) , 均方差值(Mean Square Error, MSE), 结构相似性(Structural SIMilarity, SSIM), 我们一个一个来看, 均方差值是用于比较两幅图像 K, I 的均方差值$$MSE=\\frac{1}{mn}\\sum_{i=0}^{n-1}\\sum_{j=0}^{m-1}\\parallel K(i,j)-I(i,j)\\parallel^{2}$$ 峰值信噪比PSNR衡量图像失真或是噪声水平的客观标准。2个图像之间PSNR值越大，则越相似。普遍基准为30dB，30dB以下的图像劣化较为明显。定义为，$$PSNR=10log_{10}(\\frac{MAX^{2}}{MSE})$$其中$MAX^2$ 为图片可能的最大像素值。如果每个像素都由 8 位二进制来表示，那么就为 255。 SNR用于描述信号与噪声的比值$$SNR (dB)=10 log_{10}\\left[\\frac{\\sum_{x=0}^{m-1} \\sum_{y=0}^{n-1}(f(x, y))^{2}}{\\sum_{x=0}^{m-1} \\sum_{y=0}^{n-1}(f(x, y)-\\hat{f}(x, y))^{2}}\\right]$$ SSIM 描述两个图像的相似性, 通过三个进行比较, 亮度,对比度和结构, 参考图像质量评价指标之 PSNR 和 SSIM $$l(x, y)=\\frac{2 \\mu_{x} \\mu_{y}+c_{1}}{\\mu_{x}^{2}+\\mu_{y}^{2}+c_{1}} c(x, y)=\\frac{2 \\sigma_{x} \\sigma_{y}+c_{2}}{\\sigma_{x}^{2}+\\sigma_{y}^{2}+c_{2}} s(x, y)=\\frac{\\sigma_{x y}+c_{3}}{\\sigma_{x} \\sigma_{y}+c_{3}}$$ $$\\operatorname{SSIM}(x, y)=\\frac{\\left(2 \\mu_{x} \\mu_{y}+c_{1}\\right)\\left(2 \\sigma_{x y}+c_{2}\\right)}{\\left(\\mu_{x}^{2}+\\mu_{y}^{2}+c_{1}\\right)\\left(\\sigma_{x}^{2}+\\sigma_{y}^{2}+c_{2}\\right)}$$一般取$c_3 = \\frac{c_2}{2}$。$u_x$ 为 $x$ 的均值$u_y$ 为 $y$ 的均值$\\sigma_x^2$ 为$x$ 的方差$\\sigma_y^2$ 为$y$ 的方差$\\sigma_{xy}$ 为$x$ 和$y$ 的协方差$c_1 = (k_1 L)^2, c_2=(k_2 L)^2$ 为两个常数，避免除零$L$ 为像素值的范围，$(0,255)$$k_1 = 0.01, k_2 = 0.03$ 为默认值默认参数$\\alpha = 1, \\beta = 1, \\gamma = 1$ opencv 计算 PSNR 和 SSIM本来不想写这么多的, 但是 opencv 给出了一个例程Similarity check (PNSR and SSIM) on the GPU, 提供了计算的方法, 自己不用去写了, 岂不是很爽, 所以上面就详细介绍了各个方法的使用.官方给出了普通版本以及 GPU 加速的版本, 我们暂时只使用基础的版本就好,PSNR返回一个浮点数，如果两个输入在30到50之间相似（越高越好）。SSIM返回图像的MSSIM。这也是一个介于零和一之间的浮点数（越高越好），但是每个通道都有一个浮点数。因此，我们返回一个Scalar OpenCV数据结构：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354double getPSNR(const Mat&amp; I1, const Mat&amp; I2)&#123; Mat s1; absdiff(I1, I2, s1); // |I1 - I2| s1.convertTo(s1, CV_32F); // cannot make a square on 8 bits s1 = s1.mul(s1); // |I1 - I2|^2 Scalar s = sum(s1); // sum elements per channel double sse = s.val[0] + s.val[1] + s.val[2]; // sum channels if( sse &lt;= 1e-10) // for small values return zero return 0; else &#123; double mse =sse /(double)(I1.channels() * I1.total()); double psnr = 10.0*log10((255*255)/mse); return psnr; &#125;&#125;Scalar getMSSIM( const Mat&amp; i1, const Mat&amp; i2)&#123; const double C1 = 6.5025, C2 = 58.5225; /***************************** INITS **********************************/ int d = CV_32F; Mat I1, I2; i1.convertTo(I1, d); // cannot calculate on one byte large values i2.convertTo(I2, d); Mat I2_2 = I2.mul(I2); // I2^2 Mat I1_2 = I1.mul(I1); // I1^2 Mat I1_I2 = I1.mul(I2); // I1 * I2 /*************************** END INITS **********************************/ Mat mu1, mu2; // PRELIMINARY COMPUTING GaussianBlur(I1, mu1, Size(11, 11), 1.5); GaussianBlur(I2, mu2, Size(11, 11), 1.5); Mat mu1_2 = mu1.mul(mu1); Mat mu2_2 = mu2.mul(mu2); Mat mu1_mu2 = mu1.mul(mu2); Mat sigma1_2, sigma2_2, sigma12; GaussianBlur(I1_2, sigma1_2, Size(11, 11), 1.5); sigma1_2 -= mu1_2; GaussianBlur(I2_2, sigma2_2, Size(11, 11), 1.5); sigma2_2 -= mu2_2; GaussianBlur(I1_I2, sigma12, Size(11, 11), 1.5); sigma12 -= mu1_mu2; Mat t1, t2, t3; t1 = 2 * mu1_mu2 + C1; t2 = 2 * sigma12 + C2; t3 = t1.mul(t2); // t3 = ((2*mu1_mu2 + C1).*(2*sigma12 + C2)) t1 = mu1_2 + mu2_2 + C1; t2 = sigma1_2 + sigma2_2 + C2; t1 = t1.mul(t2); // t1 =((mu1_2 + mu2_2 + C1).*(sigma1_2 + sigma2_2 + C2)) Mat ssim_map; divide(t3, t1, ssim_map); // ssim_map = t3./t1; Scalar mssim = mean( ssim_map ); // mssim = average of ssim map return mssim;&#125; 算法噪声数据我们完成了噪声添加以及噪声的量化, 我们来试一下, 给图像随机添加一定的噪声, 然后看下相应的参数变化情况对比来看就好 椒盐噪声测试我们先来测试椒盐噪声 分别计算没有噪声的图, 以及添加了 1000个 和10000个噪声的数据结果, 并将后面两个显示出来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void MainWindow::testFunc1(void)&#123; // 添加椒盐噪声 并计算 PSNR和 SSIM cv::Mat salt_img; double psnr = 0; cv::Scalar mssim; QString res_temp = \"Salt-%1 : psnr:%2, mssim: B:%3 G:%4 R:%5 \"; QString res_str; // 计算三组图像的参数 0, 1000, 10000 // 复制原始图像, 添加噪声, 计算 psnr和ssim 显示在 ui上 salt_img = gSrcImg.clone(); addSaltNoise(salt_img,0); psnr = getPSNR(gSrcImg, salt_img); mssim = getMSSIM(gSrcImg,salt_img); res_str = res_temp.arg(0) .arg(psnr) .arg(mssim.val[0]) .arg(mssim.val[1]) .arg(mssim.val[2]); ui-&gt;pt_log-&gt;appendPlainText(res_str); salt_img = gSrcImg.clone(); addSaltNoise(salt_img,1000); psnr = getPSNR(gSrcImg, salt_img); mssim = getMSSIM(gSrcImg,salt_img); res_str = res_temp.arg(1000) .arg(psnr) .arg(mssim.val[0]) .arg(mssim.val[1]) .arg(mssim.val[2]); ui-&gt;pt_log-&gt;appendPlainText(res_str); // 左侧显示 1000 噪声 右侧显示 10000 噪声 ShowMatOnQtLabel(salt_img,ui-&gt;lb_src); salt_img = gSrcImg.clone(); addSaltNoise(salt_img,10000); psnr = getPSNR(gSrcImg, salt_img); mssim = getMSSIM(gSrcImg,salt_img); res_str = res_temp.arg(10000) .arg(psnr) .arg(mssim.val[0]) .arg(mssim.val[1]) .arg(mssim.val[2]); ui-&gt;pt_log-&gt;appendPlainText(res_str); ShowMatOnQtLabel(salt_img,ui-&gt;lb_dst);&#125; 我们可以直接计算得到椒盐噪声 psnr 和 ssim 都是越大越好的, 可以明显的看到图像质量退化 123Salt-0 : psnr:0, mssim: B:1 G:1 R:1 Salt-1000 : psnr:27.7528, mssim: B:0.865341 G:0.870555 R:0.914122 Salt-10000 : psnr:17.8062, mssim: B:0.311999 G:0.327485 R:0.493874 高斯噪声测试高斯噪声我们测试了四组 分别使用参数(0,1) (0,10)(10,1)(10,10) 作为高斯参数, 最终得到后面的图, 然后计算得到的结果, 我们做的结果比较简单, 可以参考数字图像处理——添加高斯噪声&amp;椒盐噪声, 给出了很多的图, 可以参考学 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465void MainWindow::testFunc2(void)&#123; // 添加高斯噪声 并计算 PSNR和 SSIM cv::Mat guass_img; double psnr = 0; cv::Scalar mssim; QString res_temp = \"gauss-%1- %2 : psnr:%3, mssim: B:%4 G:%5 R:%6 \"; QString res_str; // 计算三组图像的参数 (0,1) (0,10), (10,1), (10,10) // 复制原始图像, 添加噪声, 计算 psnr和ssim 显示在 ui上 guass_img = gSrcImg.clone(); addGaussianNoise(guass_img,0,1); psnr = getPSNR(gSrcImg, guass_img); mssim = getMSSIM(gSrcImg,guass_img); res_str = res_temp.arg(0) .arg(1) .arg(psnr) .arg(mssim.val[0]) .arg(mssim.val[1]) .arg(mssim.val[2]); ui-&gt;pt_log-&gt;appendPlainText(res_str); guass_img = gSrcImg.clone(); addGaussianNoise(guass_img,0,10); psnr = getPSNR(gSrcImg, guass_img); mssim = getMSSIM(gSrcImg,guass_img); res_str = res_temp.arg(0) .arg(10) .arg(psnr) .arg(mssim.val[0]) .arg(mssim.val[1]) .arg(mssim.val[2]); ui-&gt;pt_log-&gt;appendPlainText(res_str); guass_img = gSrcImg.clone(); addGaussianNoise(guass_img,10,1); psnr = getPSNR(gSrcImg, guass_img); mssim = getMSSIM(gSrcImg,guass_img); res_str = res_temp.arg(10) .arg(1) .arg(psnr) .arg(mssim.val[0]) .arg(mssim.val[1]) .arg(mssim.val[2]); ui-&gt;pt_log-&gt;appendPlainText(res_str); guass_img = gSrcImg.clone(); addGaussianNoise(guass_img,10,10); psnr = getPSNR(gSrcImg, guass_img); mssim = getMSSIM(gSrcImg,guass_img); res_str = res_temp.arg(10) .arg(10) .arg(psnr) .arg(mssim.val[0]) .arg(mssim.val[1]) .arg(mssim.val[2]); ui-&gt;pt_log-&gt;appendPlainText(res_str);&#125; 1234gauss-0- 1 : psnr:46.8791, mssim: B:0.991811 G:0.991622 R:0.992751 gauss-0- 10 : psnr:28.1229, mssim: B:0.614219 G:0.608773 R:0.648285 gauss-10- 1 : psnr:28.5293, mssim: B:0.978448 G:0.980308 R:0.987926 gauss-10- 10 : psnr:25.3511, mssim: B:0.605665 G:0.600491 R:0.646768 总结原本想把滤波一起做了的, 但是越写越, 就不做太多的处理了, 我们算是介绍了噪声的来源, 噪声的模型, 以及个噪声的量化方式,然后介绍了图像添加噪声的方法 我们分别给图像添加椒盐噪声与高斯噪声, 然后分别量化了噪声的结果值, 进行对比展示, 示例的图不是很多, 程序是在代码库里面的, 可以直接去自己实现, 然后进行 进行更多图的展示 参考 《高斯噪声_百度百科》. 见于 2020年4月30日. https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0. 知乎专栏. 《【技术综述】一文道尽传统图像降噪方法》. 见于 2020年4月29日. https://zhuanlan.zhihu.com/p/51403693. 知乎专栏. 《可复现的图像降噪算法总结》. 见于 2020年4月29日. https://zhuanlan.zhihu.com/p/32502816. 《梅森旋转算法》. 收入 维基百科，自由的百科全书, 2019年11月4日. https://zh.wikipedia.org/w/index.php?title=%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95&amp;oldid=56745942. 《实现灰度图像峰值信噪比计算人工智能松子茶的专栏-CSDN博客》. 见于 2020年4月30日. https://blog.csdn.net/songzitea/article/details/17529445. 《数字图像处理-噪声 - Mohanson》. 见于 2020年4月30日. http://accu.cc/content/pil/noise/. 《图像处理基础(1)：噪声的添加和过滤 - Brook_icv - 博客园》. 见于 2020年4月30日. https://www.cnblogs.com/wangguchangqing/p/6372025.html. 《图像处理PSNR及其计算（OpenCV和matlab实现）人工智能无机器不学习-加大码的分享-CSDN博客》. 见于 2020年4月30日. https://blog.csdn.net/laoxuan2011/article/details/51519062. 《图像的 SNR 和 PSNR 的计算 - rldts - 博客园》. 见于 2020年4月30日. https://www.cnblogs.com/qrlozte/p/5340216.html. 《图像去噪算法简介 - InfantSorrow - 博客园》. 见于 2020年4月29日. https://www.cnblogs.com/CCBB/archive/2011/01/06/1929033.html. 《图像噪声的成因分类与常见图像去噪算法简介_Java_qq_27606639的博客-CSDN博客》. 见于 2020年4月30日. https://blog.csdn.net/qq_27606639/article/details/80912071. 《图像质量评估指标 SSIM / PSNR / MSE_人工智能_兔角与禅-CSDN博客》. 见于 2020年4月30日. https://blog.csdn.net/edogawachia/article/details/78756680. 《图像质量评价概述（评估指标、传统检测方法）_人工智能_qq_23304241的博客-CSDN博客》. 见于 2020年4月30日. https://blog.csdn.net/qq_23304241/article/details/80953613. 《影像降噪》. 收入 维基百科，自由的百科全书, 2018年9月20日. https://zh.wikipedia.org/w/index.php?title=%E5%BD%B1%E5%83%8F%E9%99%8D%E5%99%AA&amp;oldid=51354600.","categories":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/categories/opencv/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/tags/opencv/"},{"name":"c++","slug":"c","permalink":"https://schen1024.github.io/tags/c/"},{"name":"qt","slug":"qt","permalink":"https://schen1024.github.io/tags/qt/"}]},{"title":"Imagelab-0-QT label显示 opencv 图像","slug":"Imagelab-0-init","date":"2020-04-27T19:22:38.000Z","updated":"2023-01-01T13:25:24.230Z","comments":true,"path":"2020/04-27/Imagelab-0-init.html","link":"","permalink":"https://schen1024.github.io/2020/04-27/Imagelab-0-init.html","excerpt":"开始之前这其实也是 opencv 处理图像的系列, 只是想我们在进一步复杂化我们的代码之前, 每次给出代码我们都要给出很多, 然后窗口的显示上也有很多不必要的东西, 我们为了后面进行更好的算法效果以及算法执行, 我们先规划一下程序, 写出来一个界面程序出来, 这样的话, 我们之后的程序部分只需要给出一个函数的部分就好, 我们的程序算法在增加的时候, 将功能做到一个一个的菜单里面来, 这样一边处理算法, 一边写出界面图像.. 目录[toc] 正文我们主要将图形界面部分使用代码来实现, 这样不需要进行编译便能够大概知道结果.. 我们在进行复杂的界面之前, 我们先实现一个简单的工程, 能够使用 opencv 读取图片, 然后显示在 qt 的 label 控件 上面, QT 图像格式在 qt 中提供了几种图像显示的方式,可以看这篇文章关于 QPixmap/QImage/QPicture, 详细的介绍了几种格式的使用方法,QT 自带的 QImage 和 QPixmap, 都是支持读取图像的,可以直接用于显示图像, 但是呢, 我们后续还要进行复杂的算法实现, 所以我们还是要转回到 opencv 的怀抱中来, 那么我们不可避免的需要进行数据图像格式之间的互相转换, 目前大多说使用的方式都是 opencv 的 Mat 格式与 QT QPixmap 格式之间的转换, 按后显示到 QT 的 label 上面, 我们先来实现一下: UI 界面设计这里稍微提一下 QT Designer, 我们可以通过托拽的方式实现界面的设计, 也提供了很多组件让我们选择, 我们先暂时使用这种比较简单的方式进行, 后面逐渐介绍更为复杂的操作. 这里我们使用数字 1,2,3,4, 标记了四个区域, 就是我们常用的区域了 编辑区域, 可以编辑与托拽, 能够预览 控件结构树, 各个控件的从属结构, 名称就是 ObjectName 能够在程序使用控件名进行操控 属性区域,能够直接调整相关的参数, 也可以在程序中进行调整各种属性 控件区域, 不同种类的控件, 可以用于托拽, 直接显示在窗口中.. 具体的实现方式不用去深究, 且通过托拽改变 .ui 文件, 实际上就是 一个 xml 格式的文件, QT 通过 uic 会将 xxx.ui 转换成 ui_xxx.h 文件, 我们通过引用即可直接操控控件了, 如果我们改变了 ui, 但是运行之后没有更新, 在工程山强制 qmake 一下就能解决了 在我们这个工程中, 我们托拽了两个 QLabel 组件和两个 QPushButton 组件, 相应的可以在上图的 2 区域看到对象名称.. MainWindow: geometry: 0,0,960,540 : 我们运行的窗口尺寸 windowsTitle: “ImageLab” lb_src: geometry: 20,30,400,400 用于指定控件的左上角位置和 尺寸宽高, 我们使用这个参数指定即可 frameShape: WinPanel lb_dst: geometry: 470,30,400,400 用于指定控件的左上角位置和 尺寸宽高, 我们使用这个参数指定即可 frameShape: WinPanel btn_test1,btn_test2: 都是默认托拽的 , 尺寸默认, 位置 随意就好, 后面用于我们进行一下测试算法 暂时忽略 pt_log: 多行文本, 用于显示一些结果信息, 测试过程中的一些输出 我们这个界面也没有布局, 就是很简单的把东西给显示出来, 在编辑之后 按 Shift+Alt+R能够预览界面,如果有布局之类的需要及时查看, 我们这里就是简单的 ui , 布局什么样 得到的就是什么样子 我们后面的测试可能就是左边显示原始图像, 右边显示运算之后 的图像, 我们来实现一下 这里关于 ui 界面的设计 只是稍微提一下, 你们可以直接查看其他的文章介绍的使用方法, 简单点的可以看使用 Qt Designer 来设计界面和使用 Qt Designer 创建界面 信号与槽 实现 UI 点击事件在我们进行显示图像之前, 我们稍微介绍一下 QT 的信号与槽的实现方式, QT 最 NB 的地方实现了信号与槽 , 简单理解就是, 我们提前将信号与一个槽(函数)声明连接, 然后我们点击一个按钮 会发射一个信号, 然后经过 QT 的信号处理机制 就能够调用我们提前设定的函数了, PS: 只是粗略 的这么看就行, 具体还要复杂很多, 后面再说 我们简单实现一下 这个功能, 点击输出我们点击可哪个按钮..我们点击 测试按钮1: btn_test1调用一个函数 testFunc1, 然后在结果框输出点击了按钮1 , ,我们只看 核心的代码部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// mainwindow.cpp#include \"mainwindow.h\"#include \"ui_mainwindow.h\"MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); // 设定信号与槽 连接 connect(ui-&gt;btn_test1,&amp;QPushButton::clicked,this,&amp;MainWindow::testFunc1); connect(ui-&gt;btn_test2,&amp;QPushButton::clicked,this,&amp;MainWindow::testFunc2); // 初始化 ui ui-&gt;pt_log-&gt;clear(); // 清除框内输出&#125;MainWindow::~MainWindow()&#123; delete ui;&#125;void MainWindow::testFunc1(void)&#123; ui-&gt;pt_log-&gt;appendPlainText(\"你点击了 测试按钮 1 \");&#125;void MainWindow::testFunc2(void)&#123; ui-&gt;pt_log-&gt;appendPlainText(\"你点击了 测试按钮 2\");&#125;// mainwindow.h#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class MainWindow; &#125;QT_END_NAMESPACEclass MainWindow : public QMainWindow&#123; Q_OBJECTpublic slots: void testFunc1(void); void testFunc2(void);public: MainWindow(QWidget *parent = nullptr); ~MainWindow();private: Ui::MainWindow *ui;&#125;;#endif // MAINWINDOW_H// main.cpp#include \"mainwindow.h\"#include &lt;QApplication&gt;// 运行主窗口 用于显示界面 uiint main(int argc, char *argv[])&#123; QApplication a(argc, argv); MainWindow w; w.show(); return a.exec();&#125; 这里可以看 代码仓库 SChen1024/ImageLab V0.1.0 我们的程序一直是同步提交到 github 和 gitee 的, 有什么问题可以去看代码 QImage 和 QPixmap 显示图像上面就是在简单的测试一下, 那我们 现在就开始正式的工作 首先看下直接读取文件的方式,我们将上一节中 输出语句的函数部分换成加载图片, 能够得到下面的函数部分, 进而运行就能够得到结果图 1234567891011121314151617// 图片路径QString lena_img = \"../testimages/lena.png\";void MainWindow::testFunc1(void)&#123; QPixmap pixmap; pixmap.load(lena_img); ui-&gt;lb_src-&gt;setPixmap(pixmap); ui-&gt;pt_log-&gt;appendPlainText(\"左侧使用 QPixmap load 图像数据1 \");&#125;void MainWindow::testFunc2(void)&#123; QImage image(lena_img); ui-&gt;lb_dst-&gt;setPixmap(QPixmap::fromImage(image)); ui-&gt;pt_log-&gt;appendPlainText(\"右侧使用 QImage 转换成 QPixmap 进行显示2 \");&#125; 其实 label 只能显示 pixmap 图像, 而且十分简单操作, 而 QImage 也是转换成 QPixmap 之后才做的显示, 不过在可以去看QImage 与 QPixmap 加载图片 效果 .中介绍了其他的方式显示图像, 我们就不去深究了, QT 显示 opencv mat 图像终于终于到了我们这篇文章的重点了, 其实经过上面的铺垫, 我们 opencv 读取图像之后要做的就是 将 mat 图像转换成 QImage 或者 QPixmap 图像就好了, 多一步转换过程, 目前没有找到 mat 直接转换成 QPixmap 的方式 , 目前的实现都是 转换成 QImage 然后再转换的方式, 直接搜索 opencv Mat 转 QImage 能找到很多结果, 其实呢 原理都很简单, 根据原始图像的通道数目将图像转换成相应的 QImage 格式, 比如 3 通道的 rgb 图像转换 QImage image(mat.data, mat.cols, mat.rows,static_cast&lt;int&gt;(mat.step),QImage::Format_RGB888); 我们能够得到这样的结果, 很简单就能实现, 获取图像的宽度, 高度, 以及最重要的 data 也就是图像的数据指针, 然后依次转换成我们需要的 QImage 图像即可, 值得注意的是, opencv 是 BGR 图像的顺序, 所以最后要进行颜色通道的转换, 转换成 rgb 不然颜色会有点奇怪.. 具体的参数可以参考我之前的博文, 关于 mat 的 step 属性可以参考OpenCV 中 Mat 属性 step，size，step1，elemSize，elemSize1 这里附上 opencv Mat 与 QImage 的互相转换, 这里没有使用 if 为了更好看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * @fn QImage CvMat2QImage(const cv::Mat &amp; mat) * * @brief 将opencv mat 转换成 QT image * * @author IRIS_Chen * @date 2019/12/19 * * @param mat The matrix * * @return A QImage */QImage CvMat2QImage(const cv::Mat &amp;mat)&#123; // 图像的通道 int channel = mat.channels(); // 设立一个表 直接查询 其中 0 2 是无效值 1 3 4 对应的转换值 const std::map&lt;int, QImage::Format&gt; img_cvt_map &#123; &#123; 1, QImage::Format_Grayscale8 &#125;, &#123; 3, QImage::Format_RGB888 &#125;, &#123; 4, QImage::Format_ARGB32 &#125; &#125;; QImage image(mat.data, mat.cols, mat.rows, static_cast&lt;int&gt;(mat.step), img_cvt_map.at(channel)); // 三通道图像 值做 通道转换 return channel == 3 ? image.rgbSwapped() : image;&#125;/*** @fn static cv::Mat QImage2CvMat(const QImage &amp;image);** @brief QT Image 转换成 cv Mat 结构** @author IRIS_Chen* @date 2019/12/19** @param image The image** @return A cv::Mat*/cv::Mat QImage2CvMat(const QImage &amp;image)&#123; cv::Mat mat; const std::map&lt;QImage::Format, int&gt; img_cvt_map&#123; &#123; QImage::Format_Grayscale8, 1 &#125;, &#123; QImage::Format_RGB888, 3 &#125;, &#123; QImage::Format_ARGB32, 4&#125; &#125;; return cv::Mat(image.height(), image.width(),img_cvt_map.at(image.format()));&#125; 为了便于区分, 我们在处理图像的时候, 在图上分别显示一个字符串, opencv 的显示图像我们已经介绍过了, QT QPixmap 显示 字符串可以参考Qt 2D 绘图之三：绘制文字、路径、图像、复合模式 12345678910111213141516171819202122232425262728// 图片路径QString lena_img = \"../testimages/lena.png\";void MainWindow::testFunc1(void)&#123; QPixmap pixmap; pixmap.load(lena_img); // 在图上绘制文字 QPainter painter(&amp;pixmap); painter.setPen(QColor(Qt::yellow)); painter.drawText(100,100,\"QT QPixmap\"); ui-&gt;lb_src-&gt;setPixmap(pixmap); ui-&gt;pt_log-&gt;appendPlainText(\"左侧使用 QPixmap load 图像数据1 \");&#125;void MainWindow::testFunc2(void)&#123; cv::Mat mat = cv::imread(\"../testimages/lena.png\"); // 在图上显示文字 cv::putText(mat,\"OpenCV Mat\",cv::Point(100,100),cv::FONT_HERSHEY_COMPLEX,1.0, cv::Scalar(0, 255, 255)); QImage image = CvMat2QImage(mat); ui-&gt;lb_dst-&gt;setPixmap(QPixmap::fromImage(image)); ui-&gt;pt_log-&gt;appendPlainText(\"右侧使用 Mat --&gt; QImage --&gt; QPixmap 进行显示2 \");&#125; 运行得到的结果图片 opencv 就是 使用 mat 读取图像, 然后 转换成 QImage, 转换通道 ,再转换成 QPixmap 最后显示在 QLabel 上, 其他","text":"开始之前这其实也是 opencv 处理图像的系列, 只是想我们在进一步复杂化我们的代码之前, 每次给出代码我们都要给出很多, 然后窗口的显示上也有很多不必要的东西, 我们为了后面进行更好的算法效果以及算法执行, 我们先规划一下程序, 写出来一个界面程序出来, 这样的话, 我们之后的程序部分只需要给出一个函数的部分就好, 我们的程序算法在增加的时候, 将功能做到一个一个的菜单里面来, 这样一边处理算法, 一边写出界面图像.. 目录[toc] 正文我们主要将图形界面部分使用代码来实现, 这样不需要进行编译便能够大概知道结果.. 我们在进行复杂的界面之前, 我们先实现一个简单的工程, 能够使用 opencv 读取图片, 然后显示在 qt 的 label 控件 上面, QT 图像格式在 qt 中提供了几种图像显示的方式,可以看这篇文章关于 QPixmap/QImage/QPicture, 详细的介绍了几种格式的使用方法,QT 自带的 QImage 和 QPixmap, 都是支持读取图像的,可以直接用于显示图像, 但是呢, 我们后续还要进行复杂的算法实现, 所以我们还是要转回到 opencv 的怀抱中来, 那么我们不可避免的需要进行数据图像格式之间的互相转换, 目前大多说使用的方式都是 opencv 的 Mat 格式与 QT QPixmap 格式之间的转换, 按后显示到 QT 的 label 上面, 我们先来实现一下: UI 界面设计这里稍微提一下 QT Designer, 我们可以通过托拽的方式实现界面的设计, 也提供了很多组件让我们选择, 我们先暂时使用这种比较简单的方式进行, 后面逐渐介绍更为复杂的操作. 这里我们使用数字 1,2,3,4, 标记了四个区域, 就是我们常用的区域了 编辑区域, 可以编辑与托拽, 能够预览 控件结构树, 各个控件的从属结构, 名称就是 ObjectName 能够在程序使用控件名进行操控 属性区域,能够直接调整相关的参数, 也可以在程序中进行调整各种属性 控件区域, 不同种类的控件, 可以用于托拽, 直接显示在窗口中.. 具体的实现方式不用去深究, 且通过托拽改变 .ui 文件, 实际上就是 一个 xml 格式的文件, QT 通过 uic 会将 xxx.ui 转换成 ui_xxx.h 文件, 我们通过引用即可直接操控控件了, 如果我们改变了 ui, 但是运行之后没有更新, 在工程山强制 qmake 一下就能解决了 在我们这个工程中, 我们托拽了两个 QLabel 组件和两个 QPushButton 组件, 相应的可以在上图的 2 区域看到对象名称.. MainWindow: geometry: 0,0,960,540 : 我们运行的窗口尺寸 windowsTitle: “ImageLab” lb_src: geometry: 20,30,400,400 用于指定控件的左上角位置和 尺寸宽高, 我们使用这个参数指定即可 frameShape: WinPanel lb_dst: geometry: 470,30,400,400 用于指定控件的左上角位置和 尺寸宽高, 我们使用这个参数指定即可 frameShape: WinPanel btn_test1,btn_test2: 都是默认托拽的 , 尺寸默认, 位置 随意就好, 后面用于我们进行一下测试算法 暂时忽略 pt_log: 多行文本, 用于显示一些结果信息, 测试过程中的一些输出 我们这个界面也没有布局, 就是很简单的把东西给显示出来, 在编辑之后 按 Shift+Alt+R能够预览界面,如果有布局之类的需要及时查看, 我们这里就是简单的 ui , 布局什么样 得到的就是什么样子 我们后面的测试可能就是左边显示原始图像, 右边显示运算之后 的图像, 我们来实现一下 这里关于 ui 界面的设计 只是稍微提一下, 你们可以直接查看其他的文章介绍的使用方法, 简单点的可以看使用 Qt Designer 来设计界面和使用 Qt Designer 创建界面 信号与槽 实现 UI 点击事件在我们进行显示图像之前, 我们稍微介绍一下 QT 的信号与槽的实现方式, QT 最 NB 的地方实现了信号与槽 , 简单理解就是, 我们提前将信号与一个槽(函数)声明连接, 然后我们点击一个按钮 会发射一个信号, 然后经过 QT 的信号处理机制 就能够调用我们提前设定的函数了, PS: 只是粗略 的这么看就行, 具体还要复杂很多, 后面再说 我们简单实现一下 这个功能, 点击输出我们点击可哪个按钮..我们点击 测试按钮1: btn_test1调用一个函数 testFunc1, 然后在结果框输出点击了按钮1 , ,我们只看 核心的代码部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// mainwindow.cpp#include \"mainwindow.h\"#include \"ui_mainwindow.h\"MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); // 设定信号与槽 连接 connect(ui-&gt;btn_test1,&amp;QPushButton::clicked,this,&amp;MainWindow::testFunc1); connect(ui-&gt;btn_test2,&amp;QPushButton::clicked,this,&amp;MainWindow::testFunc2); // 初始化 ui ui-&gt;pt_log-&gt;clear(); // 清除框内输出&#125;MainWindow::~MainWindow()&#123; delete ui;&#125;void MainWindow::testFunc1(void)&#123; ui-&gt;pt_log-&gt;appendPlainText(\"你点击了 测试按钮 1 \");&#125;void MainWindow::testFunc2(void)&#123; ui-&gt;pt_log-&gt;appendPlainText(\"你点击了 测试按钮 2\");&#125;// mainwindow.h#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class MainWindow; &#125;QT_END_NAMESPACEclass MainWindow : public QMainWindow&#123; Q_OBJECTpublic slots: void testFunc1(void); void testFunc2(void);public: MainWindow(QWidget *parent = nullptr); ~MainWindow();private: Ui::MainWindow *ui;&#125;;#endif // MAINWINDOW_H// main.cpp#include \"mainwindow.h\"#include &lt;QApplication&gt;// 运行主窗口 用于显示界面 uiint main(int argc, char *argv[])&#123; QApplication a(argc, argv); MainWindow w; w.show(); return a.exec();&#125; 这里可以看 代码仓库 SChen1024/ImageLab V0.1.0 我们的程序一直是同步提交到 github 和 gitee 的, 有什么问题可以去看代码 QImage 和 QPixmap 显示图像上面就是在简单的测试一下, 那我们 现在就开始正式的工作 首先看下直接读取文件的方式,我们将上一节中 输出语句的函数部分换成加载图片, 能够得到下面的函数部分, 进而运行就能够得到结果图 1234567891011121314151617// 图片路径QString lena_img = \"../testimages/lena.png\";void MainWindow::testFunc1(void)&#123; QPixmap pixmap; pixmap.load(lena_img); ui-&gt;lb_src-&gt;setPixmap(pixmap); ui-&gt;pt_log-&gt;appendPlainText(\"左侧使用 QPixmap load 图像数据1 \");&#125;void MainWindow::testFunc2(void)&#123; QImage image(lena_img); ui-&gt;lb_dst-&gt;setPixmap(QPixmap::fromImage(image)); ui-&gt;pt_log-&gt;appendPlainText(\"右侧使用 QImage 转换成 QPixmap 进行显示2 \");&#125; 其实 label 只能显示 pixmap 图像, 而且十分简单操作, 而 QImage 也是转换成 QPixmap 之后才做的显示, 不过在可以去看QImage 与 QPixmap 加载图片 效果 .中介绍了其他的方式显示图像, 我们就不去深究了, QT 显示 opencv mat 图像终于终于到了我们这篇文章的重点了, 其实经过上面的铺垫, 我们 opencv 读取图像之后要做的就是 将 mat 图像转换成 QImage 或者 QPixmap 图像就好了, 多一步转换过程, 目前没有找到 mat 直接转换成 QPixmap 的方式 , 目前的实现都是 转换成 QImage 然后再转换的方式, 直接搜索 opencv Mat 转 QImage 能找到很多结果, 其实呢 原理都很简单, 根据原始图像的通道数目将图像转换成相应的 QImage 格式, 比如 3 通道的 rgb 图像转换 QImage image(mat.data, mat.cols, mat.rows,static_cast&lt;int&gt;(mat.step),QImage::Format_RGB888); 我们能够得到这样的结果, 很简单就能实现, 获取图像的宽度, 高度, 以及最重要的 data 也就是图像的数据指针, 然后依次转换成我们需要的 QImage 图像即可, 值得注意的是, opencv 是 BGR 图像的顺序, 所以最后要进行颜色通道的转换, 转换成 rgb 不然颜色会有点奇怪.. 具体的参数可以参考我之前的博文, 关于 mat 的 step 属性可以参考OpenCV 中 Mat 属性 step，size，step1，elemSize，elemSize1 这里附上 opencv Mat 与 QImage 的互相转换, 这里没有使用 if 为了更好看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * @fn QImage CvMat2QImage(const cv::Mat &amp; mat) * * @brief 将opencv mat 转换成 QT image * * @author IRIS_Chen * @date 2019/12/19 * * @param mat The matrix * * @return A QImage */QImage CvMat2QImage(const cv::Mat &amp;mat)&#123; // 图像的通道 int channel = mat.channels(); // 设立一个表 直接查询 其中 0 2 是无效值 1 3 4 对应的转换值 const std::map&lt;int, QImage::Format&gt; img_cvt_map &#123; &#123; 1, QImage::Format_Grayscale8 &#125;, &#123; 3, QImage::Format_RGB888 &#125;, &#123; 4, QImage::Format_ARGB32 &#125; &#125;; QImage image(mat.data, mat.cols, mat.rows, static_cast&lt;int&gt;(mat.step), img_cvt_map.at(channel)); // 三通道图像 值做 通道转换 return channel == 3 ? image.rgbSwapped() : image;&#125;/*** @fn static cv::Mat QImage2CvMat(const QImage &amp;image);** @brief QT Image 转换成 cv Mat 结构** @author IRIS_Chen* @date 2019/12/19** @param image The image** @return A cv::Mat*/cv::Mat QImage2CvMat(const QImage &amp;image)&#123; cv::Mat mat; const std::map&lt;QImage::Format, int&gt; img_cvt_map&#123; &#123; QImage::Format_Grayscale8, 1 &#125;, &#123; QImage::Format_RGB888, 3 &#125;, &#123; QImage::Format_ARGB32, 4&#125; &#125;; return cv::Mat(image.height(), image.width(),img_cvt_map.at(image.format()));&#125; 为了便于区分, 我们在处理图像的时候, 在图上分别显示一个字符串, opencv 的显示图像我们已经介绍过了, QT QPixmap 显示 字符串可以参考Qt 2D 绘图之三：绘制文字、路径、图像、复合模式 12345678910111213141516171819202122232425262728// 图片路径QString lena_img = \"../testimages/lena.png\";void MainWindow::testFunc1(void)&#123; QPixmap pixmap; pixmap.load(lena_img); // 在图上绘制文字 QPainter painter(&amp;pixmap); painter.setPen(QColor(Qt::yellow)); painter.drawText(100,100,\"QT QPixmap\"); ui-&gt;lb_src-&gt;setPixmap(pixmap); ui-&gt;pt_log-&gt;appendPlainText(\"左侧使用 QPixmap load 图像数据1 \");&#125;void MainWindow::testFunc2(void)&#123; cv::Mat mat = cv::imread(\"../testimages/lena.png\"); // 在图上显示文字 cv::putText(mat,\"OpenCV Mat\",cv::Point(100,100),cv::FONT_HERSHEY_COMPLEX,1.0, cv::Scalar(0, 255, 255)); QImage image = CvMat2QImage(mat); ui-&gt;lb_dst-&gt;setPixmap(QPixmap::fromImage(image)); ui-&gt;pt_log-&gt;appendPlainText(\"右侧使用 Mat --&gt; QImage --&gt; QPixmap 进行显示2 \");&#125; 运行得到的结果图片 opencv 就是 使用 mat 读取图像, 然后 转换成 QImage, 转换通道 ,再转换成 QPixmap 最后显示在 QLabel 上, 其他","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/tags/opencv/"},{"name":"c++","slug":"c","permalink":"https://schen1024.github.io/tags/c/"},{"name":"qt","slug":"qt","permalink":"https://schen1024.github.io/tags/qt/"},{"name":"imagelab","slug":"imagelab","permalink":"https://schen1024.github.io/tags/imagelab/"}]},{"title":"服务器站点列表","slug":"服务器站点列表","date":"2020-04-26T16:44:49.000Z","updated":"2023-01-01T13:25:24.789Z","comments":true,"path":"2020/04-26/服务器站点列表.html","link":"","permalink":"https://schen1024.github.io/2020/04-26/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%99%E7%82%B9%E5%88%97%E8%A1%A8.html","excerpt":"介绍目前 Aliserver 服务器负责托管 WHUHoude 工程下的所有网站主要分由于网站未进行备案细节, 所以网站无法直接通过80端口访问 网站的具体配置信息, 可参考博文, 主要是部署了 旧版本的asp 程序和 少量的php 网站 网站列表asp网站使用的是系统自带的 IIS 开启了88 端口, 主要是旧版本的网站可以通过whupmc.cn 域名访问, php 网站使用的 phpstudy 便携版本搭建的 Apache + MySQL 主要的网站列表是:","text":"介绍目前 Aliserver 服务器负责托管 WHUHoude 工程下的所有网站主要分由于网站未进行备案细节, 所以网站无法直接通过80端口访问 网站的具体配置信息, 可参考博文, 主要是部署了 旧版本的asp 程序和 少量的php 网站 网站列表asp网站使用的是系统自带的 IIS 开启了88 端口, 主要是旧版本的网站可以通过whupmc.cn 域名访问, php 网站使用的 phpstudy 便携版本搭建的 Apache + MySQL 主要的网站列表是:","categories":[{"name":"Person","slug":"Person","permalink":"https://schen1024.github.io/categories/Person/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://schen1024.github.io/tags/blog/"},{"name":"server","slug":"server","permalink":"https://schen1024.github.io/tags/server/"},{"name":"html","slug":"html","permalink":"https://schen1024.github.io/tags/html/"},{"name":"asp","slug":"asp","permalink":"https://schen1024.github.io/tags/asp/"},{"name":"php","slug":"php","permalink":"https://schen1024.github.io/tags/php/"}]},{"title":"opencv-8-图像核与蒙板操作","slug":"opencv-8-kernel","date":"2020-04-25T15:31:42.000Z","updated":"2023-01-01T13:25:24.777Z","comments":true,"path":"2020/04-25/opencv-8-kernel.html","link":"","permalink":"https://schen1024.github.io/2020/04-25/opencv-8-kernel.html","excerpt":"开始之前在准备开始的时候, 我大概列了一个opencv 章节列表, 按照章节进行写, 写到某些部分的时候再具体调整章节内容, 完成了之后, 会将具体的章节链接更新到这个列表中 算是作为一个目录吧.有的章节写到很快, 有的章节写的很慢, 但是我会坚持一直写下去 目录[toc] 开始按照我的写作计划, 之前算是完成了前面的大的章节, 我们开始正式进入图像处理的章节了, 在之前的章节中,我们介绍了图像的遍历操作, 我们从一个基础的问题出发, 我们对于每一点的像素值, 每个点减去他上面边的点的值作为结果值, 那我们会得到什么图呢, 图像下侧差分这我们为了简单运算吧, 我们提前将结果初始化为0, 然后将每一行的像素减去它上面的像素, 作为结果当前点的颜色值 我们看下代码以及跑起来看下会是什么结果 1234567891011121314151617181920212223242526int main(int argc, char *argv[])&#123; // 设置 要显示的图像路径 std::string lena_png = \"./TestImages/lena.png\"; cv::Mat src_img = cv::imread(lena_png); cv::Mat res_img = cv::Mat::zeros(src_img.size(), CV_8UC3); // 初始化所有结果为 0 第一行不存在上一行, 默认为0 彩色图像 每个通道都计算 for (int i = 1; i &lt; src_img.rows; i++) &#123; for (int j = 0; j &lt; src_img.cols; j++) &#123; for (int k = 0; k &lt; src_img.channels(); k++) &#123; res_img.at&lt;cv::Vec3b&gt;(i, j)[k] = src_img.at&lt;cv::Vec3b&gt;(i, j)[k] - src_img.at&lt;cv::Vec3b&gt;(i-1, j)[k]; &#125; &#125; &#125; cv::imshow(\"src_img\", src_img); cv::imshow(\"res_img\", res_img); cv::waitKey(0); return 0; // return a.exec();&#125; 其中核心部分就是计算 res_img.at&lt;cv::Vec3b&gt;(i, j)[k] = src_img.at&lt;cv::Vec3b&gt;(i, j)[k] - src_img.at&lt;cv::Vec3b&gt;(i-1, j)[k]; 颜色部分, 我们的 i 从第一行开始的 所以不会出现索引出错, 这个操作比较简单, 我们得到了下面的图像结果, 图像锐化操作我们这里说一下, 在之前的章节也都提过, 在图像处理的过程中, 我们一般采用的是灰度图像, 能够有效的获取到图像的细节特征, 而且计算起来比较方便, 所以我们在后续进行一下算法处理的时候会采用灰度图像, 特此说明 根据opencv 例程Mask operations on matrices 中提到的一个案例, 我计算一个点与它四邻域的的差值的 也就是$$g(i,j) = f(i,j) + (f(i,j)-f(i-1,j))+ (f(i,j)-f(i,j-1))+ (f(i,j)-f(i,j+1))+ (f(i,j)-f(i+1,j));$$在线性代数中, 我们的运算都能转换成矩阵的运算, 那么, 我们抽象一下, 我们能够得到这样的一个结果,$$g(i,j) = M\\cdot f(i,j), \\quad M = \\begin{bmatrix} 0 &amp; -1 &amp; 0 \\ -1 &amp; 5 &amp; -1 \\ 0 &amp; -1 &amp; 0 \\end{bmatrix}$$ 与我们的运算得到的等式是一致的, 我们考虑一下怎么实现, 这里我们也参考 例程里面的实现,我们将算法部分封装起来 这里我们使用cv::Mat res_img = testFunc(src_img); 这样的方法, 然后主要去实现 testFunc函数就行了, 后面我们为了不再重复的贴出代码, 希望之后看到的话 不要有疑问.1234567891011121314151617181920212223242526272829303132333435363738#include \"mainwindow.h\"#include &lt;QApplication&gt;// 引入 opencv 函数头文件#include &lt;opencv2/opencv.hpp&gt;// 进行 测试 算法cv::Mat testFunc(const cv::Mat &amp;src_img)&#123; cv::Mat res_img = cv::Mat::zeros(src_img.size(), CV_8UC1); for (int i = 1; i &lt; src_img.rows - 1; i++) &#123; for (int j = 1; j &lt; src_img.cols - 1; j++) &#123; res_img.at&lt;uchar&gt;(i, j) = cv::saturate_cast&lt;uchar&gt;( src_img.at&lt;uchar&gt;(i, j) + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i - 1, j) + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i + 1, j) + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i, j - 1) + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i, j + 1)); &#125; &#125; return res_img;&#125;int main(int argc, char *argv[])&#123; // 设置 要显示的图像路径 std::string lena_png = \"./TestImages/lena.png\"; cv::Mat src_img = cv::imread(lena_png); cv::cvtColor(src_img, src_img, cv::COLOR_BGR2GRAY); cv::Mat res_img = testFunc(src_img); cv::imshow(\"src_img\", src_img); cv::imshow(\"res_img\", res_img); cv::waitKey(0); return 0; // return a.exec();&#125;我们上面提出的算法就是在进行图像的锐化操作,相当于在原始像素的基础上加上了我们原图与四邻域像素的差值, 这样我们能够将边缘梯度过大的区域进行增强, 平滑部分则不会过分处理, 最终得到这样的图像处理结果.. opencv 核操作我们在处理的时候实际上没有解决边缘的问题, 在结果图中可以看到四个边缘各有一个像素的黑色边缘, 我们可以考虑计算其他的简化计算方式, 但是太过与繁琐了, 为了优化体验我们就没有处理, 但是 opencv 中提供了 一种通用的方式进行处理 也就是核, 我们先看下实现方式12345cv::Mat kernel = (cv::Mat_&lt;char&gt;(3, 3) &lt;&lt; 0, -1, 0,truetruetruetruetruetruetruetruetruetrue-1, 5, -1,truetruetruetruetruetruetruetruetruetrue0, -1, 0);cv::Mat res_img2;cv::filter2D(src_img, res_img2, src_img.depth(), kernel);我们设定核之后. 可以直接进行操作, 我们可以通过改动核从而进行图像处理, 看下图, 好像得到右侧的图像效果更好 运行时间对比两种实现结果是大概一致的, 算法上执行是一样的 , 那时间呢,在之前的章节, 我们介绍了不同的图像遍历的方式进行图像遍历, 时间上差异还是比较大的, 这次我们同样使用了两种方式进行: 索引访问和指针访问进行图像处理, 算法部分的实现是一致的, 我们写了testFunc和 testFunc2 两个函数, 相应的代代码可以看下面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include \"mainwindow.h\"#include &lt;QApplication&gt;// 引入 opencv 函数头文件#include &lt;opencv2/opencv.hpp&gt;// 进行 测试 算法cv::Mat testFunc(const cv::Mat &amp;src_img)&#123; cv::Mat res_img = cv::Mat::zeros(src_img.size(), CV_8UC1); for (int i = 1; i &lt; src_img.rows - 1; i++) &#123; for (int j = 1; j &lt; src_img.cols - 1; j++) &#123; res_img.at&lt;uchar&gt;(i, j) = cv::saturate_cast&lt;uchar&gt;(src_img.at&lt;uchar&gt;(i, j) + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i - 1, j) + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i + 1, j) + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i, j - 1) + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i, j + 1)); &#125; &#125; return res_img;&#125;// 使用测试 指针函数cv::Mat testFunc2(const cv::Mat &amp;src_img)&#123; cv::Mat res_img = cv::Mat::zeros(src_img.size(), CV_8UC1); for (int i = 1; i &lt; src_img.rows - 1; i++) &#123; const uchar* p_row_pre = src_img.ptr&lt;uchar&gt;(i - 1); const uchar* p_row_cur = src_img.ptr&lt;uchar&gt;(i); const uchar* p_row_next = src_img.ptr&lt;uchar&gt;(i + 1); uchar* p_row_res = res_img.ptr&lt;uchar&gt;(i); for (int j = 1; j &lt; src_img.cols - 1; j++) &#123; *p_row_res++ = cv::saturate_cast&lt;uchar&gt;(5 * p_row_cur[j] - p_row_cur[j-1] - p_row_cur[j+1] - p_row_pre[j] - p_row_next[j]); &#125; &#125; return res_img;&#125;int main(int argc, char *argv[])&#123; // 设置 要显示的图像路径 std::string lena_png = \"./TestImages/lena.png\"; cv::Mat src_img = cv::imread(lena_png); cv::cvtColor(src_img, src_img, cv::COLOR_BGR2GRAY); // 测试索引方式进行 锐化运算 double t = (double)cv::getTickCount(); cv::Mat res_img = testFunc(src_img); t = ((double)cv::getTickCount() - t) / cv::getTickFrequency(); std::cout &lt;&lt; \"sharpen-index: \\t\\t\" &lt;&lt; t &lt;&lt; std::endl; // 测试 指针方式进行 锐化运算 t = (double)cv::getTickCount(); res_img = testFunc2(src_img); t = ((double)cv::getTickCount() - t) / cv::getTickFrequency(); std::cout &lt;&lt; \"sharpen-pointer: \\t\" &lt;&lt; t &lt;&lt; std::endl; cv::Mat kernel = (cv::Mat_&lt;char&gt;(3, 3) &lt;&lt; 0, -1, 0, -1, 5, -1, 0, -1, 0); cv::Mat res_img2; // 测试 filter 2D 算法时间 t = (double)cv::getTickCount(); cv::filter2D(src_img, res_img2, src_img.depth(), kernel); t = ((double)cv::getTickCount() - t) / cv::getTickFrequency(); std::cout &lt;&lt; \"sharpen-filter: \\t\" &lt;&lt; t &lt;&lt; std::endl; cv::imshow(\"src_img\", src_img); cv::imshow(\"res_img\", res_img); cv::imshow(\"res_img2\", res_img2); cv::waitKey(0); return 0; // return a.exec();&#125; 算法实现上很简单, 就是我们上面提到得到方法, 结果以是接近一致的, 但是时间上差的还是比较多, 使用 filter2D 的方式访问得到的图像还是比较好看的, 运行时间也是要比我们自己通过索引方式进行的算法要快很很多的, 但是相比我们使用指针还是有所不如, 123sharpen-index: 0.0747024 ssharpen-pointer: 0.0040774 ssharpen-filter: 0.0416613 s 我们在 modules\\imgproc\\src\\filter.dispatch.cpp:1403 的位置看到了 filter2D 函数的定义123void filter2D(InputArray _src, OutputArray _dst, int ddepth, InputArray _kernel, Point anchor0, double delta, int borderType); 相应的我们去看 调用图 函数的主要调用使用了加速层的modules\\imgproc\\src\\filter.dispatch.cpp:1307 处的 hal::filter2D 函数这里涉及的部分还比较多, 可能也是由于调用的更底层的以及做了更多的边缘处理的原因 导致实际上花费的时间也更加的长, 这里暂时不去深究, 如果有机会再做进一步分析","text":"开始之前在准备开始的时候, 我大概列了一个opencv 章节列表, 按照章节进行写, 写到某些部分的时候再具体调整章节内容, 完成了之后, 会将具体的章节链接更新到这个列表中 算是作为一个目录吧.有的章节写到很快, 有的章节写的很慢, 但是我会坚持一直写下去 目录[toc] 开始按照我的写作计划, 之前算是完成了前面的大的章节, 我们开始正式进入图像处理的章节了, 在之前的章节中,我们介绍了图像的遍历操作, 我们从一个基础的问题出发, 我们对于每一点的像素值, 每个点减去他上面边的点的值作为结果值, 那我们会得到什么图呢, 图像下侧差分这我们为了简单运算吧, 我们提前将结果初始化为0, 然后将每一行的像素减去它上面的像素, 作为结果当前点的颜色值 我们看下代码以及跑起来看下会是什么结果 1234567891011121314151617181920212223242526int main(int argc, char *argv[])&#123; // 设置 要显示的图像路径 std::string lena_png = \"./TestImages/lena.png\"; cv::Mat src_img = cv::imread(lena_png); cv::Mat res_img = cv::Mat::zeros(src_img.size(), CV_8UC3); // 初始化所有结果为 0 第一行不存在上一行, 默认为0 彩色图像 每个通道都计算 for (int i = 1; i &lt; src_img.rows; i++) &#123; for (int j = 0; j &lt; src_img.cols; j++) &#123; for (int k = 0; k &lt; src_img.channels(); k++) &#123; res_img.at&lt;cv::Vec3b&gt;(i, j)[k] = src_img.at&lt;cv::Vec3b&gt;(i, j)[k] - src_img.at&lt;cv::Vec3b&gt;(i-1, j)[k]; &#125; &#125; &#125; cv::imshow(\"src_img\", src_img); cv::imshow(\"res_img\", res_img); cv::waitKey(0); return 0; // return a.exec();&#125; 其中核心部分就是计算 res_img.at&lt;cv::Vec3b&gt;(i, j)[k] = src_img.at&lt;cv::Vec3b&gt;(i, j)[k] - src_img.at&lt;cv::Vec3b&gt;(i-1, j)[k]; 颜色部分, 我们的 i 从第一行开始的 所以不会出现索引出错, 这个操作比较简单, 我们得到了下面的图像结果, 图像锐化操作我们这里说一下, 在之前的章节也都提过, 在图像处理的过程中, 我们一般采用的是灰度图像, 能够有效的获取到图像的细节特征, 而且计算起来比较方便, 所以我们在后续进行一下算法处理的时候会采用灰度图像, 特此说明 根据opencv 例程Mask operations on matrices 中提到的一个案例, 我计算一个点与它四邻域的的差值的 也就是$$g(i,j) = f(i,j) + (f(i,j)-f(i-1,j))+ (f(i,j)-f(i,j-1))+ (f(i,j)-f(i,j+1))+ (f(i,j)-f(i+1,j));$$在线性代数中, 我们的运算都能转换成矩阵的运算, 那么, 我们抽象一下, 我们能够得到这样的一个结果,$$g(i,j) = M\\cdot f(i,j), \\quad M = \\begin{bmatrix} 0 &amp; -1 &amp; 0 \\ -1 &amp; 5 &amp; -1 \\ 0 &amp; -1 &amp; 0 \\end{bmatrix}$$ 与我们的运算得到的等式是一致的, 我们考虑一下怎么实现, 这里我们也参考 例程里面的实现,我们将算法部分封装起来 这里我们使用cv::Mat res_img = testFunc(src_img); 这样的方法, 然后主要去实现 testFunc函数就行了, 后面我们为了不再重复的贴出代码, 希望之后看到的话 不要有疑问.1234567891011121314151617181920212223242526272829303132333435363738#include \"mainwindow.h\"#include &lt;QApplication&gt;// 引入 opencv 函数头文件#include &lt;opencv2/opencv.hpp&gt;// 进行 测试 算法cv::Mat testFunc(const cv::Mat &amp;src_img)&#123; cv::Mat res_img = cv::Mat::zeros(src_img.size(), CV_8UC1); for (int i = 1; i &lt; src_img.rows - 1; i++) &#123; for (int j = 1; j &lt; src_img.cols - 1; j++) &#123; res_img.at&lt;uchar&gt;(i, j) = cv::saturate_cast&lt;uchar&gt;( src_img.at&lt;uchar&gt;(i, j) + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i - 1, j) + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i + 1, j) + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i, j - 1) + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i, j + 1)); &#125; &#125; return res_img;&#125;int main(int argc, char *argv[])&#123; // 设置 要显示的图像路径 std::string lena_png = \"./TestImages/lena.png\"; cv::Mat src_img = cv::imread(lena_png); cv::cvtColor(src_img, src_img, cv::COLOR_BGR2GRAY); cv::Mat res_img = testFunc(src_img); cv::imshow(\"src_img\", src_img); cv::imshow(\"res_img\", res_img); cv::waitKey(0); return 0; // return a.exec();&#125;我们上面提出的算法就是在进行图像的锐化操作,相当于在原始像素的基础上加上了我们原图与四邻域像素的差值, 这样我们能够将边缘梯度过大的区域进行增强, 平滑部分则不会过分处理, 最终得到这样的图像处理结果.. opencv 核操作我们在处理的时候实际上没有解决边缘的问题, 在结果图中可以看到四个边缘各有一个像素的黑色边缘, 我们可以考虑计算其他的简化计算方式, 但是太过与繁琐了, 为了优化体验我们就没有处理, 但是 opencv 中提供了 一种通用的方式进行处理 也就是核, 我们先看下实现方式12345cv::Mat kernel = (cv::Mat_&lt;char&gt;(3, 3) &lt;&lt; 0, -1, 0,truetruetruetruetruetruetruetruetruetrue-1, 5, -1,truetruetruetruetruetruetruetruetruetrue0, -1, 0);cv::Mat res_img2;cv::filter2D(src_img, res_img2, src_img.depth(), kernel);我们设定核之后. 可以直接进行操作, 我们可以通过改动核从而进行图像处理, 看下图, 好像得到右侧的图像效果更好 运行时间对比两种实现结果是大概一致的, 算法上执行是一样的 , 那时间呢,在之前的章节, 我们介绍了不同的图像遍历的方式进行图像遍历, 时间上差异还是比较大的, 这次我们同样使用了两种方式进行: 索引访问和指针访问进行图像处理, 算法部分的实现是一致的, 我们写了testFunc和 testFunc2 两个函数, 相应的代代码可以看下面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include \"mainwindow.h\"#include &lt;QApplication&gt;// 引入 opencv 函数头文件#include &lt;opencv2/opencv.hpp&gt;// 进行 测试 算法cv::Mat testFunc(const cv::Mat &amp;src_img)&#123; cv::Mat res_img = cv::Mat::zeros(src_img.size(), CV_8UC1); for (int i = 1; i &lt; src_img.rows - 1; i++) &#123; for (int j = 1; j &lt; src_img.cols - 1; j++) &#123; res_img.at&lt;uchar&gt;(i, j) = cv::saturate_cast&lt;uchar&gt;(src_img.at&lt;uchar&gt;(i, j) + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i - 1, j) + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i + 1, j) + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i, j - 1) + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i, j + 1)); &#125; &#125; return res_img;&#125;// 使用测试 指针函数cv::Mat testFunc2(const cv::Mat &amp;src_img)&#123; cv::Mat res_img = cv::Mat::zeros(src_img.size(), CV_8UC1); for (int i = 1; i &lt; src_img.rows - 1; i++) &#123; const uchar* p_row_pre = src_img.ptr&lt;uchar&gt;(i - 1); const uchar* p_row_cur = src_img.ptr&lt;uchar&gt;(i); const uchar* p_row_next = src_img.ptr&lt;uchar&gt;(i + 1); uchar* p_row_res = res_img.ptr&lt;uchar&gt;(i); for (int j = 1; j &lt; src_img.cols - 1; j++) &#123; *p_row_res++ = cv::saturate_cast&lt;uchar&gt;(5 * p_row_cur[j] - p_row_cur[j-1] - p_row_cur[j+1] - p_row_pre[j] - p_row_next[j]); &#125; &#125; return res_img;&#125;int main(int argc, char *argv[])&#123; // 设置 要显示的图像路径 std::string lena_png = \"./TestImages/lena.png\"; cv::Mat src_img = cv::imread(lena_png); cv::cvtColor(src_img, src_img, cv::COLOR_BGR2GRAY); // 测试索引方式进行 锐化运算 double t = (double)cv::getTickCount(); cv::Mat res_img = testFunc(src_img); t = ((double)cv::getTickCount() - t) / cv::getTickFrequency(); std::cout &lt;&lt; \"sharpen-index: \\t\\t\" &lt;&lt; t &lt;&lt; std::endl; // 测试 指针方式进行 锐化运算 t = (double)cv::getTickCount(); res_img = testFunc2(src_img); t = ((double)cv::getTickCount() - t) / cv::getTickFrequency(); std::cout &lt;&lt; \"sharpen-pointer: \\t\" &lt;&lt; t &lt;&lt; std::endl; cv::Mat kernel = (cv::Mat_&lt;char&gt;(3, 3) &lt;&lt; 0, -1, 0, -1, 5, -1, 0, -1, 0); cv::Mat res_img2; // 测试 filter 2D 算法时间 t = (double)cv::getTickCount(); cv::filter2D(src_img, res_img2, src_img.depth(), kernel); t = ((double)cv::getTickCount() - t) / cv::getTickFrequency(); std::cout &lt;&lt; \"sharpen-filter: \\t\" &lt;&lt; t &lt;&lt; std::endl; cv::imshow(\"src_img\", src_img); cv::imshow(\"res_img\", res_img); cv::imshow(\"res_img2\", res_img2); cv::waitKey(0); return 0; // return a.exec();&#125; 算法实现上很简单, 就是我们上面提到得到方法, 结果以是接近一致的, 但是时间上差的还是比较多, 使用 filter2D 的方式访问得到的图像还是比较好看的, 运行时间也是要比我们自己通过索引方式进行的算法要快很很多的, 但是相比我们使用指针还是有所不如, 123sharpen-index: 0.0747024 ssharpen-pointer: 0.0040774 ssharpen-filter: 0.0416613 s 我们在 modules\\imgproc\\src\\filter.dispatch.cpp:1403 的位置看到了 filter2D 函数的定义123void filter2D(InputArray _src, OutputArray _dst, int ddepth, InputArray _kernel, Point anchor0, double delta, int borderType); 相应的我们去看 调用图 函数的主要调用使用了加速层的modules\\imgproc\\src\\filter.dispatch.cpp:1307 处的 hal::filter2D 函数这里涉及的部分还比较多, 可能也是由于调用的更底层的以及做了更多的边缘处理的原因 导致实际上花费的时间也更加的长, 这里暂时不去深究, 如果有机会再做进一步分析","categories":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/categories/opencv/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/tags/opencv/"},{"name":"c++","slug":"c","permalink":"https://schen1024.github.io/tags/c/"},{"name":"qt","slug":"qt","permalink":"https://schen1024.github.io/tags/qt/"}]},{"title":"opencv-7-鼠标绘制自定义图形","slug":"opencv-7-鼠标绘制自定义图形","date":"2020-04-24T18:06:27.000Z","updated":"2023-01-01T13:25:24.777Z","comments":true,"path":"2020/04-24/opencv-7-鼠标绘制自定义图形.html","link":"","permalink":"https://schen1024.github.io/2020/04-24/opencv-7-%E9%BC%A0%E6%A0%87%E7%BB%98%E5%88%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E5%BD%A2.html","excerpt":"开始之前昨天写了具体的基本的图形绘制, 然后我们使用相应的函数接口进行调用, 便能够在图像上绘制出来相应的图形, 我们以图像绘制为例, 最终都会调用了 Line 函数, 最后都是基于一个 自定义迭代器 LineIterator的形成的路径, 通过设定起始点和目标点, 相当于计算出来的斜率值, 每次累加的之后判断下一个点的位置, 通过 重载累加器的 ++ 操作, 完成直线点指针的移动, 在相应的位置填入相应的颜色就可以得到 所要绘制的线, 这里是函数的调用图, 可放大查看细节部分 这里不再深入探讨, 相应的可以去研究具体的实现, 很漂亮的源码, 写的很好我们这个章节 看一个比较高级点的操作, 操作起来比较复杂, 先不去深究其中的原理, 我们先跑起来, 然后再研究 正文主要是处理鼠标的操作就好, 然后使用绘制图像就好, 可以参考博文《OpenCV：鼠标操作（绘制直线、矩形、圆）简单示例》和博文OpenCV鼠标画图例程，鼠标绘制矩形, 鼠标绘制图像我们先梳理一下逻辑, 我们使用两张图片作为轮换, 原始图和临时图, 每次绘制在临时图上, 然后完成之后存入原始图上 初始原始图像, 绘图标志 flg false 鼠标按下, 确定起始点 start_p 标志开始绘图 鼠标移动, 移动目标点 end_p, 绘制到临时图像上 鼠标抬起, 确定最后的点, 然后将图替换原始图, 同时 绘图标志结束flg = false 循环绘制图像, 绘图中的时候 显示临时图像, 绘图之后 显示原始图像, 逻辑理清除之后,我们就想要处理一下细节部分了, 我们在之前的博文中介绍了显示图像的方式, imshow即可显示, 然后我们发现问题在于程序的鼠标是件监听了, 这里其实比较深入了, 但是呢, 我们不深入去研究, 只去看实现的过程吧,cv::setMouseCallback(windows_name, on_MouseHandle, 0);, 我们第一个 windows_name 是我们打开的窗口名称, 用于显示图像, 也能通过名称进行句柄操作, 第二个参数就是我们的鼠标处理函数了, on_MouseHandle(int event, int x, int y, int flags, void *param), 这里的函数名称可以自定义, 但是参数类型与个数必须一致, 然后我们就可以通过预定义的事件宏进行确定当前鼠标操作的动作了, 这里 比如cv::EVENT_MOUSEMOVE 宏就是 鼠标移动事件, cv::EVENT_LBUTTONDOWN,和cv::EVENT_LBUTTONUP 分别对应鼠标按下和鼠标抬起的操作, 命名写的很清楚 编码实现我们在逻辑理清除 之后, 写起来就很简单了, 可以的大傲下面的代码, 注释也比较清除, 能够一看就懂 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include \"mainwindow.h\"#include &lt;QApplication&gt;// 引入 opencv 函数头文件#include &lt;opencv2/opencv.hpp&gt;// 记录鼠标位置点, 以及 正在绘图标志位 flg cv::Point start_p(-1, -1), end_p(-1, -1);bool flg_drawing = false; // 使用原始图像与临时图像 存储cv::Mat src_img, temp_img; //鼠标回调函数 // 记录窗口的x y 位置 void on_MouseHandle(int event, int x, int y, int flags, void *param)&#123; switch (event) &#123; case cv::EVENT_LBUTTONDOWN: &#123; start_p = cv::Point(x, y); // 确定起始点 temp_img = src_img.clone(); // 复制原始图, 进行绘图操作 flg_drawing = true; &#125;break; case cv::EVENT_MOUSEMOVE: &#123; if (flg_drawing) end_p = cv::Point(x, y); // 如果在绘制, 则更新移动后的目标点 &#125;break; case cv::EVENT_LBUTTONUP: &#123; end_p = cv::Point(x, y); // 确定最终点 src_img = temp_img.clone(); // 将图像更新成为原始图 存储下来 flg_drawing = false; &#125;break; &#125;&#125;// 返回两点之间的距离 直线距离 平方和的开方值float distance(const cv::Point &amp;p1, const cv::Point &amp;p2)&#123; return cv::sqrt((p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y));&#125;int main(int argc, char *argv[])&#123; //QApplication a(argc, argv); //MainWindow w; //w.show(); // 设置 要显示的图像路径 std::string img_lena = \"./TestImages/lena.png\"; src_img = cv::imread(img_lena); std::string windows_name = \"show\"; cv::namedWindow(windows_name,cv::WINDOW_AUTOSIZE); // 设置窗口 鼠标操作 监听 函数为 on_MouseHandle cv::setMouseCallback(windows_name, on_MouseHandle, 0); while (true) &#123; // 根据当前点 绘制 if (flg_drawing) &#123; temp_img = src_img.clone(); cv::line(temp_img, start_p, end_p, cv::Scalar(0, 255, 0)); cv::rectangle(temp_img, cv::Rect(start_p, end_p), cv::Scalar(255, 0, 0)); cv::circle(temp_img, start_p, distance(start_p,end_p), cv::Scalar(0, 0, 255)); cv::imshow(windows_name, temp_img); &#125; else &#123; cv::imshow(windows_name, src_img); &#125; // 设置 按 esc 退出循环 if (cv::waitKey(30) == 27) break; &#125; return 0; // return a.exec();&#125; 运行结果然后就到了我们结果的时候了, 运行之后, 鼠标左键点击开始, 拖动实时绘制, 抬起结束绘制, 然后 我们绘制了 直线, 矩形, 和圆, 同时进行了绘制, ps: 这里录制 gif 使用的是 ScreenToGif 特别好用 我们实现的比较简单, 可以去看我提到的两篇博文, 以及这一篇鼠标作为画笔 翻译的文档,他们实现的比较复杂, 不仅实现了绘制, 还能够选择绘制什么, 也提供了 随机颜色的方法, cv::RNG可以参考OpenCV中随机颜色, 随机颜色的解释, 听简单的, 初始化随机, 自动生成随机颜色就行了,1234// 随机颜色绘制cv::line(temp_img, start_p, end_p, cv::Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255)));cv::rectangle(temp_img, cv::Rect(start_p, end_p), cv::Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255)));cv::circle(temp_img, start_p, distance(start_p,end_p), cv::Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255))); 其他","text":"开始之前昨天写了具体的基本的图形绘制, 然后我们使用相应的函数接口进行调用, 便能够在图像上绘制出来相应的图形, 我们以图像绘制为例, 最终都会调用了 Line 函数, 最后都是基于一个 自定义迭代器 LineIterator的形成的路径, 通过设定起始点和目标点, 相当于计算出来的斜率值, 每次累加的之后判断下一个点的位置, 通过 重载累加器的 ++ 操作, 完成直线点指针的移动, 在相应的位置填入相应的颜色就可以得到 所要绘制的线, 这里是函数的调用图, 可放大查看细节部分 这里不再深入探讨, 相应的可以去研究具体的实现, 很漂亮的源码, 写的很好我们这个章节 看一个比较高级点的操作, 操作起来比较复杂, 先不去深究其中的原理, 我们先跑起来, 然后再研究 正文主要是处理鼠标的操作就好, 然后使用绘制图像就好, 可以参考博文《OpenCV：鼠标操作（绘制直线、矩形、圆）简单示例》和博文OpenCV鼠标画图例程，鼠标绘制矩形, 鼠标绘制图像我们先梳理一下逻辑, 我们使用两张图片作为轮换, 原始图和临时图, 每次绘制在临时图上, 然后完成之后存入原始图上 初始原始图像, 绘图标志 flg false 鼠标按下, 确定起始点 start_p 标志开始绘图 鼠标移动, 移动目标点 end_p, 绘制到临时图像上 鼠标抬起, 确定最后的点, 然后将图替换原始图, 同时 绘图标志结束flg = false 循环绘制图像, 绘图中的时候 显示临时图像, 绘图之后 显示原始图像, 逻辑理清除之后,我们就想要处理一下细节部分了, 我们在之前的博文中介绍了显示图像的方式, imshow即可显示, 然后我们发现问题在于程序的鼠标是件监听了, 这里其实比较深入了, 但是呢, 我们不深入去研究, 只去看实现的过程吧,cv::setMouseCallback(windows_name, on_MouseHandle, 0);, 我们第一个 windows_name 是我们打开的窗口名称, 用于显示图像, 也能通过名称进行句柄操作, 第二个参数就是我们的鼠标处理函数了, on_MouseHandle(int event, int x, int y, int flags, void *param), 这里的函数名称可以自定义, 但是参数类型与个数必须一致, 然后我们就可以通过预定义的事件宏进行确定当前鼠标操作的动作了, 这里 比如cv::EVENT_MOUSEMOVE 宏就是 鼠标移动事件, cv::EVENT_LBUTTONDOWN,和cv::EVENT_LBUTTONUP 分别对应鼠标按下和鼠标抬起的操作, 命名写的很清楚 编码实现我们在逻辑理清除 之后, 写起来就很简单了, 可以的大傲下面的代码, 注释也比较清除, 能够一看就懂 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include \"mainwindow.h\"#include &lt;QApplication&gt;// 引入 opencv 函数头文件#include &lt;opencv2/opencv.hpp&gt;// 记录鼠标位置点, 以及 正在绘图标志位 flg cv::Point start_p(-1, -1), end_p(-1, -1);bool flg_drawing = false; // 使用原始图像与临时图像 存储cv::Mat src_img, temp_img; //鼠标回调函数 // 记录窗口的x y 位置 void on_MouseHandle(int event, int x, int y, int flags, void *param)&#123; switch (event) &#123; case cv::EVENT_LBUTTONDOWN: &#123; start_p = cv::Point(x, y); // 确定起始点 temp_img = src_img.clone(); // 复制原始图, 进行绘图操作 flg_drawing = true; &#125;break; case cv::EVENT_MOUSEMOVE: &#123; if (flg_drawing) end_p = cv::Point(x, y); // 如果在绘制, 则更新移动后的目标点 &#125;break; case cv::EVENT_LBUTTONUP: &#123; end_p = cv::Point(x, y); // 确定最终点 src_img = temp_img.clone(); // 将图像更新成为原始图 存储下来 flg_drawing = false; &#125;break; &#125;&#125;// 返回两点之间的距离 直线距离 平方和的开方值float distance(const cv::Point &amp;p1, const cv::Point &amp;p2)&#123; return cv::sqrt((p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y));&#125;int main(int argc, char *argv[])&#123; //QApplication a(argc, argv); //MainWindow w; //w.show(); // 设置 要显示的图像路径 std::string img_lena = \"./TestImages/lena.png\"; src_img = cv::imread(img_lena); std::string windows_name = \"show\"; cv::namedWindow(windows_name,cv::WINDOW_AUTOSIZE); // 设置窗口 鼠标操作 监听 函数为 on_MouseHandle cv::setMouseCallback(windows_name, on_MouseHandle, 0); while (true) &#123; // 根据当前点 绘制 if (flg_drawing) &#123; temp_img = src_img.clone(); cv::line(temp_img, start_p, end_p, cv::Scalar(0, 255, 0)); cv::rectangle(temp_img, cv::Rect(start_p, end_p), cv::Scalar(255, 0, 0)); cv::circle(temp_img, start_p, distance(start_p,end_p), cv::Scalar(0, 0, 255)); cv::imshow(windows_name, temp_img); &#125; else &#123; cv::imshow(windows_name, src_img); &#125; // 设置 按 esc 退出循环 if (cv::waitKey(30) == 27) break; &#125; return 0; // return a.exec();&#125; 运行结果然后就到了我们结果的时候了, 运行之后, 鼠标左键点击开始, 拖动实时绘制, 抬起结束绘制, 然后 我们绘制了 直线, 矩形, 和圆, 同时进行了绘制, ps: 这里录制 gif 使用的是 ScreenToGif 特别好用 我们实现的比较简单, 可以去看我提到的两篇博文, 以及这一篇鼠标作为画笔 翻译的文档,他们实现的比较复杂, 不仅实现了绘制, 还能够选择绘制什么, 也提供了 随机颜色的方法, cv::RNG可以参考OpenCV中随机颜色, 随机颜色的解释, 听简单的, 初始化随机, 自动生成随机颜色就行了,1234// 随机颜色绘制cv::line(temp_img, start_p, end_p, cv::Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255)));cv::rectangle(temp_img, cv::Rect(start_p, end_p), cv::Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255)));cv::circle(temp_img, start_p, distance(start_p,end_p), cv::Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255))); 其他","categories":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/categories/opencv/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/tags/opencv/"},{"name":"c++","slug":"c","permalink":"https://schen1024.github.io/tags/c/"},{"name":"qt","slug":"qt","permalink":"https://schen1024.github.io/tags/qt/"}]},{"title":"opencv-6-图像绘制与opencv Line 函数剖析","slug":"opencv-6-鼠标绘制图像","date":"2020-04-22T10:23:02.000Z","updated":"2023-01-01T13:25:24.777Z","comments":true,"path":"2020/04-22/opencv-6-鼠标绘制图像.html","link":"","permalink":"https://schen1024.github.io/2020/04-22/opencv-6-%E9%BC%A0%E6%A0%87%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F.html","excerpt":"开始之前越到后面, 写的越慢, 之前还抽空去看了下 学堂在线那篇文章提供的方法, 博客第一个人评论的我, 想想还是要给人家一个交代的, 就想着找到一个方法进行下载, 但是尝试了 还没找到, 估计我要花时间自己写一个了, 不是很难, 但是 就是要花时间, 安排到日程上了, 应该会有结果的, 到时候再写博文记录. 之前都是空的, 写起来很快, 后面的话我还要去写具体的代码实现, 争取都能够复现出来, 这样更有实际意义, 所以接下来可能更新的更慢了, 不过应该不会断, 我计划的很长, 但是我想 至少写够20篇吧, 加油. 在这篇文章以及后续的文章中,我们都会 说明一些代码出现的地方, 头文件对应的 opencv 库引用目录 include 文件夹下面的文件 源文件则是 opencv 4.3.0 下的 Source 文件夹里面的文件同样的, 文件的后面使用 :xx 标识, 在文件的xx 行的地方 头文件 opencv2/opencv.hpp:100 在 opencv.hpp 第100 行开始的地方源文件 modules/imgproc/src/drawing.cpp:1000 则是在 1000 行的地方 目录[toc] 正文在上一篇中, 我们能够进行像素点的操作了, 那么, 很明显的一个问题, 我能不能在图像上画一条线呢, 或者在图像上自己用鼠标绘制呢, 当然可以, opencv 提供了这些功能, 在opencv 的文档中 Basic Drawing, 基础绘图章节, 有相关的例程, 我们在之前的文章中提到了 opencv 座标系的问题 以左上角为起始点 横向为x, 纵向为y 使用 at(rows,cols) 确定座标值 对应的是 (行,列) 使用 point(x,y) 定位, 使用的是 (列, 行) 这两个定位是不一样的 ,所一定要注意, opencv 在 绘制图形的时候 使用的是 Point 来进行的定位, 我们可以使用 cv::Point p = cv::Point(20,30) 直接初始化, 或者使用 cv::Point p; p.x = 20,p.y=30; 初始化后进行赋值操作. 在图像上绘制标准图形我们还以 lena 为例, 在图片上绘制 以 (x,y) 座标的图形 直线: 起点(100,200) - 终点(500,300) 绿色 直线: 起点 (100,500) - 终点(500,100) 蓝色 圆: 圆心 (200,300) 半径 200 红色 矩形: 左上角点 (100,120) 右下角点(400,450); 白色 文字: 起始点: (100,200), 文字: OpenCV …. 在我们绘制之前, 我们要说明一个函数 cv::Scalar 是opencv 的颜色函数, 按照 BGR 的顺序传入三个参数, 用于指名绘制图形的颜色 note: 实际上是 4个参数, 一般我们不使用最后一个参数即可^[《OpenCV: Basic Drawing》. 见于 2020年4月24日. https://docs.opencv.org/4.3.0/d3/d96/tutorial_basic_geometric_drawing.html.] 编码实现我们根据上面给出的顺序 依次 编写代码, 将图形绘制到 lena 图的上面, 我们可以得到这样的程序, 就是一条一条的写, 我们只需要调用 相应的opencv 函数就能绘制了, 1234567891011121314151617181920212223242526272829#include &lt;opencv2/opencv.hpp&gt;int main(int argc, char *argv[])&#123; //QApplication a(argc, argv); //MainWindow w; //w.show(); // 设置 要显示的图像路径 std::string img_lena = \"./TestImages/lena.png\"; // 读取两幅彩色图像 512*512 cv::Mat lena_bgr = cv::imread(img_lena); // 声明结果图像 1020*1020 cv::Mat res_bgr = cv::Mat::zeros(cv::Size(512,512), CV_8UC3); // 绘制基本图形 cv::line(lena_bgr, cv::Point(100, 200), cv::Point(500, 300), cv::Scalar(0, 255, 0)); cv::line(lena_bgr, cv::Point(100, 500), cv::Point(500, 100), cv::Scalar(255, 0, 0)); cv::circle(lena_bgr, cv::Point(200, 300), 200, cv::Scalar(0, 0, 255)); cv::rectangle(lena_bgr, cv::Rect(cv::Point(100, 120), cv::Point(400, 500)), cv::Scalar(255, 255, 255)); cv::putText(lena_bgr, \"OpenCV\", cv::Point(100, 200), cv::FONT_HERSHEY_COMPLEX,1.0, cv::Scalar(0, 255, 255)); cv::imshow(\"lena_bgr\",lena_bgr); cv::waitKey(0); return 0; // return a.exec();&#125; 最终我们运行之后 ,便能够得到这样的一副图像, 很简单, 具体的参数部分自己选择就好, 这里只是给出一个示例, line 函数 源码分析剖析其实opencv 还能绘制其他的图形, 太多了, 可以在Drawing Functions页面去查看, 基本没啥用, 很多时候是需要了自己造个轮子就行了, 不查文档我都不知道能绘制这么多 只需要知道直线, 圆, 矩形怎么绘制的就行了, 多了也用不到 后续的部分 主要是 opencv 怎么去实现的 line 函数了, 涉及到比较基础的, 看不看不影响你的使用, 不想看的就关闭即可.. 源码解析我们以 绘制直线为例, 这个简单, 我们使用了 cv::line 就绘制出来了一条直线12345678void cv::line ( InputOutputArray img, Point pt1, Point pt2, const Scalar &amp; color, int thickness = 1, int lineType = LINE_8, int shift = 0 )各个参数意义其实名称还是能够 看出来的 img: 输入输出图像, 直接在这个图像上绘制 pt1: 起始点 (x,y) 座标 pt2: 终止点 (x,y) 座标 color: Scalar 参数生成的颜色 *thickness: 直线宽度 *lineType: 绘制的线的形式 4邻域 8邻域等 *shift: 精度, 点座标中的小数点等级(第一次看到这个参数, 暂时不管他什么意思) 一般我们只需要前面的四个参数就行了, 一般就是我们程序中的 cv::line(lena_bgr, cv::Point(100, 200), cv::Point(500, 300), cv::Scalar(0, 255, 0)); 座标颜色我们都说过了, 那我们去看下 他的源码:在 modules\\imgproc\\srcdrawing.cpp:1772 中, 我们能够看到 直线的绘制函数, 1234567891011121314151617void line( InputOutputArray _img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int line_type, int shift )&#123; CV_INSTRUMENT_REGION(); Mat img = _img.getMat(); if( line_type == CV_AA &amp;&amp; img.depth() != CV_8U ) line_type = 8; CV_Assert( 0 &lt; thickness &amp;&amp; thickness &lt;= MAX_THICKNESS ); CV_Assert( 0 &lt;= shift &amp;&amp; shift &lt;= XY_SHIFT ); double buf[4]; scalarToRawData( color, buf, img.type(), 0 ); ThickLine( img, pt1, pt2, buf, thickness, line_type, 3, shift );&#125; 这个只是一个封装, 将颜色分成一个double 数组, 然后 调用了一个新的函数 ThickLine 这里 实际上 这里的scalarToRawData 函数也是根据图像的通道进行调用了, scalarToRawData_ 的函数, 将颜色结构体的四个值分别存入数组中, 也为了兼容以前的版本, 所以采用的这种接口.123456789template &lt;typename T&gt; static inlinevoid scalarToRawData_(const Scalar&amp; s, T * const buf, const int cn, const int unroll_to)&#123; int i = 0; for(; i &lt; cn; i++) buf[i] = saturate_cast&lt;T&gt;(s.val[i]); for(; i &lt; unroll_to; i++) buf[i] = buf[i-cn];&#125; 去看了下 opencv 的矩形 rectancle 函数是实际上是基于 polyline 多边形绘制, 而它则是基于 ThickLine的, opencv 的函数都是这样基于最简单的元素来实现的, 所以我们继续看这个实现就好感觉线形状的绘制最终都是调用的这个, 那我们去看下具体的实现. 在文件 modules\\imgproc\\src\\drawing.cpp:1602 是这个函数的实现, 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576static voidThickLine( Mat&amp; img, Point2l p0, Point2l p1, const void* color, int thickness, int line_type, int flags, int shift )&#123; static const double INV_XY_ONE = 1./XY_ONE; p0.x &lt;&lt;= XY_SHIFT - shift; p0.y &lt;&lt;= XY_SHIFT - shift; p1.x &lt;&lt;= XY_SHIFT - shift; p1.y &lt;&lt;= XY_SHIFT - shift; if( thickness &lt;= 1 ) &#123; if( line_type &lt; CV_AA ) &#123; if( line_type == 1 || line_type == 4 || shift == 0 ) &#123; p0.x = (p0.x + (XY_ONE&gt;&gt;1)) &gt;&gt; XY_SHIFT; p0.y = (p0.y + (XY_ONE&gt;&gt;1)) &gt;&gt; XY_SHIFT; p1.x = (p1.x + (XY_ONE&gt;&gt;1)) &gt;&gt; XY_SHIFT; p1.y = (p1.y + (XY_ONE&gt;&gt;1)) &gt;&gt; XY_SHIFT; Line( img, p0, p1, color, line_type ); &#125; else Line2( img, p0, p1, color ); &#125; else LineAA( img, p0, p1, color ); &#125; else &#123; Point2l pt[4], dp = Point2l(0,0); double dx = (p0.x - p1.x)*INV_XY_ONE, dy = (p1.y - p0.y)*INV_XY_ONE; double r = dx * dx + dy * dy; int i, oddThickness = thickness &amp; 1; thickness &lt;&lt;= XY_SHIFT - 1; if( fabs(r) &gt; DBL_EPSILON ) &#123; r = (thickness + oddThickness*XY_ONE*0.5)/std::sqrt(r); dp.x = cvRound( dy * r ); dp.y = cvRound( dx * r ); pt[0].x = p0.x + dp.x; pt[0].y = p0.y + dp.y; pt[1].x = p0.x - dp.x; pt[1].y = p0.y - dp.y; pt[2].x = p1.x - dp.x; pt[2].y = p1.y - dp.y; pt[3].x = p1.x + dp.x; pt[3].y = p1.y + dp.y; FillConvexPoly( img, pt, 4, color, line_type, XY_SHIFT ); &#125; for( i = 0; i &lt; 2; i++ ) &#123; if( flags &amp; (i+1) ) &#123; if( line_type &lt; CV_AA ) &#123; Point center; center.x = (int)((p0.x + (XY_ONE&gt;&gt;1)) &gt;&gt; XY_SHIFT); center.y = (int)((p0.y + (XY_ONE&gt;&gt;1)) &gt;&gt; XY_SHIFT); Circle( img, center, (thickness + (XY_ONE&gt;&gt;1)) &gt;&gt; XY_SHIFT, color, 1 ); &#125; else &#123; EllipseEx( img, p0, Size2l(thickness, thickness), 0, 0, 360, color, -1, line_type ); &#125; &#125; p0 = p1; &#125; &#125;&#125; 在讲函数的实现之前, 我们先看几个参数, 线形: linetype 以及线宽 thickness 其中 linetype 这里可以看OpenCV线型lineType 这篇博客, 他做了几种线形的对比, 在 头文件opencv2\\imgproc.hpp:804 中, 定义了123456enum LineTypes &#123; FILLED = -1, LINE_4 = 4, //!&lt; 4-connected line LINE_8 = 8, //!&lt; 8-connected line LINE_AA = 16 //!&lt; antialiased line&#125;;对应的: FILLED: 填充 LINE_4: 四邻域直线, LINE_8: 8邻域直线 LINE_AA: 抗锯齿直线 再看两个宏, 在modules\\imgproc\\src\\drawing.cpp:46 定义了 XY_SHIFT: 16 XY_ONE: 1 &lt;&lt; XY_SHIFT 表示左移16位 = 65536 我们在进行转换之前, 有一个小点需要关注一下, 我们line 函数输入的点是 Point2i, 而ThickLine 函数输入的点变成了 Point2l, 有意思,在\\modules\\core\\include\\opencv2\\core\\types.hpp:190, 我们找到了这样的定义, 其实是一样的 , 就是定义的必须是 64长度的 int 类型, 为什么, 好用于移位呀,123typedef Point_&lt;int&gt; Point2i;typedef Point_&lt;int64&gt; Point2l;typedef Point2i Point;这里有一段程序, 是这样的 , 我们去掉 if 再看一下:123456789p0.x &lt;&lt;= XY_SHIFT - shift;p0.y &lt;&lt;= XY_SHIFT - shift;p1.x &lt;&lt;= XY_SHIFT - shift;p1.y &lt;&lt;= XY_SHIFT - shift;p0.x = (p0.x + (XY_ONE&gt;&gt;1)) &gt;&gt; XY_SHIFT;p0.y = (p0.y + (XY_ONE&gt;&gt;1)) &gt;&gt; XY_SHIFT;p1.x = (p1.x + (XY_ONE&gt;&gt;1)) &gt;&gt; XY_SHIFT;p1.y = (p1.y + (XY_ONE&gt;&gt;1)) &gt;&gt; XY_SHIFT;shift 的 默认参数是 0, 这里的shift 实际上是座标移位的一个作用, 实际上结果就是移位得到结果 这里加上一般是为了XY_ONE&gt;&gt;1 实际上 加上0.5 向上取整而已 个人分析, 不一定是真实意图 由于绘制函数的 ThickLine 函数考虑了线宽, 我们先以基础的线宽为例: 上面一通操作只是给座标进行了变换,得到了有效的座标, 然后 来到了我们最终的 进行绘制的函数,Line ,首写字母大写的呦, 这里的核心就是 构建一个直线迭代器, 在每个点的位置上依次填入颜色即可,1234567891011121314151617181920212223242526272829static voidLine( Mat&amp; img, Point pt1, Point pt2, const void* _color, int connectivity = 8 )&#123; if( connectivity == 0 ) connectivity = 8; else if( connectivity == 1 ) connectivity = 4; LineIterator iterator(img, pt1, pt2, connectivity, true); int i, count = iterator.count; int pix_size = (int)img.elemSize(); const uchar* color = (const uchar*)_color; for( i = 0; i &lt; count; i++, ++iterator ) &#123; uchar* ptr = *iterator; if( pix_size == 1 ) ptr[0] = color[0]; else if( pix_size == 3 ) &#123; ptr[0] = color[0]; ptr[1] = color[1]; ptr[2] = color[2]; &#125; else memcpy( *iterator, color, pix_size ); &#125;&#125; 那么, 还没到最后, 我们继续 在 modules\\imgproc\\src\\drawing.cpp:160 的地方, 找到了 LineIterator 类的 构造函数,12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* Initializes line iterator. Returns number of points on the line or negative number if error.*/LineIterator::LineIterator(const Mat&amp; img, Point pt1, Point pt2, int connectivity, bool left_to_right)&#123; count = -1; CV_Assert( connectivity == 8 || connectivity == 4 ); if( (unsigned)pt1.x &gt;= (unsigned)(img.cols) || (unsigned)pt2.x &gt;= (unsigned)(img.cols) || (unsigned)pt1.y &gt;= (unsigned)(img.rows) || (unsigned)pt2.y &gt;= (unsigned)(img.rows) ) &#123; if( !clipLine( img.size(), pt1, pt2 ) ) &#123; ptr = img.data; err = plusDelta = minusDelta = plusStep = minusStep = count = 0; ptr0 = 0; step = 0; elemSize = 0; return; &#125; &#125; size_t bt_pix0 = img.elemSize(), bt_pix = bt_pix0; size_t istep = img.step; int dx = pt2.x - pt1.x; int dy = pt2.y - pt1.y; int s = dx &lt; 0 ? -1 : 0; if( left_to_right ) &#123; dx = (dx ^ s) - s; dy = (dy ^ s) - s; pt1.x ^= (pt1.x ^ pt2.x) &amp; s; pt1.y ^= (pt1.y ^ pt2.y) &amp; s; &#125; else &#123; dx = (dx ^ s) - s; bt_pix = (bt_pix ^ s) - s; &#125; ptr = (uchar*)(img.data + pt1.y * istep + pt1.x * bt_pix0); s = dy &lt; 0 ? -1 : 0; dy = (dy ^ s) - s; istep = (istep ^ s) - s; s = dy &gt; dx ? -1 : 0; /* conditional swaps */ dx ^= dy &amp; s; dy ^= dx &amp; s; dx ^= dy &amp; s; bt_pix ^= istep &amp; s; istep ^= bt_pix &amp; s; bt_pix ^= istep &amp; s; if( connectivity == 8 ) &#123; assert( dx &gt;= 0 &amp;&amp; dy &gt;= 0 ); err = dx - (dy + dy); plusDelta = dx + dx; minusDelta = -(dy + dy); plusStep = (int)istep; minusStep = (int)bt_pix; count = dx + 1; &#125; else /* connectivity == 4 */ &#123; assert( dx &gt;= 0 &amp;&amp; dy &gt;= 0 ); err = 0; plusDelta = (dx + dx) + (dy + dy); minusDelta = -(dy + dy); plusStep = (int)(istep - bt_pix); minusStep = (int)bt_pix; count = dx + dy + 1; &#125; this-&gt;ptr0 = img.ptr(); this-&gt;step = (int)img.step; this-&gt;elemSize = (int)bt_pix0;&#125; 做稍微一点的 简化, 实际上就是考虑正负符号的处理呀, 这里主要使用的就是 异或 (xor) 和 与 运算(&amp;)这里要考虑计算顺序, 注意就好 运算优先级为如下 11 a&amp;b 逐位与 12 ^ 逐位异或（互斥或） 13 | 逐位或（可兼或） 可以参考文章异或的妙用 和文章位运算总结(按位与,或,异或), 算是一个基础的x 运算吧 在计算中, 巧妙的加入了 s 作为符号, 这样减少每次计算正负的比较, 1234567891011121314151617181920212223242526272829303132333435363738size_t bt_pix0 = img.elemSize(), bt_pix = bt_pix0;size_t istep = img.step;int dx = pt2.x - pt1.x;int dy = pt2.y - pt1.y;int s = dx &lt; 0 ? -1 : 0;dx = (dx ^ s) - s;dy = (dy ^ s) - s;pt1.x ^= (pt1.x ^ pt2.x) &amp; s;pt1.y ^= (pt1.y ^ pt2.y) &amp; s;// 记录起点的指针, ptr = (uchar*)(img.data + pt1.y * istep + pt1.x * bt_pix0);// 使用符号, 巧妙的得到 绝对值s = dy &lt; 0 ? -1 : 0;dy = (dy ^ s) - s;istep = (istep ^ s) - s;s = dy &gt; dx ? -1 : 0;// 有符号的 值交换 交换 dx dy 与 bt_pix istep/* conditional swaps */dx ^= dy &amp; s;dy ^= dx &amp; s;dx ^= dy &amp; s;bt_pix ^= istep &amp; s;istep ^= bt_pix &amp; s;bt_pix ^= istep &amp; s;err = dx - (dy + dy);plusDelta = dx + dx;minusDelta = -(dy + dy);plusStep = (int)istep;minusStep = (int)bt_pix;count = dx + 1; 这里的处理真的 很巧妙, 有符号的值交换, 然后设置相应的符号mask, 及其这里求绝对值的方式, 不懂的话 就个8位的数字 代入进行运算, 可以得到想要的结果, 跑一遍就会了我之后写一篇文章 看下这里的符号运算吧, 真厉害! 在这里完成了起始点的确定, 给出了一共有多少点的存在count=dx+1, 通过确定了 我们可以假定 dx 会沿着一个方向依次相加 但是dy呢, 我们还是没有解决怎么确定的一条直线,在Line 函数的这一句, for( i = 0; i &lt; count; i++, ++iterator ) 这里的迭代器是累加的, 但是,迭代器是我们自己自定义的, 那么, ++ 操作会不会也是自定义的呢,在modules\\imgproc\\include\\opencv2\\imgproc.hpp:4673 行的地方, 我们看到了这里重载了操作符号, 这样我们在进行加加操作的时候, 这里的err 就会自己调节了, err &gt;= 0 mask = 0 err += -2dy ptr += minusStep err &lt; 0 mask = -1 err += -2dy + 2dx 这里会 得到一个正的值,这里更加的巧妙, 具体的公式或者过程需要慢慢推导, 12345678910111213141516inlineLineIterator&amp; LineIterator::operator ++()&#123; int mask = err &lt; 0 ? -1 : 0; err += minusDelta + (plusDelta &amp; mask); ptr += minusStep + (plusStep &amp; mask); return *this;&#125;inlineLineIterator LineIterator::operator ++(int)&#123; LineIterator it = *this; ++(*this); return it;&#125; 总之就是 巧妙的使用了两个变量, 使得我们的累加根据斜率进行累加过程, 完成执行, 很巧妙, 我这里 不再进行后续推导了, , 后续有机会在做… 其他","text":"开始之前越到后面, 写的越慢, 之前还抽空去看了下 学堂在线那篇文章提供的方法, 博客第一个人评论的我, 想想还是要给人家一个交代的, 就想着找到一个方法进行下载, 但是尝试了 还没找到, 估计我要花时间自己写一个了, 不是很难, 但是 就是要花时间, 安排到日程上了, 应该会有结果的, 到时候再写博文记录. 之前都是空的, 写起来很快, 后面的话我还要去写具体的代码实现, 争取都能够复现出来, 这样更有实际意义, 所以接下来可能更新的更慢了, 不过应该不会断, 我计划的很长, 但是我想 至少写够20篇吧, 加油. 在这篇文章以及后续的文章中,我们都会 说明一些代码出现的地方, 头文件对应的 opencv 库引用目录 include 文件夹下面的文件 源文件则是 opencv 4.3.0 下的 Source 文件夹里面的文件同样的, 文件的后面使用 :xx 标识, 在文件的xx 行的地方 头文件 opencv2/opencv.hpp:100 在 opencv.hpp 第100 行开始的地方源文件 modules/imgproc/src/drawing.cpp:1000 则是在 1000 行的地方 目录[toc] 正文在上一篇中, 我们能够进行像素点的操作了, 那么, 很明显的一个问题, 我能不能在图像上画一条线呢, 或者在图像上自己用鼠标绘制呢, 当然可以, opencv 提供了这些功能, 在opencv 的文档中 Basic Drawing, 基础绘图章节, 有相关的例程, 我们在之前的文章中提到了 opencv 座标系的问题 以左上角为起始点 横向为x, 纵向为y 使用 at(rows,cols) 确定座标值 对应的是 (行,列) 使用 point(x,y) 定位, 使用的是 (列, 行) 这两个定位是不一样的 ,所一定要注意, opencv 在 绘制图形的时候 使用的是 Point 来进行的定位, 我们可以使用 cv::Point p = cv::Point(20,30) 直接初始化, 或者使用 cv::Point p; p.x = 20,p.y=30; 初始化后进行赋值操作. 在图像上绘制标准图形我们还以 lena 为例, 在图片上绘制 以 (x,y) 座标的图形 直线: 起点(100,200) - 终点(500,300) 绿色 直线: 起点 (100,500) - 终点(500,100) 蓝色 圆: 圆心 (200,300) 半径 200 红色 矩形: 左上角点 (100,120) 右下角点(400,450); 白色 文字: 起始点: (100,200), 文字: OpenCV …. 在我们绘制之前, 我们要说明一个函数 cv::Scalar 是opencv 的颜色函数, 按照 BGR 的顺序传入三个参数, 用于指名绘制图形的颜色 note: 实际上是 4个参数, 一般我们不使用最后一个参数即可^[《OpenCV: Basic Drawing》. 见于 2020年4月24日. https://docs.opencv.org/4.3.0/d3/d96/tutorial_basic_geometric_drawing.html.] 编码实现我们根据上面给出的顺序 依次 编写代码, 将图形绘制到 lena 图的上面, 我们可以得到这样的程序, 就是一条一条的写, 我们只需要调用 相应的opencv 函数就能绘制了, 1234567891011121314151617181920212223242526272829#include &lt;opencv2/opencv.hpp&gt;int main(int argc, char *argv[])&#123; //QApplication a(argc, argv); //MainWindow w; //w.show(); // 设置 要显示的图像路径 std::string img_lena = \"./TestImages/lena.png\"; // 读取两幅彩色图像 512*512 cv::Mat lena_bgr = cv::imread(img_lena); // 声明结果图像 1020*1020 cv::Mat res_bgr = cv::Mat::zeros(cv::Size(512,512), CV_8UC3); // 绘制基本图形 cv::line(lena_bgr, cv::Point(100, 200), cv::Point(500, 300), cv::Scalar(0, 255, 0)); cv::line(lena_bgr, cv::Point(100, 500), cv::Point(500, 100), cv::Scalar(255, 0, 0)); cv::circle(lena_bgr, cv::Point(200, 300), 200, cv::Scalar(0, 0, 255)); cv::rectangle(lena_bgr, cv::Rect(cv::Point(100, 120), cv::Point(400, 500)), cv::Scalar(255, 255, 255)); cv::putText(lena_bgr, \"OpenCV\", cv::Point(100, 200), cv::FONT_HERSHEY_COMPLEX,1.0, cv::Scalar(0, 255, 255)); cv::imshow(\"lena_bgr\",lena_bgr); cv::waitKey(0); return 0; // return a.exec();&#125; 最终我们运行之后 ,便能够得到这样的一副图像, 很简单, 具体的参数部分自己选择就好, 这里只是给出一个示例, line 函数 源码分析剖析其实opencv 还能绘制其他的图形, 太多了, 可以在Drawing Functions页面去查看, 基本没啥用, 很多时候是需要了自己造个轮子就行了, 不查文档我都不知道能绘制这么多 只需要知道直线, 圆, 矩形怎么绘制的就行了, 多了也用不到 后续的部分 主要是 opencv 怎么去实现的 line 函数了, 涉及到比较基础的, 看不看不影响你的使用, 不想看的就关闭即可.. 源码解析我们以 绘制直线为例, 这个简单, 我们使用了 cv::line 就绘制出来了一条直线12345678void cv::line ( InputOutputArray img, Point pt1, Point pt2, const Scalar &amp; color, int thickness = 1, int lineType = LINE_8, int shift = 0 )各个参数意义其实名称还是能够 看出来的 img: 输入输出图像, 直接在这个图像上绘制 pt1: 起始点 (x,y) 座标 pt2: 终止点 (x,y) 座标 color: Scalar 参数生成的颜色 *thickness: 直线宽度 *lineType: 绘制的线的形式 4邻域 8邻域等 *shift: 精度, 点座标中的小数点等级(第一次看到这个参数, 暂时不管他什么意思) 一般我们只需要前面的四个参数就行了, 一般就是我们程序中的 cv::line(lena_bgr, cv::Point(100, 200), cv::Point(500, 300), cv::Scalar(0, 255, 0)); 座标颜色我们都说过了, 那我们去看下 他的源码:在 modules\\imgproc\\srcdrawing.cpp:1772 中, 我们能够看到 直线的绘制函数, 1234567891011121314151617void line( InputOutputArray _img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int line_type, int shift )&#123; CV_INSTRUMENT_REGION(); Mat img = _img.getMat(); if( line_type == CV_AA &amp;&amp; img.depth() != CV_8U ) line_type = 8; CV_Assert( 0 &lt; thickness &amp;&amp; thickness &lt;= MAX_THICKNESS ); CV_Assert( 0 &lt;= shift &amp;&amp; shift &lt;= XY_SHIFT ); double buf[4]; scalarToRawData( color, buf, img.type(), 0 ); ThickLine( img, pt1, pt2, buf, thickness, line_type, 3, shift );&#125; 这个只是一个封装, 将颜色分成一个double 数组, 然后 调用了一个新的函数 ThickLine 这里 实际上 这里的scalarToRawData 函数也是根据图像的通道进行调用了, scalarToRawData_ 的函数, 将颜色结构体的四个值分别存入数组中, 也为了兼容以前的版本, 所以采用的这种接口.123456789template &lt;typename T&gt; static inlinevoid scalarToRawData_(const Scalar&amp; s, T * const buf, const int cn, const int unroll_to)&#123; int i = 0; for(; i &lt; cn; i++) buf[i] = saturate_cast&lt;T&gt;(s.val[i]); for(; i &lt; unroll_to; i++) buf[i] = buf[i-cn];&#125; 去看了下 opencv 的矩形 rectancle 函数是实际上是基于 polyline 多边形绘制, 而它则是基于 ThickLine的, opencv 的函数都是这样基于最简单的元素来实现的, 所以我们继续看这个实现就好感觉线形状的绘制最终都是调用的这个, 那我们去看下具体的实现. 在文件 modules\\imgproc\\src\\drawing.cpp:1602 是这个函数的实现, 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576static voidThickLine( Mat&amp; img, Point2l p0, Point2l p1, const void* color, int thickness, int line_type, int flags, int shift )&#123; static const double INV_XY_ONE = 1./XY_ONE; p0.x &lt;&lt;= XY_SHIFT - shift; p0.y &lt;&lt;= XY_SHIFT - shift; p1.x &lt;&lt;= XY_SHIFT - shift; p1.y &lt;&lt;= XY_SHIFT - shift; if( thickness &lt;= 1 ) &#123; if( line_type &lt; CV_AA ) &#123; if( line_type == 1 || line_type == 4 || shift == 0 ) &#123; p0.x = (p0.x + (XY_ONE&gt;&gt;1)) &gt;&gt; XY_SHIFT; p0.y = (p0.y + (XY_ONE&gt;&gt;1)) &gt;&gt; XY_SHIFT; p1.x = (p1.x + (XY_ONE&gt;&gt;1)) &gt;&gt; XY_SHIFT; p1.y = (p1.y + (XY_ONE&gt;&gt;1)) &gt;&gt; XY_SHIFT; Line( img, p0, p1, color, line_type ); &#125; else Line2( img, p0, p1, color ); &#125; else LineAA( img, p0, p1, color ); &#125; else &#123; Point2l pt[4], dp = Point2l(0,0); double dx = (p0.x - p1.x)*INV_XY_ONE, dy = (p1.y - p0.y)*INV_XY_ONE; double r = dx * dx + dy * dy; int i, oddThickness = thickness &amp; 1; thickness &lt;&lt;= XY_SHIFT - 1; if( fabs(r) &gt; DBL_EPSILON ) &#123; r = (thickness + oddThickness*XY_ONE*0.5)/std::sqrt(r); dp.x = cvRound( dy * r ); dp.y = cvRound( dx * r ); pt[0].x = p0.x + dp.x; pt[0].y = p0.y + dp.y; pt[1].x = p0.x - dp.x; pt[1].y = p0.y - dp.y; pt[2].x = p1.x - dp.x; pt[2].y = p1.y - dp.y; pt[3].x = p1.x + dp.x; pt[3].y = p1.y + dp.y; FillConvexPoly( img, pt, 4, color, line_type, XY_SHIFT ); &#125; for( i = 0; i &lt; 2; i++ ) &#123; if( flags &amp; (i+1) ) &#123; if( line_type &lt; CV_AA ) &#123; Point center; center.x = (int)((p0.x + (XY_ONE&gt;&gt;1)) &gt;&gt; XY_SHIFT); center.y = (int)((p0.y + (XY_ONE&gt;&gt;1)) &gt;&gt; XY_SHIFT); Circle( img, center, (thickness + (XY_ONE&gt;&gt;1)) &gt;&gt; XY_SHIFT, color, 1 ); &#125; else &#123; EllipseEx( img, p0, Size2l(thickness, thickness), 0, 0, 360, color, -1, line_type ); &#125; &#125; p0 = p1; &#125; &#125;&#125; 在讲函数的实现之前, 我们先看几个参数, 线形: linetype 以及线宽 thickness 其中 linetype 这里可以看OpenCV线型lineType 这篇博客, 他做了几种线形的对比, 在 头文件opencv2\\imgproc.hpp:804 中, 定义了123456enum LineTypes &#123; FILLED = -1, LINE_4 = 4, //!&lt; 4-connected line LINE_8 = 8, //!&lt; 8-connected line LINE_AA = 16 //!&lt; antialiased line&#125;;对应的: FILLED: 填充 LINE_4: 四邻域直线, LINE_8: 8邻域直线 LINE_AA: 抗锯齿直线 再看两个宏, 在modules\\imgproc\\src\\drawing.cpp:46 定义了 XY_SHIFT: 16 XY_ONE: 1 &lt;&lt; XY_SHIFT 表示左移16位 = 65536 我们在进行转换之前, 有一个小点需要关注一下, 我们line 函数输入的点是 Point2i, 而ThickLine 函数输入的点变成了 Point2l, 有意思,在\\modules\\core\\include\\opencv2\\core\\types.hpp:190, 我们找到了这样的定义, 其实是一样的 , 就是定义的必须是 64长度的 int 类型, 为什么, 好用于移位呀,123typedef Point_&lt;int&gt; Point2i;typedef Point_&lt;int64&gt; Point2l;typedef Point2i Point;这里有一段程序, 是这样的 , 我们去掉 if 再看一下:123456789p0.x &lt;&lt;= XY_SHIFT - shift;p0.y &lt;&lt;= XY_SHIFT - shift;p1.x &lt;&lt;= XY_SHIFT - shift;p1.y &lt;&lt;= XY_SHIFT - shift;p0.x = (p0.x + (XY_ONE&gt;&gt;1)) &gt;&gt; XY_SHIFT;p0.y = (p0.y + (XY_ONE&gt;&gt;1)) &gt;&gt; XY_SHIFT;p1.x = (p1.x + (XY_ONE&gt;&gt;1)) &gt;&gt; XY_SHIFT;p1.y = (p1.y + (XY_ONE&gt;&gt;1)) &gt;&gt; XY_SHIFT;shift 的 默认参数是 0, 这里的shift 实际上是座标移位的一个作用, 实际上结果就是移位得到结果 这里加上一般是为了XY_ONE&gt;&gt;1 实际上 加上0.5 向上取整而已 个人分析, 不一定是真实意图 由于绘制函数的 ThickLine 函数考虑了线宽, 我们先以基础的线宽为例: 上面一通操作只是给座标进行了变换,得到了有效的座标, 然后 来到了我们最终的 进行绘制的函数,Line ,首写字母大写的呦, 这里的核心就是 构建一个直线迭代器, 在每个点的位置上依次填入颜色即可,1234567891011121314151617181920212223242526272829static voidLine( Mat&amp; img, Point pt1, Point pt2, const void* _color, int connectivity = 8 )&#123; if( connectivity == 0 ) connectivity = 8; else if( connectivity == 1 ) connectivity = 4; LineIterator iterator(img, pt1, pt2, connectivity, true); int i, count = iterator.count; int pix_size = (int)img.elemSize(); const uchar* color = (const uchar*)_color; for( i = 0; i &lt; count; i++, ++iterator ) &#123; uchar* ptr = *iterator; if( pix_size == 1 ) ptr[0] = color[0]; else if( pix_size == 3 ) &#123; ptr[0] = color[0]; ptr[1] = color[1]; ptr[2] = color[2]; &#125; else memcpy( *iterator, color, pix_size ); &#125;&#125; 那么, 还没到最后, 我们继续 在 modules\\imgproc\\src\\drawing.cpp:160 的地方, 找到了 LineIterator 类的 构造函数,12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* Initializes line iterator. Returns number of points on the line or negative number if error.*/LineIterator::LineIterator(const Mat&amp; img, Point pt1, Point pt2, int connectivity, bool left_to_right)&#123; count = -1; CV_Assert( connectivity == 8 || connectivity == 4 ); if( (unsigned)pt1.x &gt;= (unsigned)(img.cols) || (unsigned)pt2.x &gt;= (unsigned)(img.cols) || (unsigned)pt1.y &gt;= (unsigned)(img.rows) || (unsigned)pt2.y &gt;= (unsigned)(img.rows) ) &#123; if( !clipLine( img.size(), pt1, pt2 ) ) &#123; ptr = img.data; err = plusDelta = minusDelta = plusStep = minusStep = count = 0; ptr0 = 0; step = 0; elemSize = 0; return; &#125; &#125; size_t bt_pix0 = img.elemSize(), bt_pix = bt_pix0; size_t istep = img.step; int dx = pt2.x - pt1.x; int dy = pt2.y - pt1.y; int s = dx &lt; 0 ? -1 : 0; if( left_to_right ) &#123; dx = (dx ^ s) - s; dy = (dy ^ s) - s; pt1.x ^= (pt1.x ^ pt2.x) &amp; s; pt1.y ^= (pt1.y ^ pt2.y) &amp; s; &#125; else &#123; dx = (dx ^ s) - s; bt_pix = (bt_pix ^ s) - s; &#125; ptr = (uchar*)(img.data + pt1.y * istep + pt1.x * bt_pix0); s = dy &lt; 0 ? -1 : 0; dy = (dy ^ s) - s; istep = (istep ^ s) - s; s = dy &gt; dx ? -1 : 0; /* conditional swaps */ dx ^= dy &amp; s; dy ^= dx &amp; s; dx ^= dy &amp; s; bt_pix ^= istep &amp; s; istep ^= bt_pix &amp; s; bt_pix ^= istep &amp; s; if( connectivity == 8 ) &#123; assert( dx &gt;= 0 &amp;&amp; dy &gt;= 0 ); err = dx - (dy + dy); plusDelta = dx + dx; minusDelta = -(dy + dy); plusStep = (int)istep; minusStep = (int)bt_pix; count = dx + 1; &#125; else /* connectivity == 4 */ &#123; assert( dx &gt;= 0 &amp;&amp; dy &gt;= 0 ); err = 0; plusDelta = (dx + dx) + (dy + dy); minusDelta = -(dy + dy); plusStep = (int)(istep - bt_pix); minusStep = (int)bt_pix; count = dx + dy + 1; &#125; this-&gt;ptr0 = img.ptr(); this-&gt;step = (int)img.step; this-&gt;elemSize = (int)bt_pix0;&#125; 做稍微一点的 简化, 实际上就是考虑正负符号的处理呀, 这里主要使用的就是 异或 (xor) 和 与 运算(&amp;)这里要考虑计算顺序, 注意就好 运算优先级为如下 11 a&amp;b 逐位与 12 ^ 逐位异或（互斥或） 13 | 逐位或（可兼或） 可以参考文章异或的妙用 和文章位运算总结(按位与,或,异或), 算是一个基础的x 运算吧 在计算中, 巧妙的加入了 s 作为符号, 这样减少每次计算正负的比较, 1234567891011121314151617181920212223242526272829303132333435363738size_t bt_pix0 = img.elemSize(), bt_pix = bt_pix0;size_t istep = img.step;int dx = pt2.x - pt1.x;int dy = pt2.y - pt1.y;int s = dx &lt; 0 ? -1 : 0;dx = (dx ^ s) - s;dy = (dy ^ s) - s;pt1.x ^= (pt1.x ^ pt2.x) &amp; s;pt1.y ^= (pt1.y ^ pt2.y) &amp; s;// 记录起点的指针, ptr = (uchar*)(img.data + pt1.y * istep + pt1.x * bt_pix0);// 使用符号, 巧妙的得到 绝对值s = dy &lt; 0 ? -1 : 0;dy = (dy ^ s) - s;istep = (istep ^ s) - s;s = dy &gt; dx ? -1 : 0;// 有符号的 值交换 交换 dx dy 与 bt_pix istep/* conditional swaps */dx ^= dy &amp; s;dy ^= dx &amp; s;dx ^= dy &amp; s;bt_pix ^= istep &amp; s;istep ^= bt_pix &amp; s;bt_pix ^= istep &amp; s;err = dx - (dy + dy);plusDelta = dx + dx;minusDelta = -(dy + dy);plusStep = (int)istep;minusStep = (int)bt_pix;count = dx + 1; 这里的处理真的 很巧妙, 有符号的值交换, 然后设置相应的符号mask, 及其这里求绝对值的方式, 不懂的话 就个8位的数字 代入进行运算, 可以得到想要的结果, 跑一遍就会了我之后写一篇文章 看下这里的符号运算吧, 真厉害! 在这里完成了起始点的确定, 给出了一共有多少点的存在count=dx+1, 通过确定了 我们可以假定 dx 会沿着一个方向依次相加 但是dy呢, 我们还是没有解决怎么确定的一条直线,在Line 函数的这一句, for( i = 0; i &lt; count; i++, ++iterator ) 这里的迭代器是累加的, 但是,迭代器是我们自己自定义的, 那么, ++ 操作会不会也是自定义的呢,在modules\\imgproc\\include\\opencv2\\imgproc.hpp:4673 行的地方, 我们看到了这里重载了操作符号, 这样我们在进行加加操作的时候, 这里的err 就会自己调节了, err &gt;= 0 mask = 0 err += -2dy ptr += minusStep err &lt; 0 mask = -1 err += -2dy + 2dx 这里会 得到一个正的值,这里更加的巧妙, 具体的公式或者过程需要慢慢推导, 12345678910111213141516inlineLineIterator&amp; LineIterator::operator ++()&#123; int mask = err &lt; 0 ? -1 : 0; err += minusDelta + (plusDelta &amp; mask); ptr += minusStep + (plusStep &amp; mask); return *this;&#125;inlineLineIterator LineIterator::operator ++(int)&#123; LineIterator it = *this; ++(*this); return it;&#125; 总之就是 巧妙的使用了两个变量, 使得我们的累加根据斜率进行累加过程, 完成执行, 很巧妙, 我这里 不再进行后续推导了, , 后续有机会在做… 其他","categories":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/categories/opencv/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/tags/opencv/"},{"name":"c++","slug":"c","permalink":"https://schen1024.github.io/tags/c/"},{"name":"qt","slug":"qt","permalink":"https://schen1024.github.io/tags/qt/"}]},{"title":"好用工具--VirtualAssistX","slug":"软件推荐--VirtualAssistX","date":"2020-04-22T09:35:54.000Z","updated":"2023-01-01T13:25:24.790Z","comments":true,"path":"2020/04-22/软件推荐--VirtualAssistX.html","link":"","permalink":"https://schen1024.github.io/2020/04-22/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90--VirtualAssistX.html","excerpt":"介绍VSX 真的是 VS上写 C++ 最好用的插件了, 狂吹 VSX 我一般称为 番茄插件, 因为他的图标是一个番茄, 感觉这位博主写的很详细看Visual Assist 特性和技巧 (2017) 这篇文章 , 是一位 常年使用的人写的 , 自然比我写的好, 而我只会感觉好用, 真 NB, 推荐,, 他从细节的地方都介绍了, 如果只是入门介绍的话, 推荐 这篇文章, 讲的很细节, 但是很好用 软件由于 VSX 属于付费软件, 可以选择付费购买, 看这篇文章的方法 vs 2017插件visual assist 10.9.2238破解版安装指南及百度云链接, 做了详细的安装方法 或者直接选择在 VS 的拓展界面进行能够联机安装 使用 其他","text":"介绍VSX 真的是 VS上写 C++ 最好用的插件了, 狂吹 VSX 我一般称为 番茄插件, 因为他的图标是一个番茄, 感觉这位博主写的很详细看Visual Assist 特性和技巧 (2017) 这篇文章 , 是一位 常年使用的人写的 , 自然比我写的好, 而我只会感觉好用, 真 NB, 推荐,, 他从细节的地方都介绍了, 如果只是入门介绍的话, 推荐 这篇文章, 讲的很细节, 但是很好用 软件由于 VSX 属于付费软件, 可以选择付费购买, 看这篇文章的方法 vs 2017插件visual assist 10.9.2238破解版安装指南及百度云链接, 做了详细的安装方法 或者直接选择在 VS 的拓展界面进行能够联机安装 使用 其他","categories":[{"name":"Tools","slug":"Tools","permalink":"https://schen1024.github.io/categories/Tools/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://schen1024.github.io/tags/blog/"},{"name":"VS","slug":"VS","permalink":"https://schen1024.github.io/tags/VS/"},{"name":"soft","slug":"soft","permalink":"https://schen1024.github.io/tags/soft/"},{"name":"tools","slug":"tools","permalink":"https://schen1024.github.io/tags/tools/"}]},{"title":"opencv-5-图像遍历与图像改变","slug":"opencv-5-matpx","date":"2020-04-21T17:36:33.000Z","updated":"2023-01-01T13:25:24.776Z","comments":true,"path":"2020/04-21/opencv-5-matpx.html","link":"","permalink":"https://schen1024.github.io/2020/04-21/opencv-5-matpx.html","excerpt":"目录[toc] 开始图像的像素点访问与遍历我们在上一篇文章中已经 大概介绍了 mat 图像的数据格式, 实际上可以理解为一个二维数组的格式, 那么 茴香豆的茴字一共有几种写法 访问一个像素点有几种方式呢在opencv 的官方文档: How to scan images, lookup tables and time measurement with OpenCV说了一共有三种, 常用的做法, 也可以参考Opencv访问图像像素的三种方法 这篇文章, opencv 座标定义opencv 对于图像数据的 座标是从左上角开始 的, 纵向的座标 y 也称为行 rows 横座标 y 也称为 列 cols座标范围: (0,0)– (rows-1,cols-1) 我们一般使用 (行,列) 的方式进行访问, 也比如 我们使用 $cv::Size(rows,cols)$ 设置 行列尺寸的 但是对于 二维点, $cv::Point(x,y)$ 实际上是 以 列行做 的尺寸, 此处也要进行注意 下标访问对于二维数组, 肯定是使用 下标索引访问了 比如我们在上一篇文章中, 使用 lena_rgb.at&lt;cv::Vec3b&gt;(i, j) 进行彩色图像的访问, 使用lena_gray_avg.at&lt;uchar&gt;(i, j) 进行灰度图像的访问. 也就是 Mat 的 at() 方法进行图像的访问, 具体还要考虑灰度图像或者 彩色图像, 因为对于灰度图像只有一个值, 彩色图像每一个位置是有3个值的, 我们可以使用 lena_rgb.at&lt;cv::Vec3b&gt;(i, j)[k] $k=0,1,2$ 来 访问对应的 BGR 的值, 123456789// 遍历每一个像素进行灰度化for (int i = 0; i &lt; lena_rgb.rows; i++)&#123;truefor (int j = 0; j &lt; lena_rgb.cols; j++)true&#123;truetrueimg_brg.at&lt;cv::Vec3b&gt;(i,j)[0] = 0; // 蓝色通道设为0 truetrueimg_gray.at&lt;uchar&gt;(i,j) = 0; // 灰度设为 0true&#125;&#125; 指针访问图像数据是每行存储存储的, 我们可以每次获取到一行的数据 然后把行数据作为一维数组访问, 使用指针的方式就变得很简单了, 也是目前是最快的访问方式, 对于 灰度图像, 我们可以使用 uchar* pdata = img_gray.ptr&lt;uchar&gt;(i) 访问灰度图像一行的数据, 使用 cv::Vec3b* pdata = img_gray.ptr&lt;cv::Vec3b&gt;(i) 访问一行数据, 12345678910111213cv::Mat img_gray = cv::Mat::zeros(lena_rgb.size(), CV_8UC1);cv::Mat img_bgr = cv::Mat::zeros(lena_rgb.size(), CV_8UC3);// 使用指针进行图像访问for (int i = 0; i &lt; lena_rgb.rows; i++)&#123;trueuchar *p_gray = img_gray.ptr&lt;uchar&gt;(i);truecv::Vec3b *p_bgr = img_bgr.ptr&lt;cv::Vec3b&gt;(i);truefor (int j = 0; j &lt; lena_rgb.cols; j++)true&#123;truetruep_gray[j] = 0;truetruep_bgr[j][0] = 0;true&#125;&#125; 我们通过行的索引, 获取到 第 i 行的数据指针, 然后使用作为一维数组的访问方式进行指针数据的访问, 功能强度, 十分快速, 但是可能会由于指针出现访问出错, 迭代器法访问迭代器是 C++ 11(不确定) 之后的方案, 通过迭代器能够访问不连续的数据, 这样, 我们只需要给出图像的 开始地址与 结束地址就能完成图像的访问, 也是目前最安全的方案, 不会出现越界的错误 对于灰度图像或者 彩色图像, 我们都能够使用迭代器进行访问, 123456// 使用迭代器访问for (cv::Mat_&lt;cv::Vec3b&gt;::iterator it = img_bgr.begin&lt;cv::Vec3b&gt;();trueit != img_bgr.end&lt;cv::Vec3b&gt;(); it++)&#123;true(*it)[0] = 0;&#125; 遍历访问时间对比在 opencv 的文档中, 给出了一个时间的对比方式, 通过获取 CPU 的运行时间 对比算法, 上面中, 我们给出了访问图像数据的三种方式, 这样我们就能进行一个一个像素的访问数据了,其实, 我们在每个遍历的前后添加时间 测量程序, 最后得到这样的程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include \"mainwindow.h\"#include &lt;QApplication&gt;// 引入 opencv 函数头文件#include &lt;opencv2/opencv.hpp&gt;int main(int argc, char *argv[])&#123; //QApplication a(argc, argv); //MainWindow w; //w.show(); // 设置 要显示的图像路径 //std::string test_pic = \"./TestImages/lena.png\"; double time_cnt = 0; double time_s = 0.0; // 读取图像 // cv::Mat lena_rgb = cv::imread(test_pic); // 声明 彩色图像 和灰度图像 // 设置 10000*10000 尺寸的图像, 避免出错 cv::Mat img_bgr = cv::Mat::zeros(cv::Size(1000, 1000), CV_8UC3); time_cnt = cv::getTickCount(); // 遍历每一个像素进行灰度化 for (int i = 0; i &lt; img_bgr.rows; i++) &#123; for (int j = 0; j &lt; img_bgr.cols; j++) &#123; img_bgr.at&lt;cv::Vec3b&gt;(i, j)[0] = 0; &#125; &#125; time_s = ((double)cv::getTickCount() - time_cnt) / cv::getTickFrequency(); printf(\"index scan image time: \\t\\t %f second \\n\", time_s); time_cnt = cv::getTickCount(); // 使用指针进行图像访问 for (int i = 0; i &lt; img_bgr.rows; i++) &#123; cv::Vec3b *p_bgr = img_bgr.ptr&lt;cv::Vec3b&gt;(i); for (int j = 0; j &lt; img_bgr.cols; j++) &#123; p_bgr[j][0] = 0; // 访问(i,j) 的第一个通道 &#125; &#125; time_s = ((double)cv::getTickCount() - time_cnt) / cv::getTickFrequency(); printf(\"pointer scan image time: \\t %f second \\n\", time_s); time_cnt = cv::getTickCount(); // 使用迭代器访问 for (cv::Mat_&lt;cv::Vec3b&gt;::iterator it = img_bgr.begin&lt;cv::Vec3b&gt;(); it != img_bgr.end&lt;cv::Vec3b&gt;(); it++) &#123; (*it)[0] = 0; &#125; time_s = ((double)cv::getTickCount() - time_cnt) / cv::getTickFrequency(); printf(\"iterator scan image time: \\t %f second \\n\", time_s); cv::waitKey(0); return 0; // return a.exec();&#125; 最后,运行之后便能够得到我们的运行时间, 指针访问还是最快的方式,123index scan image time: 0.040871 secondpointer scan image time: 0.015297 seconditerator scan image time: 0.561931 second差别还是有点大的, 使用 指针的方式是最快的, 迭代器是最安全的 , 但是 迭代器在较大尺寸的图的时候 是真的慢, 我们测试 的是 1000*1000 尺寸的图像, 时间差别还是比较大的, 在图像处理的过程中欧能够, 遍历图像还是比较常用的手段的, 所以 可以考虑考虑自己最熟悉的方式进行 图像遍历.. 性能情况下要多使用 指针方式访问, 注意具体的访问越界即可. 图像操作我们在能够实现图像的像素点访问之后, 会想到干什么呢, opencv的 例程中给出了两个有用的案例 Adding (blending) two images using OpenCV Changing the contrast and brightness of an image! 一个是将两幅图像做 混合叠加, 另外一个是处理图像的亮度和对比度 图像叠加我们找两个等大的图像, 对于每一个点,像素相加除以2 得到平均值, 然后 生成新的图像 代码编写感觉就是访问两幅图像, 然后叠加就好了, 跟上面讲的一样, 没有太多难度 1234567891011121314151617181920212223// 设置 要显示的图像路径std::string img_panda = \"./TestImages/panda.png\";std::string img_lena = \"./TestImages/lena.png\";// 读取两幅彩色图像 512*512cv::Mat panda_bgr = cv::imread(img_panda);cv::Mat lena_bgr = cv::imread(img_lena);// 声明结果图像cv::Mat res_bgr = cv::Mat::zeros(lena_bgr.size(), CV_8UC3);for (int i = 0; i &lt; lena_bgr.rows; i++)&#123;truefor (int j = 0; j &lt; lena_bgr.cols; j++)true&#123;truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[0] = (panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[0] + lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[0]) / 2;truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[1] = (panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[1] + lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[1]) / 2;truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[2] = (panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[2] + lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[2]) / 2;true&#125;&#125;cv::imshow(\"panda_bgr\", panda_bgr);cv::imshow(\"lena_bgr\", lena_bgr);cv::imshow(\"res_bgr\", res_bgr);cv::waitKey(0); 执行结果这种就是单纯像素的叠加, 没有什么深入的点, 理解就好了 图像”拼接”考虑一种拼接, 我们只是 将两幅图像并起来, 不考虑复杂的图像匹配, 我们可以简单的写一下, 也很简单 其实代码也很简单123456789101112131415161718192021222324252627282930313233343536// 设置 要显示的图像路径std::string img_panda = \"./TestImages/panda.png\";std::string img_lena = \"./TestImages/lena.png\";// 读取两幅彩色图像 512*512cv::Mat panda_bgr = cv::imread(img_panda);cv::Mat lena_bgr = cv::imread(img_lena);// 声明结果图像 1020*1020cv::Mat res_bgr = cv::Mat::zeros(cv::Size(1024,1024), CV_8UC3);for (int i = 0; i &lt; lena_bgr.rows; i++)&#123;truefor (int j = 0; j &lt; lena_bgr.cols; j++)true&#123;truetrue// 复制第一副图像truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[0] = (panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[0]);truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[1] = (panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[1]);truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[2] = (panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[2]);truetrue// 在第一副图下面 拼接 反色图像truetrueres_bgr.at&lt;cv::Vec3b&gt;(512+i, j)[0] = (255- panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[0]);truetrueres_bgr.at&lt;cv::Vec3b&gt;(512+i, j)[1] = (255 - panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[1]);truetrueres_bgr.at&lt;cv::Vec3b&gt;(512+i, j)[2] = (255 -panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[2]);truetrue// 复制第二幅图像 truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, 512+j)[0] = (lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[0]);truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, 512+j)[1] = (lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[1]);truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, 512+j)[2] = (lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[2]);truetrue// 在第二副图下面 拼接 反色图像truetrueres_bgr.at&lt;cv::Vec3b&gt;(512 + i, 512+j)[0] = (255 - lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[0]);truetrueres_bgr.at&lt;cv::Vec3b&gt;(512 + i, 512+j)[1] = (255 - lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[1]);truetrueres_bgr.at&lt;cv::Vec3b&gt;(512 + i, 512+j)[2] = (255 - lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[2]);true&#125;&#125; 图像 相减在考虑一种情况, 我们彩色图像的三个通道值有大有小, 那所有值减去最小值会得到什么呢, 看 代码:1234567891011121314for (int i = 0; i &lt; lena_bgr.rows; i++)&#123;truefor (int j = 0; j &lt; lena_bgr.cols; j++)true&#123;truetrue// 求出最小值truetruecv::Vec3b tmp_px = lena_bgr.at&lt;cv::Vec3b&gt;(i, j);truetrueint min_c = std::min(std::min(tmp_px[0], tmp_px[1]), tmp_px[2]);truetrue// 每个通道减去最小值truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[0] = tmp_px[0] - min_c;truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[1] = tmp_px[1] - min_c;truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[2] = tmp_px[2] - min_c;true&#125;&#125; 运行结果 亮度和对比度操作上面的两个操作只是玩玩, opencv 的例程中 关于亮度和对比度的操作还是可以试试的Changing the contrast and brightness of an image! 亮度是指 数字图像的明暗程度对比度是值 图像最高亮度与最低亮度的差值锐度: 图像边缘像素的对比度可以参考文章【数字图像处理系列二】亮度、对比度、饱和度、锐化、分辨率 其实吧, 知道就行了, 具体深究也可以看这篇一次搞懂清晰度、对比度以及锐化的区别, 有很多图片可以查看, 还能通过图像进行对比. 亮度操作回到正题, 我们要进行 亮度变换 其实就是在进行 图像灰度值的调节过程. $$g(i,j) = \\alpha \\cdot f(i,j) + \\beta$$$\\alpha$ 是原始图像 灰度放大倍数 , $\\beta$ 是灰度的偏置 bias 我们来实现一下, 看下效果:参数选择 例程中的 $\\alpha = 2.2$ , $\\beta = 50$12345678910111213float a = 2.2f, b = 50;for (int i = 0; i &lt; lena_bgr.rows; i++)&#123;truefor (int j = 0; j &lt; lena_bgr.cols; j++)true&#123;truetrue// 取出原始图像 灰度值truetruecv::Vec3b tmp_px = lena_bgr.at&lt;cv::Vec3b&gt;(i, j); truetrue// 每个通道减去最小值truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[0] = cv::saturate_cast&lt;uchar&gt;(a * tmp_px[0] + b);truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[1] = cv::saturate_cast&lt;uchar&gt;(a * tmp_px[1] + b);truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[2] = cv::saturate_cast&lt;uchar&gt;(a * tmp_px[2] + b);true&#125;&#125;运行结果图: 这里使用的是 cv::saturate_cast&lt;uchar&gt; 进行的结果转换, 都是转换成 uchar 数据, 如果直接使用 uchar 转换 得到的结果图像会很奇怪, 例如: res_bgr.at&lt;cv::Vec3b&gt;(i, j)[0] = (uchar)(a * tmp_px[0] + b); 伽马矫正(Gamma)线性变化还有很多, 灰度转换, 截取, 反色等等操作, 但是有一种非线性变化, 必须要进行介绍, 那就是 伽马矫正, 用来对于矫正输入图像的亮度值, 具体的公式表示为:$$g(i,j) = (\\frac{f(i,j)}{255})^{\\gamma} \\times 255$$ 对于不同的 $\\gamma$ 值, 我们绘制输入输出曲线可以得到这个图, 我们测试一下代码试试, 例程中使用了 一个 LUT的函数,因为看上面的变换公式, 涉及到了指数运算, 如果我们每个像素值都计算一次 会比较花时间, 反正对于一个像素值, 计算出来的gamma 值是一样的 , 我提前计算好, 之际查找不就好了吗, 我们在最开始计算出来每个 灰度值的结果表,123456789101112131415161718192021// 自定义 gamma 参数float gamma = 0.4;// 生成gamma 查找表uchar table[256] = &#123; 0 &#125;;for (int i = 0; i &lt; 256; i++)&#123;truetable[i] = std::pow(i / 255.0f, gamma) * 255;&#125;for (int i = 0; i &lt; lena_bgr.rows; i++)&#123;truefor (int j = 0; j &lt; lena_bgr.cols; j++)true&#123;truetrue// 取出原始图像 灰度值truetruecv::Vec3b tmp_px = lena_bgr.at&lt;cv::Vec3b&gt;(i, j); truetrue// 每个通道减去最小值truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[0] = table[tmp_px[0]];truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[1] = table[tmp_px[1]];truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[2] = table[tmp_px[2]];true&#125;&#125; 这个效果不是很好, 可以参考 opencv 例程里面的图, 效果真的很不错 其他","text":"目录[toc] 开始图像的像素点访问与遍历我们在上一篇文章中已经 大概介绍了 mat 图像的数据格式, 实际上可以理解为一个二维数组的格式, 那么 茴香豆的茴字一共有几种写法 访问一个像素点有几种方式呢在opencv 的官方文档: How to scan images, lookup tables and time measurement with OpenCV说了一共有三种, 常用的做法, 也可以参考Opencv访问图像像素的三种方法 这篇文章, opencv 座标定义opencv 对于图像数据的 座标是从左上角开始 的, 纵向的座标 y 也称为行 rows 横座标 y 也称为 列 cols座标范围: (0,0)– (rows-1,cols-1) 我们一般使用 (行,列) 的方式进行访问, 也比如 我们使用 $cv::Size(rows,cols)$ 设置 行列尺寸的 但是对于 二维点, $cv::Point(x,y)$ 实际上是 以 列行做 的尺寸, 此处也要进行注意 下标访问对于二维数组, 肯定是使用 下标索引访问了 比如我们在上一篇文章中, 使用 lena_rgb.at&lt;cv::Vec3b&gt;(i, j) 进行彩色图像的访问, 使用lena_gray_avg.at&lt;uchar&gt;(i, j) 进行灰度图像的访问. 也就是 Mat 的 at() 方法进行图像的访问, 具体还要考虑灰度图像或者 彩色图像, 因为对于灰度图像只有一个值, 彩色图像每一个位置是有3个值的, 我们可以使用 lena_rgb.at&lt;cv::Vec3b&gt;(i, j)[k] $k=0,1,2$ 来 访问对应的 BGR 的值, 123456789// 遍历每一个像素进行灰度化for (int i = 0; i &lt; lena_rgb.rows; i++)&#123;truefor (int j = 0; j &lt; lena_rgb.cols; j++)true&#123;truetrueimg_brg.at&lt;cv::Vec3b&gt;(i,j)[0] = 0; // 蓝色通道设为0 truetrueimg_gray.at&lt;uchar&gt;(i,j) = 0; // 灰度设为 0true&#125;&#125; 指针访问图像数据是每行存储存储的, 我们可以每次获取到一行的数据 然后把行数据作为一维数组访问, 使用指针的方式就变得很简单了, 也是目前是最快的访问方式, 对于 灰度图像, 我们可以使用 uchar* pdata = img_gray.ptr&lt;uchar&gt;(i) 访问灰度图像一行的数据, 使用 cv::Vec3b* pdata = img_gray.ptr&lt;cv::Vec3b&gt;(i) 访问一行数据, 12345678910111213cv::Mat img_gray = cv::Mat::zeros(lena_rgb.size(), CV_8UC1);cv::Mat img_bgr = cv::Mat::zeros(lena_rgb.size(), CV_8UC3);// 使用指针进行图像访问for (int i = 0; i &lt; lena_rgb.rows; i++)&#123;trueuchar *p_gray = img_gray.ptr&lt;uchar&gt;(i);truecv::Vec3b *p_bgr = img_bgr.ptr&lt;cv::Vec3b&gt;(i);truefor (int j = 0; j &lt; lena_rgb.cols; j++)true&#123;truetruep_gray[j] = 0;truetruep_bgr[j][0] = 0;true&#125;&#125; 我们通过行的索引, 获取到 第 i 行的数据指针, 然后使用作为一维数组的访问方式进行指针数据的访问, 功能强度, 十分快速, 但是可能会由于指针出现访问出错, 迭代器法访问迭代器是 C++ 11(不确定) 之后的方案, 通过迭代器能够访问不连续的数据, 这样, 我们只需要给出图像的 开始地址与 结束地址就能完成图像的访问, 也是目前最安全的方案, 不会出现越界的错误 对于灰度图像或者 彩色图像, 我们都能够使用迭代器进行访问, 123456// 使用迭代器访问for (cv::Mat_&lt;cv::Vec3b&gt;::iterator it = img_bgr.begin&lt;cv::Vec3b&gt;();trueit != img_bgr.end&lt;cv::Vec3b&gt;(); it++)&#123;true(*it)[0] = 0;&#125; 遍历访问时间对比在 opencv 的文档中, 给出了一个时间的对比方式, 通过获取 CPU 的运行时间 对比算法, 上面中, 我们给出了访问图像数据的三种方式, 这样我们就能进行一个一个像素的访问数据了,其实, 我们在每个遍历的前后添加时间 测量程序, 最后得到这样的程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include \"mainwindow.h\"#include &lt;QApplication&gt;// 引入 opencv 函数头文件#include &lt;opencv2/opencv.hpp&gt;int main(int argc, char *argv[])&#123; //QApplication a(argc, argv); //MainWindow w; //w.show(); // 设置 要显示的图像路径 //std::string test_pic = \"./TestImages/lena.png\"; double time_cnt = 0; double time_s = 0.0; // 读取图像 // cv::Mat lena_rgb = cv::imread(test_pic); // 声明 彩色图像 和灰度图像 // 设置 10000*10000 尺寸的图像, 避免出错 cv::Mat img_bgr = cv::Mat::zeros(cv::Size(1000, 1000), CV_8UC3); time_cnt = cv::getTickCount(); // 遍历每一个像素进行灰度化 for (int i = 0; i &lt; img_bgr.rows; i++) &#123; for (int j = 0; j &lt; img_bgr.cols; j++) &#123; img_bgr.at&lt;cv::Vec3b&gt;(i, j)[0] = 0; &#125; &#125; time_s = ((double)cv::getTickCount() - time_cnt) / cv::getTickFrequency(); printf(\"index scan image time: \\t\\t %f second \\n\", time_s); time_cnt = cv::getTickCount(); // 使用指针进行图像访问 for (int i = 0; i &lt; img_bgr.rows; i++) &#123; cv::Vec3b *p_bgr = img_bgr.ptr&lt;cv::Vec3b&gt;(i); for (int j = 0; j &lt; img_bgr.cols; j++) &#123; p_bgr[j][0] = 0; // 访问(i,j) 的第一个通道 &#125; &#125; time_s = ((double)cv::getTickCount() - time_cnt) / cv::getTickFrequency(); printf(\"pointer scan image time: \\t %f second \\n\", time_s); time_cnt = cv::getTickCount(); // 使用迭代器访问 for (cv::Mat_&lt;cv::Vec3b&gt;::iterator it = img_bgr.begin&lt;cv::Vec3b&gt;(); it != img_bgr.end&lt;cv::Vec3b&gt;(); it++) &#123; (*it)[0] = 0; &#125; time_s = ((double)cv::getTickCount() - time_cnt) / cv::getTickFrequency(); printf(\"iterator scan image time: \\t %f second \\n\", time_s); cv::waitKey(0); return 0; // return a.exec();&#125; 最后,运行之后便能够得到我们的运行时间, 指针访问还是最快的方式,123index scan image time: 0.040871 secondpointer scan image time: 0.015297 seconditerator scan image time: 0.561931 second差别还是有点大的, 使用 指针的方式是最快的, 迭代器是最安全的 , 但是 迭代器在较大尺寸的图的时候 是真的慢, 我们测试 的是 1000*1000 尺寸的图像, 时间差别还是比较大的, 在图像处理的过程中欧能够, 遍历图像还是比较常用的手段的, 所以 可以考虑考虑自己最熟悉的方式进行 图像遍历.. 性能情况下要多使用 指针方式访问, 注意具体的访问越界即可. 图像操作我们在能够实现图像的像素点访问之后, 会想到干什么呢, opencv的 例程中给出了两个有用的案例 Adding (blending) two images using OpenCV Changing the contrast and brightness of an image! 一个是将两幅图像做 混合叠加, 另外一个是处理图像的亮度和对比度 图像叠加我们找两个等大的图像, 对于每一个点,像素相加除以2 得到平均值, 然后 生成新的图像 代码编写感觉就是访问两幅图像, 然后叠加就好了, 跟上面讲的一样, 没有太多难度 1234567891011121314151617181920212223// 设置 要显示的图像路径std::string img_panda = \"./TestImages/panda.png\";std::string img_lena = \"./TestImages/lena.png\";// 读取两幅彩色图像 512*512cv::Mat panda_bgr = cv::imread(img_panda);cv::Mat lena_bgr = cv::imread(img_lena);// 声明结果图像cv::Mat res_bgr = cv::Mat::zeros(lena_bgr.size(), CV_8UC3);for (int i = 0; i &lt; lena_bgr.rows; i++)&#123;truefor (int j = 0; j &lt; lena_bgr.cols; j++)true&#123;truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[0] = (panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[0] + lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[0]) / 2;truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[1] = (panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[1] + lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[1]) / 2;truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[2] = (panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[2] + lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[2]) / 2;true&#125;&#125;cv::imshow(\"panda_bgr\", panda_bgr);cv::imshow(\"lena_bgr\", lena_bgr);cv::imshow(\"res_bgr\", res_bgr);cv::waitKey(0); 执行结果这种就是单纯像素的叠加, 没有什么深入的点, 理解就好了 图像”拼接”考虑一种拼接, 我们只是 将两幅图像并起来, 不考虑复杂的图像匹配, 我们可以简单的写一下, 也很简单 其实代码也很简单123456789101112131415161718192021222324252627282930313233343536// 设置 要显示的图像路径std::string img_panda = \"./TestImages/panda.png\";std::string img_lena = \"./TestImages/lena.png\";// 读取两幅彩色图像 512*512cv::Mat panda_bgr = cv::imread(img_panda);cv::Mat lena_bgr = cv::imread(img_lena);// 声明结果图像 1020*1020cv::Mat res_bgr = cv::Mat::zeros(cv::Size(1024,1024), CV_8UC3);for (int i = 0; i &lt; lena_bgr.rows; i++)&#123;truefor (int j = 0; j &lt; lena_bgr.cols; j++)true&#123;truetrue// 复制第一副图像truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[0] = (panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[0]);truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[1] = (panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[1]);truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[2] = (panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[2]);truetrue// 在第一副图下面 拼接 反色图像truetrueres_bgr.at&lt;cv::Vec3b&gt;(512+i, j)[0] = (255- panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[0]);truetrueres_bgr.at&lt;cv::Vec3b&gt;(512+i, j)[1] = (255 - panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[1]);truetrueres_bgr.at&lt;cv::Vec3b&gt;(512+i, j)[2] = (255 -panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[2]);truetrue// 复制第二幅图像 truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, 512+j)[0] = (lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[0]);truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, 512+j)[1] = (lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[1]);truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, 512+j)[2] = (lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[2]);truetrue// 在第二副图下面 拼接 反色图像truetrueres_bgr.at&lt;cv::Vec3b&gt;(512 + i, 512+j)[0] = (255 - lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[0]);truetrueres_bgr.at&lt;cv::Vec3b&gt;(512 + i, 512+j)[1] = (255 - lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[1]);truetrueres_bgr.at&lt;cv::Vec3b&gt;(512 + i, 512+j)[2] = (255 - lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[2]);true&#125;&#125; 图像 相减在考虑一种情况, 我们彩色图像的三个通道值有大有小, 那所有值减去最小值会得到什么呢, 看 代码:1234567891011121314for (int i = 0; i &lt; lena_bgr.rows; i++)&#123;truefor (int j = 0; j &lt; lena_bgr.cols; j++)true&#123;truetrue// 求出最小值truetruecv::Vec3b tmp_px = lena_bgr.at&lt;cv::Vec3b&gt;(i, j);truetrueint min_c = std::min(std::min(tmp_px[0], tmp_px[1]), tmp_px[2]);truetrue// 每个通道减去最小值truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[0] = tmp_px[0] - min_c;truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[1] = tmp_px[1] - min_c;truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[2] = tmp_px[2] - min_c;true&#125;&#125; 运行结果 亮度和对比度操作上面的两个操作只是玩玩, opencv 的例程中 关于亮度和对比度的操作还是可以试试的Changing the contrast and brightness of an image! 亮度是指 数字图像的明暗程度对比度是值 图像最高亮度与最低亮度的差值锐度: 图像边缘像素的对比度可以参考文章【数字图像处理系列二】亮度、对比度、饱和度、锐化、分辨率 其实吧, 知道就行了, 具体深究也可以看这篇一次搞懂清晰度、对比度以及锐化的区别, 有很多图片可以查看, 还能通过图像进行对比. 亮度操作回到正题, 我们要进行 亮度变换 其实就是在进行 图像灰度值的调节过程. $$g(i,j) = \\alpha \\cdot f(i,j) + \\beta$$$\\alpha$ 是原始图像 灰度放大倍数 , $\\beta$ 是灰度的偏置 bias 我们来实现一下, 看下效果:参数选择 例程中的 $\\alpha = 2.2$ , $\\beta = 50$12345678910111213float a = 2.2f, b = 50;for (int i = 0; i &lt; lena_bgr.rows; i++)&#123;truefor (int j = 0; j &lt; lena_bgr.cols; j++)true&#123;truetrue// 取出原始图像 灰度值truetruecv::Vec3b tmp_px = lena_bgr.at&lt;cv::Vec3b&gt;(i, j); truetrue// 每个通道减去最小值truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[0] = cv::saturate_cast&lt;uchar&gt;(a * tmp_px[0] + b);truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[1] = cv::saturate_cast&lt;uchar&gt;(a * tmp_px[1] + b);truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[2] = cv::saturate_cast&lt;uchar&gt;(a * tmp_px[2] + b);true&#125;&#125;运行结果图: 这里使用的是 cv::saturate_cast&lt;uchar&gt; 进行的结果转换, 都是转换成 uchar 数据, 如果直接使用 uchar 转换 得到的结果图像会很奇怪, 例如: res_bgr.at&lt;cv::Vec3b&gt;(i, j)[0] = (uchar)(a * tmp_px[0] + b); 伽马矫正(Gamma)线性变化还有很多, 灰度转换, 截取, 反色等等操作, 但是有一种非线性变化, 必须要进行介绍, 那就是 伽马矫正, 用来对于矫正输入图像的亮度值, 具体的公式表示为:$$g(i,j) = (\\frac{f(i,j)}{255})^{\\gamma} \\times 255$$ 对于不同的 $\\gamma$ 值, 我们绘制输入输出曲线可以得到这个图, 我们测试一下代码试试, 例程中使用了 一个 LUT的函数,因为看上面的变换公式, 涉及到了指数运算, 如果我们每个像素值都计算一次 会比较花时间, 反正对于一个像素值, 计算出来的gamma 值是一样的 , 我提前计算好, 之际查找不就好了吗, 我们在最开始计算出来每个 灰度值的结果表,123456789101112131415161718192021// 自定义 gamma 参数float gamma = 0.4;// 生成gamma 查找表uchar table[256] = &#123; 0 &#125;;for (int i = 0; i &lt; 256; i++)&#123;truetable[i] = std::pow(i / 255.0f, gamma) * 255;&#125;for (int i = 0; i &lt; lena_bgr.rows; i++)&#123;truefor (int j = 0; j &lt; lena_bgr.cols; j++)true&#123;truetrue// 取出原始图像 灰度值truetruecv::Vec3b tmp_px = lena_bgr.at&lt;cv::Vec3b&gt;(i, j); truetrue// 每个通道减去最小值truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[0] = table[tmp_px[0]];truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[1] = table[tmp_px[1]];truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[2] = table[tmp_px[2]];true&#125;&#125; 这个效果不是很好, 可以参考 opencv 例程里面的图, 效果真的很不错 其他","categories":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/categories/opencv/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/tags/opencv/"},{"name":"c++","slug":"c","permalink":"https://schen1024.github.io/tags/c/"},{"name":"qt","slug":"qt","permalink":"https://schen1024.github.io/tags/qt/"}]},{"title":"opencv-4-成像系统与Mat图像颜色空间","slug":"opencv-4-Mat","date":"2020-04-21T10:37:59.000Z","updated":"2023-01-01T13:25:24.776Z","comments":true,"path":"2020/04-21/opencv-4-Mat.html","link":"","permalink":"https://schen1024.github.io/2020/04-21/opencv-4-Mat.html","excerpt":"目标 知道 opencv 处理图像数据的格式 介绍 mat 基础内容 知道 BGR 颜色 显示 颜色转换 BGR 到 灰度图像 开始Opencv 主要是图像处理, 在进行图像处理的过程中有一个必须要解决的问题: 图像的内存存储, 最简单的方式就是使用二维数组来存储了. opencv 在1.0时代使用的是二维数组, 然后使用 IplImage 的指针指向数据起始的地址, 指针很强大, 但是对于新手不是很友好, 容易出现各种奇怪的问题.. opencv 从2.0 时代就开始使用 Mat 格式 来存储图像数据, 相当于从 C 版本的接口 升级到了 C++ 的接口, 到了后面就逐渐开始移除 C 接口了, 开始了 C++ 的接口, 不再需要自己去维护内存, 让它来做, 让我们不再去考虑太过底层的实现, 专注与我们自己的 算法实现上来.. VS2017 下面有一个插件 Image Watch, 可以在调试过程中查看 内存中的 opencv Mat 数据. 我们在VS 的调试过程中, 点击 视图--其他窗口--ImageWatch 会弹出窗口 我们能够看到图像的预览与实际, 点击可以使用滚轮进行放大, 比如 我们将其放大到一定程度就发现图像数据是一个一个的”格子”, 也就是我们称为的像素, 对于我们原始的 lena 图像 就是一个 $512px*512px$尺寸的图像 px 是 图像像素的单位, 可以理解为 512*512 个小格子 图像数据不是矢量数据, 不能够无限放大, 能够满足我们的日常实现即可 Mat 图像数据格式一般来说, Mat 是一种对象, 有着相应的成员, 或者可以理解为属性, 可以理解为, 我们使用二维数组存储图像数据, 可以通过一些方法直接获取到这些二维数组的参数信息以及其他信息, 便于后续实现 比如 Mat类 常用的有以下几种^[《Opencv学习（三）简记Mat中的数据类型_人工智能_hjxu2016的博客-CSDN博客》. 见于 2020年4月21日. https://blog.csdn.net/hjxu2016/article/details/81116040.] type: CV_8UC3 图像数据类型和通道数目 depth: 图像的精度, 用于表示每一个像素每一个通道的精度值 8U 表示 无符号 $2^8$ 精度, 最高256个灰度等级 channels: 通道数目 表示图像每个像素的数目 cols: 图像数据宽度 横向 rows: 图像数据高度 纵向 size(): 返回(cols, rows) 数据 data: 指向二维数组的首地址, 指向图像数据最开始的地方 step: = stride 表示图像数据每一行的字节大小 … 不再意义列举, 常用的就这么多 成像系统在数字成像系统概述 这篇文章中, 详细介绍了数字的成像系统^[《数字成像系统概述|Camera》. 见于 2020年4月21日. http://camera.geek-docs.com/camera-isp/digital-camera-system-intro.html.], 我们以这幅图为例 成像系统 满足高斯公式 $\\frac{1}{u} + \\frac{1}{v} = \\frac{1}{f}$, 传感器成像我们只看成像传感器部分, 传感器实际上是分为了每一个很小的格子, 每一个格子都会受到光照, 根据光照强度不同, 产生不同的电压信号, 通过放大电路被我们采集便能够得到整幅图像的电压, 转换以下辨识我们得到的图像数据了, 但是这里最重要的问题是, 光电传感器只能感受到光的强度, 不能感受到光的颜色, 所以 传感器上会附加 透镜, 每一个传感器只会感受到一种颜色光的强度, 组合以下便能够得到 颜色了, 颜色混合模型这里又有一个概念, 颜色混合模型,其实每个概念都是很深的东西, 但是如果不是专业涉及的话, 我们暂时不做太深入的了解 ,有兴趣的可以看CMYK 和 RGB 这两种色彩模式本质与区别在哪？ 和这篇文章从“减色法”的本质，到广色域输出的可能性 主要有两种颜色模型, 加色和减色, 可以去参考参考RGB vs CMYK: What’s the difference?这篇文章, 减色模型 一般情况下可以了理解为 CMYK 模型, 一般用于印刷, 加法模型 一般是指 RGB 颜色加法混合模型 可以用于颜色 的表示, 符合人眼的颜色感觉 跑的有点远了, 收回来 我们使用三种颜色等量叠加便能够得到白色, 对应的, 使用不同比例的颜色叠加便能够得到不同的颜色, 对应的, 我们在lena 显示的时候, 放大之后得到的数字就是我们图像的演示的 “RGB” 值, 颜色深度这里还要再做一点介绍, 颜色深度,数字图像, 自然所有的东西都是数字了, 考虑到实际计算机存储一个字节的数据为 8个bit, 1Byte = 8 bit , 每一个bit 可以表示成0或者1 则, 我们可以将每一个颜色分为 $2^8 = 256$ 种颜色进行表示, 这样即能够有效的利用数据, 也能方便的进行运算. 对于灰度图像, 一共有 256个层级 使用$[0-255]$进行表示, 对于彩色图像, 我们每一个颜色都能表示成256个颜色, 则可以得到 $256256256=16777216$ 种颜色, 我们可以使用 $ RGB(255,255,255)$ 来表示白色, 或者类似与 html 中使用 16进制来表示颜色一样 使用#ffffff 来分别表示 RGB的 颜色值. 用于表示白色 opencv 颜色空间opencv 的大坑 由于历史遗留问题, opencv 3通道彩色图像的数据格式 为 BGR的顺序, 而不是常用的RGB顺序, 在我们进行实际上的颜色选择方面一定要注意这一点, 至于为什么, 只能说为了兼容某些硬件设备, 统一一个顺序, 定下来的一个标准, 后面的又为了兼容以前的版本.. 具体的可以参考Why does OpenCV use BGR color format ? Why did they choose BGR color space in OpenCV ?The reason the early developers at OpenCV chose BGR color format is that back then BGR color format was popular among camera manufacturers and software providers. E.g. in Windows, when specifying color value using COLORREF they use the BGR format 0x00bbggrr. 实际上我们注意就好, opencv 的颜色顺序为 BGR 一般来说, 我们在 opencv 中表示各种颜色 蓝色 BGR(255,0,0); 红色 BGR(0,0,255); 绿色 BGR(0,255,0); 青色 BGR(255,255,0); 紫色 BGR(255,0,255); 黄色 BGR(0,255,255); 白色 BGR(255,255,255); 黑色 BGR(0,0,0); 中等灰色 BGR(128,128,128 ); 彩色图像灰度化我感觉这篇文章图像处理：图像灰度化 做了很多介绍, 其实 颜色对于图像处理来说意义不大, 更多的是给人的一种颜色的感觉, 所以很多时候进行图像处理的过程都是进行灰度化处理了, 由我们的成像系统可以得知, 每一个像素的位置存在三种颜色的值, 灰度化的过程就是将三个值变成一个值, 就是我们所谓的灰度化, 将原本三通道的像素值转换为1通道的像素值,一般来说, 我们就考虑颜色灰度的平均得到灰度值即可,$$Gray(i,j) = \\frac{R(i,j) + G(i,j) + B(i,j)}{3}$$这就是平均值的方式,但是呢, 人眼对于绿色比较敏感 进而提出了给出不同权重的灰度化过程, 属于一个心理学公式$$Gray(i,j) = 0.299 R(i,j) + 0.587 G(i,j) + 0.114 * B(i,j)$$ 这个权重值是一个目前使用最多的比例, 但是也有其他人提出的权重参数, 详细可以见[Grayscale wiki 页面](https://en.wikipedia.org/wiki/Grayscale 进而我比较喜欢是这篇文章从RGB色转为灰度色算法, 给出了一个比较有效的 整数移位算法, 减少整数计算带来的精度损失以及浮点运算的低效率.参照他给出的数据, 得到一个有趣的公式, 可以去详细看下,$$Gray(i,j) = (38R(i,j) + 75(G(i,j) + 15*B(i,j)) &gt;&gt; 7$$ 编码实现编辑代码我们这里为了对比 不同的灰度化做了一个展示, 其实很简单, 这里用到的 图像遍历的方式, 对于每一个像素点进行处理 三种灰度化的方式, 存入到三副图像中, 然后一起显示出来用于对比, 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include \"mainwindow.h\"#include &lt;QApplication&gt;// 引入 opencv 函数头文件#include &lt;opencv2/opencv.hpp&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); MainWindow w; w.show(); // 设置 要显示的图像路径 std::string test_pic = \"./TestImages/lena.png\"; // 读取图像 cv::Mat lena_rgb = cv::imread(test_pic); // 声明三个灰色的图像 cv::Mat lena_gray_avg = cv::Mat::zeros(lena_rgb.size(), CV_8UC1); cv::Mat lena_gray_weighted = cv::Mat::zeros(lena_rgb.size(), CV_8UC1); cv::Mat lena_gray_shift = cv::Mat::zeros(lena_rgb.size(), CV_8UC1); // 遍历每一个像素进行灰度化 for (int i = 0; i &lt; lena_rgb.rows; i++) &#123; for (int j = 0; j &lt; lena_rgb.cols; j++) &#123; cv::Vec3b tmp_px = lena_rgb.at&lt;cv::Vec3b&gt;(i, j); lena_gray_avg.at&lt;uchar&gt;(i, j) = (uchar)((tmp_px[0] + tmp_px[1] + tmp_px[2]) / 3); lena_gray_weighted.at&lt;uchar&gt;(i, j) = (uchar)((0.299f * tmp_px[0] + 0.587f * tmp_px[1] + 0.114f * tmp_px[2])); lena_gray_shift.at&lt;uchar&gt;(i, j) = (uchar)((38 * tmp_px[0] + 75 * tmp_px[1] + 15 * tmp_px[2]) &gt;&gt; 7); &#125; &#125; // 显示图像 cv::imshow(\"lena_rgb\", lena_rgb); cv::imshow(\"lena_gray_avg\", lena_gray_avg); cv::imshow(\"lena_gray_weighted\", lena_gray_weighted); cv::imshow(\"lena_gray_shift\", lena_gray_shift); cv::waitKey(0); return a.exec();&#125; 运行效果最后运行出来的结果就是下图了, 很简单, 但是 很有效, 对应最开始的图, 我们选取lena 眼镜部分, 查看 lena_gray_shift 的眼镜细节, 得到图 其他我们稍微介绍了成像的系统, 然后介绍了opencv 的 成像方法, 以及具体的颜色表示, 在后面我们就要进行 稍微深入的像素操作与图形操作了. 参考","text":"目标 知道 opencv 处理图像数据的格式 介绍 mat 基础内容 知道 BGR 颜色 显示 颜色转换 BGR 到 灰度图像 开始Opencv 主要是图像处理, 在进行图像处理的过程中有一个必须要解决的问题: 图像的内存存储, 最简单的方式就是使用二维数组来存储了. opencv 在1.0时代使用的是二维数组, 然后使用 IplImage 的指针指向数据起始的地址, 指针很强大, 但是对于新手不是很友好, 容易出现各种奇怪的问题.. opencv 从2.0 时代就开始使用 Mat 格式 来存储图像数据, 相当于从 C 版本的接口 升级到了 C++ 的接口, 到了后面就逐渐开始移除 C 接口了, 开始了 C++ 的接口, 不再需要自己去维护内存, 让它来做, 让我们不再去考虑太过底层的实现, 专注与我们自己的 算法实现上来.. VS2017 下面有一个插件 Image Watch, 可以在调试过程中查看 内存中的 opencv Mat 数据. 我们在VS 的调试过程中, 点击 视图--其他窗口--ImageWatch 会弹出窗口 我们能够看到图像的预览与实际, 点击可以使用滚轮进行放大, 比如 我们将其放大到一定程度就发现图像数据是一个一个的”格子”, 也就是我们称为的像素, 对于我们原始的 lena 图像 就是一个 $512px*512px$尺寸的图像 px 是 图像像素的单位, 可以理解为 512*512 个小格子 图像数据不是矢量数据, 不能够无限放大, 能够满足我们的日常实现即可 Mat 图像数据格式一般来说, Mat 是一种对象, 有着相应的成员, 或者可以理解为属性, 可以理解为, 我们使用二维数组存储图像数据, 可以通过一些方法直接获取到这些二维数组的参数信息以及其他信息, 便于后续实现 比如 Mat类 常用的有以下几种^[《Opencv学习（三）简记Mat中的数据类型_人工智能_hjxu2016的博客-CSDN博客》. 见于 2020年4月21日. https://blog.csdn.net/hjxu2016/article/details/81116040.] type: CV_8UC3 图像数据类型和通道数目 depth: 图像的精度, 用于表示每一个像素每一个通道的精度值 8U 表示 无符号 $2^8$ 精度, 最高256个灰度等级 channels: 通道数目 表示图像每个像素的数目 cols: 图像数据宽度 横向 rows: 图像数据高度 纵向 size(): 返回(cols, rows) 数据 data: 指向二维数组的首地址, 指向图像数据最开始的地方 step: = stride 表示图像数据每一行的字节大小 … 不再意义列举, 常用的就这么多 成像系统在数字成像系统概述 这篇文章中, 详细介绍了数字的成像系统^[《数字成像系统概述|Camera》. 见于 2020年4月21日. http://camera.geek-docs.com/camera-isp/digital-camera-system-intro.html.], 我们以这幅图为例 成像系统 满足高斯公式 $\\frac{1}{u} + \\frac{1}{v} = \\frac{1}{f}$, 传感器成像我们只看成像传感器部分, 传感器实际上是分为了每一个很小的格子, 每一个格子都会受到光照, 根据光照强度不同, 产生不同的电压信号, 通过放大电路被我们采集便能够得到整幅图像的电压, 转换以下辨识我们得到的图像数据了, 但是这里最重要的问题是, 光电传感器只能感受到光的强度, 不能感受到光的颜色, 所以 传感器上会附加 透镜, 每一个传感器只会感受到一种颜色光的强度, 组合以下便能够得到 颜色了, 颜色混合模型这里又有一个概念, 颜色混合模型,其实每个概念都是很深的东西, 但是如果不是专业涉及的话, 我们暂时不做太深入的了解 ,有兴趣的可以看CMYK 和 RGB 这两种色彩模式本质与区别在哪？ 和这篇文章从“减色法”的本质，到广色域输出的可能性 主要有两种颜色模型, 加色和减色, 可以去参考参考RGB vs CMYK: What’s the difference?这篇文章, 减色模型 一般情况下可以了理解为 CMYK 模型, 一般用于印刷, 加法模型 一般是指 RGB 颜色加法混合模型 可以用于颜色 的表示, 符合人眼的颜色感觉 跑的有点远了, 收回来 我们使用三种颜色等量叠加便能够得到白色, 对应的, 使用不同比例的颜色叠加便能够得到不同的颜色, 对应的, 我们在lena 显示的时候, 放大之后得到的数字就是我们图像的演示的 “RGB” 值, 颜色深度这里还要再做一点介绍, 颜色深度,数字图像, 自然所有的东西都是数字了, 考虑到实际计算机存储一个字节的数据为 8个bit, 1Byte = 8 bit , 每一个bit 可以表示成0或者1 则, 我们可以将每一个颜色分为 $2^8 = 256$ 种颜色进行表示, 这样即能够有效的利用数据, 也能方便的进行运算. 对于灰度图像, 一共有 256个层级 使用$[0-255]$进行表示, 对于彩色图像, 我们每一个颜色都能表示成256个颜色, 则可以得到 $256256256=16777216$ 种颜色, 我们可以使用 $ RGB(255,255,255)$ 来表示白色, 或者类似与 html 中使用 16进制来表示颜色一样 使用#ffffff 来分别表示 RGB的 颜色值. 用于表示白色 opencv 颜色空间opencv 的大坑 由于历史遗留问题, opencv 3通道彩色图像的数据格式 为 BGR的顺序, 而不是常用的RGB顺序, 在我们进行实际上的颜色选择方面一定要注意这一点, 至于为什么, 只能说为了兼容某些硬件设备, 统一一个顺序, 定下来的一个标准, 后面的又为了兼容以前的版本.. 具体的可以参考Why does OpenCV use BGR color format ? Why did they choose BGR color space in OpenCV ?The reason the early developers at OpenCV chose BGR color format is that back then BGR color format was popular among camera manufacturers and software providers. E.g. in Windows, when specifying color value using COLORREF they use the BGR format 0x00bbggrr. 实际上我们注意就好, opencv 的颜色顺序为 BGR 一般来说, 我们在 opencv 中表示各种颜色 蓝色 BGR(255,0,0); 红色 BGR(0,0,255); 绿色 BGR(0,255,0); 青色 BGR(255,255,0); 紫色 BGR(255,0,255); 黄色 BGR(0,255,255); 白色 BGR(255,255,255); 黑色 BGR(0,0,0); 中等灰色 BGR(128,128,128 ); 彩色图像灰度化我感觉这篇文章图像处理：图像灰度化 做了很多介绍, 其实 颜色对于图像处理来说意义不大, 更多的是给人的一种颜色的感觉, 所以很多时候进行图像处理的过程都是进行灰度化处理了, 由我们的成像系统可以得知, 每一个像素的位置存在三种颜色的值, 灰度化的过程就是将三个值变成一个值, 就是我们所谓的灰度化, 将原本三通道的像素值转换为1通道的像素值,一般来说, 我们就考虑颜色灰度的平均得到灰度值即可,$$Gray(i,j) = \\frac{R(i,j) + G(i,j) + B(i,j)}{3}$$这就是平均值的方式,但是呢, 人眼对于绿色比较敏感 进而提出了给出不同权重的灰度化过程, 属于一个心理学公式$$Gray(i,j) = 0.299 R(i,j) + 0.587 G(i,j) + 0.114 * B(i,j)$$ 这个权重值是一个目前使用最多的比例, 但是也有其他人提出的权重参数, 详细可以见[Grayscale wiki 页面](https://en.wikipedia.org/wiki/Grayscale 进而我比较喜欢是这篇文章从RGB色转为灰度色算法, 给出了一个比较有效的 整数移位算法, 减少整数计算带来的精度损失以及浮点运算的低效率.参照他给出的数据, 得到一个有趣的公式, 可以去详细看下,$$Gray(i,j) = (38R(i,j) + 75(G(i,j) + 15*B(i,j)) &gt;&gt; 7$$ 编码实现编辑代码我们这里为了对比 不同的灰度化做了一个展示, 其实很简单, 这里用到的 图像遍历的方式, 对于每一个像素点进行处理 三种灰度化的方式, 存入到三副图像中, 然后一起显示出来用于对比, 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include \"mainwindow.h\"#include &lt;QApplication&gt;// 引入 opencv 函数头文件#include &lt;opencv2/opencv.hpp&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); MainWindow w; w.show(); // 设置 要显示的图像路径 std::string test_pic = \"./TestImages/lena.png\"; // 读取图像 cv::Mat lena_rgb = cv::imread(test_pic); // 声明三个灰色的图像 cv::Mat lena_gray_avg = cv::Mat::zeros(lena_rgb.size(), CV_8UC1); cv::Mat lena_gray_weighted = cv::Mat::zeros(lena_rgb.size(), CV_8UC1); cv::Mat lena_gray_shift = cv::Mat::zeros(lena_rgb.size(), CV_8UC1); // 遍历每一个像素进行灰度化 for (int i = 0; i &lt; lena_rgb.rows; i++) &#123; for (int j = 0; j &lt; lena_rgb.cols; j++) &#123; cv::Vec3b tmp_px = lena_rgb.at&lt;cv::Vec3b&gt;(i, j); lena_gray_avg.at&lt;uchar&gt;(i, j) = (uchar)((tmp_px[0] + tmp_px[1] + tmp_px[2]) / 3); lena_gray_weighted.at&lt;uchar&gt;(i, j) = (uchar)((0.299f * tmp_px[0] + 0.587f * tmp_px[1] + 0.114f * tmp_px[2])); lena_gray_shift.at&lt;uchar&gt;(i, j) = (uchar)((38 * tmp_px[0] + 75 * tmp_px[1] + 15 * tmp_px[2]) &gt;&gt; 7); &#125; &#125; // 显示图像 cv::imshow(\"lena_rgb\", lena_rgb); cv::imshow(\"lena_gray_avg\", lena_gray_avg); cv::imshow(\"lena_gray_weighted\", lena_gray_weighted); cv::imshow(\"lena_gray_shift\", lena_gray_shift); cv::waitKey(0); return a.exec();&#125; 运行效果最后运行出来的结果就是下图了, 很简单, 但是 很有效, 对应最开始的图, 我们选取lena 眼镜部分, 查看 lena_gray_shift 的眼镜细节, 得到图 其他我们稍微介绍了成像的系统, 然后介绍了opencv 的 成像方法, 以及具体的颜色表示, 在后面我们就要进行 稍微深入的像素操作与图形操作了. 参考","categories":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/categories/opencv/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/tags/opencv/"},{"name":"c++","slug":"c","permalink":"https://schen1024.github.io/tags/c/"},{"name":"qt","slug":"qt","permalink":"https://schen1024.github.io/tags/qt/"},{"name":"mat","slug":"mat","permalink":"https://schen1024.github.io/tags/mat/"}]},{"title":"opencv-3-图片存储与相对路径","slug":"opencv-3-showimageandwrite","date":"2020-04-21T08:51:21.000Z","updated":"2023-01-01T13:25:24.775Z","comments":true,"path":"2020/04-21/opencv-3-showimageandwrite.html","link":"","permalink":"https://schen1024.github.io/2020/04-21/opencv-3-showimageandwrite.html","excerpt":"在上一篇文章opencv 显示第一副图像 中, 我们完成了一副图像的显示, 包括使用VS,和QT 进行显示.. 本文将展示如何进行图像的显示与存储过程, 主要以 QT为例, 附带介绍一下 VS的实现方法 图像显示与存储程序我们以上一章节的显示图像为例 一定要注意 路径的位置, windows 下面的 \\ 斜杠 为 C++ 里面的转义符号, 换成 / 或者 \\ 来表示 12345678910111213141516171819202122232425262728#include \"mainwindow.h\"#include &lt;QApplication&gt;// 引入 opencv 函数头文件#include &lt;opencv2/opencv.hpp&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); MainWindow w; w.show(); // 设置 要显示的图像路径 std::string test_pic = \"D:\\\\Project\\\\Vision\\\\ImageLab\\\\TestImages\\\\lena.png\"; // 读取图像 cv::Mat lena_img = cv::imread(test_pic); // 显示图像 cv::imshow(\"图像显示窗口\", lena_img); // cv::waitKey(100); // 存储图像 std::string write_pic = \"D:\\\\Project\\\\Vision\\\\ImageLab\\\\TestImages\\\\lena_write.png\"; cv::imwrite(write_pic,lena_img); return a.exec();&#125; 我们使用 imread 函数 去读取文件, 使用 imshow 显示图像, 使用 imwrite 将图像存储到文件中. 我们运行能够显示 lena 图像, 然后点击右上角 关闭窗口之后, 可以在文件夹看到生成的图像, write_lena.png 图像, 和原始图像一模一样, 程序运行目录在我们的程序运行过程中, 为了避免一些不必要的解释, 我们都使用的是 绝对路径,但是如果我们需要做迁移, 到别的电脑上, 大概率是运行不成功的, 会显示文件无法找到等问题, 所以 程序中尽量使用相对路径具体的路径的差别可以参考相对路径和绝对路径 相对路径与绝对路径绝对路径就是 从硬盘开始的, 一直到某个文件夹的路径, 类似于 D:\\Project\\Vision\\ImageLab 的形式,相对路径是从当前文件开始的, 使用 ./ 表示当前目录, ../ 表示上一层目录,对于我们 QT 工程来说, 原始运行目录为: D:\\Project\\Vision\\ImageLab ./ 表示 D:\\Project\\Vision\\ImageLab ../ 表示 D:\\Project\\Vision ./TestImages 表示 D:\\Project\\Vision\\ImageLab\\TestImages ../ImageLab 又表示回来了当前目录 D:\\Project\\Vision\\ImageLab ./Depend/opencv/lib 可以表示到 opencv 的lib 库文件夹 D:\\Project\\Vision\\ImageLab\\Depend\\opencv\\lib 多用就好, 很容易就上手学会了. QT 运行路径QT 默认的构建目录 可以在 工具--选项--构建与运行-- 默认构建目录 里面设置, 默认里面是../%{JS: Util.asciify(&quot;build-%{CurrentProject:Name}-%{CurrentKit:FileSystemName}-%{CurrentBuild:Name}&quot;)}这里是 QT 进行的一些宏的解析, %{CurrentProject:Name} 表示当前工程名 ImageLab , %{CurrentKit:FileSystemName} 是运行环境 Desktop_Qt_5_14_2_MSVC2017_64bit, %{CurrentBuild:Name} 是 Debug, 最后 解析成 ../build-ImageLab-Desktop_Qt_5_14_2_MSVC2017_64bit-Debug, 会在当前文件夹的上一层目录里面建立 build-ImageLab-Desktop_Qt_5_14_2_MSVC2017_64bit-Debug 文件夹, 把所有的编译文件和生成文件放进去, 我不是很喜欢这种方式, 不过建立好工程之后, 可以在 左侧的 项目里面, 选择你的编译套件, 然后设置 构建目录 我们将其设置成为 D:\\Project\\Vision\\ImageLab\\Debug , 这样, 我们在程序执行过程中可以将读写的文件路径改为 ../TestImages/lena.png, 和 ../TestImages/lenalena_write.png 文件, 同样的程序也能够运行成功. 再次看到 lena VS 运行路径VS 的构建目录可以通过设置中间目录和输入目录设定, VS 的工程设置都是在解决方案上右键, 设置 调试-- 工作目录 VS 使用 $(ProjectDir) 的形式去解析宏定义, 这个目录表示 VS 工程(不是解决方案) 的路径, 在本工程中表示 就是 D:\\Project\\Vision\\ImageLab 目录, 那我们的 读写文件的路径都要更改, ./TestImages/lena.png, 和 ./TestImages/lenalena_write.png 其他在VS 和 QT 混合编程的时候 一定要注意相对路径的设置 不要坑到了自己..","text":"在上一篇文章opencv 显示第一副图像 中, 我们完成了一副图像的显示, 包括使用VS,和QT 进行显示.. 本文将展示如何进行图像的显示与存储过程, 主要以 QT为例, 附带介绍一下 VS的实现方法 图像显示与存储程序我们以上一章节的显示图像为例 一定要注意 路径的位置, windows 下面的 \\ 斜杠 为 C++ 里面的转义符号, 换成 / 或者 \\ 来表示 12345678910111213141516171819202122232425262728#include \"mainwindow.h\"#include &lt;QApplication&gt;// 引入 opencv 函数头文件#include &lt;opencv2/opencv.hpp&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); MainWindow w; w.show(); // 设置 要显示的图像路径 std::string test_pic = \"D:\\\\Project\\\\Vision\\\\ImageLab\\\\TestImages\\\\lena.png\"; // 读取图像 cv::Mat lena_img = cv::imread(test_pic); // 显示图像 cv::imshow(\"图像显示窗口\", lena_img); // cv::waitKey(100); // 存储图像 std::string write_pic = \"D:\\\\Project\\\\Vision\\\\ImageLab\\\\TestImages\\\\lena_write.png\"; cv::imwrite(write_pic,lena_img); return a.exec();&#125; 我们使用 imread 函数 去读取文件, 使用 imshow 显示图像, 使用 imwrite 将图像存储到文件中. 我们运行能够显示 lena 图像, 然后点击右上角 关闭窗口之后, 可以在文件夹看到生成的图像, write_lena.png 图像, 和原始图像一模一样, 程序运行目录在我们的程序运行过程中, 为了避免一些不必要的解释, 我们都使用的是 绝对路径,但是如果我们需要做迁移, 到别的电脑上, 大概率是运行不成功的, 会显示文件无法找到等问题, 所以 程序中尽量使用相对路径具体的路径的差别可以参考相对路径和绝对路径 相对路径与绝对路径绝对路径就是 从硬盘开始的, 一直到某个文件夹的路径, 类似于 D:\\Project\\Vision\\ImageLab 的形式,相对路径是从当前文件开始的, 使用 ./ 表示当前目录, ../ 表示上一层目录,对于我们 QT 工程来说, 原始运行目录为: D:\\Project\\Vision\\ImageLab ./ 表示 D:\\Project\\Vision\\ImageLab ../ 表示 D:\\Project\\Vision ./TestImages 表示 D:\\Project\\Vision\\ImageLab\\TestImages ../ImageLab 又表示回来了当前目录 D:\\Project\\Vision\\ImageLab ./Depend/opencv/lib 可以表示到 opencv 的lib 库文件夹 D:\\Project\\Vision\\ImageLab\\Depend\\opencv\\lib 多用就好, 很容易就上手学会了. QT 运行路径QT 默认的构建目录 可以在 工具--选项--构建与运行-- 默认构建目录 里面设置, 默认里面是../%{JS: Util.asciify(&quot;build-%{CurrentProject:Name}-%{CurrentKit:FileSystemName}-%{CurrentBuild:Name}&quot;)}这里是 QT 进行的一些宏的解析, %{CurrentProject:Name} 表示当前工程名 ImageLab , %{CurrentKit:FileSystemName} 是运行环境 Desktop_Qt_5_14_2_MSVC2017_64bit, %{CurrentBuild:Name} 是 Debug, 最后 解析成 ../build-ImageLab-Desktop_Qt_5_14_2_MSVC2017_64bit-Debug, 会在当前文件夹的上一层目录里面建立 build-ImageLab-Desktop_Qt_5_14_2_MSVC2017_64bit-Debug 文件夹, 把所有的编译文件和生成文件放进去, 我不是很喜欢这种方式, 不过建立好工程之后, 可以在 左侧的 项目里面, 选择你的编译套件, 然后设置 构建目录 我们将其设置成为 D:\\Project\\Vision\\ImageLab\\Debug , 这样, 我们在程序执行过程中可以将读写的文件路径改为 ../TestImages/lena.png, 和 ../TestImages/lenalena_write.png 文件, 同样的程序也能够运行成功. 再次看到 lena VS 运行路径VS 的构建目录可以通过设置中间目录和输入目录设定, VS 的工程设置都是在解决方案上右键, 设置 调试-- 工作目录 VS 使用 $(ProjectDir) 的形式去解析宏定义, 这个目录表示 VS 工程(不是解决方案) 的路径, 在本工程中表示 就是 D:\\Project\\Vision\\ImageLab 目录, 那我们的 读写文件的路径都要更改, ./TestImages/lena.png, 和 ./TestImages/lenalena_write.png 其他在VS 和 QT 混合编程的时候 一定要注意相对路径的设置 不要坑到了自己..","categories":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/categories/opencv/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://schen1024.github.io/tags/C/"},{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/tags/opencv/"},{"name":"qt","slug":"qt","permalink":"https://schen1024.github.io/tags/qt/"}]},{"title":"swordoffer-start","slug":"swordoffer-start","date":"2020-04-20T19:29:23.000Z","updated":"2023-01-01T13:25:24.779Z","comments":true,"path":"2020/04-20/swordoffer-start.html","link":"","permalink":"https://schen1024.github.io/2020/04-20/swordoffer-start.html","excerpt":"开始再开一个系列, 这两个系列是一直都想写的 , 但是总是只写一部分, 我最喜欢的两个部分就是 算法刷题, 还有就是图像处理, 早上开始了 opencv 的系列, 那现在就开始剑指 offer 这本书的系列吧, 主要参考 牛客 剑指 offer LC 剑指 offer github 剑指 offer 结束争取完成所有的题目, 然后记录下来, 并写出详细的题解过程. 希望自己能坚持下去.","text":"开始再开一个系列, 这两个系列是一直都想写的 , 但是总是只写一部分, 我最喜欢的两个部分就是 算法刷题, 还有就是图像处理, 早上开始了 opencv 的系列, 那现在就开始剑指 offer 这本书的系列吧, 主要参考 牛客 剑指 offer LC 剑指 offer github 剑指 offer 结束争取完成所有的题目, 然后记录下来, 并写出详细的题解过程. 希望自己能坚持下去.","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://schen1024.github.io/tags/c/"},{"name":"offer","slug":"offer","permalink":"https://schen1024.github.io/tags/offer/"},{"name":"swordoffer","slug":"swordoffer","permalink":"https://schen1024.github.io/tags/swordoffer/"}]},{"title":"opencv-2-VS2017与QT显示图像","slug":"opencv-2-vsqt","date":"2020-04-20T12:05:49.000Z","updated":"2023-01-01T13:25:24.775Z","comments":true,"path":"2020/04-20/opencv-2-vsqt.html","link":"","permalink":"https://schen1024.github.io/2020/04-20/opencv-2-vsqt.html","excerpt":"目的 使用 VS 构建第一个 opencv 程序 使用 QT 构建 第一个 opencv 程序 VS 导入 QT 程序 开始我们需要设置 dll 文件的运行路径, 避免运行的时候找不到相应的库而报错,接下来, 我们需要使用 设置运行环境我们整理得到了, 我们需要将 我们的dll 文件夹 加入到系统 的Path 路径过程如下: 此电脑--右键--属性--高级系统设置--环境变量--系统变量--Path--编辑--新建 然后填入我们 dll 所在的文件夹即可 VS2017使用 opencv 程序opencv 的官方给出了一个 windows Visual Studio 使用 opencv 的方法^[《OpenCV: How to build applications with OpenCV inside the 〈Microsoft Visual Studio〉》. 见于 2020年4月20日. https://docs.opencv.org/4.3.0/dd/d6e/tutorial_windows_visual_studio_opencv.html.],其实都差不多, 在 博客 Win10, VS2017环境下OpenCV3.4.2的配置 也是使用 包含目录, 库目录, 以及附加依赖项进行的展示过程, 在后面执行之前, 的opencv 的目录结构是存在 D:\\Project\\Vision\\ImageLab\\Depend\\opencv目录下面的, 我们在前面介绍了每个文件夹里面的内容1234opencv430true- dlltrue- libtrue- include 新建工程新建空的VS 项目, imagelab 在解决方案上右键, 点击属性进行配置即可 包含目录与库目录 添加你的 include 文件夹和 lib 文件夹即可 这里使用的是我的 绝对路径, 如果使用, 必须更改为你自己的路径, 不然 肯定出错. 库文件 此处选择的是相应的 opencv_world430d.lib, opencv 在3.0 的版本之后, 只需要加入一个 world 的lib 文件即可, 不需要添加一系列的库文件, 也可以单独编译得到 值添加单个的库, 这里建议去看 Win10, VS2017环境下OpenCV3.4.2的配置 这篇博文, 写的十分详细, 编写程序12345678910111213141516171819#include &lt;iostream&gt;// 引入 opencv 函数头文件#include &lt;opencv2/opencv.hpp&gt;int main()&#123; // 设置 要显示的图像路径 std::string test_pic = \"D:\\\\Project\\\\Vision\\\\ImageLab\\\\TestImages\\\\lena.png\"; // 读取图像 cv::Mat lena_img = cv::imread(test_pic); // 显示图像 cv::imshow(\"图像显示窗口\", lena_img); cv::waitKey(0); return 0;&#125; 调试运行如果配置没有问题, 注意上面配置 的都是 debug x64, 在编辑页面也要是 一样的吗不能出错, 不然编辑的不对, 点击 生成--生成解决方案 如果程序复制过去的没有问题, 就不会有问题了, 此处我默认看这里的人有了一定的 C++ 程序基础, 不然解释太多的话就很麻烦, 点击绿色的 本地 windows 调试器 直接运行 就能看到这个窗口了 到这里, 我们的 VS 使用 opencv 就完成了 , 很容易就搞定了.. QT 使用 opencv 程序QT 使用 opencv 更加简单, QT的主要工程文件是 *.pro 文件, 我们可以在文件中加入一些配置信息 便于我们执行 可以参考Windows下QT Creator配置OpenCV(VC版) 新建工程新建工程 imagelab , 在工程上右键, 添加库 添加外部库, 点击选择到 lib 文件, 会自动选择 include文件夹, 检查一下是否包含正确, 最终会在 *.pro文件中 添加12345win32:CONFIG(release, debug|release): LIBS += -L$$PWD/Depend/opencv/lib/ -lopencv_world430else:win32:CONFIG(debug, debug|release): LIBS += -L$$PWD/Depend/opencv/lib/ -lopencv_world430dINCLUDEPATH += $$PWD/Depend/opencv/includeDEPENDPATH += $$PWD/Depend/opencv/include我们 imagelab.pro 工程在 D:\\Project\\Vision\\ImageLab 文件夹下, 对应的库 D:\\Project\\Vision\\ImageLab\\Depend\\opencv\\lib 文件夹下面, 所以, 这里 $$PWD 是 QT pro 文件的语法, 能够获取到 pro文件所在的目录, 也就是工程的当前目录, QT 工程 需要首先执行 qmake 生成 编译文件, 编写代码QT 就是 标准的C++, 只不过 QT 是一套 C++库, 我们能够很容易的使用 界面库, 生成带有界面的程序.. 我们先不考虑界面的实现, 我们在主程序执行 return 把我们的图像读取与显示代码添加进去, 并在开头引入头文件, 就能得到下面的代码文件. 能够实现程序的读取 主体部分和 vs 工程中的程序一样,12345678910111213141516171819202122232425#include \"mainwindow.h\"#include &lt;QApplication&gt;// 引入 opencv 函数头文件#include &lt;opencv2/opencv.hpp&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); MainWindow w; w.show();true // 设置 要显示的图像路径 std::string test_pic = \"D:\\\\Project\\\\Vision\\\\ImageLab\\\\TestImages\\\\lena.png\"; // 读取图像 cv::Mat lena_img = cv::imread(test_pic); // 显示图像 cv::imshow(\"图像显示窗口\", lena_img); cv::waitKey(0);true return a.exec();&#125; 调试运行点击构建, 最后点击运行, 如果一切顺利, 我们就能看到这幅图像了, 这里图像显示还是 opencv 的窗口, 我们后续会将其显示在opencv 的窗口上, VS 导入 QT 工程VS 有一个很好用的插件, 叫做 Qt Visual Studio Tools, 可以下载安装,或者在 VS 工具--拓展与更新--联机--搜索 进行安装, 安装之后需要重启 VS VS 开发 opencv 的程序 必备插件 Image Watch, 可以在调试过程中查看 内存中的 opencv Mat 数据. 强烈推荐.. 点击 设置 QT option 然后添加, 直到我们点击到 QT安装目录下面 的 具体编译器文件夹,F:\\Fxxk\\QT\\Qt5.14.2\\5.14.2\\msvc2017_64 我们使用 QT 插件导入 *.pro 文件, 会生成相应的工程, 跟我们直接 VS与 opencv 的工程设置不同, QT 自动生成的文件没有更改 包含目录和库文件 而是选择了在 附加包含目录里面增加了, 不仅增加了 opencv 的目录, 而且包含了 QT 的很多库目录, 对应的 , 我们仍然使用 附加依赖项 设置 输入 lib 文件 这样, 我们就能使用 VS 编译得到 QT 的程序, 编译成功, 运行即可再次看到 lena 图像 其他我们后续的开发主要是 QT 进行开发, 用于生成自定义的界面, 便于我们开发过程中的图像展示工作.","text":"目的 使用 VS 构建第一个 opencv 程序 使用 QT 构建 第一个 opencv 程序 VS 导入 QT 程序 开始我们需要设置 dll 文件的运行路径, 避免运行的时候找不到相应的库而报错,接下来, 我们需要使用 设置运行环境我们整理得到了, 我们需要将 我们的dll 文件夹 加入到系统 的Path 路径过程如下: 此电脑--右键--属性--高级系统设置--环境变量--系统变量--Path--编辑--新建 然后填入我们 dll 所在的文件夹即可 VS2017使用 opencv 程序opencv 的官方给出了一个 windows Visual Studio 使用 opencv 的方法^[《OpenCV: How to build applications with OpenCV inside the 〈Microsoft Visual Studio〉》. 见于 2020年4月20日. https://docs.opencv.org/4.3.0/dd/d6e/tutorial_windows_visual_studio_opencv.html.],其实都差不多, 在 博客 Win10, VS2017环境下OpenCV3.4.2的配置 也是使用 包含目录, 库目录, 以及附加依赖项进行的展示过程, 在后面执行之前, 的opencv 的目录结构是存在 D:\\Project\\Vision\\ImageLab\\Depend\\opencv目录下面的, 我们在前面介绍了每个文件夹里面的内容1234opencv430true- dlltrue- libtrue- include 新建工程新建空的VS 项目, imagelab 在解决方案上右键, 点击属性进行配置即可 包含目录与库目录 添加你的 include 文件夹和 lib 文件夹即可 这里使用的是我的 绝对路径, 如果使用, 必须更改为你自己的路径, 不然 肯定出错. 库文件 此处选择的是相应的 opencv_world430d.lib, opencv 在3.0 的版本之后, 只需要加入一个 world 的lib 文件即可, 不需要添加一系列的库文件, 也可以单独编译得到 值添加单个的库, 这里建议去看 Win10, VS2017环境下OpenCV3.4.2的配置 这篇博文, 写的十分详细, 编写程序12345678910111213141516171819#include &lt;iostream&gt;// 引入 opencv 函数头文件#include &lt;opencv2/opencv.hpp&gt;int main()&#123; // 设置 要显示的图像路径 std::string test_pic = \"D:\\\\Project\\\\Vision\\\\ImageLab\\\\TestImages\\\\lena.png\"; // 读取图像 cv::Mat lena_img = cv::imread(test_pic); // 显示图像 cv::imshow(\"图像显示窗口\", lena_img); cv::waitKey(0); return 0;&#125; 调试运行如果配置没有问题, 注意上面配置 的都是 debug x64, 在编辑页面也要是 一样的吗不能出错, 不然编辑的不对, 点击 生成--生成解决方案 如果程序复制过去的没有问题, 就不会有问题了, 此处我默认看这里的人有了一定的 C++ 程序基础, 不然解释太多的话就很麻烦, 点击绿色的 本地 windows 调试器 直接运行 就能看到这个窗口了 到这里, 我们的 VS 使用 opencv 就完成了 , 很容易就搞定了.. QT 使用 opencv 程序QT 使用 opencv 更加简单, QT的主要工程文件是 *.pro 文件, 我们可以在文件中加入一些配置信息 便于我们执行 可以参考Windows下QT Creator配置OpenCV(VC版) 新建工程新建工程 imagelab , 在工程上右键, 添加库 添加外部库, 点击选择到 lib 文件, 会自动选择 include文件夹, 检查一下是否包含正确, 最终会在 *.pro文件中 添加12345win32:CONFIG(release, debug|release): LIBS += -L$$PWD/Depend/opencv/lib/ -lopencv_world430else:win32:CONFIG(debug, debug|release): LIBS += -L$$PWD/Depend/opencv/lib/ -lopencv_world430dINCLUDEPATH += $$PWD/Depend/opencv/includeDEPENDPATH += $$PWD/Depend/opencv/include我们 imagelab.pro 工程在 D:\\Project\\Vision\\ImageLab 文件夹下, 对应的库 D:\\Project\\Vision\\ImageLab\\Depend\\opencv\\lib 文件夹下面, 所以, 这里 $$PWD 是 QT pro 文件的语法, 能够获取到 pro文件所在的目录, 也就是工程的当前目录, QT 工程 需要首先执行 qmake 生成 编译文件, 编写代码QT 就是 标准的C++, 只不过 QT 是一套 C++库, 我们能够很容易的使用 界面库, 生成带有界面的程序.. 我们先不考虑界面的实现, 我们在主程序执行 return 把我们的图像读取与显示代码添加进去, 并在开头引入头文件, 就能得到下面的代码文件. 能够实现程序的读取 主体部分和 vs 工程中的程序一样,12345678910111213141516171819202122232425#include \"mainwindow.h\"#include &lt;QApplication&gt;// 引入 opencv 函数头文件#include &lt;opencv2/opencv.hpp&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); MainWindow w; w.show();true // 设置 要显示的图像路径 std::string test_pic = \"D:\\\\Project\\\\Vision\\\\ImageLab\\\\TestImages\\\\lena.png\"; // 读取图像 cv::Mat lena_img = cv::imread(test_pic); // 显示图像 cv::imshow(\"图像显示窗口\", lena_img); cv::waitKey(0);true return a.exec();&#125; 调试运行点击构建, 最后点击运行, 如果一切顺利, 我们就能看到这幅图像了, 这里图像显示还是 opencv 的窗口, 我们后续会将其显示在opencv 的窗口上, VS 导入 QT 工程VS 有一个很好用的插件, 叫做 Qt Visual Studio Tools, 可以下载安装,或者在 VS 工具--拓展与更新--联机--搜索 进行安装, 安装之后需要重启 VS VS 开发 opencv 的程序 必备插件 Image Watch, 可以在调试过程中查看 内存中的 opencv Mat 数据. 强烈推荐.. 点击 设置 QT option 然后添加, 直到我们点击到 QT安装目录下面 的 具体编译器文件夹,F:\\Fxxk\\QT\\Qt5.14.2\\5.14.2\\msvc2017_64 我们使用 QT 插件导入 *.pro 文件, 会生成相应的工程, 跟我们直接 VS与 opencv 的工程设置不同, QT 自动生成的文件没有更改 包含目录和库文件 而是选择了在 附加包含目录里面增加了, 不仅增加了 opencv 的目录, 而且包含了 QT 的很多库目录, 对应的 , 我们仍然使用 附加依赖项 设置 输入 lib 文件 这样, 我们就能使用 VS 编译得到 QT 的程序, 编译成功, 运行即可再次看到 lena 图像 其他我们后续的开发主要是 QT 进行开发, 用于生成自定义的界面, 便于我们开发过程中的图像展示工作.","categories":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/categories/opencv/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://schen1024.github.io/tags/C/"},{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/tags/opencv/"},{"name":"qt","slug":"qt","permalink":"https://schen1024.github.io/tags/qt/"},{"name":"VS","slug":"VS","permalink":"https://schen1024.github.io/tags/VS/"}]},{"title":"opencv-1-QT_OPENCV 安装","slug":"opencv-1-QT_OPENCV","date":"2020-04-20T09:03:27.000Z","updated":"2023-01-01T13:25:24.773Z","comments":true,"path":"2020/04-20/opencv-1-QT_OPENCV.html","link":"","permalink":"https://schen1024.github.io/2020/04-20/opencv-1-QT_OPENCV.html","excerpt":"既然我们是从头开始的, 那我们就从 opencv 的安装开始吧, 主要环境为: win10 1909 - 18363.720 版本 VS2017 15.9.22 QT 5.14.2 opencv 4.3.0安装由于 QT 默认的 C++ 编译器是 minGW, 而 opencv 编译好的 dll 文件和 lib 文件都是 只有 vc14版本与vc15版本^[《VS(Visual Studio)与VC(Visual C++)版本对应关系_C/C++_aoanng的博客-CSDN博客》. 见于 2020年4月20日. https://blog.csdn.net/colourful_sky/article/details/79495536.]. PS: 如果你使用 minGW 编译 opencv 的程序会 会提示很多错误, 主要是编译得到的库 不支持的原因, 这里要做对照, VS的版本可以 是 VS2015或者 VS2017 对应 opencv 的 vc14和vc15目录, VS2019 暂时无法对应QT的版本, 所以一定要注意这里 个人喜欢的安装顺序是, VS2017 QT opencv 1. VS2017 安装自从 VS 2017版本之后, 都是线上安装了, 对于以前的版本如VS2015,需要先下载一个 7G的 iso 文件, 再虚拟光驱的方式安装了, 省事不少.微软官方-VS2017下载 在线安装 安装文件只有几兆, 点击运行之后能够在线下载, 很快很快. 推荐这个方法来, 安装的时候 建议勾选 全部下载后安装. 我已经安装了 VS2017, 所以可以直接启动, 点击可用选择 VS2017 专业版本(VS2017 Professional) 或者 社区(Community) 版本, 后者是免费的, 前者自己选择试用或者 自己搜索方法,具体的版本区别可以看《VS2017各版本区别开发工具大白的求知路-CSDN博客》 VS 系列都比较大, 会安装很多依赖库, 如果C盘比较小的话, 建议安装在其他硬盘, 能够节省一点空间 其实在安装 VS之后, 我们就能进行opencv 的代码编写了, 具体的可以参考Win10, VS2017环境下OpenCV3.4.2的配置, 其实大部分的教程都是这么做的, 但是我们是做 的更深入, 所以这里如果只是想使用 opencv 的可以参考链接进行^[《Win10, VS2017环境下OpenCV3.4.2的配置 - Jisongxie - 博客园》. 见于 2020年4月20日. https://www.cnblogs.com/jisongxie/p/9316283.html.], 我们要做的是一个图像处理的平台, 所以要做的比较深入, 为了能够在QT 上调试程序, 可以参考这篇文章QT使用CDB调试程序, 介绍了 windows CDB 下载链接 先安装, 后面会介绍. 2. QT 安装使用 QT官方 release下载相应版本的QT, 我们这里使用的是 QT5.14.2 一路 next , 如果需要必须登录的话, 就去注册一个, 以前好像能跳过的, 现在不能跳过了 如果出现 必须启用一个资源库之类的提示, 就直接配置就好 QT的组件不需要全部选择,选择你需要的部分就行了, 其实 MinGW 可以全部取消的 ,暂时先留着, , UWP是 win10 商店的, 其实没人用 , 自己考虑就好, 源代码不需要, QT的一堆组件其实只有 不到20M, 都很小, 就都装上了, 如果感觉, 红框标出来的最好都勾选, 黄色标记的建议勾选, 其他的随意吧, 个人习惯, 安装可以选择文件夹, 建议选择大点的空间, 我这样选择也是占有 3.6G 的空间, 全选可能有 10G,其实安装完成之后可以去安装文件夹找到 MaintenanceTool.exe 的程序, 能够对QT 程序进行卸载, 自己可以查阅相关博客看到, 不做介绍. 完成安装之后, 我们打开 QTCreator ^[QT自带的代码 UI IDE] 依次点击菜单栏上的 工具--选项--Kits--套件, 由于我们先安装VS, QT安装之后会自动检测到相应的版本, 如果失败, 前面会有红色感叹号或者黄色警告, 我们选择 Desktop Qt5.14.2 MSVC2017 64bit , 会列出来具体的参数信息, 我们尽量将 Compiler (编译器这里) 都选择 amd64 的 编译器, 在上面我们让 安装了 CDB, 这里 就是第二个箭头指出来的 cdb.exe, 不然此处无法选择, 就会是 黄色的感叹号了, 也不能使用 QT 调试 程序了, PS: 只是不能在 MSVC2017 下调试程序 , cdb 配套 MSVC 编译器, GDB 配套 MinGW 里面的 gcc 和 g++ 编译器 也能进行程序的调试, 只是如果配置这套工具链, 我们需要参考OpenCV+Qt+Win10开发环境配置 这篇文章里面 的步骤去编译 mingw 的opencv ,我的设备需要编译将近一天时间才能完成, 太浪费时间了. 3. OpenCV 安装opencv 可以在官方 release页面直接下载, 我们这里选择下载opencv4.3.0 windows 版本, 下载包有 202M opencv 真的是越来越大了 opencv 的安装包其实就是一个自解压文件, 点击运行选择目的路径即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119opencv430+---build| +---bin| +---etc| | +---haarcascades| | +---lbpcascades| | \\---licenses| +---include| | \\---opencv2| | +---calib3d| | +---core| | +---dnn| | +---features2d| | +---flann| | +---gapi| | +---highgui| | +---imgcodecs| | +---imgproc| | +---ml| | +---objdetect| | +---photo| | +---stitching| | +---video| | \\---videoio| +---java| | +---x64| | \\---x86| +---python| | \\---cv2| \\---x64| +---vc14| | +---bin| | \\---lib| \\---vc15| +---bin| \\---lib\\---sources +---3rdparty | +---carotene | +---cpufeatures | +---ffmpeg | +---include | +---ippicv | +---ittnotify | +---libjasper | +---libjpeg | +---libjpeg-turbo | +---libpng | +---libtengine | +---libtiff | +---libwebp | +---openexr | +---openvx | +---protobuf | +---quirc | +---tbb | \\---zlib | \\---patches +---apps | +---annotation | +---createsamples | +---interactive-calibration | +---traincascade | +---version | \\---visualisation +---cmake | +---android | +---checks | +---FindCUDA | +---platforms | \\---templates +---data | +---haarcascades | +---haarcascades_cuda | +---hogcascades | +---lbpcascades | \\---vec_files +---doc | +---images | +---js_tutorials | +---pattern_tools | +---py_tutorials | +---tools | \\---tutorials +---include | \\---opencv2 +---modules | +---calib3d | +---core | +---dnn | +---features2d | +---flann | +---gapi | +---highgui | +---imgcodecs | +---imgproc | +---java | +---js | +---ml | +---objdetect | +---photo | +---python | +---stitching | +---ts | +---video | +---videoio | \\---world +---platforms | +---android | +---ios | +---js | +---linux | +---maven | +---osx | +---scripts | +---wince | +---winpack_dldt | \\---winrt \\---samples 我们放置在了 F:\\Vision\\opencv430文件夹下面, 得到了上面的 文件列表, 主要用到的库文件都是在 build 文件夹内, source 文件夹下面是 源代码, 实际上 我们在程序中需要用的 只有 这里需要的程序, 动态链接库 dll 文件, 静态库 lib 文件, 以及 包含目录 include 文件夹,12345678910111213141516171819202122232425262728opencv430+---dll| opencv_videoio_ffmpeg430_64.dll| opencv_world430.dll| opencv_world430.pdb| opencv_world430d.dll| opencv_world430d.pdb| +---include| \\---opencv2| +---calib3d| +---core| +---dnn| +---features2d| +---flann| +---gapi| +---highgui| +---imgcodecs| +---imgproc| +---ml| +---objdetect| +---photo| +---stitching| +---video| \\---videoio\\---lib opencv_world430.lib opencv_world430d.lib 如果不是需要调试信息的话, dll 文件夹下面的 pdb 文件可以全部删除,在忽略 dll 文件之后, 我将自己常用的 C++ 的依赖库 都放在了 github上SChen1024/CVDepend有需要的可以去查看下载, 后续到这里, 我们才算是完成了第一步的安装程序, 后面 开始上手进行使用 opencv 了","text":"既然我们是从头开始的, 那我们就从 opencv 的安装开始吧, 主要环境为: win10 1909 - 18363.720 版本 VS2017 15.9.22 QT 5.14.2 opencv 4.3.0安装由于 QT 默认的 C++ 编译器是 minGW, 而 opencv 编译好的 dll 文件和 lib 文件都是 只有 vc14版本与vc15版本^[《VS(Visual Studio)与VC(Visual C++)版本对应关系_C/C++_aoanng的博客-CSDN博客》. 见于 2020年4月20日. https://blog.csdn.net/colourful_sky/article/details/79495536.]. PS: 如果你使用 minGW 编译 opencv 的程序会 会提示很多错误, 主要是编译得到的库 不支持的原因, 这里要做对照, VS的版本可以 是 VS2015或者 VS2017 对应 opencv 的 vc14和vc15目录, VS2019 暂时无法对应QT的版本, 所以一定要注意这里 个人喜欢的安装顺序是, VS2017 QT opencv 1. VS2017 安装自从 VS 2017版本之后, 都是线上安装了, 对于以前的版本如VS2015,需要先下载一个 7G的 iso 文件, 再虚拟光驱的方式安装了, 省事不少.微软官方-VS2017下载 在线安装 安装文件只有几兆, 点击运行之后能够在线下载, 很快很快. 推荐这个方法来, 安装的时候 建议勾选 全部下载后安装. 我已经安装了 VS2017, 所以可以直接启动, 点击可用选择 VS2017 专业版本(VS2017 Professional) 或者 社区(Community) 版本, 后者是免费的, 前者自己选择试用或者 自己搜索方法,具体的版本区别可以看《VS2017各版本区别开发工具大白的求知路-CSDN博客》 VS 系列都比较大, 会安装很多依赖库, 如果C盘比较小的话, 建议安装在其他硬盘, 能够节省一点空间 其实在安装 VS之后, 我们就能进行opencv 的代码编写了, 具体的可以参考Win10, VS2017环境下OpenCV3.4.2的配置, 其实大部分的教程都是这么做的, 但是我们是做 的更深入, 所以这里如果只是想使用 opencv 的可以参考链接进行^[《Win10, VS2017环境下OpenCV3.4.2的配置 - Jisongxie - 博客园》. 见于 2020年4月20日. https://www.cnblogs.com/jisongxie/p/9316283.html.], 我们要做的是一个图像处理的平台, 所以要做的比较深入, 为了能够在QT 上调试程序, 可以参考这篇文章QT使用CDB调试程序, 介绍了 windows CDB 下载链接 先安装, 后面会介绍. 2. QT 安装使用 QT官方 release下载相应版本的QT, 我们这里使用的是 QT5.14.2 一路 next , 如果需要必须登录的话, 就去注册一个, 以前好像能跳过的, 现在不能跳过了 如果出现 必须启用一个资源库之类的提示, 就直接配置就好 QT的组件不需要全部选择,选择你需要的部分就行了, 其实 MinGW 可以全部取消的 ,暂时先留着, , UWP是 win10 商店的, 其实没人用 , 自己考虑就好, 源代码不需要, QT的一堆组件其实只有 不到20M, 都很小, 就都装上了, 如果感觉, 红框标出来的最好都勾选, 黄色标记的建议勾选, 其他的随意吧, 个人习惯, 安装可以选择文件夹, 建议选择大点的空间, 我这样选择也是占有 3.6G 的空间, 全选可能有 10G,其实安装完成之后可以去安装文件夹找到 MaintenanceTool.exe 的程序, 能够对QT 程序进行卸载, 自己可以查阅相关博客看到, 不做介绍. 完成安装之后, 我们打开 QTCreator ^[QT自带的代码 UI IDE] 依次点击菜单栏上的 工具--选项--Kits--套件, 由于我们先安装VS, QT安装之后会自动检测到相应的版本, 如果失败, 前面会有红色感叹号或者黄色警告, 我们选择 Desktop Qt5.14.2 MSVC2017 64bit , 会列出来具体的参数信息, 我们尽量将 Compiler (编译器这里) 都选择 amd64 的 编译器, 在上面我们让 安装了 CDB, 这里 就是第二个箭头指出来的 cdb.exe, 不然此处无法选择, 就会是 黄色的感叹号了, 也不能使用 QT 调试 程序了, PS: 只是不能在 MSVC2017 下调试程序 , cdb 配套 MSVC 编译器, GDB 配套 MinGW 里面的 gcc 和 g++ 编译器 也能进行程序的调试, 只是如果配置这套工具链, 我们需要参考OpenCV+Qt+Win10开发环境配置 这篇文章里面 的步骤去编译 mingw 的opencv ,我的设备需要编译将近一天时间才能完成, 太浪费时间了. 3. OpenCV 安装opencv 可以在官方 release页面直接下载, 我们这里选择下载opencv4.3.0 windows 版本, 下载包有 202M opencv 真的是越来越大了 opencv 的安装包其实就是一个自解压文件, 点击运行选择目的路径即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119opencv430+---build| +---bin| +---etc| | +---haarcascades| | +---lbpcascades| | \\---licenses| +---include| | \\---opencv2| | +---calib3d| | +---core| | +---dnn| | +---features2d| | +---flann| | +---gapi| | +---highgui| | +---imgcodecs| | +---imgproc| | +---ml| | +---objdetect| | +---photo| | +---stitching| | +---video| | \\---videoio| +---java| | +---x64| | \\---x86| +---python| | \\---cv2| \\---x64| +---vc14| | +---bin| | \\---lib| \\---vc15| +---bin| \\---lib\\---sources +---3rdparty | +---carotene | +---cpufeatures | +---ffmpeg | +---include | +---ippicv | +---ittnotify | +---libjasper | +---libjpeg | +---libjpeg-turbo | +---libpng | +---libtengine | +---libtiff | +---libwebp | +---openexr | +---openvx | +---protobuf | +---quirc | +---tbb | \\---zlib | \\---patches +---apps | +---annotation | +---createsamples | +---interactive-calibration | +---traincascade | +---version | \\---visualisation +---cmake | +---android | +---checks | +---FindCUDA | +---platforms | \\---templates +---data | +---haarcascades | +---haarcascades_cuda | +---hogcascades | +---lbpcascades | \\---vec_files +---doc | +---images | +---js_tutorials | +---pattern_tools | +---py_tutorials | +---tools | \\---tutorials +---include | \\---opencv2 +---modules | +---calib3d | +---core | +---dnn | +---features2d | +---flann | +---gapi | +---highgui | +---imgcodecs | +---imgproc | +---java | +---js | +---ml | +---objdetect | +---photo | +---python | +---stitching | +---ts | +---video | +---videoio | \\---world +---platforms | +---android | +---ios | +---js | +---linux | +---maven | +---osx | +---scripts | +---wince | +---winpack_dldt | \\---winrt \\---samples 我们放置在了 F:\\Vision\\opencv430文件夹下面, 得到了上面的 文件列表, 主要用到的库文件都是在 build 文件夹内, source 文件夹下面是 源代码, 实际上 我们在程序中需要用的 只有 这里需要的程序, 动态链接库 dll 文件, 静态库 lib 文件, 以及 包含目录 include 文件夹,12345678910111213141516171819202122232425262728opencv430+---dll| opencv_videoio_ffmpeg430_64.dll| opencv_world430.dll| opencv_world430.pdb| opencv_world430d.dll| opencv_world430d.pdb| +---include| \\---opencv2| +---calib3d| +---core| +---dnn| +---features2d| +---flann| +---gapi| +---highgui| +---imgcodecs| +---imgproc| +---ml| +---objdetect| +---photo| +---stitching| +---video| \\---videoio\\---lib opencv_world430.lib opencv_world430d.lib 如果不是需要调试信息的话, dll 文件夹下面的 pdb 文件可以全部删除,在忽略 dll 文件之后, 我将自己常用的 C++ 的依赖库 都放在了 github上SChen1024/CVDepend有需要的可以去查看下载, 后续到这里, 我们才算是完成了第一步的安装程序, 后面 开始上手进行使用 opencv 了","categories":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/categories/opencv/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/tags/opencv/"},{"name":"c++","slug":"c","permalink":"https://schen1024.github.io/tags/c/"},{"name":"qt","slug":"qt","permalink":"https://schen1024.github.io/tags/qt/"}]},{"title":"opencv-文章列表","slug":"opencv-bloglist","date":"2020-04-20T09:00:50.000Z","updated":"2023-01-01T13:25:24.778Z","comments":true,"path":"2020/04-20/opencv-bloglist.html","link":"","permalink":"https://schen1024.github.io/2020/04-20/opencv-bloglist.html","excerpt":"开始由于害怕自己忘记或者拖延, 这篇文章就作为 opencv 系列的一个目录以及 todo 吧, 我会依次添加相应的内容并整理好的. 大概率还是按照opencv 的文档结构进行 一一的介绍, 尽量完成整个文档的学习, 对于熟悉的模块希望自己能够更深入的了解, 对于用的很少或者自己不熟悉的还希望能指正出来, 共同学习 列表 1. 引导篇系列 opencv-0 项目启程 https://schen1024.github.io/2020/04-20/opencv-0-start.html opencv-1-QT_OPENCV 安装 https://schen1024.github.io/2020/04-20/opencv-1-QT_OPENCV.html opencv第一副图像显示 https://schen1024.github.io/2020/04-20/opencv-2-vsqt.html opencv-2-VS2017与QT显示图像 https://schen1024.github.io/2020/04-20/opencv-2-vsqt.html opencv-3-图片存储与相对路径 https://schen1024.github.io/2020/04-21/opencv-3-showimageandwrite.html 2. 基础入门 opencv-4-成像系统与Mat图像颜色空间 https://schen1024.github.io/2020/04-21/opencv-4-Mat.html opencv-5-图像遍历与图像改变 https://schen1024.github.io/2020/04-21/opencv-5-matpx.html opencv-6-图像绘制与opencv Line 函数剖析 https://schen1024.github.io/2020/04-22/opencv-6-%E9%BC%A0%E6%A0%87%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F.html opencv-7-鼠标绘制自定义图形 https://schen1024.github.io/2020/04-24/opencv-7-%E9%BC%A0%E6%A0%87%E7%BB%98%E5%88%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E5%BD%A2.html 4. 图像处理 核运算 图像降噪与平滑 形态学操作 图像金字塔与插值运算 阈值与自适应 边缘算子 霍夫直线变换 霍夫圆变换 映射操作 仿射变换 直方图计算 直方图均衡 直方图比较 模板匹配 轮廓检测 凸包 轮廓包络 图像分割 去模糊 降噪 配置文件读取与输出 . 图像视频输入与输出 . 相机校准与3D重建 . 2D特征检测 . 视频分析 . 对象检测 . 深度神经网络 . 机器学习模块 . 图形API . 计算摄影 . 图像拼接 . GPU加速计算","text":"开始由于害怕自己忘记或者拖延, 这篇文章就作为 opencv 系列的一个目录以及 todo 吧, 我会依次添加相应的内容并整理好的. 大概率还是按照opencv 的文档结构进行 一一的介绍, 尽量完成整个文档的学习, 对于熟悉的模块希望自己能够更深入的了解, 对于用的很少或者自己不熟悉的还希望能指正出来, 共同学习 列表 1. 引导篇系列 opencv-0 项目启程 https://schen1024.github.io/2020/04-20/opencv-0-start.html opencv-1-QT_OPENCV 安装 https://schen1024.github.io/2020/04-20/opencv-1-QT_OPENCV.html opencv第一副图像显示 https://schen1024.github.io/2020/04-20/opencv-2-vsqt.html opencv-2-VS2017与QT显示图像 https://schen1024.github.io/2020/04-20/opencv-2-vsqt.html opencv-3-图片存储与相对路径 https://schen1024.github.io/2020/04-21/opencv-3-showimageandwrite.html 2. 基础入门 opencv-4-成像系统与Mat图像颜色空间 https://schen1024.github.io/2020/04-21/opencv-4-Mat.html opencv-5-图像遍历与图像改变 https://schen1024.github.io/2020/04-21/opencv-5-matpx.html opencv-6-图像绘制与opencv Line 函数剖析 https://schen1024.github.io/2020/04-22/opencv-6-%E9%BC%A0%E6%A0%87%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F.html opencv-7-鼠标绘制自定义图形 https://schen1024.github.io/2020/04-24/opencv-7-%E9%BC%A0%E6%A0%87%E7%BB%98%E5%88%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E5%BD%A2.html 4. 图像处理 核运算 图像降噪与平滑 形态学操作 图像金字塔与插值运算 阈值与自适应 边缘算子 霍夫直线变换 霍夫圆变换 映射操作 仿射变换 直方图计算 直方图均衡 直方图比较 模板匹配 轮廓检测 凸包 轮廓包络 图像分割 去模糊 降噪 配置文件读取与输出 . 图像视频输入与输出 . 相机校准与3D重建 . 2D特征检测 . 视频分析 . 对象检测 . 深度神经网络 . 机器学习模块 . 图形API . 计算摄影 . 图像拼接 . GPU加速计算","categories":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/categories/opencv/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/tags/opencv/"},{"name":"c++","slug":"c","permalink":"https://schen1024.github.io/tags/c/"},{"name":"qt","slug":"qt","permalink":"https://schen1024.github.io/tags/qt/"},{"name":"list","slug":"list","permalink":"https://schen1024.github.io/tags/list/"}]},{"title":"opencv-0-项目启程","slug":"opencv-0-start","date":"2020-04-20T07:41:45.000Z","updated":"2023-01-01T13:25:24.772Z","comments":true,"path":"2020/04-20/opencv-0-start.html","link":"","permalink":"https://schen1024.github.io/2020/04-20/opencv-0-start.html","excerpt":"开始无数次说要开始 opencv 的系列, 但是都由于各种原因没有坚持下去,这次我做最后一次尝试, 也做最后一次坚持, 如果不做下去, 我就再也不开这个坑. 学习opencv 也有好几年了, 看到别人也写了各种的博文, 也学习了很多, 我也想写一点什么作为自己的一个总结, 我会将自己用到的和能够查到的都尽量写完整, 完善自己的知识库, 进而都整理出来, 完成写作. 工作量可能有点大, 但是我会坚持下去的.希望我能成功了再回看这个项目 思路从 Opencv 的基础开始, 从安装开始, 在到基本的操作, 再到每种算法的起源和发展, 并深入的剖析 opencv 的源码, 对应的还会写处相应的程序来, 这样 能够更为方便的展示效果 结构文章的结构可能会变化, 但是大概的结构还是有的,最开始从 opencv 的文档入手, 也看过很多别人翻译的文档, opencv 官方站点 参与了部分翻译内容的 OpenCV 中文文档 4.0.0 早期的 opencv 中国 opencv2.3.2 中文文档 个人翻译的 opencv 4.1.0 中文文档 w3cschoold 文档库 opencv 但是我这次也不是去做文档的翻译工作了, 我要做的更深一点, 往下深挖具体的实现原理并作出演示在文档的基础上, 去查看相关操作的基本原理, 进而分析不同情况下的执行情况, 最后写小的 demo 用于测试, 并给处演示. 最终的代码会同步在两个仓库中 Github/SChen1024/Imagelab Gitee/schen00/Imagelab 工具 代码编写: QT+OpenCV图像处理这里的主要内容是学习的Opencv, 个人主要开发是基于CPP的, 所以这里选择了使用 QT 作为桌面程序的开发, 这里选择了最新版本的程序, 涉及到调试部分的话, 使用的是 Visual Studio , 由于版本问题, 这边直接下载的 OpenCV, 编译好的库是 VS2017版本的, 所以在 QT 中 使用对应的 VS 2017_X64 QT 5.14.2 OpenCV 4.3.0 VS2017 源码阅读: VSCode+ Source InsightVSCode 主要用于查看临时代码 进行少量的代码编写, 也能配置进行编译, 但是我不是很喜欢, 所以主要用于代码展示与 markdown 的编写, 配合 hexo blog 作为自己目前的博客环境Source Insight 4.0 用于进行源代码的查看, 在大的工程查看的时候很好用, 之前用的比较多, 所以现在仍然这样. 博文编写: 小书匠 和 Zotero小书匠是我偶然发现的一款应用, 真的很好用, 功能很强大, 最方便的一点能够很方便的绑定多个图床, 目前的图片主要放在自己的 gitee 仓库里面, 作为图片存留. 能够本地客户端与线上直接同步, 十分方便.Zotero, 可以将自己感觉参考到的网页类似于文献一样的组织起来,能够很方便的使用. 写博客也有种写论文的感觉了. ^[阳志平的网志. 《Zotero（1）：文献管理软件Zotero基础及进阶示范》, 2013年4月4日. https://www.yangzhiping.com/tech/zotero1.html.] 其他工具 Chrome , 最好用的浏览器 github 学习的地方 CSDN/cnblogs/简书/知乎 能看到很多前辈的博文,真的很有用, 学到了很多. 其他在图像处理的学习过程中, 受到了很多博主的影响 CSDN 浅墨_毛星云, 算是入了门, 学会了使用 opencv 的基础内容 cnblogs ImageShop, 从图像处理的角度给了让我知道了还能这么做, 他个人喜欢最求更快的图像处理技术, 很有趣的一个博主. …. 还有很多 博主, 此处不再列举. 参考链接","text":"开始无数次说要开始 opencv 的系列, 但是都由于各种原因没有坚持下去,这次我做最后一次尝试, 也做最后一次坚持, 如果不做下去, 我就再也不开这个坑. 学习opencv 也有好几年了, 看到别人也写了各种的博文, 也学习了很多, 我也想写一点什么作为自己的一个总结, 我会将自己用到的和能够查到的都尽量写完整, 完善自己的知识库, 进而都整理出来, 完成写作. 工作量可能有点大, 但是我会坚持下去的.希望我能成功了再回看这个项目 思路从 Opencv 的基础开始, 从安装开始, 在到基本的操作, 再到每种算法的起源和发展, 并深入的剖析 opencv 的源码, 对应的还会写处相应的程序来, 这样 能够更为方便的展示效果 结构文章的结构可能会变化, 但是大概的结构还是有的,最开始从 opencv 的文档入手, 也看过很多别人翻译的文档, opencv 官方站点 参与了部分翻译内容的 OpenCV 中文文档 4.0.0 早期的 opencv 中国 opencv2.3.2 中文文档 个人翻译的 opencv 4.1.0 中文文档 w3cschoold 文档库 opencv 但是我这次也不是去做文档的翻译工作了, 我要做的更深一点, 往下深挖具体的实现原理并作出演示在文档的基础上, 去查看相关操作的基本原理, 进而分析不同情况下的执行情况, 最后写小的 demo 用于测试, 并给处演示. 最终的代码会同步在两个仓库中 Github/SChen1024/Imagelab Gitee/schen00/Imagelab 工具 代码编写: QT+OpenCV图像处理这里的主要内容是学习的Opencv, 个人主要开发是基于CPP的, 所以这里选择了使用 QT 作为桌面程序的开发, 这里选择了最新版本的程序, 涉及到调试部分的话, 使用的是 Visual Studio , 由于版本问题, 这边直接下载的 OpenCV, 编译好的库是 VS2017版本的, 所以在 QT 中 使用对应的 VS 2017_X64 QT 5.14.2 OpenCV 4.3.0 VS2017 源码阅读: VSCode+ Source InsightVSCode 主要用于查看临时代码 进行少量的代码编写, 也能配置进行编译, 但是我不是很喜欢, 所以主要用于代码展示与 markdown 的编写, 配合 hexo blog 作为自己目前的博客环境Source Insight 4.0 用于进行源代码的查看, 在大的工程查看的时候很好用, 之前用的比较多, 所以现在仍然这样. 博文编写: 小书匠 和 Zotero小书匠是我偶然发现的一款应用, 真的很好用, 功能很强大, 最方便的一点能够很方便的绑定多个图床, 目前的图片主要放在自己的 gitee 仓库里面, 作为图片存留. 能够本地客户端与线上直接同步, 十分方便.Zotero, 可以将自己感觉参考到的网页类似于文献一样的组织起来,能够很方便的使用. 写博客也有种写论文的感觉了. ^[阳志平的网志. 《Zotero（1）：文献管理软件Zotero基础及进阶示范》, 2013年4月4日. https://www.yangzhiping.com/tech/zotero1.html.] 其他工具 Chrome , 最好用的浏览器 github 学习的地方 CSDN/cnblogs/简书/知乎 能看到很多前辈的博文,真的很有用, 学到了很多. 其他在图像处理的学习过程中, 受到了很多博主的影响 CSDN 浅墨_毛星云, 算是入了门, 学会了使用 opencv 的基础内容 cnblogs ImageShop, 从图像处理的角度给了让我知道了还能这么做, 他个人喜欢最求更快的图像处理技术, 很有趣的一个博主. …. 还有很多 博主, 此处不再列举. 参考链接","categories":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://schen1024.github.io/categories/OpenCV/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://schen1024.github.io/tags/C/"},{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/tags/opencv/"},{"name":"QT","slug":"QT","permalink":"https://schen1024.github.io/tags/QT/"}]},{"title":"[SketchUp]-绘制自己的家","slug":"sketchup-myhouse","date":"2020-04-19T15:02:30.000Z","updated":"2023-01-01T13:25:24.778Z","comments":true,"path":"2020/04-19/sketchup-myhouse.html","link":"","permalink":"https://schen1024.github.io/2020/04-19/sketchup-myhouse.html","excerpt":"简介最近已经完成了 毕业论文, 等待盲审的过程中, 将过去几年做的东西也都一一整理了, 硬盘中好几个不敢动的文件夹 也都可以删除了. 想着这段时间开始将以前落下的东西一一补齐的, 昨天的时候偶然看到了别人发的装修图–SKETCHUP高精度控制下的室内装修设计 篇一：#原创新人#精装控制篇 , 感觉好厉害, 自己心理有点痒痒了, 以前的时候自己尝试过绘制自己的家, 但是不知道什么原因也都放弃了, 这次想着正好有时间, 就自己上手试试. 然后搜到了节俭装修不简单 篇四：SketchUp在装修上的应用简说 这篇文章, 做了一个简单的介绍, 一看, 好简单, 然后就上手了 软件SketchUp 2020 破解版从SketchUp Pro 2020 v20.0破解版 下载的 SketchUp 2020 百度网盘 提取码:mrkh 有需要的自己取用 过程0. 上手我自己有过 一些画图软件的基础, CAD, SolidWorks, ANSYS,所以感觉 SKetchUp 的上手很简单, 就是感觉操作没有我想的那么好玩, 其实三维软件都差不多,注意视角的旋转就好, 鼠标中键真的很好用,我一般喜欢鼠标中键旋转视角, 右键长按 平移视角, 但是这个做的不是很好, 右键没有, 不是很习惯 1. 绘制墙壁和开孔在这篇文章节俭装修不简单 篇四：SketchUp在装修上的应用简说 中, 详细介绍了怎么进行平面图形的绘制, 这里可以过去学习一下, 翻出我家的房产证, 看了下房子的大的尺寸信息,然后就可以开始就开始画了, 画图的时候一定要注意墙壁厚度, 尽量保持在每次只取一边, SU 好像很难更改之间的尺寸, 所以建议定好, 具体的门窗信息考 自己列一个表 带着尺子去一个一个的量就好了. 这里使用的门窗数据 单位都是 $cm$ , 但是在 SU 里面,画图的时候 是点击起始点, 然后输入参数, 在右下角能够看到, 单位是 $mm$ (具体看你选的模板, 有 $mm$ 和 $inch$ 两种单位). 一般老房子都是 $30cm$ 的墙壁厚度, $3m$ 左右的高度 , 门大概 80cm 宽, 窗户一般距离地面 90cm 高 2. 自定义门老式房型的门还真不好找, SU 最强大的就是有着无数的3D 图库库上找到好看的自己下载 , 可以直接导入到我们的图中, 进行缩放合适的位置就好了 由于我家的门比较老了, 所以我就自己画了一个, 算是上手吧. SU 只有推拉一个操作, 但是可以使用 bool 运算进行组合, 我就直接弄了一个听简单的 , 纹理是 自带的系统染色工具, 点一下就行了, 凑合能看, 做不到SW 的各种渲染效果. 好像无法进行对称, 所以我又复制出来一个 右开门的门 3 自定义窗户窗户也一样, 推来得到3D的图, 删除掉中间的部分 然后 加上玻璃就行了, 稍微计算一下具体的尺寸就好, 自带的颜色都好丑, 只有这种还算能看吧, 不锈钢 直男的感觉… 然后我家窗户也很复杂, 自己又做了组合, 得到了 然后室内的窗户是进行了包边的, 然后加上去之后居然看起来还不错…. 4. 组装门窗SU 可以导入别的图 ,然后使用 移动, 缩放工具能不同尺寸的图适应到孔内, 经过复杂的操作, 最终我们完成了家庭房屋的大部分结果, 是不是还行. 阳台的的窗户真的很难看, 有时间再单独画吧, ….暂时还没做的其他步骤 -1. 渲染出图最后一步, 进行渲染出图, 抱歉, 你的电脑太垃圾, 无法进行渲染, 请安装好一点的显卡… 就没有然后了 总结优点: 上手容易 操作简单 模型丰富 组合容易 缺点: 复杂操作很难实现 专业性不强 无法精准控制 SU 十分适合新手, 或者想玩玩的 , 组装之类的只要能到位看不出来就行, 专业软件则能做的更好,但是上手快呀, 成就感十足, 值得尝试玩玩就好…","text":"简介最近已经完成了 毕业论文, 等待盲审的过程中, 将过去几年做的东西也都一一整理了, 硬盘中好几个不敢动的文件夹 也都可以删除了. 想着这段时间开始将以前落下的东西一一补齐的, 昨天的时候偶然看到了别人发的装修图–SKETCHUP高精度控制下的室内装修设计 篇一：#原创新人#精装控制篇 , 感觉好厉害, 自己心理有点痒痒了, 以前的时候自己尝试过绘制自己的家, 但是不知道什么原因也都放弃了, 这次想着正好有时间, 就自己上手试试. 然后搜到了节俭装修不简单 篇四：SketchUp在装修上的应用简说 这篇文章, 做了一个简单的介绍, 一看, 好简单, 然后就上手了 软件SketchUp 2020 破解版从SketchUp Pro 2020 v20.0破解版 下载的 SketchUp 2020 百度网盘 提取码:mrkh 有需要的自己取用 过程0. 上手我自己有过 一些画图软件的基础, CAD, SolidWorks, ANSYS,所以感觉 SKetchUp 的上手很简单, 就是感觉操作没有我想的那么好玩, 其实三维软件都差不多,注意视角的旋转就好, 鼠标中键真的很好用,我一般喜欢鼠标中键旋转视角, 右键长按 平移视角, 但是这个做的不是很好, 右键没有, 不是很习惯 1. 绘制墙壁和开孔在这篇文章节俭装修不简单 篇四：SketchUp在装修上的应用简说 中, 详细介绍了怎么进行平面图形的绘制, 这里可以过去学习一下, 翻出我家的房产证, 看了下房子的大的尺寸信息,然后就可以开始就开始画了, 画图的时候一定要注意墙壁厚度, 尽量保持在每次只取一边, SU 好像很难更改之间的尺寸, 所以建议定好, 具体的门窗信息考 自己列一个表 带着尺子去一个一个的量就好了. 这里使用的门窗数据 单位都是 $cm$ , 但是在 SU 里面,画图的时候 是点击起始点, 然后输入参数, 在右下角能够看到, 单位是 $mm$ (具体看你选的模板, 有 $mm$ 和 $inch$ 两种单位). 一般老房子都是 $30cm$ 的墙壁厚度, $3m$ 左右的高度 , 门大概 80cm 宽, 窗户一般距离地面 90cm 高 2. 自定义门老式房型的门还真不好找, SU 最强大的就是有着无数的3D 图库库上找到好看的自己下载 , 可以直接导入到我们的图中, 进行缩放合适的位置就好了 由于我家的门比较老了, 所以我就自己画了一个, 算是上手吧. SU 只有推拉一个操作, 但是可以使用 bool 运算进行组合, 我就直接弄了一个听简单的 , 纹理是 自带的系统染色工具, 点一下就行了, 凑合能看, 做不到SW 的各种渲染效果. 好像无法进行对称, 所以我又复制出来一个 右开门的门 3 自定义窗户窗户也一样, 推来得到3D的图, 删除掉中间的部分 然后 加上玻璃就行了, 稍微计算一下具体的尺寸就好, 自带的颜色都好丑, 只有这种还算能看吧, 不锈钢 直男的感觉… 然后我家窗户也很复杂, 自己又做了组合, 得到了 然后室内的窗户是进行了包边的, 然后加上去之后居然看起来还不错…. 4. 组装门窗SU 可以导入别的图 ,然后使用 移动, 缩放工具能不同尺寸的图适应到孔内, 经过复杂的操作, 最终我们完成了家庭房屋的大部分结果, 是不是还行. 阳台的的窗户真的很难看, 有时间再单独画吧, ….暂时还没做的其他步骤 -1. 渲染出图最后一步, 进行渲染出图, 抱歉, 你的电脑太垃圾, 无法进行渲染, 请安装好一点的显卡… 就没有然后了 总结优点: 上手容易 操作简单 模型丰富 组合容易 缺点: 复杂操作很难实现 专业性不强 无法精准控制 SU 十分适合新手, 或者想玩玩的 , 组装之类的只要能到位看不出来就行, 专业软件则能做的更好,但是上手快呀, 成就感十足, 值得尝试玩玩就好…","categories":[{"name":"Person","slug":"Person","permalink":"https://schen1024.github.io/categories/Person/"}],"tags":[{"name":"home","slug":"home","permalink":"https://schen1024.github.io/tags/home/"},{"name":"soft","slug":"soft","permalink":"https://schen1024.github.io/tags/soft/"},{"name":"sketchup","slug":"sketchup","permalink":"https://schen1024.github.io/tags/sketchup/"}]},{"title":"再见VS2015","slug":"byeVS2015","date":"2020-04-16T12:35:39.000Z","updated":"2023-01-01T13:25:24.266Z","comments":true,"path":"2020/04-16/byeVS2015.html","link":"","permalink":"https://schen1024.github.io/2020/04-16/byeVS2015.html","excerpt":"开始我是 15 年开始有的笔记本电脑， 也是那时候开始有的笔记本电脑， 算了算 从那个时候就是开始使用 VS 了， 当时看着真的是一个很大很大的软件， 现如今其他的软件装得多了， 发现并不是很大了。 使用 VS 有几年了， 总的来说，使用到的功能只是基础， 能进行代码编辑， 编译，调试， 主要的工作了， 安装了很多很多的插件， 越来越舍不得了， 更好的工具其实也没有什么更好的工具， 只是使用新的版本而已， 恰逢毕业之际， 正好对自己的电脑进行一次大的更新， 旧的删除， 新的引入， 也是对自己工作的一个总结吧， 希望在未来能够更好的出产新的东西。 夸VS2015 真的很好用，宇宙第一 IDE 结束卸载方法参考了完美卸载 Visual Studio2015 的方法汇总","text":"开始我是 15 年开始有的笔记本电脑， 也是那时候开始有的笔记本电脑， 算了算 从那个时候就是开始使用 VS 了， 当时看着真的是一个很大很大的软件， 现如今其他的软件装得多了， 发现并不是很大了。 使用 VS 有几年了， 总的来说，使用到的功能只是基础， 能进行代码编辑， 编译，调试， 主要的工作了， 安装了很多很多的插件， 越来越舍不得了， 更好的工具其实也没有什么更好的工具， 只是使用新的版本而已， 恰逢毕业之际， 正好对自己的电脑进行一次大的更新， 旧的删除， 新的引入， 也是对自己工作的一个总结吧， 希望在未来能够更好的出产新的东西。 夸VS2015 真的很好用，宇宙第一 IDE 结束卸载方法参考了完美卸载 Visual Studio2015 的方法汇总","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://schen1024.github.io/tags/C/"},{"name":"VS2015","slug":"VS2015","permalink":"https://schen1024.github.io/tags/VS2015/"}]},{"title":"websitelist","slug":"websitelist","date":"2020-04-13T16:44:47.000Z","updated":"2023-01-01T13:25:24.779Z","comments":true,"path":"2020/04-13/websitelist.html","link":"","permalink":"https://schen1024.github.io/2020/04-13/websitelist.html","excerpt":"","text":"","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[]},{"title":"C51_PID 水温控制系统","slug":"C51_PID","date":"2020-04-05T15:10:52.000Z","updated":"2023-01-01T13:25:24.200Z","comments":true,"path":"2020/04-05/C51_PID.html","link":"","permalink":"https://schen1024.github.io/2020/04-05/C51_PID.html","excerpt":"","text":"前言通过 C 语言程序写入 51 单片机实现水的温度的采集,并通过控制器控制加热器给水体加热,对水体的温进行 PID 控制,保证温度在设定值范围内波动最终包括 C51 的视频的内容以及部分参考资料都可以在 百度分享链接内下载 链接: https://pan.baidu.com/s/1jpawh31O1gqv9CU_0LXFZQ 提取码: 2333 包含店家赠送的 51 的资料以及使用过程中需要用到的部分参考文件以及代码 1. 系统设计系统硬件部分主要包含主控制器(==89C52RC==),温度传感器(==DS18B20==),加热器,数码管显示,AD 采集以及 DA 输出 1.1 主控制器主控制器是 89C52 使用手册下载 也可以在 pdf 文件中找到使用手册本次实验使用的设备是 ==德飞莱 LY-51S V3.0== 可以参考附件中 V2.32 版本的使用手册,实物可以参考京东链接介绍页面^[https://item.jd.com/29638729865.html], 基本操作视频在最上方发出的百度分享链接中(2.7G),以及店家附带的关于系统板的参考资料(600M) 系统控制器的原理图如图 1.1 所示 图 1.2 所示是 51 系统板原始图像,跟本版本几乎一致, 可以参考 最终只使用到了:数码管显示,只是 LED 小灯,串口模块,AD-DA 模块,循环会一一介绍 1.2 LED 小灯程序里面设计了四个小灯来标识程序执行情况,对应的使用==P10 #F44336==,==P12 #F44336==,==P14 #F44336==,==P16 #F44336==四个端口,这样便于小灯之前区分开,避免识别出错, LED 只需要在程序中将 LED 进行赋值 1 0 即可控制小灯亮灭,由于小灯是==共阳极==, 所以 设定 LED=1 小灯是灭的 LED=0 实现小灯亮起 12345// 定义小灯表示输出sbit LED0 = P1^0; // 程序主循环函数sbit LED1 = P1^2; // 读取温度闪灯, 每次读取温度 闪灯一次sbit LED2 = P1^4; // 小灯,串口接收信号 闪灯sbit LED3 = P1^6; // 小灯,串口接收信号 闪灯 虽然原理图里面显示小灯是不同颜色, 但是在实际显示的时候全部是红色 所以间隔取了 4 个小灯来标识程序执行 LED0 是程序主循环程序指示灯,亮灭代表程序进入主程序的 while 循环中循环执行, 主循环 控制小灯闪灭,同时循环判断读取温度标识位==ReadTempFlag== 只有满足的情况下会进入执行否则不执行LED1 是温度读取小灯, 标识 程序进入中断函数执行, 设定值是中断函数每 2ms 进入一次中断, 每次中断执行数码管刷新任务,同时每中断 250 次 0.5s 将程序执行标志位==ReadTempFlag== 置位 便于主程序执行,所以程序读取温度周期和程序执行周期都是==0.5s==LED2 标识串口输出数据的小灯,每次串口接收到==一个==数据会将 LED2 进行取反操作 如果输入两个数据则小灯会快速亮灭一次完成操作LED3 标识命令执行小灯,程序里面目前设定的是 5 个字符标识一条指令, 每次满足 5 个字符之后 LED3 小灯会亮起,标识指令输入完成,当不满足的时候灯会灭掉,可以通过此等判断当前状态 1.3 数码管显示数码管显示包含 8 个数据口 P0 的全部端口 P00-P07 以及两个控制控制口==P22 #F44336==,==P23 #F44336==的 123#define DataPort P0 //定义数据端口 程序中遇到DataPort 则用P0 替换sbit LATCH1=P2^2;//定义锁存使能端口 段锁存sbit LATCH2=P2^3;// 位锁存 共阴极数码管原理图 对应的程序可以见程序工程==display.c== 在头文件==display.h==中定义了程序接口,对应的需要将 P0 口的线接到数码管的数据口上==J3== , 同时需要将==J50==接口短接,否则数码管会很暗,几乎不可见同时需要将控制线 LATCH1 接到==J2==的 B 口, LATCH2 接到==J2==的 A 口 程序会每次 2ms 循环显示数码管,==showTemp== 显示前面四个字,(-)25.1 的格式显示温度, ==showOuts== 显示后面资格字 会显示-999 到 999 的输出值, 显示计算得到的输出设定值, 输出值的显示会限定在-999 到 999 之间, 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 千四个数码管 显示温度 _00.0 格式float showTemp(unsigned int temp)&#123; unsigned int TempH,TempL; uchar b=0,s=0,g=0,d=0; // 百 十 个位显示 float t_ = 0.0f; // 显示温度值 if(temp&amp;0x8000) &#123; TempData[0]=0x40;//负号标志 temp=~temp; // 取反加1 temp +=1; &#125; else &#123; TempData[0]=0; &#125; TempH=temp&gt;&gt;4; TempL=temp&amp;0x0F; TempL=TempL*6/10;//小数近似处理 b = TempH/100; // 百位 s = (TempH%100)/10; // 十位 g = (TempH%10); // 个位 d = TempL; // 十分位 if(TempH/100==0) TempData[1]=0; else TempData[1]=dofly_DuanMa[b]; //十位温度 if((b==0)&amp;&amp;(s==0))//消隐 TempData[1]=0x00; else TempData[1]=dofly_DuanMa[s]; //十位温度 TempData[2]=dofly_DuanMa[g]|0x80; //个位温度,带小数点 TempData[3]=dofly_DuanMa[d]; t_ = b*100+s*10+g+d*0.1; return t_;&#125;// 显示输出值, 取整 最大 999void showOuts(int num)&#123; // 限定在-999~999 num = num&gt;999?999:num; num = num&lt;-999?-999:num; if(num&lt;0) &#123; TempData[4]=0x40;//负号标志 num = -num; &#125; else TempData[4]=0x00;//正号不显示 TempData[5]=dofly_DuanMa[num/100]; //十位温度 TempData[6]=dofly_DuanMa[num%100/10]; //个位温度,带小数点 TempData[7]=dofly_DuanMa[num%10];&#125; 1.4 温度传感器温度传感器使用的集成的 DS18B20 模块,有三个接线, 白色是 5V-VCC 黑色是 GND.黄色是信号线,在程序中设定 AD 采集接口是==P36 #F44336==接口 以便进行 AD 采集定义在==18b20.h==文件中,对应的实现包含了传感器的初始初始化以及温度采集函数,通过调用采集函数==ReadTemperature==可以返回 uint 型的温度数据, 其中在==display.c==中包含了==showTemp== 函数中可以将 uint 型的数据进行解码得到==float==型的数据 并显示在数码管的前面四个数字中 按照(-)25.0 的格式显示总共四个格子, 标识当前的温度, 同时串口会实时的将温度输出到串口处, 输出格式为 ==025==的格式输出,实际上每次输出之后 会用一个空格分割每次的值,在串口部分详细介绍 温度传感器的温度输出值,可以参考 pdf 文件中的温度传感器的中文资料,其中数据与真实温度设定值可以参考下面的标识方式,实际上需要将 uint16 位的数据转换成 float 型的数据==温度传感器需要进行温度标定==,将输出结果与真实温度进行数据标定成一个标准数据,,否则数据可能存在一个误差, 温度传感器的温度读取只在 18b20 文件中, 只需要将==P36==接口接到温度传感器的信号线上便能够读取温度, 不需要使用 i2c 来实现,似乎也不要使用 AD 采集就能得到结果 1.5 串口 UART51 单片机的串口部分包含比较简单,但是硬件部分存在大坑, 建议不要改动相应的程序 可以备份之后再进行修改,需要分开部分进行介绍 包括串口基本部分,以及串口输出部分以及串口接收指令部分由于 51 单片机支持串口下载,可以直接通过 STC 下载器将 hex 下载进 51 中,同时可以打开串口与单片机进行通讯 1.51 串口基本部分51 单片机的串口部分操作比较类似, 目前程序里面使用的是==2400== 波特率 baudrate,可以基本部分进行串口初始化以及实现串口发送单个字符以及发送字符串的功能 由于程序存在 串口初始化和定时器初始化, 所以在初始化过程中可以打开串口中断和定时器中断,初始化成功之后在主程序中使用==EA=1== 开启总中断,使能程序的中断过程避免由于中断导致初始化失败引发的程序假死串口部分的基本部分可以参考程序的注释部分的内容, 程序附带文件夹里面包括了其他的串口的使用介绍例程,部分介绍了 uart 的缓冲区扩充机制,以及一个环形缓冲区的结构设计,以及一个使用 uart 的 modbus 协议的实现,之后可能会用到的内容, 12345678910111213141516171819202122232425262728293031323334353637383940/*------------------------------------------------ 串口初始化------------------------------------------------*/void InitUART (void)&#123; SCON = 0x50; // SCON: 模式 1, 8-bit UART, 使能接收 TMOD &amp;= 0x0F; //清零T1的控制位 TMOD |= 0x20; // TMOD: timer 1, mode 2, 8-bit 重装 TH1 = 0xF3; // TH1: 重装值 2400 波特率 晶振 11.0592MHz ET1 =0 ; //禁止T1中断 ES = 1; //打开串口中断 //EA = 1; //打开总中断 TR1 = 1; // TR1: timer 1 打开&#125;/*------------------------------------------------ 发送一个字节------------------------------------------------*/void uartSendByte(unsigned char dat)&#123; SBUF = dat; //while(!TI) ; // 延时一定时间 保证发送成功 如果使用上面的循环 等待硬件TI触发 很容易造成程序卡死,建议设定成 DelayMs(10); TI = 0;&#125;/*------------------------------------------------ 发送一个字符串------------------------------------------------*/void SendStr(unsigned char *s)&#123; while(*s!='\\0')// \\0 表示字符串结束标志，通过检测是否字符串末尾 &#123;true uartSendByte(*s);true s++; &#125;&#125; 1.52 串口输出部分串口缓冲器 SBUF 只有一个字节,每次只能存储一个字节, 每次会将接收到的数据存放在 SBUF 中,如果将数据存放在 SBUF 中之后就能够实现输出字节了,下面两个函数 是实现发送一个三位的温度值的实现方法,即将每一位输出出去,显示在串口部分, 1234567891011121314151617181920212223242526272829303132333435363738394041// 发送 整型数据void SendNum(int num)&#123;true// xdata 关键字会将数据存在 扩展RAM中 避免主data数据空间不够导致的出错 xdata unsigned char b1=0;truexdata unsigned char s1=0;truexdata unsigned char g1=0; if(num&lt;0) &#123; uartSendByte(0x2D); //发送负号 - num=-num; &#125; b1=(num/100)+0x30; s1=(num%100)/10+0x30; g1=num%10+0x30;true// 将数据直接发送回去 然后 结束trueuartSendByte(b1);trueuartSendByte(s1);trueuartSendByte(g1);trueSendStr(\" \"); // 发送空格分割&#125;// 发送 float 数据 3.1fvoid SendNumF(float num)&#123;trueuint i_num = 0;trueuint f_num = 0.0f;truei_num = (int)num; //获取整型truef_num = 10.0f*(num-i_num); //获取小数点的值trueSendNum(i_num);trueuartSendByte(0x2E); // 发送给一个点号trueSendNum(f_num);trueSendStr(\" \");&#125; 1.53 串口服务函数串口中断使用的是中断 4 每次接收到数据之后触发中断,进入中断服务函数中每次接受到数据之后会将串口接收灯置位, 亮灭一次,同时将接受到的字符返回到显示界面, 然后将接收到的字符使用串口处理函数进行处理,处理函数会进行累加,记录当前字符的数目, 设定的存储区域位 5 位的数组,每次会循环覆盖掉之前的数据,当接收满了 5 个字符之后能够将 LED3 电量,表示接受到了一条指令,目前程序下载之后可能需要手动输入空字符等到灯亮起来之后再输入完整指令 目前只支持==T0350==格式的指令,程序会判断第一个字符是否为 T, 如果满足则会将数组的==RE_STR==的 RE_STR[2],RE_STR[3]里面的数据组合成温度值, 表示设定的温度,其余部分暂时没有考虑添加,之后可能会进行处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#define MAX_NUM_b 5 // 设定存在值就5个字符unsigned char xdata RE_STR[MAX_NUM_b]; //存储显示值的全局变量/*------------------------------------------------ 串口中断程序------------------------------------------------*/void UART_SER (void) interrupt 4 //串行中断服务程序&#123; unsigned char Temp; //定义临时变量 if(RI) //判断是接收中断产生 &#123; RI=0; //标志位清零 Temp=SBUF; //读入缓冲区的值 LED2 = !LED2; // 亮灭串口接收灯 SBUF=Temp; //把接收到的值 再发回电脑端 handleRE(Temp); &#125; if(TI) //如果是发送标志位，清零 &#123; TI=0; &#125;&#125;// 处理接收串口事件 每次接收会 出发函数void handleRE(uchar t)&#123; static uchar count_r=0; // 每次接收数据加1 // 如果不是 结束符号 if (t != '\\0') &#123; RE_STR[count_r] = t; &#125; count_r++; // 灯灭 每次程序将灯灭掉 LED3 = 1; if(count_r == MAX_NUM_b) &#123; count_r = 0; SendStr(\"!\");truetrue// 如果首位是T 则 后三位标识 温度 x10truetrueif(RE_STR[0] == 't' || RE_STR[0] == 'T')truetrue&#123;truetruetruetemp_set = (RE_STR[2]-0x30)*10+(RE_STR[3]-0x30);truetruetrueSendStr(\"T:\");truetruetrueSendNum(temp_set);truetrue&#125; LED3 = 0; // 灯亮 &#125;&#125; 1.6 AD-DA 模块AD-DA 转换模块可以参考附件文件夹 pdf 中 AD 模块内容, 实际过程中 AD 采集模块 并没有用到,温度采集的部分使用的是==P36==接口, 使用 在 ADC.c 中进行了定义 但是程序中使用了 DA 模块实现了温度的输出值, 此处可以更改温度读取 设定,改用 AD 采集获取信号信号,目前使用的是直接读取结果, 1.61 I2C 接口实现温度传感器是是 DS18b20 的格式, 器件的初始化 使用 I2C 协议进行操作,参考程序内部的==i2c.c==函数实现,内容比较多,可以直接区程序里面进行参考,数字 I2c 的实现 都差不多,注意时序就好, I2C 的接口需要接到==P20 #F44336==,==P21 #F44336==接口在板上 J8 接口处,使用 I2c 可以控制 系统板上的 4 路 AD 采集以及一路 AD 输出, 函数头定义了 I2C 器件地址, 可以参考附件中介绍,完成数据采集过程. 12345sbit SDA=P2^1;sbit SCL=P2^0;#define AddWr 0x90 //写数据地址#define AddRd 0x91 //读数据地址 1.62 AD-DA 输出实现AD 采集函数可以实现 4 路 AD 采集过程,DA 输出只支持 DA 输出, 将==J33==的接口短接之后可以使用 DA 输出 的电压值控制小灯==LED9== 的亮亮度,此小灯是输出到了阴极,如果输出 5V 则小灯是灭的 输出 0 则会亮起来,但是 LED 存在当输出的两端电压差值在 1.5V 以内 小灯则不会亮, 1234567891011121314151617181920212223242526272829303132333435363738/*------------------------------------------------ 读AD转值程序输入参数 Chl 表示需要转换的通道，范围从0-3返回值范围0-255------------------------------------------------*/unsigned char ReadADC(unsigned char Chl) &#123; unsigned char Val; Start_I2c(); //启动总线 SendByte(AddWr); //发送器件地址 if(ack==0)return(0); SendByte(0x40|Chl); //发送器件子地址 if(ack==0)return(0); Start_I2c(); SendByte(AddWr+1); if(ack==0)return(0); Val=RcvByte(); NoAck_I2c(); //发送非应位 Stop_I2c(); //结束总线 return(Val); &#125;/*------------------------------------------------ 写入DA转换数值输入参数：dat 表示需要转换的DA数值，范围是0-255------------------------------------------------*/bit WriteDAC(unsigned char dat)&#123; Start_I2c(); //启动总线 SendByte(AddWr); //发送器件地址 if(ack==0)return(0); SendByte(0x40); //发送器件子地址 if(ack==0)return(0); SendByte(dat); //发送数据 if(ack==0)return(0); Stop_I2c();truereturn 1;&#125; 1.62 PI 控制以及输出主循环过程中设置了读取温度标志位后,会进去温度读取过程,, 然后根据显示温度,串口输出温度,之后进行 PI 运算, 最终显示输出值之后之后将电压输出到 电压中 1234567891011121314151617181920212223242526272829if(ReadTempFlag==1) &#123; ReadTempFlag=0; temp=ReadTemperature(); //读取温度 // num2str(101); t_0 = showTemp(temp); // 显示温度 SendNum(t_0); // 串口输出温度 //=================================== // //PID ek = (temp_set-t_0); ei += ek; tp = ek*P; ti = ei*I; out_pi = tp+ti; //=================================== //out_pi= out_pi; showOuts(out_pi); out_pi = (out_pi&gt;255?255:out_pi); out_pi = (out_pi&lt;0?0:out_pi); // 将控制结果输出到灯光的控制中 WriteDAC(out_pi); // 最后总控制输出电压 &#125; // end of readTempFlag","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"51","slug":"51","permalink":"https://schen1024.github.io/tags/51/"},{"name":"C","slug":"C","permalink":"https://schen1024.github.io/tags/C/"},{"name":"PID","slug":"PID","permalink":"https://schen1024.github.io/tags/PID/"},{"name":"UART","slug":"UART","permalink":"https://schen1024.github.io/tags/UART/"},{"name":"水温控制","slug":"水温控制","permalink":"https://schen1024.github.io/tags/%E6%B0%B4%E6%B8%A9%E6%8E%A7%E5%88%B6/"}]},{"title":"待写博文-ToDoList","slug":"ToDO","date":"2020-04-05T15:10:52.000Z","updated":"2023-01-01T13:25:24.240Z","comments":true,"path":"2020/04-05/ToDO.html","link":"","permalink":"https://schen1024.github.io/2020/04-05/ToDO.html","excerpt":"列表有时候会有一些想写的点， 但是当时或者其他有些事情或者时间上无法写， 这里列下来 todo， 等待有时间的时候去写。 待写博文 latex 标点符号 latex 列表缩进问题 latex 排版问题 Opencv 系列 待更新","text":"列表有时候会有一些想写的点， 但是当时或者其他有些事情或者时间上无法写， 这里列下来 todo， 等待有时间的时候去写。 待写博文 latex 标点符号 latex 列表缩进问题 latex 排版问题 Opencv 系列 待更新","categories":[{"name":"TODO","slug":"TODO","permalink":"https://schen1024.github.io/categories/TODO/"}],"tags":[{"name":"TODO","slug":"TODO","permalink":"https://schen1024.github.io/tags/TODO/"},{"name":"blog，hexo","slug":"blog，hexo","permalink":"https://schen1024.github.io/tags/blog%EF%BC%8Chexo/"}]},{"title":"latex 标点符号","slug":"latex-punctuation","date":"2020-04-05T14:40:43.000Z","updated":"2023-01-01T13:25:24.772Z","comments":true,"path":"2020/04-05/latex-punctuation.html","link":"","permalink":"https://schen1024.github.io/2020/04-05/latex-punctuation.html","excerpt":"","text":"","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"home","slug":"home","permalink":"https://schen1024.github.io/tags/home/"},{"name":"shopping","slug":"shopping","permalink":"https://schen1024.github.io/tags/shopping/"},{"name":"washing machine","slug":"washing-machine","permalink":"https://schen1024.github.io/tags/washing-machine/"}]},{"title":"latex-列表环境","slug":"latex-list","date":"2020-03-29T21:24:54.000Z","updated":"2023-01-01T13:25:24.771Z","comments":true,"path":"2020/03-29/latex-list.html","link":"","permalink":"https://schen1024.github.io/2020/03-29/latex-list.html","excerpt":"介绍latex 主要有三种列表环境,进行罗列的实现, 无序列表 – itemize 有序列表 – enumerate 描述列表 – description 本文进行了一一介绍和演示, 同时添加了嵌套列表环境和自定义列表环境的说明 latex 列表环境latex 的列表环境都是使用例如如下的形式进行的罗列, 123456\\begin&#123;itemize&#125; \\item 条目1 \\item 条目2 \\item 条目3 \\item .....\\end&#123;itemize&#125; 无序列表 –itemize 环境最基本的无序列表的形势 1234567无序列表环境:\\begin&#123;itemize&#125; \\item 条目1 \\item 条目2 \\item 条目3 \\item .....\\end&#123;itemize&#125; 默认的前缀是实心的 黑色原点, 但是我们可以在 \\item[] 中进行自定义符号, 一般来说, 想要的符号都能够进行显示 对于列表中没有指定符号的项目, 会使用默认 的符号 123456789101112无序列表环境--自定义符号:\\begin&#123;itemize&#125; \\item[-] 条目1 \\item[+] 条目2 \\item[x] 条目3 \\item[/] 条目4 \\item[*] 条目5 \\item[a] 条目6 \\item[$\\circ$] 条目7 \\item[$\\bigotimes$] 条目8 \\item .....\\end&#123;itemize&#125; 有序列表 – enumerate 环境要想使用 有序列表, 需要在导言区 引入 \\usepackage{enumerate} 有序列表也是 中间对齐的样式.首先介绍最为基本的有序列表的形式, 默认 使用 数字加. 的形势 如 1. 1234567有序列表-- 默认:\\begin&#123;enumerate&#125; \\item 条目1 \\item 条目2 \\item 条目3 \\item .....\\end&#123;enumerate&#125; 实际上, 有序列表可以使用 1, A,a,I,i 标记开始有序的开始, 分别对应, 数字, 大小写字母表和大小写罗马数字 但是其他的字符 只是默认无含义, 当作序号开始的修饰, 既是同样是序列中的字符, 比如 B,b 之类的 , 同样的, 如果有两个序号控制字符, 系统会以后面的字符作为控制, 而且, 前面的也会被替换掉, 所以这如果有重复的字符一定要注意 1234567有序列表-- 指定样式:\\begin&#123;enumerate&#125;[test(2,B,b,) 1, A, a, i, I,] \\item 条目1 \\item 条目2 \\item 条目3 \\item .....\\end&#123;enumerate&#125; 同样的, 有序列表的默认是按照等级的, 最低的是直接默认的 1. 其次是 \\begin{enumerate}[1,] 后面的序列控制, 最后面的是在单个项目之前的指定符号, \\item[*] 如果存在的话, 会覆盖相应的符号, 且, 编号会漏过相应的项目. 123456\\begin&#123;enumerate&#125; \\item 条目1 \\item[*] 条目2 \\item[-] 条目3 \\item .....\\end&#123;enumerate&#125; 描述列表 – description此列表主要用于罗列之后进行解释, 不会有编号 符号, 但是会将括号内的次进行加粗加黑处理 如果当前 item 不存在 描述词, 则 默认显示,如 条目 4 但是样式会比较奇怪, 1234567891011\\begin&#123;description&#125; \\item[条目11] 条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1 \\item[条目22] 条目2.. \\item[条目22] 条目3 \\item 条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4\\end&#123;description&#125; 嵌套列表latex 不仅可以单独使用, 恶意是可以进行嵌套使用的,嵌套列表 1234567891011121314151617181920212223242526\\begin&#123;description&#125; \\item[条目11] 条目1条目1条目1条目1条目1条目1条目1 \\begin&#123;enumerate&#125;[A.] \\item 条目1 条目1条目1条目1条目1 \\begin&#123;itemize&#125; \\item 条目1 \\item 条目2 \\item 条目3 \\item ..... \\end&#123;itemize&#125; \\item 条目2 \\item 条目3 \\item ..... \\end&#123;enumerate&#125; \\item[条目22] 条目2.. \\item[条目22] 条目3 \\item 条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4\\end&#123;description&#125; 自定义环境借用参考链接 1 中的图, 可以看到各种命令的说明, 以及 latex 进行排版布局的说明 垂直间距topsep 列表环境与上文之间的距离parsep 条目里面段落之间的距离itemsep 条目之间的距离partopsep 条目与下面段落的距离 水平间距leftmargin 列表环境左边的空白长度rightmargin 列表环境右边的空白长度labelsep 标号与列表环境左侧的距离itemindent 条目的缩进距离labelwidth 标号的宽度listparindent 条目下面段落的缩进距离 同样的, 我们在描述列表中能够看到缩进问题, 导致的显示比较难看, 这里我们可以参考 链接 2 给出的自定义命令的方式进行解决 12345678\\usepackage&#123;blindtext&#125;\\newcommand&#123;\\deflabel&#125;[1]&#123;\\bf #1\\hfill&#125;%\\newenvironment&#123;newlist&#125;[1]%&#123;\\begin&#123;list&#125;&#123;&#125;&#123;\\settowidth&#123;\\labelwidth&#125;&#123;\\bf #1&#125;% \\setlength&#123;\\leftmargin&#125;&#123;\\labelwidth&#125;% \\addtolength&#123;\\leftmargin&#125;&#123;\\labelsep&#125;% \\renewcommand&#123;\\makelabel&#125;&#123;\\deflabel&#125;&#125;&#125;%&#123;\\end&#123;list&#125;&#125; 在导言区设定了新的命令, 我们在文档中直接进行使用就行了, 注意使用的是偶 在 \\begin{newlist} 后面的条目最好填上最长的条目, 这样后面每个项目都缩进相应的尺寸, 达到显示美观的结果 1234567891011\\begin&#123;newlist&#125;&#123;条目11条条目11条&#125; \\item[条目11条条目11条] 条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1 \\item[条目22] 条目2.. \\item[条目22] 条目3 \\item 条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4\\end&#123;newlist&#125;","text":"介绍latex 主要有三种列表环境,进行罗列的实现, 无序列表 – itemize 有序列表 – enumerate 描述列表 – description 本文进行了一一介绍和演示, 同时添加了嵌套列表环境和自定义列表环境的说明 latex 列表环境latex 的列表环境都是使用例如如下的形式进行的罗列, 123456\\begin&#123;itemize&#125; \\item 条目1 \\item 条目2 \\item 条目3 \\item .....\\end&#123;itemize&#125; 无序列表 –itemize 环境最基本的无序列表的形势 1234567无序列表环境:\\begin&#123;itemize&#125; \\item 条目1 \\item 条目2 \\item 条目3 \\item .....\\end&#123;itemize&#125; 默认的前缀是实心的 黑色原点, 但是我们可以在 \\item[] 中进行自定义符号, 一般来说, 想要的符号都能够进行显示 对于列表中没有指定符号的项目, 会使用默认 的符号 123456789101112无序列表环境--自定义符号:\\begin&#123;itemize&#125; \\item[-] 条目1 \\item[+] 条目2 \\item[x] 条目3 \\item[/] 条目4 \\item[*] 条目5 \\item[a] 条目6 \\item[$\\circ$] 条目7 \\item[$\\bigotimes$] 条目8 \\item .....\\end&#123;itemize&#125; 有序列表 – enumerate 环境要想使用 有序列表, 需要在导言区 引入 \\usepackage{enumerate} 有序列表也是 中间对齐的样式.首先介绍最为基本的有序列表的形式, 默认 使用 数字加. 的形势 如 1. 1234567有序列表-- 默认:\\begin&#123;enumerate&#125; \\item 条目1 \\item 条目2 \\item 条目3 \\item .....\\end&#123;enumerate&#125; 实际上, 有序列表可以使用 1, A,a,I,i 标记开始有序的开始, 分别对应, 数字, 大小写字母表和大小写罗马数字 但是其他的字符 只是默认无含义, 当作序号开始的修饰, 既是同样是序列中的字符, 比如 B,b 之类的 , 同样的, 如果有两个序号控制字符, 系统会以后面的字符作为控制, 而且, 前面的也会被替换掉, 所以这如果有重复的字符一定要注意 1234567有序列表-- 指定样式:\\begin&#123;enumerate&#125;[test(2,B,b,) 1, A, a, i, I,] \\item 条目1 \\item 条目2 \\item 条目3 \\item .....\\end&#123;enumerate&#125; 同样的, 有序列表的默认是按照等级的, 最低的是直接默认的 1. 其次是 \\begin{enumerate}[1,] 后面的序列控制, 最后面的是在单个项目之前的指定符号, \\item[*] 如果存在的话, 会覆盖相应的符号, 且, 编号会漏过相应的项目. 123456\\begin&#123;enumerate&#125; \\item 条目1 \\item[*] 条目2 \\item[-] 条目3 \\item .....\\end&#123;enumerate&#125; 描述列表 – description此列表主要用于罗列之后进行解释, 不会有编号 符号, 但是会将括号内的次进行加粗加黑处理 如果当前 item 不存在 描述词, 则 默认显示,如 条目 4 但是样式会比较奇怪, 1234567891011\\begin&#123;description&#125; \\item[条目11] 条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1 \\item[条目22] 条目2.. \\item[条目22] 条目3 \\item 条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4\\end&#123;description&#125; 嵌套列表latex 不仅可以单独使用, 恶意是可以进行嵌套使用的,嵌套列表 1234567891011121314151617181920212223242526\\begin&#123;description&#125; \\item[条目11] 条目1条目1条目1条目1条目1条目1条目1 \\begin&#123;enumerate&#125;[A.] \\item 条目1 条目1条目1条目1条目1 \\begin&#123;itemize&#125; \\item 条目1 \\item 条目2 \\item 条目3 \\item ..... \\end&#123;itemize&#125; \\item 条目2 \\item 条目3 \\item ..... \\end&#123;enumerate&#125; \\item[条目22] 条目2.. \\item[条目22] 条目3 \\item 条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4\\end&#123;description&#125; 自定义环境借用参考链接 1 中的图, 可以看到各种命令的说明, 以及 latex 进行排版布局的说明 垂直间距topsep 列表环境与上文之间的距离parsep 条目里面段落之间的距离itemsep 条目之间的距离partopsep 条目与下面段落的距离 水平间距leftmargin 列表环境左边的空白长度rightmargin 列表环境右边的空白长度labelsep 标号与列表环境左侧的距离itemindent 条目的缩进距离labelwidth 标号的宽度listparindent 条目下面段落的缩进距离 同样的, 我们在描述列表中能够看到缩进问题, 导致的显示比较难看, 这里我们可以参考 链接 2 给出的自定义命令的方式进行解决 12345678\\usepackage&#123;blindtext&#125;\\newcommand&#123;\\deflabel&#125;[1]&#123;\\bf #1\\hfill&#125;%\\newenvironment&#123;newlist&#125;[1]%&#123;\\begin&#123;list&#125;&#123;&#125;&#123;\\settowidth&#123;\\labelwidth&#125;&#123;\\bf #1&#125;% \\setlength&#123;\\leftmargin&#125;&#123;\\labelwidth&#125;% \\addtolength&#123;\\leftmargin&#125;&#123;\\labelsep&#125;% \\renewcommand&#123;\\makelabel&#125;&#123;\\deflabel&#125;&#125;&#125;%&#123;\\end&#123;list&#125;&#125; 在导言区设定了新的命令, 我们在文档中直接进行使用就行了, 注意使用的是偶 在 \\begin{newlist} 后面的条目最好填上最长的条目, 这样后面每个项目都缩进相应的尺寸, 达到显示美观的结果 1234567891011\\begin&#123;newlist&#125;&#123;条目11条条目11条&#125; \\item[条目11条条目11条] 条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1 \\item[条目22] 条目2.. \\item[条目22] 条目3 \\item 条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4\\end&#123;newlist&#125; 其他最终附上最后的在线工程 OverLeaf latex-list.tex 可以在 latex-list.tex 看到相应的演示 参考链接 latex 使用 enumitem 宏包调整 enumerate 或 itemize 的上下左右缩进间距 description 环境悬挂缩进 LaTeX 中列表的使用 Latex-条目、编号、描述","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"latex","slug":"latex","permalink":"https://schen1024.github.io/tags/latex/"},{"name":"template","slug":"template","permalink":"https://schen1024.github.io/tags/template/"},{"name":"learn","slug":"learn","permalink":"https://schen1024.github.io/tags/learn/"}]},{"title":"nCOV 数据简要分析 (0326)","slug":"COV-data-analysis","date":"2020-03-26T17:36:42.000Z","updated":"2023-01-01T13:25:24.221Z","comments":true,"path":"2020/03-26/COV-data-analysis.html","link":"","permalink":"https://schen1024.github.io/2020/03-26/COV-data-analysis.html","excerpt":"简介碰巧看到了数据上传, 正在跑数据的我想着要不拟合一下看看, 然后, 就做了两个小时, 这里做一个简单的记录过程, 后续可能做在线的 实时预测,,(坑…) 这个结果还是不能乱发的, 不然下一个谣言就是我了, 狗命要紧.. 时代的一粒尘,落到个人身上就是一座大山,偏偏我们生活在尘土飞扬的时代—— 方方 灾难并不是死了两万人这样一件事，而是死了一个人这件事，发生了两万次——-北野武 这是 灾难给我的印象最深的两句话, 愿逝者安息, RIP 获取数据目前数据很多, 我比较信赖的是 JHU 给的一个 全球的数据集 CSSEGISandData/COVID-19 数据[^covid-19], 也有更为详细的国内的数据集比如 DXY-COVID-19-Data[^dxy-cov], 相信之后也会有很多人进行数据分析, 我这边使用的是 2020 年 3 月 25 日归档数据 数据整理拿到数据之后是一个 502x66的数据, 包括全世界 省/州 62 天来的时间序列数据, 有着国家/省/经纬度 以及时间序列 我们不做具体的每个地区的分析, 这里直接纵向累加即可, 最终得到的数据是 501x62 尺寸的数据进而累加之后 进行时间序列的绘制 这里为了顺手 所以这边分析暂时都是使用的 MATLAB 数据拟合这里避免一些数据问题, 我这单独标记出来了自 25 天的数据,在这之前的数据只有中国的, 这里只取后面的数据进行分析, 第 25 天也就是 2020 年 2 月 16 日的数据, 这里使用了 MATLAB 的 cftool 进行曲线拟合[^cftool] 具体的使用方法见参考链接 这边使用的是二次的指数拟合 $$y=ae^{bx} + ce^{dx}$$ 最终得到的结果如图 最终的到的拟合结果 三组结果都可以, 一般取第一组数据 123456789101112131415General model Exp2: f(x) = a*exp(b*x) + c*exp(d*x)Coefficients (with 95% confidence bounds):a = 7.173e+04 (7.011e+04, 7.336e+04)b = 0.007432 (0.004555, 0.01031)c = 654.7 (443.6, 865.9)d = 0.1647 (0.1564, 0.1729)Goodness of fit: SSE: 9.988e+07 R-square: 0.9994 Adjusted R-square: 0.9994 RMSE: 1767 SSE :错误的平方和。此统计量测量响应的拟合值的偏差。接近 0 的值表示更好的匹配。R-square ：多重测定系数。数值的大小在 0 到 1 之间，越接近 1，表明方程的变量对 y 的解释能力越强。Adjusted R-square ：自由度调整 r 平方。接近 1 的值表示更好的匹配。当您向模型中添加附加系数时, 它通常是适合质量的最佳指示器。RMSE ：均方根误差。接近 0 的值表示更好的匹配。 这里这个数据拟合的已经很好了, 测试发现使用 傅里叶多项式3 次以上也能很好的拟合或者 高斯 4 次以上 都能很好的拟合, 拟合得到的相似程度已经很接近了, 如果单纯的数据分析已经足够了, 真的要去做的话还是要用医学模型进行分析, 这里只是简单的做以下 数据预测有了数据曲线之后能做的事情就很多了, 按照得到的曲线方程进行后续拟合, 然后看什么时候能够达到 100W 的数据大关 如果单纯从数据的角度考虑, 数据拟合的是没有问题的 , 数据显示 大改会在 03/30 号 那天 数据会超过 100W 的情况, 数据仅供参考, 没有任何意义 其他这个结果没有任何意义, 实际上的模型要复杂很多, 我希望这个数据从明天就不再继续增加了, 然后 所有人都恢复健康, 希望数据不会成真, 但是我预感这个数据很可能会突破 100W, 应该在 4 月份的上旬或者 中旬左右, 愿逝者安息, 世间平平安安","text":"简介碰巧看到了数据上传, 正在跑数据的我想着要不拟合一下看看, 然后, 就做了两个小时, 这里做一个简单的记录过程, 后续可能做在线的 实时预测,,(坑…) 这个结果还是不能乱发的, 不然下一个谣言就是我了, 狗命要紧.. 时代的一粒尘,落到个人身上就是一座大山,偏偏我们生活在尘土飞扬的时代—— 方方 灾难并不是死了两万人这样一件事，而是死了一个人这件事，发生了两万次——-北野武 这是 灾难给我的印象最深的两句话, 愿逝者安息, RIP 获取数据目前数据很多, 我比较信赖的是 JHU 给的一个 全球的数据集 CSSEGISandData/COVID-19 数据[^covid-19], 也有更为详细的国内的数据集比如 DXY-COVID-19-Data[^dxy-cov], 相信之后也会有很多人进行数据分析, 我这边使用的是 2020 年 3 月 25 日归档数据 数据整理拿到数据之后是一个 502x66的数据, 包括全世界 省/州 62 天来的时间序列数据, 有着国家/省/经纬度 以及时间序列 我们不做具体的每个地区的分析, 这里直接纵向累加即可, 最终得到的数据是 501x62 尺寸的数据进而累加之后 进行时间序列的绘制 这里为了顺手 所以这边分析暂时都是使用的 MATLAB 数据拟合这里避免一些数据问题, 我这单独标记出来了自 25 天的数据,在这之前的数据只有中国的, 这里只取后面的数据进行分析, 第 25 天也就是 2020 年 2 月 16 日的数据, 这里使用了 MATLAB 的 cftool 进行曲线拟合[^cftool] 具体的使用方法见参考链接 这边使用的是二次的指数拟合 $$y=ae^{bx} + ce^{dx}$$ 最终得到的结果如图 最终的到的拟合结果 三组结果都可以, 一般取第一组数据 123456789101112131415General model Exp2: f(x) = a*exp(b*x) + c*exp(d*x)Coefficients (with 95% confidence bounds):a = 7.173e+04 (7.011e+04, 7.336e+04)b = 0.007432 (0.004555, 0.01031)c = 654.7 (443.6, 865.9)d = 0.1647 (0.1564, 0.1729)Goodness of fit: SSE: 9.988e+07 R-square: 0.9994 Adjusted R-square: 0.9994 RMSE: 1767 SSE :错误的平方和。此统计量测量响应的拟合值的偏差。接近 0 的值表示更好的匹配。R-square ：多重测定系数。数值的大小在 0 到 1 之间，越接近 1，表明方程的变量对 y 的解释能力越强。Adjusted R-square ：自由度调整 r 平方。接近 1 的值表示更好的匹配。当您向模型中添加附加系数时, 它通常是适合质量的最佳指示器。RMSE ：均方根误差。接近 0 的值表示更好的匹配。 这里这个数据拟合的已经很好了, 测试发现使用 傅里叶多项式3 次以上也能很好的拟合或者 高斯 4 次以上 都能很好的拟合, 拟合得到的相似程度已经很接近了, 如果单纯的数据分析已经足够了, 真的要去做的话还是要用医学模型进行分析, 这里只是简单的做以下 数据预测有了数据曲线之后能做的事情就很多了, 按照得到的曲线方程进行后续拟合, 然后看什么时候能够达到 100W 的数据大关 如果单纯从数据的角度考虑, 数据拟合的是没有问题的 , 数据显示 大改会在 03/30 号 那天 数据会超过 100W 的情况, 数据仅供参考, 没有任何意义 其他这个结果没有任何意义, 实际上的模型要复杂很多, 我希望这个数据从明天就不再继续增加了, 然后 所有人都恢复健康, 希望数据不会成真, 但是我预感这个数据很可能会突破 100W, 应该在 4 月份的上旬或者 中旬左右, 愿逝者安息, 世间平平安安 代码最终附带 分析代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960% COV data an[city,day] = size(serial);time_sum = zeros(1,day);for i=1:day time_sum(1,i) = sum(serial(:,i));endplot(time_sum,'-*');days = 1:day;d = 25;l_days = 1:day-d;for i=1:day-d time_sum2(1,i) = sum(serial(:,i+d));endtime_sum2 = time_sum2 - time_sum2(1);% 运行 2月16号之后的数据figurehold on% 从 第25天的数据 也就是 02/16日开始init_day = datetime(2020,02,15);t1 = init_day + l_days;plot(t1,time_sum2,'-o');% 绘制 拟合曲线a = 7.173e+04;b = 0.007432;c = 645.7;d = 0.1647;set_day = 45;hold onx = 1:set_day;y= a*exp(b*x)+c*exp(d*x);% 绘制 10000000 边界线y_max = 1000000*ones(1,set_day);plot(t,y_max);% 绘制 预测线t = init_day+(x);plot(t,y,'-*');% 创建 xlabelxlabel(&#123;'2月16号 以后日期序列'&#125;);datetick('x',6);% 创建 ylabelylabel('Confirm 人数'); 参考链接 2020-03-25 数据存档 [^covid-19]: CSSEGISandData/COVID-19 https://github.com/CSSEGISandData/COVID-19[^dxy-cov]: DXY-COVID-19-Data https://github.com/BlankerL/DXY-COVID-19-Data[^cftool]: matlabcftool 用法及其菜单 https://blog.csdn.net/misskissC/article/details/8797655","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://schen1024.github.io/tags/matlab/"},{"name":"data","slug":"data","permalink":"https://schen1024.github.io/tags/data/"},{"name":"cov","slug":"cov","permalink":"https://schen1024.github.io/tags/cov/"}]},{"title":"多平台博客搭建","slug":"多平台博客搭建","date":"2020-03-25T22:07:44.000Z","updated":"2023-01-01T13:25:24.783Z","comments":true,"path":"2020/03-25/多平台博客搭建.html","link":"","permalink":"https://schen1024.github.io/2020/03-25/%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html","excerpt":"慢慢的有了 经营自己的意识, 自己很早就开始博客, 但是很多东西都是 很快的放弃了, 导致自己废掉的计划很多,也算是经历过一些好玩的东西了, 但是很多都没有记录下来, 现在去想反而没有那么好玩了, 个人经历经历过个人博客建站, 时代, 自己去买主机,或者主机空间, 买域名, 部署后台, 然后部署数据库, 最后设计个人站点, 考虑SEO, 做百度提交….. 每一次动手都会经历一次, 太麻烦了, 后面就只在自己笔记本上写了, 当时也是傻, 好好的博客平台为什么不去写呢, (傻….) 我的经历就想 网上流传的这段话 喜欢写Blog的人，会经历三个阶段。第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。 最开始的博客肯定要算是 wordpress 了, 大名鼎鼎, 但是后面真是太慢了, 后台点一下等三秒, 体验很差 就放弃了,后来转到 emlog, 然后写过一些, 也是逐渐废弃了,在后来就是使用 hexo了, 目前也还在使用,现在呢,则想着多个平台发布自己写的内容, 希望能够帮到别人 多平台博客现阶段主要的协作是本地的 markdown 写作, 主要的写作工具是 VSCode, 然后还有 一个markdown 编辑器 小书匠, 可以在线写作或者本地软件写作, 而且能够将内容同步保存到多个平台, 真的很方便 写作完成使用 hexo deploy 到 github-page 或者 直接 push 到私有仓库, 使用 github-action 进行部署, 可以参考我的文章, hexo 博客, 目前的主博客站点, 除了技术内容还会写一些私密的内容, 太过私人的东西我就加密起来了, 大家都不尴尬 cnblogs 博客, 帮助了我很多, 里面东西质量真的很高, 我爱这个平台, 可以使用小书匠-本地客户端 直接使用 metawebapi 直接发布, meta 数据可以直接读取, 感谢 CSDN 博客 博客内容太乱了, 但是总能找到有用的东西, 但是重复的东西太多,而且广告太多, 所以 当作自己的博客引流工具吧, 其他, 暂时兴趣不大, 更多其实有了更多关注之后, 自己应该会更多的发布自己遇到的问题以及自己解决问题的方法, 如有可能, 帮助到别人真是是自己最开心的 部分..","text":"慢慢的有了 经营自己的意识, 自己很早就开始博客, 但是很多东西都是 很快的放弃了, 导致自己废掉的计划很多,也算是经历过一些好玩的东西了, 但是很多都没有记录下来, 现在去想反而没有那么好玩了, 个人经历经历过个人博客建站, 时代, 自己去买主机,或者主机空间, 买域名, 部署后台, 然后部署数据库, 最后设计个人站点, 考虑SEO, 做百度提交….. 每一次动手都会经历一次, 太麻烦了, 后面就只在自己笔记本上写了, 当时也是傻, 好好的博客平台为什么不去写呢, (傻….) 我的经历就想 网上流传的这段话 喜欢写Blog的人，会经历三个阶段。第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。 最开始的博客肯定要算是 wordpress 了, 大名鼎鼎, 但是后面真是太慢了, 后台点一下等三秒, 体验很差 就放弃了,后来转到 emlog, 然后写过一些, 也是逐渐废弃了,在后来就是使用 hexo了, 目前也还在使用,现在呢,则想着多个平台发布自己写的内容, 希望能够帮到别人 多平台博客现阶段主要的协作是本地的 markdown 写作, 主要的写作工具是 VSCode, 然后还有 一个markdown 编辑器 小书匠, 可以在线写作或者本地软件写作, 而且能够将内容同步保存到多个平台, 真的很方便 写作完成使用 hexo deploy 到 github-page 或者 直接 push 到私有仓库, 使用 github-action 进行部署, 可以参考我的文章, hexo 博客, 目前的主博客站点, 除了技术内容还会写一些私密的内容, 太过私人的东西我就加密起来了, 大家都不尴尬 cnblogs 博客, 帮助了我很多, 里面东西质量真的很高, 我爱这个平台, 可以使用小书匠-本地客户端 直接使用 metawebapi 直接发布, meta 数据可以直接读取, 感谢 CSDN 博客 博客内容太乱了, 但是总能找到有用的东西, 但是重复的东西太多,而且广告太多, 所以 当作自己的博客引流工具吧, 其他, 暂时兴趣不大, 更多其实有了更多关注之后, 自己应该会更多的发布自己遇到的问题以及自己解决问题的方法, 如有可能, 帮助到别人真是是自己最开心的 部分..","categories":[{"name":"Person","slug":"Person","permalink":"https://schen1024.github.io/categories/Person/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://schen1024.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://schen1024.github.io/tags/blog/"},{"name":"cnblogs","slug":"cnblogs","permalink":"https://schen1024.github.io/tags/cnblogs/"},{"name":"csdn","slug":"csdn","permalink":"https://schen1024.github.io/tags/csdn/"}]},{"title":"hexo-themes-setting","slug":"hexo-themes-setting","date":"2020-03-24T21:09:37.000Z","updated":"2023-01-01T13:25:24.266Z","comments":true,"path":"2020/03-24/hexo-themes-setting.html","link":"","permalink":"https://schen1024.github.io/2020/03-24/hexo-themes-setting.html","excerpt":"Hexo 主题配置管理一半有几种方式, 可以删除 git 单独维护也可以使用 hexo 推荐的方式进行维护 所有需要写在主题配置文件中的配置都可以写在站点配置文件的 theme_config: 中 通常情况下，Hexo 主题是一个独立的项目，并拥有一个独立的 _config.yml 配置文件。你可以在站点的 _config.yml 配置文件中配置你的主题，这样你就不需要 fork 一份主题并维护主题独立的配置文件。 以下是一个覆盖主题配置的例子： 123# _config.ymltheme_config: bio: 'My awesome bio' 123# themes/my-theme/_config.ymlbio: 'Some generic bio'logo: 'a-cool-image.png' 最终主题配置的输出是： 1234&#123; \"bio\": \"My awesome bio\", \"logo\": \"a-cool-image.png\"&#125; 然后在项目中, 使用 git submodule 添加模块, 便能直接使用了,","text":"Hexo 主题配置管理一半有几种方式, 可以删除 git 单独维护也可以使用 hexo 推荐的方式进行维护 所有需要写在主题配置文件中的配置都可以写在站点配置文件的 theme_config: 中 通常情况下，Hexo 主题是一个独立的项目，并拥有一个独立的 _config.yml 配置文件。你可以在站点的 _config.yml 配置文件中配置你的主题，这样你就不需要 fork 一份主题并维护主题独立的配置文件。 以下是一个覆盖主题配置的例子： 123# _config.ymltheme_config: bio: 'My awesome bio' 123# themes/my-theme/_config.ymlbio: 'Some generic bio'logo: 'a-cool-image.png' 最终主题配置的输出是： 1234&#123; \"bio\": \"My awesome bio\", \"logo\": \"a-cool-image.png\"&#125; 然后在项目中, 使用 git submodule 添加模块, 便能直接使用了, 参考链接 Advanced Settings「进阶设定」 hexo 文档–配置","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://schen1024.github.io/tags/hexo/"},{"name":"theme","slug":"theme","permalink":"https://schen1024.github.io/tags/theme/"}]},{"title":"GithubAction-Deploy","slug":"GithubAction-Deploy","date":"2020-03-24T20:59:44.000Z","updated":"2023-01-01T13:25:24.227Z","comments":true,"path":"2020/03-24/GithubAction-Deploy.html","link":"","permalink":"https://schen1024.github.io/2020/03-24/GithubAction-Deploy.html","excerpt":"使用 github action 自动化部署创建 GitHub repository 存放源文件在 repo 设置界面里添加 Secrets（本地生成一对公私钥 ssh-keygen，这里填上私钥，命名为 ACTION_DEPLOY_KEY（可以任意命名，但要和 Actions 里的设定$对应)在存放 GitHub pages 的 repo 设定 Deploy keys 为刚生成的公钥在根目录下创建 GitHub Actions workflow 文件 123456789101112131415161718192021222324252627282930name: Build and Update Note.junyangz.com for github pageson: pushjobs: build: runs-on: macOS-latest steps: - uses: actions/checkout@v1 - name: Use Node.js 10.x uses: actions/setup-node@v1 with: node-version: '10.x' - name: Setup Hexo env env: ACTION_DEPLOY_KEY: $&#123;&#123; secrets.ACTION_DEPLOY_KEY &#125;&#125; run: | # set up private key for deploy mkdir -p ~/.ssh/ echo \"$ACTION_DEPLOY_KEY\" &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts # set git infomation git config --global user.name 'Junyangz' git config --global user.email 'junyangz.iie@gmail.com' # install dependencies npm i -g hexo-cli npm i - name: Deploy run: | # generate and depoly hexo g -d","text":"使用 github action 自动化部署创建 GitHub repository 存放源文件在 repo 设置界面里添加 Secrets（本地生成一对公私钥 ssh-keygen，这里填上私钥，命名为 ACTION_DEPLOY_KEY（可以任意命名，但要和 Actions 里的设定$对应)在存放 GitHub pages 的 repo 设定 Deploy keys 为刚生成的公钥在根目录下创建 GitHub Actions workflow 文件 123456789101112131415161718192021222324252627282930name: Build and Update Note.junyangz.com for github pageson: pushjobs: build: runs-on: macOS-latest steps: - uses: actions/checkout@v1 - name: Use Node.js 10.x uses: actions/setup-node@v1 with: node-version: '10.x' - name: Setup Hexo env env: ACTION_DEPLOY_KEY: $&#123;&#123; secrets.ACTION_DEPLOY_KEY &#125;&#125; run: | # set up private key for deploy mkdir -p ~/.ssh/ echo \"$ACTION_DEPLOY_KEY\" &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts # set git infomation git config --global user.name 'Junyangz' git config --global user.email 'junyangz.iie@gmail.com' # install dependencies npm i -g hexo-cli npm i - name: Deploy run: | # generate and depoly hexo g -d 参考链接 GitHub Actions 部署 Hexo 博客 通过 Github Actions 自动部署 Hexo","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"github","slug":"github","permalink":"https://schen1024.github.io/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"https://schen1024.github.io/tags/hexo/"},{"name":"action","slug":"action","permalink":"https://schen1024.github.io/tags/action/"}]},{"title":"回忆碎片-wl","slug":"回忆碎片-wl","date":"2020-03-24T16:41:09.000Z","updated":"2023-01-01T13:25:24.783Z","comments":true,"path":"2020/03-24/回忆碎片-wl.html","link":"","permalink":"https://schen1024.github.io/2020/03-24/%E5%9B%9E%E5%BF%86%E7%A2%8E%E7%89%87-wl.html","excerpt":"","text":"","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://schen1024.github.io/categories/uncategorized/"}],"tags":[]},{"title":"基于粒子群优化的仓储机器人","slug":"基于粒子群优化算法的路径规划仓储机器人","date":"2020-03-05T22:07:44.000Z","updated":"2023-01-01T13:25:24.783Z","comments":true,"path":"2020/03-05/基于粒子群优化算法的路径规划仓储机器人.html","link":"","permalink":"https://schen1024.github.io/2020/03-05/%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%BE%A4%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E4%BB%93%E5%82%A8%E6%9C%BA%E5%99%A8%E4%BA%BA.html","excerpt":"","text":"1.绪论1.课题研究背景与意义2.仓储机器人的简介与分类3.机器人定位与路径规划4.课题主要研究内容2.路径规划介绍路径规划基础1. 建图 2. 定位 基础路径规划算法1. A* 2. D* 粒子群算法 及其优化1. PSO 3. 机器人运行环境设计1. 环境设计1. 仓库/ 货架 情况设计 2. 机器人设计 3. 运行策略 2. 定位与建图1. 室内定位方式 2. 4. 仓储机器人路径规划单机器人运行规划多机器人 路径规划任务设计 单任务 (离线 模式) 路径规划 在线模式, 单机路径规划 连续运行 不同算法 运行仿真5.总结与展望","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"PSO","slug":"PSO","permalink":"https://schen1024.github.io/tags/PSO/"},{"name":"robot","slug":"robot","permalink":"https://schen1024.github.io/tags/robot/"},{"name":"algorithm","slug":"algorithm","permalink":"https://schen1024.github.io/tags/algorithm/"}]},{"title":"ssr的pac中加入学校图书馆数据库访问pac","slug":"ssr的pac中加入学校图书馆数据库访问pac","date":"2020-02-29T18:57:56.000Z","updated":"2023-01-01T13:25:24.779Z","comments":true,"path":"2020/02-29/ssr的pac中加入学校图书馆数据库访问pac.html","link":"","permalink":"https://schen1024.github.io/2020/02-29/ssr%E7%9A%84pac%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%AD%A6%E6%A0%A1%E5%9B%BE%E4%B9%A6%E9%A6%86%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AEpac.html","excerpt":"在家的时候, 需要使用代理, 同时要使用图书馆的数据库, 两个代理有点冲突, 自己研究了一下ssr 的规则, 发现比较简单. 可以页面后贴出的代码进行研究 pac.txt pac 的内部完全就是 js 的语法逻辑, 不是十分熟悉, 写的有点硬, 可以自己考虑优化 执行从 FindProxyForURL 开始执行, 然后根据具体内容进行代理访问 按照学校代理的判断方式, 判断一个 url 是否符合图书馆给出的pac 地址,将访问数据库的链接,执行 PROXY proxy2.lib.whu.edu.cn:81 代理链接, 第一次建立链接的时候, 需要使用图书馆 帐号密码进行验证, 剩余的链接进行 ssr 验证, 进行正常的代理 执行过程.","text":"在家的时候, 需要使用代理, 同时要使用图书馆的数据库, 两个代理有点冲突, 自己研究了一下ssr 的规则, 发现比较简单. 可以页面后贴出的代码进行研究 pac.txt pac 的内部完全就是 js 的语法逻辑, 不是十分熟悉, 写的有点硬, 可以自己考虑优化 执行从 FindProxyForURL 开始执行, 然后根据具体内容进行代理访问 按照学校代理的判断方式, 判断一个 url 是否符合图书馆给出的pac 地址,将访问数据库的链接,执行 PROXY proxy2.lib.whu.edu.cn:81 代理链接, 第一次建立链接的时候, 需要使用图书馆 帐号密码进行验证, 剩余的链接进行 ssr 验证, 进行正常的代理 执行过程. 代码demo 参考链接 PAC代理语法含义与书写规范","categories":[{"name":"SSR","slug":"SSR","permalink":"https://schen1024.github.io/categories/SSR/"}],"tags":[{"name":"proxy","slug":"proxy","permalink":"https://schen1024.github.io/tags/proxy/"},{"name":"SSR","slug":"SSR","permalink":"https://schen1024.github.io/tags/SSR/"},{"name":"pac","slug":"pac","permalink":"https://schen1024.github.io/tags/pac/"}]},{"title":"hexo_docker","slug":"hexo-docker","date":"2020-02-22T13:13:45.000Z","updated":"2023-01-01T13:25:24.266Z","comments":true,"path":"2020/02-22/hexo-docker.html","link":"","permalink":"https://schen1024.github.io/2020/02-22/hexo-docker.html","excerpt":"docker hexo 环境配置安装以下软件 node yarn hexo-cli git","text":"docker hexo 环境配置安装以下软件 node yarn hexo-cli git","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[]},{"title":"latex-图文并排","slug":"latex-图片并排","date":"2020-02-20T20:30:11.000Z","updated":"2023-01-01T13:25:24.772Z","comments":true,"path":"2020/02-20/latex-图片并排.html","link":"","permalink":"https://schen1024.github.io/2020/02-20/latex-%E5%9B%BE%E7%89%87%E5%B9%B6%E6%8E%92.html","excerpt":"Latex 图文并排我们在论文中进行论文混排的时候, 主要有三种, 单图插入 双图并列 多图混排 我们主要使用的图片排版工具包是 12\\usepackage&#123;graphicx&#125;\\usepackage&#123;subfigure&#125; 1. 单图插入使用 \\begin{figure} 作为环境的开始, 使用 \\includegraphics 图片引入, 并进行尺寸设置并能使用 \\caption 做图片题注, 使用 \\label 作为引用标识, [latex 插入单图代码] [] [] []view raw123456\\begin{figure}[!htbp] \\centering \\includegraphics[height=4.5cm,width=9.5cm]{dm_hb.png} \\caption[图片短标题,显示在目录]{这里是显示在图片下面的长标题} \\label{fig:1} % 用于引用图片\\end{figure} 2. 双图并列双图并列 一半有两种 两个单独的图展示 不共享标题 一个图里面的 abc 子图 共享统一标题 可单独子标题 [latex 双图并列] [] [] []view raw12345678910111213141516172. 双图并列展示, 分别使用 abc 来标识子图\\begin{figure}[!htbp] \\centering \\subfigure[pic1.1111111111111]{ \\begin{minipage}[t]{0.5\\linewidth} \\centering \\includegraphics[width=\\textwidth]{dm_hb.png} \\end{minipage}% }% \\subfigure[pic2. 2222222]{ \\begin{minipage}[t]{0.5\\linewidth} \\centering \\includegraphics[width=\\linewidth]{dm_hb.png} \\end{minipage}% }% \\caption{总图的标识}\\end{figure} 3. 4 图栅格布局注意 第 2 个和第 3 个图之间 加入一个换行, 保证图片 强制换行显示[latex 双图并列] [] [] []view raw1234567891011121314151617181920212223242526272829\\begin{figure}[!htbp] \\centering \\subfigure[pic1.1111111111111]{ \\begin{minipage}[t]{0.5\\linewidth} \\centering \\includegraphics[width=\\textwidth]{dm_hb.png} \\end{minipage}% }% \\subfigure[pic2. 2222222]{ \\begin{minipage}[t]{0.5\\linewidth} \\centering \\includegraphics[width=\\linewidth]{dm_hb.png} \\end{minipage}% }% \\subfigure[pic1.333333333333333]{ \\begin{minipage}[t]{0.5\\linewidth} \\centering \\includegraphics[width=\\textwidth]{dm_hb.png} \\end{minipage}% }% \\subfigure[pic2. 44444444444]{ \\begin{minipage}[t]{0.5\\linewidth} \\centering \\includegraphics[width=\\linewidth]{dm_hb.png} \\end{minipage}% }% \\caption{总图的标识}\\end{figure}","text":"Latex 图文并排我们在论文中进行论文混排的时候, 主要有三种, 单图插入 双图并列 多图混排 我们主要使用的图片排版工具包是 12\\usepackage&#123;graphicx&#125;\\usepackage&#123;subfigure&#125; 1. 单图插入使用 \\begin{figure} 作为环境的开始, 使用 \\includegraphics 图片引入, 并进行尺寸设置并能使用 \\caption 做图片题注, 使用 \\label 作为引用标识, [latex 插入单图代码] [] [] []view raw123456\\begin{figure}[!htbp] \\centering \\includegraphics[height=4.5cm,width=9.5cm]{dm_hb.png} \\caption[图片短标题,显示在目录]{这里是显示在图片下面的长标题} \\label{fig:1} % 用于引用图片\\end{figure} 2. 双图并列双图并列 一半有两种 两个单独的图展示 不共享标题 一个图里面的 abc 子图 共享统一标题 可单独子标题 [latex 双图并列] [] [] []view raw12345678910111213141516172. 双图并列展示, 分别使用 abc 来标识子图\\begin{figure}[!htbp] \\centering \\subfigure[pic1.1111111111111]{ \\begin{minipage}[t]{0.5\\linewidth} \\centering \\includegraphics[width=\\textwidth]{dm_hb.png} \\end{minipage}% }% \\subfigure[pic2. 2222222]{ \\begin{minipage}[t]{0.5\\linewidth} \\centering \\includegraphics[width=\\linewidth]{dm_hb.png} \\end{minipage}% }% \\caption{总图的标识}\\end{figure} 3. 4 图栅格布局注意 第 2 个和第 3 个图之间 加入一个换行, 保证图片 强制换行显示[latex 双图并列] [] [] []view raw1234567891011121314151617181920212223242526272829\\begin{figure}[!htbp] \\centering \\subfigure[pic1.1111111111111]{ \\begin{minipage}[t]{0.5\\linewidth} \\centering \\includegraphics[width=\\textwidth]{dm_hb.png} \\end{minipage}% }% \\subfigure[pic2. 2222222]{ \\begin{minipage}[t]{0.5\\linewidth} \\centering \\includegraphics[width=\\linewidth]{dm_hb.png} \\end{minipage}% }% \\subfigure[pic1.333333333333333]{ \\begin{minipage}[t]{0.5\\linewidth} \\centering \\includegraphics[width=\\textwidth]{dm_hb.png} \\end{minipage}% }% \\subfigure[pic2. 44444444444]{ \\begin{minipage}[t]{0.5\\linewidth} \\centering \\includegraphics[width=\\linewidth]{dm_hb.png} \\end{minipage}% }% \\caption{总图的标识}\\end{figure} 代码样例此处给出 Overleaf Latex 图文混排 MWE 的最小工程, 可以在线查看运行 或者复制 下面的代码进行运行 [latex 图文混排 代码实例] []view raw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100\\documentclass{article}% 中文包\\usepackage[UTF8]{ctex}% 导言区% 图片排版工具\\usepackage{graphicx}\\usepackage{subfigure}\\usepackage{float}\\usepackage{subfigure}\\title{Latex模板}\\author{SChen1024 }\\date{March 2020}\\begin{document}% \\maketitle\\section{latex 图片布局}\\subsection{单图}\\begin{figure}[!htbp] \\centering \\includegraphics[height=4.5cm,width=9.5cm]{dm_hb.png} \\caption[图片短标题,显示在目录]{这里是显示在图片下面的长标题} \\label{fig:1} % 用于引用图片\\end{figure}\\subsection{双图并排}1. 双图并列展示, 算是不同的图% 文档中添加\\begin{figure}[!htbp]true\\begin{minipage}[t]{0.5\\linewidth}truetrue\\centeringtruetrue\\includegraphics[width=\\textwidth]{dm_hb.png}truetrue\\caption{测试图1}truetrue\\label{fig:1}true\\end{minipage}true\\begin{minipage}[t]{0.5\\linewidth}truetrue\\centeringtruetrue\\includegraphics[width=\\textwidth]{dm_hb.png}truetrue\\caption{测试图2}truetrue\\label{fig:2}true\\end{minipage} \\\\\\end{figure}2. 双图并列展示, 分别使用 abc 来标识子图\\begin{figure}[!htbp] \\centering \\subfigure[pic1.1111111111111]{ \\begin{minipage}[t]{0.5\\linewidth} \\centering \\includegraphics[width=\\textwidth]{dm_hb.png} \\end{minipage}% }% \\subfigure[pic2. 2222222]{ \\begin{minipage}[t]{0.5\\linewidth} \\centering \\includegraphics[width=\\linewidth]{dm_hb.png} \\end{minipage}% }% \\caption{总图的标识}\\end{figure}3. 四张图片的排列\\begin{figure}[!htbp] \\centering \\subfigure[pic1.1111111111111]{ \\begin{minipage}[t]{0.5\\linewidth} \\centering \\includegraphics[width=\\textwidth]{dm_hb.png} \\end{minipage}% }% \\subfigure[pic2. 2222222]{ \\begin{minipage}[t]{0.5\\linewidth} \\centering \\includegraphics[width=\\linewidth]{dm_hb.png} \\end{minipage}% }% \\subfigure[pic1.333333333333333]{ \\begin{minipage}[t]{0.5\\linewidth} \\centering \\includegraphics[width=\\textwidth]{dm_hb.png} \\end{minipage}% }% \\subfigure[pic2. 44444444444]{ \\begin{minipage}[t]{0.5\\linewidth} \\centering \\includegraphics[width=\\linewidth]{dm_hb.png} \\end{minipage}% }% \\caption{总图的标识}\\end{figure}\\end{document} 参考链接 LaTeX 技巧 901：驯化 LaTeX 页面布局 LaTeX 文档多图排版 LaTeX 如何让两张图并排显示？","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"latex","slug":"latex","permalink":"https://schen1024.github.io/tags/latex/"},{"name":"overleaf","slug":"overleaf","permalink":"https://schen1024.github.io/tags/overleaf/"}]},{"title":"罗盘校准","slug":"罗盘校准设计","date":"2020-01-06T16:21:04.000Z","updated":"2023-01-01T13:25:24.789Z","comments":true,"path":"2020/01-06/罗盘校准设计.html","link":"","permalink":"https://schen1024.github.io/2020/01-06/%E7%BD%97%E7%9B%98%E6%A0%A1%E5%87%86%E8%AE%BE%E8%AE%A1.html","excerpt":"罗盘校准过程 打开串口 发送定时校准命令 设定校准时间 1 分钟回复 68 05 00 08 00 0D 接收校准进度 输出残差 罗盘校准状态表示 串口未打开 –&gt; 打开串口 –&gt; flg -1 未开始校准 -&gt; 发送定时校准命令 0 校准中 -&gt; 校准进度中 校准完成 或者 定时时间到 –&gt; 校准结束 -&gt; 校准残差-&gt; 校准结果5. 校准设计 点击校准进入校准界面, 初始化按钮显示,状态显示, 串口数据框内容, 选择串口参数, 点击打开串口 串口打开, 设计定时器, 循环读取串口数据 查看接收到的数据的命令位命令, 根据收到的命令一起当前状态更新串口状态, 直到收到结果表示罗盘校准完成, 结束校准 罗盘校准流程图12345678910111213141516171819202122232425262728293031323334353637383940414243444546sequenceDiagram participant UI as 界面UI participant Serial as 串口 participant Compass as 电子罗盘 participant Status as 校准状态 Note over Status: 0: 串口未开启 UI -&gt;&gt;+ Serial: 打开串口 Note over Status: 1: 连续接收模式 opt 连续接收到数据 Serial -&gt;&gt; Compass: [停止连续发送模式] end Note over Status: 2: 交互模式 UI -&gt;&gt; Serial: 一分钟校准 Serial -&gt;&gt; Compass: [定时一分钟校准] Note over Status: 3: 校准模式 loop 读取电子罗盘数据 Compass -&gt;&gt; Serial: [回复指令] opt Recv Data Note over Serial: 查看关键命令字 alt 0x08 &amp;&amp; Status &#x3D;&#x3D; 3 # Serial -&gt;&gt; UI: 进入校准模式 Note over Serial: 进入校准模式 else 0xF9 Note over Status: 4: 校准中 Note over Serial: 校准中 更新接收 # Serial -&gt;&gt; Serial: 校准中 更新接收进度 Compass -&gt;&gt; Compass: 进行26点椭球拟合旋转 else 0xA8 Note over Status: 5: 校准结果 # Serial -&gt;&gt; UI: 显示校准残差 Note over Serial: 校准残差 else 0x08 &amp;&amp; Status &#x3D;&#x3D; 5 Note over Status: 6: 校准完成 # Serial -&gt;&gt; UI: 显示校准结果 end end Serial -&gt;&gt; UI: 在文本框中显示回复指令 end UI -&gt;&gt;- Serial: 校准完成 Note over Status: -1: 清理结果 Note over UI: 返回操作界面","text":"罗盘校准过程 打开串口 发送定时校准命令 设定校准时间 1 分钟回复 68 05 00 08 00 0D 接收校准进度 输出残差 罗盘校准状态表示 串口未打开 –&gt; 打开串口 –&gt; flg -1 未开始校准 -&gt; 发送定时校准命令 0 校准中 -&gt; 校准进度中 校准完成 或者 定时时间到 –&gt; 校准结束 -&gt; 校准残差-&gt; 校准结果5. 校准设计 点击校准进入校准界面, 初始化按钮显示,状态显示, 串口数据框内容, 选择串口参数, 点击打开串口 串口打开, 设计定时器, 循环读取串口数据 查看接收到的数据的命令位命令, 根据收到的命令一起当前状态更新串口状态, 直到收到结果表示罗盘校准完成, 结束校准 罗盘校准流程图12345678910111213141516171819202122232425262728293031323334353637383940414243444546sequenceDiagram participant UI as 界面UI participant Serial as 串口 participant Compass as 电子罗盘 participant Status as 校准状态 Note over Status: 0: 串口未开启 UI -&gt;&gt;+ Serial: 打开串口 Note over Status: 1: 连续接收模式 opt 连续接收到数据 Serial -&gt;&gt; Compass: [停止连续发送模式] end Note over Status: 2: 交互模式 UI -&gt;&gt; Serial: 一分钟校准 Serial -&gt;&gt; Compass: [定时一分钟校准] Note over Status: 3: 校准模式 loop 读取电子罗盘数据 Compass -&gt;&gt; Serial: [回复指令] opt Recv Data Note over Serial: 查看关键命令字 alt 0x08 &amp;&amp; Status &#x3D;&#x3D; 3 # Serial -&gt;&gt; UI: 进入校准模式 Note over Serial: 进入校准模式 else 0xF9 Note over Status: 4: 校准中 Note over Serial: 校准中 更新接收 # Serial -&gt;&gt; Serial: 校准中 更新接收进度 Compass -&gt;&gt; Compass: 进行26点椭球拟合旋转 else 0xA8 Note over Status: 5: 校准结果 # Serial -&gt;&gt; UI: 显示校准残差 Note over Serial: 校准残差 else 0x08 &amp;&amp; Status &#x3D;&#x3D; 5 Note over Status: 6: 校准完成 # Serial -&gt;&gt; UI: 显示校准结果 end end Serial -&gt;&gt; UI: 在文本框中显示回复指令 end UI -&gt;&gt;- Serial: 校准完成 Note over Status: -1: 清理结果 Note over UI: 返回操作界面","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://schen1024.github.io/tags/C/"},{"name":"Serial","slug":"Serial","permalink":"https://schen1024.github.io/tags/Serial/"}]},{"title":"python读取txt批量创建文件","slug":"python读取txt批量创建文件","date":"2019-12-30T17:03:56.000Z","updated":"2023-01-01T13:25:24.778Z","comments":true,"path":"2019/12-30/python读取txt批量创建文件.html","link":"","permalink":"https://schen1024.github.io/2019/12-30/python%E8%AF%BB%E5%8F%96txt%E6%89%B9%E9%87%8F%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6.html","excerpt":"前几天有个小问题, 需要批量建立很多文件夹,, 所以手动写了个小的脚本, 后续可以直接使用 读取目录文件, 然后直接创建相应的文件 基本思路: 就是读取用户输入参数, 获取所在路径以及所要命名的后缀 获取txt所在路径, 得到同级目录 读取txt 的每一行 并计数得到数字 根据同级目录拼接路径, 创建文件(如果存在不覆盖) 输出结果","text":"前几天有个小问题, 需要批量建立很多文件夹,, 所以手动写了个小的脚本, 后续可以直接使用 读取目录文件, 然后直接创建相应的文件 基本思路: 就是读取用户输入参数, 获取所在路径以及所要命名的后缀 获取txt所在路径, 得到同级目录 读取txt 的每一行 并计数得到数字 根据同级目录拼接路径, 创建文件(如果存在不覆盖) 输出结果 代码demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/python# -*- coding: UTF-8 -*-import sysimport os# 输入 指定 txt 文件路径, 创建文件的后缀 txt js# 读取指定文件的txt 文档# 在 txt 的同级目录下面建立相应的文件def ReadArg(): \"\"\" 通过sys模块来识别参数demo, http://blog.csdn.net/ouyang_peng/ \"\"\" print('参数个数为:', len(sys.argv), '个参数。') print('参数列表:', str(sys.argv)) print('脚本名为：', sys.argv[0]) for i in range(1, len(sys.argv)): print('参数 %s 为：%s' % (i, sys.argv[i])) return sys.argvdef ReadTxtLists(file): ''' 读物 txt 文件中的文件列表 ''' res =[] with open(file,'r') as f: for line in f: line.strip('\\n') line = ''.join(line.split()) res.append(line) return resdef CreateFile(file): with open(file, 'a'): os.utime(file,None)def main(): argv = ReadArg() suffix = \"txt\" # 默认后缀 # 只有两个参数表示没有 给后缀名 if(len(argv) &gt;= 3): suffix = argv[2] file_name= argv[1] # 读取得到所有的文件名 files = ReadTxtLists(file_name) (filepath, filename) = os.path.split(file_name) # 计数 生成拼接文件 # 最终创建文件 如果存在 不更新文件 cnt = 0 for file in files: cnt += 1 file_str = filepath + \"\\\\\" + str(cnt).zfill(2) + \"_\" + file + \".\" + suffix CreateFile(file_str) print(file_str+'\\n')if __name__ == \"__main__\": main()","categories":[{"name":"python","slug":"python","permalink":"https://schen1024.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://schen1024.github.io/tags/python/"},{"name":"batch","slug":"batch","permalink":"https://schen1024.github.io/tags/batch/"},{"name":"file","slug":"file","permalink":"https://schen1024.github.io/tags/file/"}]},{"title":"串口字符串-HEX格式","slug":"串口字符串-HEX格式","date":"2019-12-24T11:43:32.000Z","updated":"2023-01-01T13:25:24.780Z","comments":true,"path":"2019/12-24/串口字符串-HEX格式.html","link":"","permalink":"https://schen1024.github.io/2019/12-24/%E4%B8%B2%E5%8F%A3%E5%AD%97%E7%AC%A6%E4%B8%B2-HEX%E6%A0%BC%E5%BC%8F.html","excerpt":"介绍串口通信过程中 通常涉及一个数据的模拟过程以及数据发送过程, 一般来说, 我们会发送一串指令给下位机 168 05 00 84 01 02 03 例如这种, 我们明白 这是我们 将相应的字符转换成 hex 字符显示,用于表示 ascii 字母的使用, 但是在程序中 我们可以直接使用 字符串表示我们想写入的字符, 容纳后转换之后 串口数据相应的 ASCII 码的过程, 下面 介绍一下常用的转换函数 数据格式在我们的描述中,首先给出一个 或者参考 Wikipedia ACII 的详细介绍此处我们均使用 “abc123” 作为字符串在各个里面的显示来表示 字符串 string 指的是 “abc 123” 这种能用 ascii 表示的 能够打出来的字符, 由于我们部分字符不能打出来,或者说是 不可显示字符,只用于控制指令, 存在缺陷 string str = “abc123” 字符串数组 char [] uchar[] 指 cpp 中 的一种数据, 存放的 char 型或者 uchar 的字符, 我们可以使用 -128-127 或者 0-255 的数字表示, 我们暂时均认为是 uchar 的数组 便于后续处理 uchar buffer= {97,98,99,49,50,51} 字符串指针 char uchar 是类型指针,一般指向的是字符串数据的首地址,由于我们处理过程中 很多函数 认为 0x00 ‘\\0’ 是结束,所以处理的时候尽量传入 长度 uchar *buffer = buffer hex 字符串 将字符串数组里面的值转换成 16 进制的两位值,然后使用空格分割, 便于输入指令, 例如 string command=”61 62 63 31 32 33” 这种合适各有优劣, 比如我们在常用的 Modbus 控制中 使用 这种控制命令发送到下位机, 一般直接在串口输入, 然后使用 hex 发送即可, 但是如果我们测试过程中 需要将相应的数据按照两位的段, 填入 txt 文本中, 每次读取一行数据, 然后将数据转换成 ascii 便能模拟 二进制流的输入输出 168 13 00 85 11 12 21 22 31 32 00 00 01 00 00 02 00 00 03 88 FF 01 02 03 04 05 0F","text":"介绍串口通信过程中 通常涉及一个数据的模拟过程以及数据发送过程, 一般来说, 我们会发送一串指令给下位机 168 05 00 84 01 02 03 例如这种, 我们明白 这是我们 将相应的字符转换成 hex 字符显示,用于表示 ascii 字母的使用, 但是在程序中 我们可以直接使用 字符串表示我们想写入的字符, 容纳后转换之后 串口数据相应的 ASCII 码的过程, 下面 介绍一下常用的转换函数 数据格式在我们的描述中,首先给出一个 或者参考 Wikipedia ACII 的详细介绍此处我们均使用 “abc123” 作为字符串在各个里面的显示来表示 字符串 string 指的是 “abc 123” 这种能用 ascii 表示的 能够打出来的字符, 由于我们部分字符不能打出来,或者说是 不可显示字符,只用于控制指令, 存在缺陷 string str = “abc123” 字符串数组 char [] uchar[] 指 cpp 中 的一种数据, 存放的 char 型或者 uchar 的字符, 我们可以使用 -128-127 或者 0-255 的数字表示, 我们暂时均认为是 uchar 的数组 便于后续处理 uchar buffer= {97,98,99,49,50,51} 字符串指针 char uchar 是类型指针,一般指向的是字符串数据的首地址,由于我们处理过程中 很多函数 认为 0x00 ‘\\0’ 是结束,所以处理的时候尽量传入 长度 uchar *buffer = buffer hex 字符串 将字符串数组里面的值转换成 16 进制的两位值,然后使用空格分割, 便于输入指令, 例如 string command=”61 62 63 31 32 33” 这种合适各有优劣, 比如我们在常用的 Modbus 控制中 使用 这种控制命令发送到下位机, 一般直接在串口输入, 然后使用 hex 发送即可, 但是如果我们测试过程中 需要将相应的数据按照两位的段, 填入 txt 文本中, 每次读取一行数据, 然后将数据转换成 ascii 便能模拟 二进制流的输入输出 168 13 00 85 11 12 21 22 31 32 00 00 01 00 00 02 00 00 03 88 FF 01 02 03 04 05 0F 数据格式转换1. uchar 数据和 char 字节数据的相互转换char 类型的数据 -128-127, uchar 类型数据 0-255, 均是一个字节, char 类型的首位数据为符号位, 所以会存在从 127(0111 1111) +1 之后变成 -128(1000 0000) 的变换, 然后也会存在从-1(1111 1111) 到 0(0000 0000) 的变换, 详细可以搜索 char 溢出 与 数据补码 的相关内容, 所以 uchar -char 的相互变换可以考虑成 两个部分uchar 的 [0, 127] == char [0,127]ucahr 的 [128, 255] == char [-128,-1] 1234567891011// uchar 数据转换 char &gt;127 c1-256char Utils_String::UChar2Char(uchar c1)&#123; return static_cast&lt;char&gt;(c1 &gt; 127 ? c1 - 256 : c1);&#125;// char 类型转换 uchar &lt;0 -- c1 +256uchar Utils_String::Char2UChar(char c1)&#123; return static_cast&lt;uchar&gt;((c1 &lt; 0 ? 256 + c1 : c1));&#125; 2. hex 与数字的相互转换一般的 hex 表示的 16 进制字符, 由于为了便于我们进行显示, 16 进制由 0-9 a-f 供给 16 个字符依次表示 0-15 , 此处暂时不考虑 大写字母, 大写的 A-F 等同于小写的 a-f, 由于 uchar 类型的数据在 0-256 之间, 正好可以表示成 2 个 16 进制字符来进行表示, 使用前缀字符 0x 表示 16 进制, 0o 表示 8 进制 0d 表示 10 进制 [0,255] ==[0x00,0xff]我们建立一位字符 0-f 与 0-15 之间的转换, 有两种转换方式, 一种就是 if 判断进行强制转换, 另外一种 是使用 码表的排列进行一定 的优化处理 1位hex 与num 的相互转换代码1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @fn int Utils_String::Hex2Num(const char ch) * * @brief 根据 各种情况 转换字母 一位字母 大于 48 的 +9 然后取后4位的值 * * * * @author IRIS_Chen * @date 2019/12/16 * * @param ch The ch * * @return An int */int Utils_String::Hex2Num(const char ch)&#123; //int res = (ch &amp; '@' ? ch + 9 : ch) &amp; 0x0F; //LInfo(\"ch:&#123;&#125;,res:&#123;&#125;\", ch, res); return (ch &amp; '@' ? ch + 9 : ch) &amp; 0x0F;&#125;/** * @fn char Utils_String::Num2Hex(int num, bool Up ) * * @brief 将 0-15 转换成 0-F * * @author IRIS_Chen * @date 2019/12/18 * * @param num Number of * @param Up True to up * * @return The total number of 2 hexadecimal */char Utils_String::Num2Hex(int num, bool Up /* = true */)&#123; char res; if (num &gt;= 10 &amp;&amp; num &lt;= 15) &#123; res = num - 10 + (Up ? 'A' : 'a'); &#125; else res = num + '0'; return res;&#125;1位hex 与num 的相互转换代码 2位hex 与 uchar相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * @fn uchar Utils_String::Hex2Uchar(const std::string &amp; str) * * @brief Hexadecimal 2 uchar 将两个 hex 字符 转换成 0-256 * * @author IRIS_Chen * @date 2019/12/18 * * @param str The string 默认初始两位字符 FF == 255 00 = 0 0D = 14 * * @return An uchar */uchar Utils_String::Hex2Uchar(const std::string &amp; str)&#123; uchar res = 0; for (const auto &amp;s:str) &#123; res = (res &lt;&lt; 4) + Hex2Num(s); &#125; return res;&#125;/** * @fn std::string Utils_String::Num2Hex(uchar num, bool Up) * * @brief Number 2 hexadecimal 得到的结果只有 小写 * * @author IRIS_Chen * @date 2019/12/18 * * @param num Number of * @param Up True to up * * @return The total number of 2 hexadecimal */std::string Utils_String::Num2Hex(uchar num, bool Up)&#123; std::map&lt;int, char&gt; t_base = &#123; &#123; 8,'o' &#125;, &#123; 10,'d' &#125;, &#123; 16,'x' &#125; &#125;; if (!t_base.count(base)) return \"\"; // 使用 sprintf 格式化输出, 将数字 转换成相应的进制值 std::string format = \"%0\" + std::to_string(width) + t_base.find(base)-&gt;second; char *buf = new char[20]; sprintf(buf, format.c_str(), num); std::string res=std::string(buf); // 转换大小写 return Up ? StringUpper(res) : StringLowwer (res);&#125; 3. 给定字符串转换成字符串数组由于 原生的 string 存在字符转指针的转换可以使用 原生的指针来处理 123456789101112131415161718192021222324252627282930313233/** * @fn const uchar * Utils_String::String2Uchar(const std::string &amp; str) * * @brief String 2 uchar * * @author IRIS_Chen * @date 2019/12/16 * * @param str The string * * @return Null if it fails, else a pointer to a const uchar */const uchar * Utils_String::String2Uchar(const std::string &amp; str)&#123; return (uchar*)str.c_str();&#125;/** * @fn std::string Utils_String::Uchar2String(const uchar * buffer) * * @brief Uchar 2 string * * @author IRIS_Chen * @date 2019/12/16 * * @param buffer The buffer * * @return A std::string */std::string Utils_String::Uchar2String(const uchar * buffer)&#123; std::string str = (char*)buffer; return str;&#125; 4. hex 字符串 转换 字符串数组依次取两个字符, 转换成一个 ucahr 值 存入数据中即可 hex 字符串 与字符串数组的相互转换 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * @fn uchar * Utils_String::Hex2CharArr(uchar *&amp;buffer, const std::string &amp; str, bool flg_space) * * @brief Hexadecimal 2 character array hex 字符串 转换成 数组 * * @author IRIS_Chen * @date 2019/12/18 * * @param [in,out] buffer [in,out] If non-null, the buffer * @param str The string * @param flg_space True to flg space hex 是否使用空格分割 * * @return Null if it fails, else a pointer to an uchar */uchar * Utils_String::Hex2CharArr(uchar *&amp;buffer, const std::string &amp; str, bool flg_space)&#123; // 出错 只有两个值 默认不符合 操作 if (str.size() &lt; 3) return nullptr; // 默认够长 判断是否存在空格 if (str[2] == ' ') flg_space = true; int step = flg_space ? 3 : 2; buffer = new uchar[(str.size() + 1) / step +1 ]; std::string str2 = \"\"; for (int i = 0; i &lt; static_cast&lt;int&gt;(str.size());) &#123; uchar ch = Hex2Uchar(str.substr(static_cast&lt;size_t&gt;(i), 2)); // 根据是否有空格选择 移动 *(buffer + i/step) = ch; i += step; str2 += std::to_string((int)ch) + \"-\"; &#125; // LInfo(\"charArr:&#123;&#125;\", str2); return buffer;&#125;/** * @fn std::string Utils_String::CharArr2Hex(uchar * buffer, int length, int flg_space) * * @brief Character array 2 hexadecimal 数组 转换成 hex 字符 * * 将UCHAR 字符串依次转换成 string 字符串 * * @author IRIS_Chen * @date 2019/12/18 * * @param [in,out] buffer If non-null, the buffer * @param length The length * @param flg_space The flg space * * @return A std::string */std::string Utils_String::CharArr2Hex(uchar * buffer, int length, int flg_space)&#123; std::string str = \"\"; // 读取数组中所有字符 for (int i = 0; i &lt; length; i++) &#123; str += Num2Hex(*buffer++); // 如果开启空格的话 每两个字符 之间加入一个空格 最后一个不加 if (flg_space &amp;&amp; i != length - 1) str += \" \"; &#125; return str;&#125; 更多大概就这么多常用的转换过程, 还存在一个 单独 数组转换 字符串的函数, 可以使用 sprintf 格式化输出, 或者使用 暴力循环取余得到最后的结果值 数字与字符串的转换 可多位 多进制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * @fn std::string Utils_String::NumToString(int num, int width, int base) * * @brief Number to string 整型数据 前补 0 占位符显示 进制 为 8 10 16 如果超过给出的宽度 原始宽度显示 * * @author IRIS_Chen * @date 2019/12/3 * * @param num Number of * @param width The width * @param base The base * * @return The total number of to string */std::string Utils_String::NumToString(int num, int width, int base)&#123;#if 0 // 保证 存在进制 只考虑 2 8 , 10 16 进制 static std::map&lt;int, char&gt; t_base = &#123; &#123; 2,'0' &#125;, &#123; 8,'o' &#125;, &#123; 10,'d' &#125;, &#123; 16,'x' &#125; &#125;; if (!t_base.count(base)) return \"\"; // 二进制 特殊处理 if (base == 2) &#123; std::string str_8 = NumToString(num, width, 8); // 设置8进制 转2进制码表, 转换之后 去除前缀0 即可 static const std::vector&lt;std::string&gt; table = &#123; \"000\",\"001\",\"010\",\"011\",\"100\",\"101\",\"110\",\"111\" &#125;; std::string str_2 = \"\"; for (auto s : str_8) &#123; if(s =='0') continue; str_2 += table[s - '0']; &#125; // 去掉前面所有的 0值 从1 开始 int pos = static_cast&lt;int&gt;(str_2.find_first_of('1')); // #TODO(Schen00) 处理, 得到的长度小于width 的情况 return pos == std::string::npos ?\"\":str_2.substr (pos); &#125; std::string format = \"%0\" + std::to_string(width) + t_base.find(base)-&gt;second; char *buf = new char[20]; sprintf(buf, format.c_str(), num); return std::string(buf);#else std::string res = \"\"; while (num) &#123; res = base == 16 ? Num2Hex(num % base) : (num % base + '0') + res; num /= base; &#125; // 不足位 补0 足位 不删除 int cnt = width - res.size(); while (cnt--) &#123; res = '0' + res; &#125; return res;#endif&#125;","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://schen1024.github.io/tags/C/"},{"name":"Serial","slug":"Serial","permalink":"https://schen1024.github.io/tags/Serial/"},{"name":"SerialPort","slug":"SerialPort","permalink":"https://schen1024.github.io/tags/SerialPort/"},{"name":"HEX","slug":"HEX","permalink":"https://schen1024.github.io/tags/HEX/"}]},{"title":"OpenCV0-项目启程","slug":"OpenCV0-项目启程","date":"2019-12-20T15:11:40.000Z","updated":"2023-01-01T13:25:24.234Z","comments":true,"path":"2019/12-20/OpenCV0-项目启程.html","link":"","permalink":"https://schen1024.github.io/2019/12-20/OpenCV0-%E9%A1%B9%E7%9B%AE%E5%90%AF%E7%A8%8B.html","excerpt":"每当自己面临困难的时候, 自己总会给自己找很多事来做, 显得自己做的很好一样, 总是给自己一个很大的期望,认为自己能够做好, 这次的我在胡思乱想之际, 开始了两个项目, 其中一个就是现在正在规划的 opencv 大项目 前因后果自己开始使用opencv 也有一年半的时间了, 从最开始的实现起来很简单, 到后面有过一定的深入理解, 但是在事实上, 自己做的远远不够, 甚至在很多时候, 仅仅是调用api 而已, 之前参与过 一个 opencv4.0中文文档 的中文文档的翻译项目, 但是他们只是简单的做下去,并没有做的很深, 而且他们由于一些原因似乎出现了问题.所以, 这边 之后可能考虑 不仅是翻译原本的教程, 同时发布相关的源码解析过程, 做单独的 opencv 各个模块的解析过程 总体构成介绍 opencv- blog 个人研究 opencv 的相关内容介绍, 使用简单的 hexo 搭建的blog 项目 source - opencv 的源码 根据当前时间 2019-12-20 使用较新 的版本 opencv-4.1.2 版本源码, soft - 自己实现的基于 QT 做的界面的 opencv 的一个基础使用库, 用于实现opencv 的算法功能, 实现的过程也会发布到相应的 blog 内容中 其他","text":"每当自己面临困难的时候, 自己总会给自己找很多事来做, 显得自己做的很好一样, 总是给自己一个很大的期望,认为自己能够做好, 这次的我在胡思乱想之际, 开始了两个项目, 其中一个就是现在正在规划的 opencv 大项目 前因后果自己开始使用opencv 也有一年半的时间了, 从最开始的实现起来很简单, 到后面有过一定的深入理解, 但是在事实上, 自己做的远远不够, 甚至在很多时候, 仅仅是调用api 而已, 之前参与过 一个 opencv4.0中文文档 的中文文档的翻译项目, 但是他们只是简单的做下去,并没有做的很深, 而且他们由于一些原因似乎出现了问题.所以, 这边 之后可能考虑 不仅是翻译原本的教程, 同时发布相关的源码解析过程, 做单独的 opencv 各个模块的解析过程 总体构成介绍 opencv- blog 个人研究 opencv 的相关内容介绍, 使用简单的 hexo 搭建的blog 项目 source - opencv 的源码 根据当前时间 2019-12-20 使用较新 的版本 opencv-4.1.2 版本源码, soft - 自己实现的基于 QT 做的界面的 opencv 的一个基础使用库, 用于实现opencv 的算法功能, 实现的过程也会发布到相应的 blog 内容中 其他","categories":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://schen1024.github.io/categories/OpenCV/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://schen1024.github.io/tags/OpenCV/"}]},{"title":"spdlog使用以及自定义日志设计","slug":"spdlog使用以及自定义日志设计","date":"2019-12-18T20:46:34.000Z","updated":"2023-01-01T13:25:24.779Z","comments":true,"path":"2019/12-18/spdlog使用以及自定义日志设计.html","link":"","permalink":"https://schen1024.github.io/2019/12-18/spdlog%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%E8%AE%BE%E8%AE%A1.html","excerpt":"","text":"","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://schen1024.github.io/tags/C/"},{"name":"Utils","slug":"Utils","permalink":"https://schen1024.github.io/tags/Utils/"},{"name":"Logger","slug":"Logger","permalink":"https://schen1024.github.io/tags/Logger/"}]},{"title":"QT踩坑记录1-多线程信号与槽","slug":"QT踩坑记录2-多线程信号与槽","date":"2019-12-15T20:21:56.000Z","updated":"2023-01-01T13:25:24.240Z","comments":true,"path":"2019/12-15/QT踩坑记录2-多线程信号与槽.html","link":"","permalink":"https://schen1024.github.io/2019/12-15/QT%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%952-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD.html","excerpt":"错误输出无错误输出, 但是声明了信号的连接,但是无法使用 程序中就是无命令 介绍QT 典型程序 123456789101112131415161718192021222324252627#include &lt;QObject&gt;class MyClass:public QObject&#123; Q_OBJECTsignals: void signals_dosomething(int n);public slots: void slots_dosomething(int n) &#123; m_value_ = n; &#125;private: int m_value_;public: MyClass(QObjet *parent = nullptr) :QObject(parent), m_value_(0) &#123; QObject::connect(this, &amp;MyClass::signals_dosomething, this, &amp;MyClass::slots_dosomething, Qt::DirectConnection); &#125;&#125;","text":"错误输出无错误输出, 但是声明了信号的连接,但是无法使用 程序中就是无命令 介绍QT 典型程序 123456789101112131415161718192021222324252627#include &lt;QObject&gt;class MyClass:public QObject&#123; Q_OBJECTsignals: void signals_dosomething(int n);public slots: void slots_dosomething(int n) &#123; m_value_ = n; &#125;private: int m_value_;public: MyClass(QObjet *parent = nullptr) :QObject(parent), m_value_(0) &#123; QObject::connect(this, &amp;MyClass::signals_dosomething, this, &amp;MyClass::slots_dosomething, Qt::DirectConnection); &#125;&#125; 解决手动指定连接方式 connect(sender, signal, receiver, slot);其实，connect 还有一个 Qt::ConnectionType 参数，只是它带有默认值，且多数情况下，默认值足够了，所以最少有机会去了解。Qt::ConnectionType 的可选值如下： Qt::AutoConnection:默认值，使用这个值则连接类型会在信号发送时决定。如果接收者和发送者在同一个线程，则自动使用 Qt::DirectConnection 类型。如果接收者和发送者不在一个线程，则自动使用 Qt::QueuedConnection。 Qt::DirectConnection: 槽函数会在信号发送的时候直接被调用，槽函数运行于信号发送者所在线程。效果看上去就像是直接在信号发送位置调用了槽函数。这个在多线程环境下比较危险，可能会造成奔溃。 Qt::QueuedConnection: 槽函数在控制回到接收者所在线程的事件循环时被调用，槽函数运行于信号接收者所在线程。发送信号之后，槽函数不会立刻被调用，等到接收者的当前函数执行完，进入事件循环之后，槽函数才会被调用。多线程环境下一般用这个。 12345QObject::connect(this, &amp;MyClass::signals_dosomething, this, &amp;MyClass::slots_dosomething, Qt::DirectConnection); 更多参考链接 Qt 多线程中的信号-槽","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://schen1024.github.io/tags/C/"},{"name":"QT","slug":"QT","permalink":"https://schen1024.github.io/tags/QT/"},{"name":"Bugs","slug":"Bugs","permalink":"https://schen1024.github.io/tags/Bugs/"}]},{"title":"QT踩坑记录1-Q_OBJECT编译问题","slug":"QT踩坑记录1-Q-OBJECT编译问题","date":"2019-12-15T20:19:16.000Z","updated":"2023-01-01T13:25:24.237Z","comments":true,"path":"2019/12-15/QT踩坑记录1-Q-OBJECT编译问题.html","link":"","permalink":"https://schen1024.github.io/2019/12-15/QT%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%951-Q-OBJECT%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98.html","excerpt":"错误输出Q_OBJECT 宏错误的地方会编译出现这样的错误, 无法找到…. 由于自己不想再看到这个错误, 此处 复制自 参考连接 1, 主要是连接错误 LNK2001 , 12341&gt;LoginDlg.obj : error LNK2001: 无法解析的外部符号 \"public: virtual struct QMetaObject const * __thiscall CLoginDlg::metaObject(void)const \" (? metaObject@CLoginDlg@@UBEPBUQMetaObject@@XZ)1&gt;LoginDlg.obj : error LNK2001: 无法解析的外部符号 \"public: virtual void * __thiscall CLoginDlg::qt_metacast(char const *)\" (?qt_metacast@CLoginDlg@@UAEPAXPBD@Z)1&gt;LoginDlg.obj : error LNK2001: 无法解析的外部符号 \"public: virtual int __thiscall CLoginDlg::qt_metacall(enum QMetaObject::Call,int,void * *)\" (?qt_metacall@CLoginDlg@@UAEHW4Call@QMetaObject@@HPAPAX@Z)1&gt;D:\\VC++\\QtT\\MyDialog\\\\MyDialog.exe : fatal error LNK1120: 3 个无法解析的外部命令 介绍首先看一下一个基本的 QT 类的简单实现, 继承自 QObject, 然后定义了 一个信号 signals_dosomething 和 一个槽函数 slots_dosomething ,信号函数不用去实现, 只需要 设定与相应的函数进行连接即可, 即 使用 QObject::connect 连接, 且信号函数与槽函数的参数一致, 信号这里的连接与函数参数也是一个坑, 后续会更新相应的章节, 那类中 最开始 的地方 为什么要有一个 宏 Q_OBJECT 这里可以参考 QT Q_OBJECT, 里面做了详细的解释 123456789101112131415161718192021222324252627#include &lt;QObject&gt;class MyClass:public QObject&#123; Q_OBJECTsignals: void signals_dosomething(int n);public slots: void slots_dosomething(int n) &#123; m_value_ = n; &#125;private: int m_value_;public: MyClass(QObjet *parent = nullptr) :QObject(parent), m_value_(0) &#123; QObject::connect(this, &amp;MyClass::signals_dosomething, this, &amp;MyClass::slots_dosomething, Qt::DirectConnection); &#125;&#125;","text":"错误输出Q_OBJECT 宏错误的地方会编译出现这样的错误, 无法找到…. 由于自己不想再看到这个错误, 此处 复制自 参考连接 1, 主要是连接错误 LNK2001 , 12341&gt;LoginDlg.obj : error LNK2001: 无法解析的外部符号 \"public: virtual struct QMetaObject const * __thiscall CLoginDlg::metaObject(void)const \" (? metaObject@CLoginDlg@@UBEPBUQMetaObject@@XZ)1&gt;LoginDlg.obj : error LNK2001: 无法解析的外部符号 \"public: virtual void * __thiscall CLoginDlg::qt_metacast(char const *)\" (?qt_metacast@CLoginDlg@@UAEPAXPBD@Z)1&gt;LoginDlg.obj : error LNK2001: 无法解析的外部符号 \"public: virtual int __thiscall CLoginDlg::qt_metacall(enum QMetaObject::Call,int,void * *)\" (?qt_metacall@CLoginDlg@@UAEHW4Call@QMetaObject@@HPAPAX@Z)1&gt;D:\\VC++\\QtT\\MyDialog\\\\MyDialog.exe : fatal error LNK1120: 3 个无法解析的外部命令 介绍首先看一下一个基本的 QT 类的简单实现, 继承自 QObject, 然后定义了 一个信号 signals_dosomething 和 一个槽函数 slots_dosomething ,信号函数不用去实现, 只需要 设定与相应的函数进行连接即可, 即 使用 QObject::connect 连接, 且信号函数与槽函数的参数一致, 信号这里的连接与函数参数也是一个坑, 后续会更新相应的章节, 那类中 最开始 的地方 为什么要有一个 宏 Q_OBJECT 这里可以参考 QT Q_OBJECT, 里面做了详细的解释 123456789101112131415161718192021222324252627#include &lt;QObject&gt;class MyClass:public QObject&#123; Q_OBJECTsignals: void signals_dosomething(int n);public slots: void slots_dosomething(int n) &#123; m_value_ = n; &#125;private: int m_value_;public: MyClass(QObjet *parent = nullptr) :QObject(parent), m_value_(0) &#123; QObject::connect(this, &amp;MyClass::signals_dosomething, this, &amp;MyClass::slots_dosomething, Qt::DirectConnection); &#125;&#125; 解决由于本人使用的是 QT 构建工程,然后使用 VS 的 QT VS Tools 将 QT 工程转生成的 VS 工程,存在各种问题,甚至出现 QT 编译通过 VS 编译不通过的问题, 这里使用最暴力的方式, 直接使用 QT 的 moc 命令 将相应 类的声明 h 文件 moc 成 cpp 文件, 1moc MyClass.h -o moc_MyClass.cpp 然后将 cpp 文件放置到相应的生成目录下面即可, 一般在 解决方案/工程/debug 下面,里面全是 moc_* 的 cpp 文件和 obj 文件注意查找自己的目录下面即可, 在手动 moc 生成之后, 之前编译不通过的 VS 工程也编译通过了,这里猜想是, 利用 Qt 编程时，写好.h、.cpp 文件并第一次编译之后，若.h 文件中定义类时没有添加 QOBJECT 宏以及信号函数、槽函数，VS 编译命令中就没有 moc 命令，就不会调用 Qt 的 moc 工具以生成 moc*.cpp 文件；并且即使添加了 Q_OBJECT 宏之后，VS 也不会自动添加 moc 命令，因而不会生成 moc 文件。VS 在 LINK 时，找不到 moc 文件，就出现了 error LNK2001 的错误。 更多参考链接 error LNK2001: 无法解析的外部符号 What does the Q_OBJECT macro do? Why do all Qt objects need this macro? “Qt 之 Q_OBJECT 详解” 一定要看 error LNK2001: 无法解析的外部符号 Qt 的 moc 机制","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://schen1024.github.io/tags/C/"},{"name":"QT","slug":"QT","permalink":"https://schen1024.github.io/tags/QT/"},{"name":"Bugs","slug":"Bugs","permalink":"https://schen1024.github.io/tags/Bugs/"}]},{"title":"QT踩坑记录0-汇总","slug":"QT踩坑记录0-汇总","date":"2019-12-15T19:45:36.000Z","updated":"2023-01-01T13:25:24.237Z","comments":true,"path":"2019/12-15/QT踩坑记录0-汇总.html","link":"","permalink":"https://schen1024.github.io/2019/12-15/QT%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%950-%E6%B1%87%E6%80%BB.html","excerpt":"QT 是一个跨平台的C++库, 提供了通用的解决方式,方便我们进行界面开发, 但是每个库总有各种问题,可能是自己的原因,也可能是设备环境的原因, 甚至可能是库的原因, 使用QT也有很长一段时间了, 遇到了各种问题,有的已经解决了,有的还在困扰自己. 此处记录下来自己遇到的各种关于QT库的问题, 希望对别人有 少许帮助. 此系列更多是自己遇到的问题的记录, 部分基础的问题以及常见的问题能够通过一定的搜索解决掉了,就没有去做详细解释, 但是那种坑了自己一天甚至更长时间的 问题 应该被记录下来. 章节汇总QT 踩坑记录 Q_OBJECT 宏错误 QT 信号与槽连接 QT 打包与依赖问题 QT 资源问题","text":"QT 是一个跨平台的C++库, 提供了通用的解决方式,方便我们进行界面开发, 但是每个库总有各种问题,可能是自己的原因,也可能是设备环境的原因, 甚至可能是库的原因, 使用QT也有很长一段时间了, 遇到了各种问题,有的已经解决了,有的还在困扰自己. 此处记录下来自己遇到的各种关于QT库的问题, 希望对别人有 少许帮助. 此系列更多是自己遇到的问题的记录, 部分基础的问题以及常见的问题能够通过一定的搜索解决掉了,就没有去做详细解释, 但是那种坑了自己一天甚至更长时间的 问题 应该被记录下来. 章节汇总QT 踩坑记录 Q_OBJECT 宏错误 QT 信号与槽连接 QT 打包与依赖问题 QT 资源问题","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[]},{"title":"Window+Protobuf使用说明","slug":"Window-Protobuf使用说明","date":"2019-11-27T16:24:54.000Z","updated":"2023-01-01T13:25:24.241Z","comments":true,"path":"2019/11-27/Window-Protobuf使用说明.html","link":"","permalink":"https://schen1024.github.io/2019/11-27/Window-Protobuf%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html","excerpt":"介绍起因由于项目中要用到二进制存储数据,之前使用的方式是按照字节数依次将数据写入字节流中, 但是这样做起来做文件的协议兼容比较难做,所以我们考虑使用 protobuf 来做格式定义, 便于不同版本的文件兼容, 这边使用用起来十分方便且后续添加参数之后, 版本之间的改动很好处理,多出来的参数或者未找到的参数可以使用默认处理即可,十分方便 常用配置文件介绍程序的配置文件是一个很常用的手段, 每次读取配置文件的信息, 容纳后根据参数决定我们的执行顺序, 是程序的一个很好的设计方式, 常用的配置文件我们会选择使用自己可读的文件格式,进行一定的程序注释之类的,然后在通过配置接口,将我们需要的参数依次读取到内存中,进行读写. 常用的配置文件格式有: xml yaml json ini properties …… 具体的参数区别与优劣比较自己可以查阅 常用配置文件格式","text":"介绍起因由于项目中要用到二进制存储数据,之前使用的方式是按照字节数依次将数据写入字节流中, 但是这样做起来做文件的协议兼容比较难做,所以我们考虑使用 protobuf 来做格式定义, 便于不同版本的文件兼容, 这边使用用起来十分方便且后续添加参数之后, 版本之间的改动很好处理,多出来的参数或者未找到的参数可以使用默认处理即可,十分方便 常用配置文件介绍程序的配置文件是一个很常用的手段, 每次读取配置文件的信息, 容纳后根据参数决定我们的执行顺序, 是程序的一个很好的设计方式, 常用的配置文件我们会选择使用自己可读的文件格式,进行一定的程序注释之类的,然后在通过配置接口,将我们需要的参数依次读取到内存中,进行读写. 常用的配置文件格式有: xml yaml json ini properties …… 具体的参数区别与优劣比较自己可以查阅 常用配置文件格式 protocbuf 介绍Protocol buffers 是一种语言中立，平台无关，可扩展的序列化数据的格式，可用于通信协议，数据存储等。 Protocol buffers 在序列化数据方面，它是灵活的，高效的。相比于 XML 来说，Protocol buffers 更加小巧，更加快速，更加简单。一旦定义了要处理的数据的数据结构之后，就可以利用 Protocol buffers 的代码生成工具生成相关的代码。甚至可以在无需重新部署程序的情况下更新数据结构。只需使用 Protobuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。 Protocol buffers 很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。 使用说明环境列表本次使用的环境列表如下 protobuf 3.11.0 protobuf-all-3.11.0.zip cmake 3.14.2 VS2015 本机配置开源库编译由于是在 Windows 下面编译, 所以这边使用了 cmake-gui 的编译方式, 按照如下步骤配置 0. 假设已经新建了一个文件夹,后续的操作都在此文件夹下 假设操作的所有文件夹都在 D:/Soft/Protobuf 文件夹下面, 新建三个文件夹,便于后续操作, 我们使用 $() 代替在你自己设备中的路径, 不要弄错_ source $(SOURCE) 原始文件_ build $(BUILD) 工程文件和编译文件 * install $(INSTALL) 软件最后安装的路径 下载原始项目,如果压缩包,将全部文件解压到 $(SOURCE) 文件夹下面 使用 cmake-gui 配置相应的原始文件夹, 一般打开到 原始文件夹下有 CMakeLists.txt的文件目录即可, 如: $(SOURCE)/protobuf-3.11.0/cmake 目标目录打开到 $(BUILD) 点击左下角,Configure, 选择 自己本机的 VS 版本 可以选择架构 例如: VS2015 x64 架构 再次点击 Configure ,程序会开始读取 CMakeLists 里面的参数, 输出窗口会输出 log 信息, 如果有红色会报错,我们需要排查相应的库是否完成依赖项,如果有重要依赖, 可能无法完成编译 如果一切无措,我们可以看到 如图的 cmake 编译参数, 这是简略参数, 根据具体内容, 我们勾选相应的参数并设置相应的安装路径即可完成配置, 再次点击配置, 程序会进行配置, 选项会取消红色, 等生成完成即可, 点击 Generate 生成 VS2015 工程, 我们可以选择 open Project 快速打开,或者到 $(BUILD) 文件夹 点击对应的 sln 文件打开项目 使用 VS2015 编译库 一般 我们打开之后, 选择 Debug 或者 Release 选择 生成-生成解决方案, VS 就开始了编译过程, 开始进行了项目编译过程 可能存在编译错误, 一般不会出现, 不建议更改源项目, 可以查看是否自己错误 编译好的之后的安装文件夹可能存在如下的文件夹结构, 将 $(INSTALL)/bin 加入到 path 环境中, 里面有 dll 文件和 exe 文件便于使用 1234├─bin├─examples├─include└─lib 使用编译好的库 lib 假设我们需要测试 lib 文件, 建立 VS2015 工程, 新建 main.cpp addressbook.proto 的文件 在我们使用编译好的库的时候, 需要引用 include 文件才能进行编译, $(INSTALL)/include 我们使用 protobuf 的例程文件里面的 addressbook.proto, 配置相应的消息格式, 自定义 message 格式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// See README.txt for information and build instructions.//// Note: START and END tags are used in comments to define sections used in// tutorials. They are not part of the syntax for Protocol Buffers.//// To get an in-depth walkthrough of this file and the related examples, see:// https://developers.google.com/protocol-buffers/docs/tutorials// [START declaration]syntax = \"proto3\";package tutorial;import \"google/protobuf/timestamp.proto\";// [END declaration]// [START java_declaration]option java_package = \"com.example.tutorial\";option java_outer_classname = \"AddressBookProtos\";// [END java_declaration]// [START csharp_declaration]option csharp_namespace = \"Google.Protobuf.Examples.AddressBook\";// [END csharp_declaration]// [START messages]message Person &#123; string name = 1; int32 id = 2; // Unique ID number for this person. string email = 3; enum PhoneType &#123; MOBILE = 0; HOME = 1; WORK = 2; &#125; message PhoneNumber &#123; string number = 1; PhoneType type = 2; &#125; repeated PhoneNumber phones = 4; google.protobuf.Timestamp last_updated = 5;&#125;// Our address book file is just one of these.message AddressBook &#123; repeated Person people = 1;&#125;// [END messages] 在工作目录下打开命令行, 使用 bash 执行命令 将 .proto 文件编译成 对应的 .h 和 .cpp 文件 1protoc ./addressbook.proto --cpp_out=./ 将样例里面的 列出人员和新加人员复制到自定义文件中 根据测试样例改写的 Main.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149// See README.txt for information and build instructions.#include &lt;ctime&gt;#include &lt;fstream&gt;#include &lt;google/protobuf/util/time_util.h&gt;// #include &lt;google/protobuf/&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include \"addressbook.pb.h\"using namespace std;using google::protobuf::util::TimeUtil;// Iterates though all people in the AddressBook and prints info about them.void ListPeople(const tutorial::AddressBook&amp; address_book) &#123; for (int i = 0; i &lt; address_book.people_size(); i++) &#123; const tutorial::Person&amp; person = address_book.people(i); cout &lt;&lt; \"Person ID: \" &lt;&lt; person.id() &lt;&lt; endl; cout &lt;&lt; \" Name: \" &lt;&lt; person.name() &lt;&lt; endl; if (person.email() != \"\") &#123; cout &lt;&lt; \" E-mail address: \" &lt;&lt; person.email() &lt;&lt; endl; &#125; for (int j = 0; j &lt; person.phones_size(); j++) &#123; const tutorial::Person::PhoneNumber&amp; phone_number = person.phones(j); switch (phone_number.type()) &#123; case tutorial::Person::MOBILE: cout &lt;&lt; \" Mobile phone #: \"; break; case tutorial::Person::HOME: cout &lt;&lt; \" Home phone #: \"; break; case tutorial::Person::WORK: cout &lt;&lt; \" Work phone #: \"; break; default: cout &lt;&lt; \" Unknown phone #: \"; break; &#125; cout &lt;&lt; phone_number.number() &lt;&lt; endl; &#125; if (person.has_last_updated()) &#123; cout &lt;&lt; \" Updated: \" &lt;&lt; TimeUtil::ToString(person.last_updated()) &lt;&lt; endl; &#125; &#125;&#125;// This function fills in a Person message based on user input.void PromptForAddress(tutorial::Person* person) &#123; cout &lt;&lt; \"Enter person ID number: \"; int id; cin &gt;&gt; id; person-&gt;set_id(id); cin.ignore(256, '\\n'); cout &lt;&lt; \"Enter name: \"; getline(cin, *person-&gt;mutable_name()); cout &lt;&lt; \"Enter email address (blank for none): \"; string email; getline(cin, email); if (!email.empty()) &#123; person-&gt;set_email(email); &#125; while (true) &#123; cout &lt;&lt; \"Enter a phone number (or leave blank to finish): \"; string number; getline(cin, number); if (number.empty()) &#123; break; &#125; tutorial::Person::PhoneNumber* phone_number = person-&gt;add_phones(); phone_number-&gt;set_number(number); cout &lt;&lt; \"Is this a mobile, home, or work phone? \"; string type; getline(cin, type); if (type == \"mobile\") &#123; phone_number-&gt;set_type(tutorial::Person::MOBILE); &#125; else if (type == \"home\") &#123; phone_number-&gt;set_type(tutorial::Person::HOME); &#125; else if (type == \"work\") &#123; phone_number-&gt;set_type(tutorial::Person::WORK); &#125; else &#123; cout &lt;&lt; \"Unknown phone type. Using default.\" &lt;&lt; endl; &#125; &#125; *person-&gt;mutable_last_updated() = TimeUtil::SecondsToTimestamp(time(nullptr));&#125;// Main function: Reads the entire address book from a file,// adds one person based on user input, then writes it back out to the same// file.int main(int argc, char* argv[]) &#123; // Verify that the version of the library that we linked against is // compatible with the version of the headers we compiled against. GOOGLE_PROTOBUF_VERIFY_VERSION; if (argc != 2) &#123; cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \" ADDRESS_BOOK_FILE\" &lt;&lt; endl; return -1; &#125; tutorial::AddressBook address_book; &#123; // Read the existing address book. fstream input(argv[1], ios::in | ios::binary); if (!input) &#123; cout &lt;&lt; argv[1] &lt;&lt; \": File not found. Creating a new file.\" &lt;&lt; endl; &#125; else if (!address_book.ParseFromIstream(&amp;input)) &#123; cerr &lt;&lt; \"Failed to parse address book.\" &lt;&lt; endl; return -1; &#125; &#125; // 列出文件 读取的人员 ListPeople(address_book); // 重新添加一个人员 PromptForAddress(address_book.add_people()); &#123; // Write the new address book back to disk. fstream output(argv[1], ios::out | ios::trunc | ios::binary); if (!address_book.SerializeToOstream(&amp;output)) &#123; cerr &lt;&lt; \"Failed to write address book.\" &lt;&lt; endl; return -1; &#125; &#125; // Optional: Delete all global objects allocated by libprotobuf. google::protobuf::ShutdownProtobufLibrary(); return 0;&#125; 配置 main 函数的输入参数项目–右键–属性–调试–命令参数—-加入 ./test.bin 配置 C++ 项目 include 文件夹和附加库项目–右键–属性–VC++目录–包含目录–编辑—–加入 $(INSTALL)/include项目–右键–属性–链接器–输入–附加依赖项– 编辑——-加入 $(INSTALL)/lib/libprotobuf.lib 和 $(INSTALL)/lib/libprotobufd.lib 如果编译了 共享 dll 文件项目–右键–属性–C/C++–预处理器–预处理器定义–编辑—-加入 PROTOBUF_USE_DLLS 最终编译成功, 可以列出来 文件中的参数, 最终生成的二进制文件 hex 文件内容 1234 Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F00000000: 0A 15 0A 01 32 10 01 1A 01 33 22 03 0A 01 34 2A ....2....3&quot;...4*00000010: 06 08 B2 AD F9 EE 05 0A 15 0A 01 32 10 01 1A 01 ..2-yn.....2....00000020: 33 22 03 0A 01 34 2A 06 08 D2 AD F9 EE 05 3&quot;...4*..R-yn. 更多由于我们需要才自定义文件的后续添加大量的数据文件, 所以无法使用这种方式, 可能还是要使用更多的文件版本的方式来处理文件兼容性问题吧, 后续会将自己的参数设计思路以及参数实现方法 参考链接 C++ 程序员 Protocol Buffers 基础指南 Protocol Buffer Basics: C++ Google Protocol Buffer 的使用和原理 高效的数据压缩编码方式 Protobuf Protobuf 终极教程 protobuf【1】详细的安装和使用（windows cpp）","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://schen1024.github.io/tags/C/"},{"name":"Window","slug":"Window","permalink":"https://schen1024.github.io/tags/Window/"},{"name":"Cmake","slug":"Cmake","permalink":"https://schen1024.github.io/tags/Cmake/"},{"name":"Protocbuf","slug":"Protocbuf","permalink":"https://schen1024.github.io/tags/Protocbuf/"}]},{"title":"个人程序命名规范","slug":"个人程序命名规范","date":"2019-11-20T22:06:18.000Z","updated":"2023-01-01T13:25:24.780Z","comments":true,"path":"2019/11-20/个人程序命名规范.html","link":"","permalink":"https://schen1024.github.io/2019/11-20/%E4%B8%AA%E4%BA%BA%E7%A8%8B%E5%BA%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83.html","excerpt":"程序命名规则函数命名参考 google 命名规范, 但是由于自己的项目实际存在其他的库以及其他的程序,所以不能完全依赖,以及存在一些个人的命名习惯,所以仅供参考 文件名文件名一般是类名,部分是 单词的组合,有三种格式 FileName 首字母大写 fileName 除第一个单词首字母大写 filename 全小写 xxx_1107 避免冲突的文件存储 xxx_date_time_xx 根据日期时间以及 临时 避免数据重复 一般来说, 同名文件存在 .cpp 和 .h 两种对应格式, 相应的 .cpp/.cc 存放在 Code/src 文件夹, .h 存放在 Code/inc 文件夹具体的文件列表可以参考 项目文档里面列出的文档树以及文档里面详细介绍了每个文件的内容 按照拓展名区分文件类型 C/C++ 文件 .c 纯 c 文件 .cpp 部分 QT 的提升组件 以及主要执行文件 .cc 自定义类的实现文件 .h 类的声明文件 ui_xxx.h qt 使用 uic 编译 ui 生成的头文件 moc_xxx.h qt 使用 moc 编译 Object 类生成的 moc 文件, 处理信号与槽 test_xxx.cc 使用 doctest 的写的测试函数 文档文件 .md 自己写的各个模块的文档 .doc doc 格式文档, 后续生成即可 .html doxygen 通过注释生成的文件 配置文件以及资源文件 .yml .xml opencv 可以读取的配置文件 .pro .pri QT 工程文件,配置工程参数 .rc QT 编译资源文件 .ui QT 自己使用 ui 操作 .qml QT QML 界面文件 .ts QT 翻译家文件,用于多语言版本程序 资源文件 .txt log 文件存储文件 或临时文件 .idoi 自定义存储文件结构 .png 文档需要的图片或者读取文件存储的格式 .xlsx 部分 UI 表 以及多无代码表 等表格存储 临时记录,最后会转进各个 markdown 进行同一管理 .pdf 文档的部分版本留存,暂定规则之类 其他文件 .bat 自己写的部分脚本 来实现操作的批量操作 .properties SonarQube 配置文件 .zip 程序压缩文件备份","text":"程序命名规则函数命名参考 google 命名规范, 但是由于自己的项目实际存在其他的库以及其他的程序,所以不能完全依赖,以及存在一些个人的命名习惯,所以仅供参考 文件名文件名一般是类名,部分是 单词的组合,有三种格式 FileName 首字母大写 fileName 除第一个单词首字母大写 filename 全小写 xxx_1107 避免冲突的文件存储 xxx_date_time_xx 根据日期时间以及 临时 避免数据重复 一般来说, 同名文件存在 .cpp 和 .h 两种对应格式, 相应的 .cpp/.cc 存放在 Code/src 文件夹, .h 存放在 Code/inc 文件夹具体的文件列表可以参考 项目文档里面列出的文档树以及文档里面详细介绍了每个文件的内容 按照拓展名区分文件类型 C/C++ 文件 .c 纯 c 文件 .cpp 部分 QT 的提升组件 以及主要执行文件 .cc 自定义类的实现文件 .h 类的声明文件 ui_xxx.h qt 使用 uic 编译 ui 生成的头文件 moc_xxx.h qt 使用 moc 编译 Object 类生成的 moc 文件, 处理信号与槽 test_xxx.cc 使用 doctest 的写的测试函数 文档文件 .md 自己写的各个模块的文档 .doc doc 格式文档, 后续生成即可 .html doxygen 通过注释生成的文件 配置文件以及资源文件 .yml .xml opencv 可以读取的配置文件 .pro .pri QT 工程文件,配置工程参数 .rc QT 编译资源文件 .ui QT 自己使用 ui 操作 .qml QT QML 界面文件 .ts QT 翻译家文件,用于多语言版本程序 资源文件 .txt log 文件存储文件 或临时文件 .idoi 自定义存储文件结构 .png 文档需要的图片或者读取文件存储的格式 .xlsx 部分 UI 表 以及多无代码表 等表格存储 临时记录,最后会转进各个 markdown 进行同一管理 .pdf 文档的部分版本留存,暂定规则之类 其他文件 .bat 自己写的部分脚本 来实现操作的批量操作 .properties SonarQube 配置文件 .zip 程序压缩文件备份 类名全部首字母大写例如: CamProc. CamCapture. WorkWindow 函数名 普通函数: 首字母大写 多个单词每个单词首字母大写, 例如: CreateMapMat, Init QT 这种全大写,,省事, 例如: ShowImageOnQTLabel, RenderHCM QT 的信号或者槽函数: 使用 slot_ 开头命名 如: slot_render_HCM 使用 Slot_ 开头命名 例如: Slot_UpdateUIByRunPara 按照 QT 的规则, on_xxx_clicked 这种形式,表明函数信号: 例如: on_btn_work_exit_clicked QT 的信号函数, 完全自定义, 可以使用 signal 命名, 例如: signal_close_windows 变量名变量参考匈牙利命名法, 使用 类型_变量名 来声明, 变量作用区域类型前缀 全局变量 g_ g 局部变量 (无) 争取全部小写 成员变量 m_ + 其他类型 m + class 类型名 容器类型前缀 使用类型来做开头 主要是 queue 和 vector q_ 自定义队列前缀 v_ vector 类型数据 变量类型前缀,基本使用类型的第一个字母小写来做 b_ bool 类型 变量 k_ 常量 c_ 字符类型 f_ float 变量 d_ double 类型变量 s_ 字符串变量 std::string 类型变量 a_ 图片类型 cv::Mat 避免各种字母重复 t_ 自定义 线程变量前缀 x_ 线程处理锁 ui 标识窗口的 ui 文件 (无) 类型 Class 类 实现 结构体元素变量前缀 n 整型数据 r 图像区域 {x,y,width,height} 这种格式 St 结构体类型名称 (无) 使用大写字母 作为 结构体变量名称 如 Serial Image","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://schen1024.github.io/tags/C/"},{"name":"NameStyle","slug":"NameStyle","permalink":"https://schen1024.github.io/tags/NameStyle/"}]},{"title":"引入OpenCV导致私有内存巨大","slug":"引入OpenCV导致私有内存巨大","date":"2019-11-15T20:03:54.000Z","updated":"2023-01-01T13:25:24.785Z","comments":true,"path":"2019/11-15/引入OpenCV导致私有内存巨大.html","link":"","permalink":"https://schen1024.github.io/2019/11-15/%E5%BC%95%E5%85%A5OpenCV%E5%AF%BC%E8%87%B4%E7%A7%81%E6%9C%89%E5%86%85%E5%AD%98%E5%B7%A8%E5%A4%A7.html","excerpt":"说明在调试程序的时候 发现自己的程序在 VS 的调试窗口占用很高,花时间关注了一下这个问题, 手动写了小的程序复现这个问题,最终确定了占用巨大的问题. VS 的调试工具表示的内存占用是统计的程序 私有字节 的大小, 而任务管理器统计的内存占用是程序的 工作集 大小,具体二者的内存的区别可以参考问题 Virtual Size causing program to run out of memory 的答案, Private bytes tells you how many bytes of virtual device memory your process has mapped, excluding virtual memory shared with other processes (e.g. mapped files, global heap, etc). Working set tells you how many bytes of physical memory you are actively using. This includes physical memory, device buffers, and mapped files. It’s a pretty strange figure, since it equates to touched physical memory + mapped virtual non-system memory. In general, you should completely ignore this figure. It’s practically useless for debugging memory leaks. Virtual bytes is the total amount of virtual memory you have mapped. 解决通过不断的重复和二分, 最终确定了是 OpenCV 引入的头文件问题, 在我们平时写 OpenCV 的程序的时候, 总是简单的使用 #include &lt;opencv.hpp&gt; 引入一个头文件来解决问题, 也是官方推荐的写法, 十分方便, 但是巨大, 我们分别使用三种方式测试, 分别是","text":"说明在调试程序的时候 发现自己的程序在 VS 的调试窗口占用很高,花时间关注了一下这个问题, 手动写了小的程序复现这个问题,最终确定了占用巨大的问题. VS 的调试工具表示的内存占用是统计的程序 私有字节 的大小, 而任务管理器统计的内存占用是程序的 工作集 大小,具体二者的内存的区别可以参考问题 Virtual Size causing program to run out of memory 的答案, Private bytes tells you how many bytes of virtual device memory your process has mapped, excluding virtual memory shared with other processes (e.g. mapped files, global heap, etc). Working set tells you how many bytes of physical memory you are actively using. This includes physical memory, device buffers, and mapped files. It’s a pretty strange figure, since it equates to touched physical memory + mapped virtual non-system memory. In general, you should completely ignore this figure. It’s practically useless for debugging memory leaks. Virtual bytes is the total amount of virtual memory you have mapped. 解决通过不断的重复和二分, 最终确定了是 OpenCV 引入的头文件问题, 在我们平时写 OpenCV 的程序的时候, 总是简单的使用 #include &lt;opencv.hpp&gt; 引入一个头文件来解决问题, 也是官方推荐的写法, 十分方便, 但是巨大, 我们分别使用三种方式测试, 分别是 不引入 Opencv 头文件, WorkingSet: 31,636 KB, PrivateByte: 6,224 KB ; VS: 7 MB 引入 一个 Opencv.hpp 头文件, WorkingSet: 49,012 KB, PrivateByte: 999,068 KB VS:1 GB 引入 一个 Opencv.hpp 头文件, WorkingSet: 31,700 KB, PrivateByte: 6,252 KB VS:7 MB 查看 opencv.hpp 文件里面的内容 最终通过二分排查, 确定了 只要引用 opencv2/dnn.hpp 之后,占用巨大, 本项目中不会用到这个头文件所以,这里可以不加入即可,问题解决!! 1234567891011121314151617// #include \"opencv2/opencv_modules.hpp\"//#include \"opencv2/calib3d.hpp\"//#include \"opencv2/features2d.hpp\"#include \"opencv2/dnn.hpp\" // 最终确定占用巨大//#include \"opencv2/flann.hpp\"//#include \"opencv2/highgui.hpp\"//#include \"opencv2/imgcodecs.hpp\"//#include \"opencv2/imgproc.hpp\"//#include \"opencv2/ml.hpp\"//#include \"opencv2/objdetect.hpp\"//#include \"opencv2/photo.hpp\"//#include \"opencv2/shape.hpp\"//#include \"opencv2/stitching.hpp\"//#include \"opencv2/superres.hpp\"//#include \"opencv2/video.hpp\"//#include \"opencv2/videoio.hpp\"//#include \"opencv2/videostab.hpp\" 更多图中程序部分是 VS2015 , 右侧进程管理查看软件是 ProcessExplorer_v16.21 可以查看进程的各种细节 参考链接无","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://schen1024.github.io/tags/C/"},{"name":"VS2015","slug":"VS2015","permalink":"https://schen1024.github.io/tags/VS2015/"},{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/tags/opencv/"}]},{"title":"AtomineerUtils使用说明","slug":"AtomineerUtils使用说明","date":"2019-11-14T21:07:29.000Z","updated":"2023-01-01T13:25:24.183Z","comments":true,"path":"2019/11-14/AtomineerUtils使用说明.html","link":"","permalink":"https://schen1024.github.io/2019/11-14/AtomineerUtils%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html","excerpt":"介绍AtomineerUtils 是国外的一款用于生成源代码注释的一款 VS 插件工具.这款插件，支持 C、C++、C++/CLI、C#、Java 语言等，由此可以看出其强大，注释的风格可以灵活配置。 安装方法软件是付费软件, 具体使用版本见附件 AtomineerUtils936 也可以在参考链接给出的网页内找到 使用方法. 具体安装方法可以看压缩包内附件文档, 正常安装相应文件夹内的VS插件,本人使用的是 VS2015 插件 第一次请务必断网进入VS，在插件里面把本工具的自动更新关闭掉，更新到最新版本将直接无法使用破解版本(如果刚好试用到期也不就不能用了)。 VS 2015之下的版本(未测试是否可用): 安装路径自己选的，然后找到：你的安装路径/visual studio 20**/Addins/AtomineerUtils/替换掉里面的Atomineer.Utils.dll就好了 VS 2015版本: 替换位置: %LocalAppData%/Microsoft/VisualStudio/14.0/Extensions/**(随机的名称)/VS 2017版本: 替换位置: %LocalAppData%/Microsoft/VisualStudio/15.0_** (随机的名称) /Extensions/**(随机的名称)/ 在相应文件夹内找到文件, 使用附件文件夹内的 同名文件替换掉里面的AtomineerProDocumentation.dll就好了 可以在VS 的拓展目录C:\\Users\\Chen\\AppData\\Local\\Microsoft\\VisualStudio\\14.0\\Extensions 下搜索文件名可以快速找到 例如个人最终的路径为 C:\\Users\\Chen\\AppData\\Local\\Microsoft\\VisualStudio\\14.0\\Extensions\\g2iuajz1.bzo\\AtomineerProDocumentation.dll PS:如果使用过程中出现路径错误的情况，菜单栏-&gt;工具-&gt;Atomineer…Trial-&gt;…options 进去点下确定出来就好了。 或者进入安装路径找到AtomineerUtilsWizard.exe，通过一下配置向导","text":"介绍AtomineerUtils 是国外的一款用于生成源代码注释的一款 VS 插件工具.这款插件，支持 C、C++、C++/CLI、C#、Java 语言等，由此可以看出其强大，注释的风格可以灵活配置。 安装方法软件是付费软件, 具体使用版本见附件 AtomineerUtils936 也可以在参考链接给出的网页内找到 使用方法. 具体安装方法可以看压缩包内附件文档, 正常安装相应文件夹内的VS插件,本人使用的是 VS2015 插件 第一次请务必断网进入VS，在插件里面把本工具的自动更新关闭掉，更新到最新版本将直接无法使用破解版本(如果刚好试用到期也不就不能用了)。 VS 2015之下的版本(未测试是否可用): 安装路径自己选的，然后找到：你的安装路径/visual studio 20**/Addins/AtomineerUtils/替换掉里面的Atomineer.Utils.dll就好了 VS 2015版本: 替换位置: %LocalAppData%/Microsoft/VisualStudio/14.0/Extensions/**(随机的名称)/VS 2017版本: 替换位置: %LocalAppData%/Microsoft/VisualStudio/15.0_** (随机的名称) /Extensions/**(随机的名称)/ 在相应文件夹内找到文件, 使用附件文件夹内的 同名文件替换掉里面的AtomineerProDocumentation.dll就好了 可以在VS 的拓展目录C:\\Users\\Chen\\AppData\\Local\\Microsoft\\VisualStudio\\14.0\\Extensions 下搜索文件名可以快速找到 例如个人最终的路径为 C:\\Users\\Chen\\AppData\\Local\\Microsoft\\VisualStudio\\14.0\\Extensions\\g2iuajz1.bzo\\AtomineerProDocumentation.dll PS:如果使用过程中出现路径错误的情况，菜单栏-&gt;工具-&gt;Atomineer…Trial-&gt;…options 进去点下确定出来就好了。 或者进入安装路径找到AtomineerUtilsWizard.exe，通过一下配置向导 使用方法说明由于插件没有中文, 但是并不难理解,使用的详细方法可以分为以下几步 1. VS 进入设置方法工具-&gt;AtomineerProDocumentation Trail -&gt; Atominee Option 2. 初始设定建议点击 quick 选择设置方案,根据自己感觉比较好看的方式设定即可, 因为后续需求, 这里选择的方案是 doxygen 的方式, 后续可以根据注释生成项目文档仅供参考 3. 注释模板路径在通用设置界面, 选择注释模板文件的搜索路径, 会先从给出的路径进行搜索,如果存在会优先使用,如果找不到就会使用程序默认的方式生成注释, 附件详细配置文档 给出了自己的一份配置文件, 比较满意 如果自己感觉不舒服可以自己调整 在通用设置的上半部分还可以设置右键显示的快捷菜单和菜单栏二级菜单显示的内容 4. 注释规则可以根据不同的规则生成不同的注释, 这里使用较少, 暂时不了解怎么使用的, 详细配置文档详细配置文档定义了相应的行 执行相应的内容 在执行生成注释的时候会根据xml 配置文件以及在软件中的设置自动生成相关内容 详细配置文档 详细配置文档 DoxygenTemplates.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451&lt;DoxygenTemplates&gt; &lt;!-- Templates for Doxygen/JavaDoc/Qt Comment blocks =============================================== These control which entries are added to the doc-comment for each type of code element, and their order. Full documentation can be found in the Atomineer user manual. --&gt; &lt;!-- Global settings for the entry types. These control the style and formatting of the individual types of entries defined in the templates below. Each element here should match one of the entries in your template blocks, and should either match the entry names Atomineer supports (e.g. \"summary\") or a custom entry type. If you wish to use a different name in your entries than Atomineer (e.g. you prefer \"brief\" to \"summary\", then use the &lt;summary&gt; element and set its _tagName attribute to \"brief\". You can also add a comma-separated list of _aliases to allow for conversions from legacy comments. Primary settings (see the user manual for more details) are: _optional true indicates this entry is not to be added by Atomineer, but shuld be preserved false indicates that this entry type is required, so Atomineer should automtaically add it _punctuate true/false to control automatic punctuation insertion _wordwrap true/false to control whether word-wrapping is applied to the description _copyFromBase true/fase to control whether this type of entry can be copied from base-class documentation _tagName The entry tag you want to use in your documentation, e.g. for Atomineer's \"summary\" you might prefer to use the tag \"description\" _aliases A comma-separated list of other tags that should be considered equivalent (to convert legacy comments) --&gt; &lt;!-- 条目类型的全局设置。=\"\" 它们控制下面模板中定义的各种条目类型的样式和格式。=\"\" 这里的每个元素都应该匹配模板块中的一个条目，并且应该匹配=\"\" 条目名称Atomineer支持（例如“摘要”）或自定义条目类型。如果你想使用不同的=\"\" 您的条目中的名称不是Atomineer（例如，您更喜欢“简要”到“摘要”，然后使用=\"\" 元素 并将其_tagName属性设置为“brief”。您还可以添加逗号分隔的_aliases列表以允许 来自遗留评论的转换。 主要设置（有关详细信息，请参阅用户手册）包括： _optional true表示Atomineer不会添加此条目，但会保留该条目 false表示此条目类型是必需的，因此Atomineer应自动添加它 _punctuate true / false控制自动标点符号插入 _wordwrap true / false控制是否将自动换行应用于描述 _copyFromBase true / fase控制是否可以从基类文档中复制此类条目 _tagName您要在文档中使用的条目标记，例如对于Atomineer的“总结”你可能会 更喜欢使用标签“description” _aliases以逗号分隔的其他标记列表，应视为等效（转换旧版注释） --&gt; &lt;!-- prototye is a template placeholder for the code element type (fn,method,class,interface,etc) --&gt; &lt;EntrySettings&gt; &lt;prototype _punctuate=\"false\" /&gt; &lt;author _punctuate=\"false\" _optional=\"true\" /&gt; &lt;copyright _punctuate=\"false\" _optional=\"true\" _aliases=\"copyright,Copyright,Copy,copy\"/&gt; &lt;date _punctuate=\"false\" _optional=\"true\" /&gt; &lt;remarks _optional=\"true\" _aliases=\"remark\" /&gt; &lt;summary _punctuate=\"false\" _tagName=\"brief\" _aliases=\"summary,desc,description,details,purpose,short\" /&gt; &lt;exception _tagName=\"exception\" _aliases=\"throw,throws\" /&gt; &lt;param _punctuate=\"false\" _tagName=\"param\" _aliases=\"parameter\" /&gt; &lt;typeparam _tagName=\"tparam\" _aliases=\"typeparam\" /&gt; &lt;returns _punctuate=\"false\" _tagName=\"returns\" _aliases=\"return,retval,result,value\" /&gt; &lt;seealso _punctuate=\"false\" _optional=\"true\" _tagName=\"sa\" _aliases=\"see,seealso\" /&gt; &lt;example _punctuate=\"false\" _optional=\"true\" _tagName=\"example\" /&gt; &lt;inheritdoc _punctuate=\"false\" _optional=\"true\" _tagName=\"inheritdoc\" /&gt; &lt;/EntrySettings&gt;` &lt;!-- Special header and footer pair for .h and .hpp files, which will automatically add an include-once mechanism to the file.--&gt; &lt;!-- .h 文件 自动添加 #If endif--&gt; &lt;!--&lt;file _filetypes=\".h .hpp\" _addfooter=\"true\" _separators=\"false\"&gt; &lt;prototype&gt;%projectpathname%&lt;/prototype&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;changelog&gt;%date% %user% Created&lt;/changelog&gt; #ifndef __%leafname%_H__ #define __%leafname%_H__ &lt;/file&gt; &lt;filefooter filetypes=\".h.hpp\" _separators=\"false\"&gt; End of %projectpathname% #endif // __%leafname%_H__ &lt;/filefooter&gt;--&gt; &lt;!-- 文件头 comment 格式--&gt; &lt;file&gt; &lt;prototype&gt;%projectpathname%&lt;/prototype&gt; &lt;copyright&gt; Copyright (c) 2019 IRIS_Chen IRIS Lab &lt;/copyright&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;changelog&gt;%date% %user% Created&lt;/changelog&gt; &lt;/file&gt; &lt;file-vb _separators=\"false\"&gt; &lt;prototype&gt;%projectpathname%&lt;/prototype&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;/file-vb&gt; &lt;!-- Free-form text example &lt;file&gt; // project: %project% // file: %projectpathname% // // summary: %fileDescription% // // %copyright% // // Date Developer Change // %date% %user% Created &lt;/file&gt; --&gt; &lt;!-- Default plain-text Atomineer file footer. These follow the same form as the file headers above --&gt; &lt;filefooter&gt; End of %projectpathname% &lt;/filefooter&gt; &lt;filefooter-vb _separators=\"false\"&gt; '--------------------------------------------------------------------------------------------------- ' End of %projectpathname% &lt;/filefooter-vb&gt; &lt;!-- Comment template for catch-all comments. These are added when the filetype of the document is not one of the core languages that Atomineer can parse to auto-document. The separators and line headers used for each file extension (e.g. .html, .sql) are configured in your Prefs.xml, allowing Atomineer to correctly insert simple \"boilerplate\" comments into any file format. --&gt; &lt;catchall&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;author&gt;%user%&lt;/author&gt; &lt;date&gt;%date%&lt;/date&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/catchall&gt; &lt;!-- Default namespace comment. As with file comments, you can use plain-text or XML commenting for this entry. --&gt; &lt;namespace&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/namespace&gt; &lt;typedef&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/typedef&gt; &lt;enum&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/enum&gt; &lt;bitfield&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/bitfield&gt; &lt;struct&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;author&gt;%user%&lt;/author&gt; &lt;date&gt;%date%&lt;/date&gt; &lt;_ /&gt; &lt;param /&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/struct&gt; &lt;union&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;author&gt;%user%&lt;/author&gt; &lt;date&gt;%date%&lt;/date&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/union&gt; &lt;class&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;author&gt;%user%&lt;/author&gt; &lt;date&gt;%date%&lt;/date&gt; &lt;_ /&gt; &lt;param /&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/class&gt; &lt;interface&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;author&gt;%user%&lt;/author&gt; &lt;date&gt;%date%&lt;/date&gt; &lt;_ /&gt; &lt;param /&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/interface&gt; &lt;module&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;author&gt;%user%&lt;/author&gt; &lt;date&gt;%date%&lt;/date&gt; &lt;_ /&gt; &lt;param /&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/module&gt; &lt;!-- C/C++ #define macro --&gt; &lt;def&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;author&gt;%user%&lt;/author&gt; &lt;date&gt;%date%&lt;/date&gt; &lt;_ /&gt; &lt;param /&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/def&gt; &lt;!-- C++ Function Method 头部声明 --&gt; &lt;method&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;author&gt;%user%&lt;/author&gt; &lt;date&gt;%date%&lt;/date&gt; &lt;_ /&gt; &lt;exception /&gt; &lt;_ /&gt; &lt;param /&gt; &lt;_ /&gt; &lt;returns /&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/method&gt; &lt;property&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;exception /&gt; &lt;_ /&gt; &lt;param /&gt; &lt;_ /&gt; &lt;value /&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/property&gt; &lt;indexer&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;exception /&gt; &lt;_ /&gt; &lt;param /&gt; &lt;_ /&gt; &lt;returns /&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/indexer&gt; &lt;delegate&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;author&gt;%user%&lt;/author&gt; &lt;date&gt;%date%&lt;/date&gt; &lt;_ /&gt; &lt;exception /&gt; &lt;_ /&gt; &lt;param /&gt; &lt;_ /&gt; &lt;returns /&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/delegate&gt; &lt;constructor&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;author&gt;%user%&lt;/author&gt; &lt;date&gt;%date%&lt;/date&gt; &lt;_ /&gt; &lt;exception /&gt; &lt;_ /&gt; &lt;param /&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/constructor&gt; &lt;destructor&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;author&gt;%user%&lt;/author&gt; &lt;date&gt;%date%&lt;/date&gt; &lt;_ /&gt; &lt;exception /&gt; &lt;_ /&gt; &lt;param /&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/destructor&gt; &lt;finaliser&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;author&gt;%user%&lt;/author&gt; &lt;date&gt;%date%&lt;/date&gt; &lt;_ /&gt; &lt;exception /&gt; &lt;_ /&gt; &lt;param /&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/finaliser&gt; &lt;operator&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;author&gt;%user%&lt;/author&gt; &lt;date&gt;%date%&lt;/date&gt; &lt;_ /&gt; &lt;exception /&gt; &lt;_ /&gt; &lt;param /&gt; &lt;_ /&gt; &lt;returns /&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/operator&gt; &lt;eventhandler&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;author&gt;%user%&lt;/author&gt; &lt;date&gt;%date%&lt;/date&gt; &lt;_ /&gt; &lt;exception /&gt; &lt;_ /&gt; &lt;param /&gt; &lt;_ /&gt; &lt;returns /&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/eventhandler&gt; &lt;eventsender&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;author&gt;%user%&lt;/author&gt; &lt;date&gt;%date%&lt;/date&gt; &lt;_ /&gt; &lt;exception /&gt; &lt;_ /&gt; &lt;param /&gt; &lt;_ /&gt; &lt;returns /&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/eventsender&gt; &lt;member&gt; &lt;summary /&gt; &lt;/member&gt; &lt;!-- Templates for methods in abstract classes and interfaces --&gt; &lt;interfacemethod&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;param /&gt; &lt;_ /&gt; &lt;returns /&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/interfacemethod&gt; &lt;interfaceproperty&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;value /&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/interfaceproperty&gt; &lt;interfaceindexer&gt; &lt;prototype /&gt; &lt;_ /&gt; &lt;summary /&gt; &lt;_ /&gt; &lt;param /&gt; &lt;_ /&gt; &lt;returns /&gt; &lt;_ /&gt; &lt;seealso /&gt; &lt;/interfaceindexer&gt; &lt;/DoxygenTemplates&gt; 参考链接 Atomineer Pro Documentation Trial 9.36 Crack atomineer pro documentation utils(visual studio常用插件) V9.45 官方版 Atomineer Pro Documentation Trial 9.36 Cracked","categories":[{"name":"Tools","slug":"Tools","permalink":"https://schen1024.github.io/categories/Tools/"}],"tags":[{"name":"VS2015","slug":"VS2015","permalink":"https://schen1024.github.io/tags/VS2015/"},{"name":"Plugin","slug":"Plugin","permalink":"https://schen1024.github.io/tags/Plugin/"},{"name":"Crack","slug":"Crack","permalink":"https://schen1024.github.io/tags/Crack/"},{"name":"Atomineer","slug":"Atomineer","permalink":"https://schen1024.github.io/tags/Atomineer/"}]},{"title":"QT使用提升自定义组件","slug":"QT使用提升自定义组件","date":"2019-11-10T18:52:41.000Z","updated":"2023-01-01T13:25:24.234Z","comments":true,"path":"2019/11-10/QT使用提升自定义组件.html","link":"","permalink":"https://schen1024.github.io/2019/11-10/QT%E4%BD%BF%E7%94%A8%E6%8F%90%E5%8D%87%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6.html","excerpt":"QT 组件提升来实现自定义功能 介绍我们在使用 QT 设置界面之后,往往需要自己实现一些方法,如果是单独 的还好,但是如果遇到很多同类型的都有需求, 比如 我们使用 QLineEdit 来处理数据,每次填入的数值都要更新到一个参数值中的时候, 我们需要将这个输入框的完成信号 连接到一个自定义的函数中 来更改某个值, 如果很多的时候, 我们就可以使用 继承组件然后使用提升来做了 应用如图所示的界面,我们需要对每个单行编辑框, 完成点击按钮就调整值的的方法 具体的提升的方法可以参考 Qt 自定义控件以及控件的提升 的具体做法, 这里只介绍我们使用的方法 我们自定义的 类为 CLineEdit我们设置了 公开的 Associate 函数, 将我们需要显示的 QLineEdit 组件 和两个 点击按钮以及内存存储相应数据的位置 关联起来, 点击相应按钮之后 会执行内存数据的加减, 然后再显示在相应的组件上, 便于查看,","text":"QT 组件提升来实现自定义功能 介绍我们在使用 QT 设置界面之后,往往需要自己实现一些方法,如果是单独 的还好,但是如果遇到很多同类型的都有需求, 比如 我们使用 QLineEdit 来处理数据,每次填入的数值都要更新到一个参数值中的时候, 我们需要将这个输入框的完成信号 连接到一个自定义的函数中 来更改某个值, 如果很多的时候, 我们就可以使用 继承组件然后使用提升来做了 应用如图所示的界面,我们需要对每个单行编辑框, 完成点击按钮就调整值的的方法 具体的提升的方法可以参考 Qt 自定义控件以及控件的提升 的具体做法, 这里只介绍我们使用的方法 我们自定义的 类为 CLineEdit我们设置了 公开的 Associate 函数, 将我们需要显示的 QLineEdit 组件 和两个 点击按钮以及内存存储相应数据的位置 关联起来, 点击相应按钮之后 会执行内存数据的加减, 然后再显示在相应的组件上, 便于查看, 实现代码具体实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192/** * @file Code\\model\\clineedit.h. * @copyright Copyright (c) 2019 IRIS_Chen IRIS Lab * * @brief Declares the clineedit class * @changelog 2019/11/12 IRIS_Chen Created. */#ifndef CLINEEDIT_H#define CLINEEDIT_H#include &lt;QObject&gt;#include &lt;QPushButton&gt;#include &lt;QLineEdit&gt;#include &lt;QMouseEvent&gt;#include &lt;QLabel&gt;#include &lt;QObject&gt;#include &lt;QWidget&gt;#include &lt;QString&gt;/** * @class CLineEdit clineedit.h Code\\model\\clineedit.h * * @brief 继承Qt 自定义文件 提升成为自己的组件, 修改窗口的值之后 保证相应的值 直接赋值到相应的内存中 如果关联了相应的 点击按钮, 按钮点击之后可以触发 数据更改 * * @author IRIS_Chen * @date 2019/11/13 */class CLineEdit : public QLineEdit&#123; private: int *m_data_; ///&lt; 指定数据关联的指针 QPushButton *btn_plus_; ///&lt; 定义增加按钮 QPushButton *btn_minus_; ///&lt; 定义减少按钮 public: explicit CLineEdit(QWidget *parent = nullptr) : QLineEdit(parent), m_data_(nullptr), btn_plus_(nullptr), btn_minus_(nullptr) &#123; // 输入完成进入自定义处理函数 &#125; /** * @fn bool CLineEdit::Associate(int *data, bool over = true) * * @brief 将内存与组件关联 * * @author IRIS_Chen * @date 2019/11/13 * * @param [in,out] data If non-null, the data * @param over (Optional) True to over * * @return True if it succeeds, false if it fails */ bool Associate(int *data, bool over = true) &#123; // 有值且不让覆盖 返回出错 if (!over &amp;&amp; m_data_ != nullptr) return false; m_data_ = data; ShowData(); return true; &#125; /** * @fn bool CLineEdit::Associate(int *data, QPushButton *plus, QPushButton *minus, bool over = true) * * @brief 关联数据 和两个按钮 * * @author IRIS_Chen * @date 2019/11/13 * * @param [in,out] data If non-null, the data * @param [in,out] plus If non-null, the plus * @param [in,out] minus If non-null, the minus * @param over (Optional) True to over * * @return True if it succeeds, false if it fails */ bool Associate(int *data, QPushButton *plus, QPushButton *minus, bool over = true) &#123; // 有值且不让覆盖 返回出错 if (!over &amp;&amp; (m_data_ || btn_minus_ || btn_plus_)) return false; m_data_ = data; btn_minus_ = minus; btn_plus_ = plus; // 关联 按钮点击信号 QObject::connect(this, &amp;QLineEdit::editingFinished, this, &amp;CLineEdit::LineEditDataProc); QObject::connect(btn_plus_, &amp;QPushButton::clicked, this, &amp;CLineEdit::LineEditDataPlus); QObject::connect(btn_minus_, &amp;QPushButton::clicked, this, &amp;CLineEdit::LineEditDataMinus); ShowData(); return true; &#125; private slots: /** * @fn bool CLineEdit::LineEditDataProc(void) * * @brief 数据输入完成 将数据存储相应内存中 * 暂时只考虑 数据部分, 将填入的数据内容给 获取出来 * * @author IRIS_Chen * @date 2019/11/13 * * @return True if it succeeds, false if it fails */ bool LineEditDataProc(void) &#123; if (!m_data_) return false; QString str = this-&gt;text(); int num = str.toInt(); // 转换相应的值存储 *(this-&gt;m_data_) = static_cast&lt;int&gt;(num); // LTrace(\"line data Edit:&#123;&#125;--&#123;&#125;\", (int)m_data_, *m_data_); return true; &#125; /** * @fn bool CLineEdit::LineEditDataPlus(void) * * @brief 数据 增加 并做显示 * * @author IRIS_Chen * @date 2019/11/13 * * @return True if it succeeds, false if it fails */ bool LineEditDataPlus(void) &#123; if (!m_data_) return false; *m_data_ = *m_data_ + 1; ShowData(); // LTrace(\"line data Plus:&#123;&#125;--&#123;&#125;\", (int)m_data_, *m_data_); return true; &#125; /** * @fn bool CLineEdit::LineEditDataMinus(void) * * @brief 数据减少 信号 * * @author IRIS_Chen * @date 2019/11/13 * * @return True if it succeeds, false if it fails */ bool LineEditDataMinus(void) &#123; if (!m_data_) return false; *m_data_ = *m_data_ - 1; ShowData(); // LTrace(\"line data Minus:&#123;&#125;--&#123;&#125;\", (int)m_data_, *m_data_); return true; &#125; private: /** * @fn void CLineEdit::ShowData(void) * * @brief Shows the data * * @author IRIS_Chen * @date 2019/11/13 */ void ShowData(void) &#123; if (m_data_) &#123; QString str = QString::number(*m_data_); this-&gt;setText(str); string tmp = str.toStdString(); &#125; &#125;&#125;;#endif // CLINEEDIT_H 更多我们可以设置相应的更为复杂的提升, 不仅关联 int 类型数据, 还能关联其他类型的数据比如字符串之类的 便于后续开发过程 参考链接 Qt 自定义控件以及控件的提升 Qt 基础学习（3）—–滑动条之 QSlider Qt 中控件类的提升","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://schen1024.github.io/tags/C/"},{"name":"QT","slug":"QT","permalink":"https://schen1024.github.io/tags/QT/"},{"name":"QT自定义","slug":"QT自定义","permalink":"https://schen1024.github.io/tags/QT%E8%87%AA%E5%AE%9A%E4%B9%89/"}]},{"title":"串口数据帧同步","slug":"串口数据帧同步","date":"2019-11-09T11:50:00.000Z","updated":"2023-01-01T13:25:24.781Z","comments":true,"path":"2019/11-09/串口数据帧同步.html","link":"","permalink":"https://schen1024.github.io/2019/11-09/%E4%B8%B2%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%B8%A7%E5%90%8C%E6%AD%A5.html","excerpt":"介绍串口是十分常用的一个资源, 每次需要进行处理串口数据, 但是 PC 上的串口存在缓冲区机制, 导致串口跟我们在单片机中的使用方式可能有所不同,每次拿到缓冲区数据之后,判断是否满足帧头,进而开始新的一帧数据计数存储, 最终满足一帧数据之后 将数据发送出来. 原理我们使用自定义的存储结果 作为自己的存储结果, 一般来说在项目中使用就是帧数据长度是一致的, 我们的程序也是基于这个原理的 1234567class SerialData&#123; public: uchar *data_; ///&lt; 帧数据 uchar *head_; ///&lt; 帧头数据 int dat_len_; ///&lt; 数据帧长度&#125;","text":"介绍串口是十分常用的一个资源, 每次需要进行处理串口数据, 但是 PC 上的串口存在缓冲区机制, 导致串口跟我们在单片机中的使用方式可能有所不同,每次拿到缓冲区数据之后,判断是否满足帧头,进而开始新的一帧数据计数存储, 最终满足一帧数据之后 将数据发送出来. 原理我们使用自定义的存储结果 作为自己的存储结果, 一般来说在项目中使用就是帧数据长度是一致的, 我们的程序也是基于这个原理的 1234567class SerialData&#123; public: uchar *data_; ///&lt; 帧数据 uchar *head_; ///&lt; 帧头数据 int dat_len_; ///&lt; 数据帧长度&#125; 我们需要根据自己的协议初始化数据长度和数据帧头内容 假设我们的数据为 14 个字节 包括 一般使用串口通信的数据都是按照这种格式进行的数据发送, [帧头] [长度] [地址] [指令] [数据] [校验]00 01 02 03 04 05 06 07 08 09 10 11 12 1368 0D 00 84 00 04 09 11 79 45 00 81 13 01 123frame_len = 14;data_ = new uchar[frame_len]; ///&lt; 存储数据head_ = new uchar[4]&#123; 0x68,0x0D,0x00,0x84 &#125;; ///&lt; 旧版协议头 实际上我们确定通信协议之后,PC 不存在命令之类的解析的话,可以把前面四个字节处理帧头,每次接收到帧头四个字节的时候表示数据已经重新开始了一帧,将收集到的数据存储相应的流程即可,继续处理后续数据 如果数据正常, 读取到帧头数据之后,假设帧头数据一致, 数据依次往后填充数据,等到数组填满,会再次获取到帧头数据 根据上一帧的状态码, 确定当前值, 如果满足设定的四个值, 满足帧头数据, 处理后续字节 将数据与帧头数组依次比较,使用 $flg_status$ 记录上一次匹配的位置, 如果不一致, 置零, 下次重新开始, 每次判断四个字节一致之后, $flg_status$ 累加到了 4 , 这时候进行 数据校验, 根据结果,将当前数据帧的值 压入队列中, 以上方法会导致第一帧校验失败,但是后续的帧处理结果可以保证不会出现问题, 相当于将四个字符作为了帧尾处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static int data_cnt = 0;static int flg_status = 0; // 0 普通数据,与数据头1 比较, 1 数据头1,2 数据头2, 3 数据头3, // 每次将缓冲区 数据全部读出来, // 判断上一帧读取到了什么状态, 数据分为 前4个字节的帧头数据和 后面的数据 // 1.读取到了帧头 // 2. 读取到了一般数据帧 // 每次计数, 读取到帧头的时候, 判断数据是否已经满了, 已经满了进行数据校验, 满足就加入数据 // 数据未满, 则可能数据未满,QByteArray recv = serial_-&gt;readAll(); // QSerial 读取的数据类型是 QByteArrrayint N = recv.size();if (recv.isEmpty())&#123; Sleep(5); // 休眠5毫秒 LError(\"recv data is empty\"); return false;&#125;// 遍历得到的数据数组for (int i = 0; i &lt; N; i++)&#123; uchar tmp = char2uchar(recv[i]); // 每次来了数据与上次的置位比较, 如果一致, 比较后一位, // 如果前面4位都一致,表示已经开始了新的一帧, 将数据依次复制 // 如果数据已经满足帧头, 将之前的数据 校验满足之后加入队列中, 其他线程处理 if (tmp == m_Frame.head_[flg_status]) &#123; flg_status++; if (flg_status == 4) &#123; // 由于存在每次存入数据的时候存在上一帧的数据 问题 所以这里校验可能失败 m_read_queue_-&gt;Push(m_Frame); // 更新前面4个字节的帧头数据 for (int i = 0; i &lt; 4; i++) m_Frame.data_[i] = m_Frame.head_[i]; // 匹配重新置零, 同时将数据前面数据复制过去 flg_status = 0; &#125; &#125; else &#123; flg_status = 0; // 如果前面的匹配上了, 后面匹配不上, 则重新开始进行匹配 &#125; m_Frame.data_[data_cnt++] = tmp; // 移动指针, 将数据存储到数组中 // 超过设定值, 减去一个长度,避免越界 // 与取与操作 % 处理一致 // 重新开始的位置 从可以刷新的数据开始 if (data_cnt == m_Frame.dat_len_) data_cnt = 0;&#125; 更多这个程序是自己目前在使用的方法,简单有效, 适用于串口通信的数据处理,十分好用, 这个算是项目文档 的一部分,后续可能再拓展, 但是基本框架不变, 测试起来也很好用 自己测试过程可以使用 VSPD 虚拟串口 6.9 汉化版 模拟出来两个相连的串口,初始设置一下就好, 然后使用普通的串口调试软件打开两个串口即可进行通信,十分方便, 参考链接无","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://schen1024.github.io/tags/C/"},{"name":"串口","slug":"串口","permalink":"https://schen1024.github.io/tags/%E4%B8%B2%E5%8F%A3/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://schen1024.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"Hexo博客插入图片的方法","slug":"Hexo博客插入图片的方法","date":"2019-11-09T10:15:08.000Z","updated":"2023-01-01T13:25:24.228Z","comments":true,"path":"2019/11-09/Hexo博客插入图片的方法.html","link":"","permalink":"https://schen1024.github.io/2019/11-09/Hexo%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E6%B3%95.html","excerpt":"hexo blog 插入图片的方法总结hexo 的 blog 内容是根据 markdown 文件的内容生成的 html 文件, 生成的文件全部在 /public 文件夹中, 所以我们使用相对路径的引用可能导致问题, 总结了一下常用的引用图片的几种方式,记录一下,避免再次忘记 绝对引用: 使用 /source/images 文件夹 相对引用: 使用 post_asset_folder:true 建立文章同名文件夹 CDN 或者图床引用 1. 绝对引用少量使用图片的时候使用, 将文件放在 /source/images 文件夹下, 使用 markdown 语法 ![Lena](/images/lena.png) 可以实现图片显示, 但是这种引用在本地 markdown 编辑器中会无法预览,因为相对路径不一致,找不到文件, 不过在首页内容和文章正文中都能正常显示,十分方便 个人使用的方法就是这种, 由于自己很少插入图片, 但是存在一个问题,后续可能维护起来麻烦, 不知道哪里引用了哪个图片,导致文章删除但是图片仍在, 很麻烦 2. 相对引用在站点配置文件/_config.yml 中配置指令 post_asset_folder: true 这样在每次新建文章的时候就会建立同名文件夹, 直接将相应的文章图片放在文件夹内 使用 语法 ![Lena](Hexo博客插入图片的方法/lena.png) 可以访问同名文件夹下图片资源,十分方便","text":"hexo blog 插入图片的方法总结hexo 的 blog 内容是根据 markdown 文件的内容生成的 html 文件, 生成的文件全部在 /public 文件夹中, 所以我们使用相对路径的引用可能导致问题, 总结了一下常用的引用图片的几种方式,记录一下,避免再次忘记 绝对引用: 使用 /source/images 文件夹 相对引用: 使用 post_asset_folder:true 建立文章同名文件夹 CDN 或者图床引用 1. 绝对引用少量使用图片的时候使用, 将文件放在 /source/images 文件夹下, 使用 markdown 语法 ![Lena](/images/lena.png) 可以实现图片显示, 但是这种引用在本地 markdown 编辑器中会无法预览,因为相对路径不一致,找不到文件, 不过在首页内容和文章正文中都能正常显示,十分方便 个人使用的方法就是这种, 由于自己很少插入图片, 但是存在一个问题,后续可能维护起来麻烦, 不知道哪里引用了哪个图片,导致文章删除但是图片仍在, 很麻烦 2. 相对引用在站点配置文件/_config.yml 中配置指令 post_asset_folder: true 这样在每次新建文章的时候就会建立同名文件夹, 直接将相应的文章图片放在文件夹内 使用 语法 ![Lena](Hexo博客插入图片的方法/lena.png) 可以访问同名文件夹下图片资源,十分方便 3. 在线资源在线图片如果我们要的图片现在网络上已经存在了,我们找到相应的地址直接引用就好可以只用标准 markdown 图片语法引用相关图片 ![百度图片--lena](http://images2018.cnblogs.com/blog/1003156/201806/1003156-20180604175546711-227291592.png) 例如 百度图片 CSDN 图片 博客园图片 维基百科图片 自己做的图如果我们要的图只是我们自己画出来的图,或者生成的图,可以使用在线图床上传之后得到链接使用, 个人感觉最好用的图床是 sm.ms, 点击上传之后可以得到各种链接,十分方便, 最终给出的链接比如 https://i.loli.net/2019/11/09/KDut86ljxM9TXnP.png 的形式 刚刚上传了代码的一段截图 得到链接在这里测试使用 图像样式自定义对于 markdown 插入的图片,可能不是很满足自己的需求,需要进行一定的图片调整,比如图片居中或者图片大小控制 相应的各家 markdown 的编辑器有自己的实现规则,但是在 hexo blog 中我们对于图片的处理一般是转为直接 做 html 处理, 比如 使用 img 标记来控制图片显示大小图片大小控制&lt;img src=&quot;/images/lena.png&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt; 使用 div 加上 css 来控制图片的显示和大小&lt;div style=&quot;width: 200px; margin: auto&quot;&gt;![Lena](/images/lena.png)&lt;/div&gt; Hexo 中扩展 Markdown 语法设置图片的大小 blog 中自己写了一个控制显示的方法,可以参考 更多个人目前使用的方法 1但是后续可能要换成方法 2 更加方便管理图片以及后续可能的迁移过程, 希望对看到的你们有一点帮助. 参考链接 在 Hexo 博客中插入图片的各种方式 Hexo 博客搭建之在文章中插入图片 hexo 博客图片问题 Hexo 插入图片和设置图片大小 Hexo 中扩展 Markdown 语法设置图片的大小","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://schen1024.github.io/tags/hexo/"},{"name":"图片","slug":"图片","permalink":"https://schen1024.github.io/tags/%E5%9B%BE%E7%89%87/"},{"name":"blog","slug":"blog","permalink":"https://schen1024.github.io/tags/blog/"}]},{"title":"C++-doctest-测试框架","slug":"C-doctest-测试框架","date":"2019-11-08T12:50:20.000Z","updated":"2023-01-01T13:25:24.199Z","comments":true,"path":"2019/11-08/C-doctest-测试框架.html","link":"","permalink":"https://schen1024.github.io/2019/11-08/C-doctest-%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6.html","excerpt":"测试框架doctest 是用过的最简单好用的的单元测试框架, 只需要引用 一个头文件即可 无 main 函数的测试样例1234567891011#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN#include \"doctest.h\"int factorial(int number) &#123; return number &lt;= 1 ? number : factorial(number - 1) * number; &#125;TEST_CASE(\"testing the factorial function\") &#123; CHECK(factorial(1) == 1); CHECK(factorial(2) == 2); CHECK(factorial(3) == 6); CHECK(factorial(10) == 3628800);&#125;","text":"测试框架doctest 是用过的最简单好用的的单元测试框架, 只需要引用 一个头文件即可 无 main 函数的测试样例1234567891011#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN#include \"doctest.h\"int factorial(int number) &#123; return number &lt;= 1 ? number : factorial(number - 1) * number; &#125;TEST_CASE(\"testing the factorial function\") &#123; CHECK(factorial(1) == 1); CHECK(factorial(2) == 2); CHECK(factorial(3) == 6); CHECK(factorial(10) == 3628800);&#125; 有 main 函数的测试样例在函数 context 的 run 执行的时候 会将所有 TEST_CASE 的宏函数展开执行, 可以根据自己的情况安排测试 123456789101112131415161718192021222324252627282930313233#define DOCTEST_CONFIG_IMPLEMENT#include \"doctest.h\"int main(int argc, char **argv) &#123; doctest::Context context; context.applyCommandLine(argc, argv); int res = context.run(); // run doctest // important - query flags (and --exit) rely on the user doing this if (context.shouldExit()) &#123; // propagate the result of the tests return res; &#125; printf(\"%s\\n\", \"Hello, World!\"); system(\"pause\"); return 0;&#125;int factorial(const int number) &#123; return number &lt; 1 ? 1 : number &lt;= 1 ? number : factorial(number - 1) * number;&#125;TEST_CASE(\"testing the factorial function\") &#123; CHECK(factorial(0) == 1); CHECK(factorial(1) == 1); CHECK(factorial(2) == 2); CHECK(factorial(3) == 6); CHECK(factorial(10) == 3628800);&#125; 更多自己简单使用的功能能够使用了,自己看到了 vczh 写的一个简单的测试框架的实现, 了解原理,然后发现了这个 C++库, 真的很好用, 目前自己需要的功能够用, 后续更过功能还要自己去啃 doctest 文档 但是感觉 GoogleTest 提供的功能更多, 后续可能切换过去, 参考链接 doctest 文档翻译 Doctest Github 仓库 Doctest 官方例程 Vczh 自定义测试框架实现","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://schen1024.github.io/tags/C/"},{"name":"UnitTest","slug":"UnitTest","permalink":"https://schen1024.github.io/tags/UnitTest/"},{"name":"Doctest","slug":"Doctest","permalink":"https://schen1024.github.io/tags/Doctest/"}]},{"title":"C++多线程队列实现","slug":"C-多线程队列实现","date":"2019-11-08T12:49:12.000Z","updated":"2023-01-01T13:25:24.199Z","comments":true,"path":"2019/11-08/C-多线程队列实现.html","link":"","permalink":"https://schen1024.github.io/2019/11-08/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0.html","excerpt":"介绍在项目中,进行多线程队列实现是一个比较麻烦的事, 找到了一个实现比较好的多线程队列实现, 自己做了一点修改更加适应自己的项目, 记录下来, 有需要的自己进行修改使用. 代码写的并不是很好, 封装起来的实现也是并不是很好用, 个人水平的一个记录, 希望理解 多线程队列实现 初始化一定长度的空间存储数据 每次压入或者弹出操作的时候需要获取锁, 保证同时只有一个操作可以被执行, 压入或者弹出数据的时候, 如果队列已经满了或者空的, 另外一个线程可能需要等待, 或者返回 false 具体看程序注释,考虑自己情况进行程序修改 最终清理对象数据, 清空队列,退出线程 具体实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312#ifndef CQUEUE_H__#define CQUEUE_H__#pragma once#include &lt;atomic&gt;#include &lt;condition_variable&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;mutex&gt;#include &lt;queue&gt;/** * @class Queue CQueue.h Code\\inc\\CQueue.h * * @brief 线程安全队列实现 * * 因为有std::mutex和std::condition_variable类成员,所以此类不支持复制构造函数也不支持赋值操作符(=) * * @author IRIS_Chen * @date 2019/10/10 * * @tparam T Generic type parameter. */template &lt;class T&gt;/** * @class CQueue CQueue.h Code\\inc\\CQueue.h * * @brief Queue of cs. * * @author IRIS_Chen * @date 2019/10/17 */class CQueue&#123; protected: // Data std::queue&lt;T&gt; _queue; ///&lt; 存储数据的真实队列, 不是线程安全的 private: typename std::queue&lt;T&gt;::size_type _size_max; ///&lt; 队列的最大长度 // Thread gubbins std::mutex _mutex; ///&lt; 线程操作 锁 std::condition_variable _fullQue; ///&lt; 队列满了的信号 std::condition_variable _empty; ///&lt; 队列为空的信号 // Exit // 原子操作 std::atomic_bool _quit; ///&lt; &#123; false &#125;; // 退出信号 std::atomic_bool _finished; ///&lt; &#123; false &#125;; // 完成信号 // 表示不再继续输入数据 public: /** * @fn CQueue::CQueue(const size_t size_max) * * @brief 初始化队列长度,并将退出标志和 满信号标志置空 * * @author IRIS_Chen * @date 2019/10/17 * * @param size_max 队列的最长尺寸 */ CQueue(const size_t size_max) :_size_max(size_max) &#123; _quit = ATOMIC_VAR_INIT(false); _finished = ATOMIC_VAR_INIT(false); &#125; /** * @fn CQueue::CQueue(CONST CQueue&amp;) = delete; * * @brief 不允许拷贝构造函数 * * @author IRIS_Chen * @date 2019/10/17 * * @param parameter1 The first parameter */ CQueue(CONST CQueue&amp;) = delete; ///&lt; 不允许拷贝构造函数 /** * @fn CQueue::~CQueue() * * @brief Finalizes an instance of the CQueue class 销毁队列, 退出线程 清除数据 // 存在问题 * * @author IRIS_Chen * @date 2019/11/8 */ ~CQueue() &#123; Quit(); while (_queue.size()) ; &#125; /** * @fn bool CQueue::Push(T&amp; data) * * @brief 队列中加入新的 对象 根据情况决定 满信号之后 新数据丢弃或者等待 * * @author IRIS_Chen * @date 2019/10/10 * * @param [in,out] data The data to Push. * * @return True if it succeeds, false if it fails. */ bool Push(T&amp; data) &#123; std::unique_lock&lt;std::mutex&gt; lock(_mutex); while (!_quit &amp;&amp; !_finished) &#123; if (_queue.size() &lt; _size_max) &#123; _queue.push(std::move(data)); //_queue.Push(data); _empty.notify_all(); return true; &#125; else &#123; // wait的时候自动释放锁，如果wait到了会获取锁 // _fullQue.wait(lock); return false; ///&lt; 如果满了 这里不进行等待 避免出现问题 &#125; &#125; return false; &#125; /** * @fn bool CQueue::Pop(T &amp;data) * * @brief 返回队列最前面的元素 并且弹出 // 如果空 如果finish 则直接返回fasle 否则 等待队列加入元素 * * @author IRIS_Chen * @date 2019/10/14 * * @param [in,out] data The data to Pop. * * @return True if it succeeds, false if it fails. */ bool Pop(T &amp;data) &#123; std::unique_lock&lt;std::mutex&gt; lock(_mutex); while (!_quit) &#123; if (!_queue.empty()) // 队列非空 &#123; //data = std::move(_queue.front()); data = _queue.front(); _queue.pop(); _fullQue.notify_all(); // 通知所有 由于满队无法加入的线程 return true; &#125; else if (_queue.empty() &amp;&amp; _finished) // 队列为空 且不再加入 &#123; return false; &#125; else &#123; // _empty.wait(lock); // 等待队列加入元素 return false; ///&lt; 不等待元素加入数据 &#125; &#125; return false; &#125; /** * @fn std::shared_ptr&lt;T&gt; CQueue::Pop(void) * * @brief 弹出一个元素 直接返回 出错无法报错 * * @author IRIS_Chen * @date 2019/10/14 * * @return The previous top-of-stack object. */ std::shared_ptr&lt;T&gt; Pop(void) &#123; std::unique_lock&lt;std::mutex&gt; lock(_mutex); std::shared_ptr&lt;T&gt; res = nullptr; while (!_quit) &#123; if (!_queue.empty()) // 队列非空 &#123; //data = std::move(_queue.front()); res = std::make_shared&lt;T&gt;(_queue.front()); _queue.pop(); _fullQue.notify_all(); // 通知所有 由于满队无法加入的线程 return res; &#125; else if (_queue.empty() &amp;&amp; _finished) // 队列为空 且不再加入 &#123; return res; // 无数据进入 智能返回一个空指针 (可能出错) &#125; else &#123; _empty.wait(lock); // 等待队列加入元素 &#125; &#125; return false; &#125; /** * @fn void CQueue::Finished() * * @brief The queue has Finished accepting input 标识队列完成输入 不再继续输入 * * @author IRIS_Chen * @date 2019/10/14 */ void Finished() &#123; _finished = true; _empty.notify_all(); &#125; /** * @fn void CQueue::Quit() * * @brief Quits this CQueue 退出队列, 无法再加入压入或者弹出数据 * * @author IRIS_Chen * @date 2019/10/14 */ void Quit() &#123; _quit = true; _empty.notify_all(); _fullQue.notify_all(); &#125; /** * @fn int CQueue::Length() * * @brief Gets the Length 返回队列目前长度 * * @author IRIS_Chen * @date 2019/10/14 * * @return An int. */ int Length() &#123; std::unique_lock&lt;std::mutex&gt; lock(_mutex); return static_cast&lt;int&gt;(_queue.size()); &#125; /** * @fn int CQueue::Size() * * @brief Gets the Size 返回当前队列长度 * * @author IRIS_Chen * @date 2019/10/14 * * @return An int. */ int Size() &#123; std::unique_lock&lt;std::mutex&gt; lock(_mutex); return static_cast&lt;int&gt;(_queue.size()); &#125; /** * @fn bool CQueue::empty(void) * * @brief 判断是否为空 * * @author IRIS_Chen * @date 2019/10/17 * * @return True if it succeeds, false if it fails */ bool Empty(void) &#123; std::unique_lock&lt;std::mutex&gt; lock(_mutex); return (0 == _queue.size()); &#125; /** * @fn bool CQueue::Clear(void) * * @brief 清空队列 * * @author IRIS_Chen * @date 2019/10/17 * * @return True if it succeeds, false if it fails */ bool Clear(void) &#123; std::unique_lock&lt;std::mutex&gt; lock(_mutex); while (!_queue.empty ()) &#123; Pop(); // 依次弹出数据 &#125; return true; &#125;&#125;;#endif","text":"介绍在项目中,进行多线程队列实现是一个比较麻烦的事, 找到了一个实现比较好的多线程队列实现, 自己做了一点修改更加适应自己的项目, 记录下来, 有需要的自己进行修改使用. 代码写的并不是很好, 封装起来的实现也是并不是很好用, 个人水平的一个记录, 希望理解 多线程队列实现 初始化一定长度的空间存储数据 每次压入或者弹出操作的时候需要获取锁, 保证同时只有一个操作可以被执行, 压入或者弹出数据的时候, 如果队列已经满了或者空的, 另外一个线程可能需要等待, 或者返回 false 具体看程序注释,考虑自己情况进行程序修改 最终清理对象数据, 清空队列,退出线程 具体实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312#ifndef CQUEUE_H__#define CQUEUE_H__#pragma once#include &lt;atomic&gt;#include &lt;condition_variable&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;mutex&gt;#include &lt;queue&gt;/** * @class Queue CQueue.h Code\\inc\\CQueue.h * * @brief 线程安全队列实现 * * 因为有std::mutex和std::condition_variable类成员,所以此类不支持复制构造函数也不支持赋值操作符(=) * * @author IRIS_Chen * @date 2019/10/10 * * @tparam T Generic type parameter. */template &lt;class T&gt;/** * @class CQueue CQueue.h Code\\inc\\CQueue.h * * @brief Queue of cs. * * @author IRIS_Chen * @date 2019/10/17 */class CQueue&#123; protected: // Data std::queue&lt;T&gt; _queue; ///&lt; 存储数据的真实队列, 不是线程安全的 private: typename std::queue&lt;T&gt;::size_type _size_max; ///&lt; 队列的最大长度 // Thread gubbins std::mutex _mutex; ///&lt; 线程操作 锁 std::condition_variable _fullQue; ///&lt; 队列满了的信号 std::condition_variable _empty; ///&lt; 队列为空的信号 // Exit // 原子操作 std::atomic_bool _quit; ///&lt; &#123; false &#125;; // 退出信号 std::atomic_bool _finished; ///&lt; &#123; false &#125;; // 完成信号 // 表示不再继续输入数据 public: /** * @fn CQueue::CQueue(const size_t size_max) * * @brief 初始化队列长度,并将退出标志和 满信号标志置空 * * @author IRIS_Chen * @date 2019/10/17 * * @param size_max 队列的最长尺寸 */ CQueue(const size_t size_max) :_size_max(size_max) &#123; _quit = ATOMIC_VAR_INIT(false); _finished = ATOMIC_VAR_INIT(false); &#125; /** * @fn CQueue::CQueue(CONST CQueue&amp;) = delete; * * @brief 不允许拷贝构造函数 * * @author IRIS_Chen * @date 2019/10/17 * * @param parameter1 The first parameter */ CQueue(CONST CQueue&amp;) = delete; ///&lt; 不允许拷贝构造函数 /** * @fn CQueue::~CQueue() * * @brief Finalizes an instance of the CQueue class 销毁队列, 退出线程 清除数据 // 存在问题 * * @author IRIS_Chen * @date 2019/11/8 */ ~CQueue() &#123; Quit(); while (_queue.size()) ; &#125; /** * @fn bool CQueue::Push(T&amp; data) * * @brief 队列中加入新的 对象 根据情况决定 满信号之后 新数据丢弃或者等待 * * @author IRIS_Chen * @date 2019/10/10 * * @param [in,out] data The data to Push. * * @return True if it succeeds, false if it fails. */ bool Push(T&amp; data) &#123; std::unique_lock&lt;std::mutex&gt; lock(_mutex); while (!_quit &amp;&amp; !_finished) &#123; if (_queue.size() &lt; _size_max) &#123; _queue.push(std::move(data)); //_queue.Push(data); _empty.notify_all(); return true; &#125; else &#123; // wait的时候自动释放锁，如果wait到了会获取锁 // _fullQue.wait(lock); return false; ///&lt; 如果满了 这里不进行等待 避免出现问题 &#125; &#125; return false; &#125; /** * @fn bool CQueue::Pop(T &amp;data) * * @brief 返回队列最前面的元素 并且弹出 // 如果空 如果finish 则直接返回fasle 否则 等待队列加入元素 * * @author IRIS_Chen * @date 2019/10/14 * * @param [in,out] data The data to Pop. * * @return True if it succeeds, false if it fails. */ bool Pop(T &amp;data) &#123; std::unique_lock&lt;std::mutex&gt; lock(_mutex); while (!_quit) &#123; if (!_queue.empty()) // 队列非空 &#123; //data = std::move(_queue.front()); data = _queue.front(); _queue.pop(); _fullQue.notify_all(); // 通知所有 由于满队无法加入的线程 return true; &#125; else if (_queue.empty() &amp;&amp; _finished) // 队列为空 且不再加入 &#123; return false; &#125; else &#123; // _empty.wait(lock); // 等待队列加入元素 return false; ///&lt; 不等待元素加入数据 &#125; &#125; return false; &#125; /** * @fn std::shared_ptr&lt;T&gt; CQueue::Pop(void) * * @brief 弹出一个元素 直接返回 出错无法报错 * * @author IRIS_Chen * @date 2019/10/14 * * @return The previous top-of-stack object. */ std::shared_ptr&lt;T&gt; Pop(void) &#123; std::unique_lock&lt;std::mutex&gt; lock(_mutex); std::shared_ptr&lt;T&gt; res = nullptr; while (!_quit) &#123; if (!_queue.empty()) // 队列非空 &#123; //data = std::move(_queue.front()); res = std::make_shared&lt;T&gt;(_queue.front()); _queue.pop(); _fullQue.notify_all(); // 通知所有 由于满队无法加入的线程 return res; &#125; else if (_queue.empty() &amp;&amp; _finished) // 队列为空 且不再加入 &#123; return res; // 无数据进入 智能返回一个空指针 (可能出错) &#125; else &#123; _empty.wait(lock); // 等待队列加入元素 &#125; &#125; return false; &#125; /** * @fn void CQueue::Finished() * * @brief The queue has Finished accepting input 标识队列完成输入 不再继续输入 * * @author IRIS_Chen * @date 2019/10/14 */ void Finished() &#123; _finished = true; _empty.notify_all(); &#125; /** * @fn void CQueue::Quit() * * @brief Quits this CQueue 退出队列, 无法再加入压入或者弹出数据 * * @author IRIS_Chen * @date 2019/10/14 */ void Quit() &#123; _quit = true; _empty.notify_all(); _fullQue.notify_all(); &#125; /** * @fn int CQueue::Length() * * @brief Gets the Length 返回队列目前长度 * * @author IRIS_Chen * @date 2019/10/14 * * @return An int. */ int Length() &#123; std::unique_lock&lt;std::mutex&gt; lock(_mutex); return static_cast&lt;int&gt;(_queue.size()); &#125; /** * @fn int CQueue::Size() * * @brief Gets the Size 返回当前队列长度 * * @author IRIS_Chen * @date 2019/10/14 * * @return An int. */ int Size() &#123; std::unique_lock&lt;std::mutex&gt; lock(_mutex); return static_cast&lt;int&gt;(_queue.size()); &#125; /** * @fn bool CQueue::empty(void) * * @brief 判断是否为空 * * @author IRIS_Chen * @date 2019/10/17 * * @return True if it succeeds, false if it fails */ bool Empty(void) &#123; std::unique_lock&lt;std::mutex&gt; lock(_mutex); return (0 == _queue.size()); &#125; /** * @fn bool CQueue::Clear(void) * * @brief 清空队列 * * @author IRIS_Chen * @date 2019/10/17 * * @return True if it succeeds, false if it fails */ bool Clear(void) &#123; std::unique_lock&lt;std::mutex&gt; lock(_mutex); while (!_queue.empty ()) &#123; Pop(); // 依次弹出数据 &#125; return true; &#125;&#125;;#endif 更多有另外的多线程实现, 来自网上找到的, 可能找不到参考链接了, 贴出来 供参考 线程安全队列 1具体实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190/** * @class ThreadSafeQueue CQueue.h Code\\inc\\CQueue.h * * @brief 线程安全队列实现 * * @author IRIS_Chen * @date 2019/10/10 * * @tparam T Generic type parameter. */template&lt;typename T&gt;/** * @class ThreadSafeQueue CQueue.h Code\\inc\\CQueue.h * * @brief Queue of thread safes. * * @author IRIS_Chen * @date 2019/10/17 */class ThreadSafeQueue&#123; private: /** * @property mutable std::mutex mut * * @brief Gets the mut * * @return The mut */ mutable std::mutex mut; std::queue&lt;T&gt; data_queue; ///&lt; Queue of data std::condition_variable data_cond; ///&lt; The data condition public: /** * @fn ThreadSafeQueue::ThreadSafeQueue() * * @brief Initializes a new instance of the ThreadSafeQueue class * * @author IRIS_Chen * @date 2019/10/17 */ ThreadSafeQueue() &#123;&#125; /** * @fn ThreadSafeQueue::ThreadSafeQueue(ThreadSafeQueue const&amp; other) * * @brief 拷贝构造函数 * * @author IRIS_Chen * @date 2019/10/17 * * @param other The other */ ThreadSafeQueue(ThreadSafeQueue const&amp; other) &#123; std::lock_guard&lt;std::mutex&gt; lk(other.mut); data_queue = other.data_queue; &#125; /** * @fn void ThreadSafeQueue::Push(T&amp; new_value) * * @brief Pushes an object onto this stack * * @author IRIS_Chen * @date 2019/10/17 * * @param [in,out] new_value The new value to Push */ void push(T&amp; new_value)//入队操作 &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); data_queue.push(new_value); data_cond.notify_one(); &#125; /** * @fn void ThreadSafeQueue::wait_and_pop(T&amp; value) * * @brief Wait and Pop * * @author IRIS_Chen * @date 2019/10/17 * * @param [in,out] value The value */ void wait_and_pop(T&amp; value)//直到有元素可以删除为止 &#123; std::unique_lock&lt;std::mutex&gt; lk(mut); data_cond.wait(lk, [this] &#123; return !data_queue.empty(); &#125;); value = data_queue.front(); data_queue.pop(); &#125; /** * @fn std::shared_ptr&lt;T&gt; ThreadSafeQueue::wait_and_pop() * * @brief Wait and pop * * @author IRIS_Chen * @date 2019/10/17 * * @return A std::shared_ptr&amp;lt;T&amp;gt; */ std::shared_ptr&lt;T&gt; wait_and_pop() &#123; std::unique_lock&lt;std::mutex&gt; lk(mut); data_cond.wait(lk, [this] &#123; return !data_queue.empty(); &#125;); std::shared_ptr&lt;T&gt; res(std::make_shared&lt;T&gt;(data_queue.front())); data_queue.pop(); return res; &#125; /** * @fn bool ThreadSafeQueue::try_pop(T&amp; value) * * @brief Attempts to pop * * @author IRIS_Chen * @date 2019/10/17 * * @param [in,out] value The value * * @return True if it succeeds, false if it fails */ bool try_pop(T&amp; value)//不管有没有队首元素直接返回 &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); if (data_queue.empty()) return false; value = data_queue.front(); data_queue.pop(); return true; &#125; /** * @fn std::shared_ptr&lt;T&gt; ThreadSafeQueue::try_pop() * * @brief Try pop * * @author IRIS_Chen * @date 2019/10/17 * * @return A std::shared_ptr&amp;lt;T&amp;gt; */ std::shared_ptr&lt;T&gt; try_pop() &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); if (data_queue.empty()) return std::shared_ptr&lt;T&gt;(); std::shared_ptr&lt;T&gt; res(std::make_shared&lt;T&gt;(data_queue.front())); data_queue.pop(); return res; &#125; /** * @fn bool ThreadSafeQueue::empty() const * * @brief Empties this object * * @author IRIS_Chen * @date 2019/10/17 * * @return True if it succeeds, false if it fails */ bool empty() const &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); return data_queue.empty(); &#125;&#125;; 线程安全队列 2 具体实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include &lt;queue&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;initializer_list&gt;/** 线程安全队列* T为队列元素类型* 因为有std::mutex和std::condition_variable类成员,所以此类不支持复制构造函数也不支持赋值操作符(=)* */template&lt;typename T&gt;/** * @class threadsafe_queue CQueue.h Code\\inc\\CQueue.h * * @brief Queue of threadsafes. * * @author IRIS_Chen * @date 2019/10/17 */class threadsafe_queue&#123; private: /** * @property mutable std::mutex mut * * @brief data_queue访问信号量 * * @return The mut */ mutable std::mutex mut; /** * @property mutable std::condition_variable data_cond * * @brief Gets the data condition * * @return The data condition */ mutable std::condition_variable data_cond; using queue_type = std::queue&lt;T&gt;; ///&lt; Type of the queue queue_type data_queue; ///&lt; Queue of data public: using value_type = typename queue_type::value_type; ///&lt; Type of the value using container_type = typename queue_type::container_type; ///&lt; Type of the container /** * @fn threadsafe_queue::threadsafe_queue() = default; * * @brief Initializes a new instance of the threadsafe_queue class * * @author IRIS_Chen * @date 2019/10/17 */ threadsafe_queue() = default; /** * @fn threadsafe_queue::threadsafe_queue(const threadsafe_queue&amp;) = delete; * * @brief Initializes a new instance of the threadsafe_queue class * * @author IRIS_Chen * @date 2019/10/17 * * @param parameter1 The first parameter */ threadsafe_queue(const threadsafe_queue&amp;) = delete; /** * @fn threadsafe_queue&amp; threadsafe_queue::operator=(const threadsafe_queue&amp;) = delete; * * @brief Assignment operator * * @author IRIS_Chen * @date 2019/10/17 * * @param parameter1 The first parameter * * @return A shallow copy of this object */ threadsafe_queue&amp; operator=(const threadsafe_queue&amp;) = delete; /* * 使用迭代器为参数的构造函数,适用所有容器对象 * */ template&lt;typename _InputIterator&gt; /** * @fn threadsafe_queue::threadsafe_queue(_InputIterator first, _InputIterator last) * * @brief Initializes a new instance of the threadsafe_queue class * * @author IRIS_Chen * @date 2019/10/17 * * @param first The first * @param last The last */ threadsafe_queue(_InputIterator first, _InputIterator last) &#123; for (auto itor = first; itor != last; ++itor) &#123; data_queue.push(*itor); &#125; &#125; /** * @fn explicit threadsafe_queue::threadsafe_queue(const container_type &amp;c) * * @brief Initializes a new instance of the threadsafe_queue class * * @author IRIS_Chen * @date 2019/10/17 * * @param c A container_type to process */ explicit threadsafe_queue(const container_type &amp;c) :data_queue(c) &#123;&#125; /* * 使用初始化列表为参数的构造函数 * */ /** * @fn threadsafe_queue::threadsafe_queue(std::initializer_list&lt;value_type&gt; list) * * @brief Initializes a new instance of the threadsafe_queue class * * @author IRIS_Chen * @date 2019/10/17 * * @param list The list */ threadsafe_queue(std::initializer_list&lt;value_type&gt; list) :threadsafe_queue(list.begin(), list.end()) &#123; &#125; /* * 将元素加入队列 * */ /** * @fn void threadsafe_queue::push(const value_type &amp;new_value) * * @brief Pushes an object onto this stack * * @author IRIS_Chen * @date 2019/10/17 * * @param new_value The new value to push */ void push(const value_type &amp;new_value) &#123; std::lock_guard&lt;std::mutex&gt;lk(mut); data_queue.push(std::move(new_value)); data_cond.notify_one(); &#125; /* * 从队列中弹出一个元素,如果队列为空就阻塞 * */ /** * @fn value_type threadsafe_queue::wait_and_pop() * * @brief Wait and pop * * @author IRIS_Chen * @date 2019/10/17 * * @return A value_type */ value_type wait_and_pop() &#123; std::unique_lock&lt;std::mutex&gt;lk(mut); data_cond.wait(lk, [this] &#123; return !this-&gt;data_queue.empty(); &#125;); auto value = std::move(data_queue.front()); data_queue.pop(); return value; &#125; /* * 从队列中弹出一个元素,如果队列为空返回false * */ /** * @fn bool threadsafe_queue::try_pop(value_type&amp; value) * * @brief Attempts to pop * * @author IRIS_Chen * @date 2019/10/17 * * @param [in,out] value The value * * @return True if it succeeds, false if it fails */ bool try_pop(value_type&amp; value) &#123; std::lock_guard&lt;std::mutex&gt;lk(mut); if (data_queue.empty()) return false; value = std::move(data_queue.front()); data_queue.pop(); return true; &#125; /* * 返回队列是否为空 * */ /** * @fn auto threadsafe_queue::empty() const-&gt;decltype(data_queue.empty()) * * @brief Gets the empty * * @author IRIS_Chen * @date 2019/10/17 * * @return An auto */ auto empty() const-&gt;decltype(data_queue.empty()) &#123; std::lock_guard&lt;std::mutex&gt;lk(mut); return data_queue.empty(); &#125; /* * 返回队列中元素数个 * */ /** * @fn auto threadsafe_queue::Size() const-&gt;decltype(data_queue.Size()) * * @brief Gets the Size * * @author IRIS_Chen * @date 2019/10/17 * * @return An auto */ auto size() const-&gt;decltype(data_queue.size()) &#123; std::lock_guard&lt;std::mutex&gt;lk(mut); return data_queue.size(); &#125;&#125;; /* threadsafe_queue */ 参考链接 C++11:基于 std::queue 和 std::mutex 构建一个线程安全的队列 Thread-safe concurrent FIFO queue in C++ Java 多线程总结之线程安全队列 Queue C++并发实战 12：线程安全的 queue","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://schen1024.github.io/tags/C/"},{"name":"多线程","slug":"多线程","permalink":"https://schen1024.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"队列","slug":"队列","permalink":"https://schen1024.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"学习","slug":"学习","permalink":"https://schen1024.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"平面点集中距离最近的点对","slug":"平面点集中距离最近的点对","date":"2019-10-22T12:51:14.000Z","updated":"2023-01-01T13:25:24.785Z","comments":true,"path":"2019/10-22/平面点集中距离最近的点对.html","link":"","permalink":"https://schen1024.github.io/2019/10-22/%E5%B9%B3%E9%9D%A2%E7%82%B9%E9%9B%86%E4%B8%AD%E8%B7%9D%E7%A6%BB%E6%9C%80%E8%BF%91%E7%9A%84%E7%82%B9%E5%AF%B9.html","excerpt":"问题描述平面上 $N$ 个点,求点集中距离最小的一对(欧式距离)如图所示, 给定 7 个点的座标, 求距离最近的两个点. 问题解决对于 $N$ 个点的点对距离, 可以使用不同的方法解决, 暴力: 暴力枚举所有的点, 找到最近的两个点的距离, 时间复杂度: $O(N^2)$; 分治1: 按照横座标排序,分为左右两部分,分别求出两部分中的最小距离, 最后考虑最近距离点对在左右两个部分的情况, 时间复杂度: $O(NlogNlogN)$ 基于哈希的随机算法3: 算法实现题目实战参考链接 最近点对问题 平面最近点对 nlogn 分治算法 求平面中距离最近的两点 求最近点对的三种方法 平面最近点距离问题(分治法)","text":"问题描述平面上 $N$ 个点,求点集中距离最小的一对(欧式距离)如图所示, 给定 7 个点的座标, 求距离最近的两个点. 问题解决对于 $N$ 个点的点对距离, 可以使用不同的方法解决, 暴力: 暴力枚举所有的点, 找到最近的两个点的距离, 时间复杂度: $O(N^2)$; 分治1: 按照横座标排序,分为左右两部分,分别求出两部分中的最小距离, 最后考虑最近距离点对在左右两个部分的情况, 时间复杂度: $O(NlogNlogN)$ 基于哈希的随机算法3: 算法实现题目实战参考链接 最近点对问题 平面最近点对 nlogn 分治算法 求平面中距离最近的两点 求最近点对的三种方法 平面最近点距离问题(分治法)","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"分治","slug":"分治","permalink":"https://schen1024.github.io/tags/%E5%88%86%E6%B2%BB/"},{"name":"数学","slug":"数学","permalink":"https://schen1024.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"无序数组中求最大值和最小值的最少比较次数","slug":"无序数组中求最大值和最小值的最少比较次数","date":"2019-10-21T18:13:03.000Z","updated":"2023-01-01T13:25:24.788Z","comments":true,"path":"2019/10-21/无序数组中求最大值和最小值的最少比较次数.html","link":"","permalink":"https://schen1024.github.io/2019/10-21/%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%91%E6%AF%94%E8%BE%83%E6%AC%A1%E6%95%B0.html","excerpt":"无序数组中求最大值和最小值的最少比较次数原理介绍求一个无序数组中的最大值和最小值是一个很常见的情况, 一般来说, 最大值和最小值不是同一个元素, 我们可以通过下面几种方法来求: 排序算法:将数组排序后, 第一个元素是最小值,最后一个元素是最大值,以快排平均复杂度为例,时间复杂度 $O(NlogN)$,空间复杂度: $O(logN)$,比较次数: $NlogN$ ; 两个元素记录最大值和最小值,判断每个值是否大于最大值或者最小值, 比较次数: $2*N$’; 使用两个值记录最大值和最小值, 每次取出两个值,先进行比较,小的与最小值比较,大的与最大值比较 , 比较次数: $1.5*N$ 将相邻的数进行比较,大的放在偶数位置,小的放在奇数位置, 最后奇数位置比较和偶数位置对应比较,得到最大值和最小值,比较次数: $1.5*N$ ; 分治法, topK 问题的简化版本分成两部分,找到前半部分的 Min Max, 最后比较结果可得到最后的值 方法 3 和方法 4 的 过程很接近, 方法 3 更为容易实现, 具体实现可见后续","text":"无序数组中求最大值和最小值的最少比较次数原理介绍求一个无序数组中的最大值和最小值是一个很常见的情况, 一般来说, 最大值和最小值不是同一个元素, 我们可以通过下面几种方法来求: 排序算法:将数组排序后, 第一个元素是最小值,最后一个元素是最大值,以快排平均复杂度为例,时间复杂度 $O(NlogN)$,空间复杂度: $O(logN)$,比较次数: $NlogN$ ; 两个元素记录最大值和最小值,判断每个值是否大于最大值或者最小值, 比较次数: $2*N$’; 使用两个值记录最大值和最小值, 每次取出两个值,先进行比较,小的与最小值比较,大的与最大值比较 , 比较次数: $1.5*N$ 将相邻的数进行比较,大的放在偶数位置,小的放在奇数位置, 最后奇数位置比较和偶数位置对应比较,得到最大值和最小值,比较次数: $1.5*N$ ; 分治法, topK 问题的简化版本分成两部分,找到前半部分的 Min Max, 最后比较结果可得到最后的值 方法 3 和方法 4 的 过程很接近, 方法 3 更为容易实现, 具体实现可见后续 算法实现方法 1 快排123456// 找到数组元素的最大值和最小值vector&lt;int&gt; findMinMax(vector&lt;int&gt; arr)&#123; sort(arr.begin(),arr.end()); return &#123;arr[0],arr.back()&#125;;&#125; 方法 212345678910111213// 找到数组元素的最大值和最小值vector&lt;int&gt; findMinMax(vector&lt;int&gt; arr)&#123; int min_ = INT_MAX,max_ = INT_MIN; for(int i=0;i&lt;arr.size();++i) &#123; if(arr[i] &gt; max_) max_ = arr[i]; if(arr[i] &lt; min_) min_ = arr[i]; &#125; return &#123;min_,max_&#125;;&#125; 方法 3使用两个值记录最大值和最小值, 每次取出两个值,先进行比较,小的与最小值比较,大的与最大值比较 , 比较次数: $1.5*N$ 12345678910111213141516171819202122232425262728// 找到数组元素的最大值和最小值vector&lt;int&gt; findMinMax(vector&lt;int&gt; arr) &#123; int min_ = INT_MAX,max_ = INT_MIN; // 处理前面偶数个元素 for(int i=0;i&lt;arr.size()/2;++i) &#123; // 得到两个元素的最大值和最小值 int tmp_min,tmp_max; if(arr[i] &lt; arr[i+1]) &#123; tmp_min = arr[i]; tmp_max = arr[i+1]; &#125; else &#123; tmp_min = arr[i+1]; tmp_max = arr[i]; &#125; // 比较,更新最大值和最小值 if(tmp_max &gt; max_) max_ = tmp_max; if(tmp_min &lt; min_) min_ = tmp_min; &#125; // 处理数组个数为奇数的情况 // 处理最后一个元素 if(arr.size()%2) &#123; int tmp = arr.back(); if(tmp &gt; max_) max_ = tmp; if(tmp &lt; min_) min_ = tmp; &#125; return &#123;min_,max_&#125;;&#125; 方法 4比较前面偶数个元素,小的放在奇数位置,大的放在偶数位置, 比较次数: $1.5*N$ 12345678910111213141516171819202122// 找到数组元素的最大值和最小值vector&lt;int&gt; findMinMax(vector&lt;int&gt; arr) &#123; int min_ = INT_MAX,max_ = INT_MIN; // 调整位置, 小的位于奇数,大的位置偶数 for(int i=0;i&lt;arr.size()/2;i++) &#123; if(arr[i] &gt; arr[i+1]) swap(arr[i],arr[i+1]); &#125; // 更新最大值和最小值 for(int i=0;i&lt;arr.size()/2;i++) &#123; if(arr[i] &lt; min_) min_ = arr[i]; if(arr[i+1] &gt; max_) max_ = arr[i+1]; &#125; // 处理数组个数为奇数的情况 // 处理最后一个元素 if(arr.size()%2) &#123; int tmp = arr.back(); if(tmp &gt; max_) max_ = tmp; if(tmp &lt; min_) min_ = tmp; &#125; return &#123;min_,max_&#125;;&#125; 方法 5在 N 个数中求最小值 Min 和 Max, 分成两个部分,依次取 Min 和 Max,略 参考链接 关于在一个无序数组中的数求最大值和最小值的最小比较次数 无序数组同时查找最大和最小的元素 面试题-算法：乱序数组中找最大值和最小值 【编程之美】读书笔记：寻找数组中的最大值和最小值","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[]},{"title":"FindAJob","slug":"FindAJob","date":"2019-10-10T22:06:18.000Z","updated":"2023-01-01T13:25:24.223Z","comments":true,"path":"2019/10-10/FindAJob.html","link":"","permalink":"https://schen1024.github.io/2019/10-10/FindAJob.html","excerpt":"","text":"此文章是找工作系列的第一篇文章, 主要展示文章的书写方式, 介绍系列文章的大纲以及后续可能进行的内容梳理. 个人并不认为自己最终拿到的 offer 非常满意, 但是由于各种原因所以还是做了妥协, 准备的面试过程中, 看到了很多, 学到了很多, 但是 系列文章介绍 时间安排 提前批 实习/全职 非技术要求 简历 面试 手撕/白板 BQ 群面 问面试官的话 技术要求 计算机基础 算法与数据结构 操作系统 计算机网络 数据库 设计模式 Offer 环节 薪资待遇 offer 比较 公司评价 其他 各家公司评价","categories":[{"name":"Person","slug":"Person","permalink":"https://schen1024.github.io/categories/Person/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://schen1024.github.io/tags/Interview/"},{"name":"Jobs","slug":"Jobs","permalink":"https://schen1024.github.io/tags/Jobs/"}]},{"title":"QT bug ig9icd64.dll","slug":"bug-ig9icd64-dll","date":"2019-08-11T19:48:32.000Z","updated":"2023-01-01T13:25:24.265Z","comments":true,"path":"2019/08-11/bug-ig9icd64-dll.html","link":"","permalink":"https://schen1024.github.io/2019/08-11/bug-ig9icd64-dll.html","excerpt":"ig9icd64.dll 处有未经处理的异常遇到了一个 ==奇奇怪怪==的 bug, 一般的 QT 程序中 在==main.cpp== 中初始化一个窗口进行显示后,进行执行 QApplication 的 执行 一般是如下的结构: 12345678910// QT 5.11 的例程程序 示例int main(int argc, char **argv)&#123; QGuiApplication app(argc, argv); AnalogClockWindow clock; clock.show(); return app.exec();&#125;","text":"ig9icd64.dll 处有未经处理的异常遇到了一个 ==奇奇怪怪==的 bug, 一般的 QT 程序中 在==main.cpp== 中初始化一个窗口进行显示后,进行执行 QApplication 的 执行 一般是如下的结构: 12345678910// QT 5.11 的例程程序 示例int main(int argc, char **argv)&#123; QGuiApplication app(argc, argv); AnalogClockWindow clock; clock.show(); return app.exec();&#125; 但是不知到为什么问题, 调试程序的时候突然出现了,如图所示的错误, 提醒 ==ig9icd64.dll== 处有未经处理的异常,调试发现是在执行最后一句,==return app.exec();== 进行一定搜索之后,找到了一篇 blog 介绍Qt 上 OpenGL 画图不能正常使用，程序崩溃, 介绍的很详细, 然后解决方法是 更新显卡驱动或者重新安装一下显卡驱动 查看了很多网站,以及在==Intel== 的官方社区里面都有人提出这个的问题,而且应该是一个普遍的一个问题了 给出几个参考链接 以供查询 Crash in ig9icd64.dll on intel 630 (and similar) gpu in 64bit windows 10 #23863Editor doesn’t draw properly (one frame lag) on systems with Intel drivers (driver vendor bug) 最终发现了 QT 官方给出的一个 BUG 报告中Windows/IntelHD Graphics 620: Qt Quick application crashes if it contains a visible element, with certain compilers介绍了这个 bug 是由于硬件渲染出现了问题, 自己想办法更新驱动或者==开启软件渲染==来避免问题,开启方法可用以下语句: QQuickWindow::setSceneGraphBackend(QSGRendererInterface::Software); 或者使用 QT_OPENGL = angle 来抑制崩溃 官方还给出了详细的介绍,以及调用的堆栈信息,可以自己查阅相关内容 2019_08_11","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"bug","slug":"bug","permalink":"https://schen1024.github.io/tags/bug/"},{"name":"intel","slug":"intel","permalink":"https://schen1024.github.io/tags/intel/"}]},{"title":"Introduction","slug":"intro","date":"2019-08-06T00:00:00.000Z","updated":"2023-01-01T13:25:24.771Z","comments":true,"path":"2019/08-06/intro.html","link":"","permalink":"https://schen1024.github.io/2019/08-06/intro.html","excerpt":"常用命令记录记录下来常用命令, 免得每次都要查找 常用指令和发布文章常用指令 hexo new “postName” //新建文章hexo new page “pageName” //新建页面hexo g //生成静态页面至 public 目录hexo server //开启预览访问端口（默认端口 4000，’ctrl + c’关闭 server）hexo deploy //将.deploy 目录部署到 GitHub 常用组合 hexo cleanhexo ghexo dhexo d -g #生成部署hexo s -g #生成预览 发布文章终端 cd 到 blog 文件夹下，执行如下命令新建文章： hexo new “xxx”名为 xxx.md 的文件会建在目录…/blog/source/_posts 下。 ==scaffolds== 文件夹下面存储的是模板文件,可以自定义部分模板, 使用 hexo new temp xxx.md生成新文件 所有的文章都会以 md 形式保存在_post 文件夹中，只要在_post 文件夹中新建 md 类型的文档，就能在执行 hexo g 的时候被渲染。新建的文章头需要添加一些信息，如下所示： 123456---title: xxx //在此处添加你的标题。date: 2016-10-07 13:38:49 //在此处输入编辑这篇文章的时间。tags: xxx //在此处输入这篇文章的标签。categories: xxx //在此处输入这篇文章的分类。--- 文章编辑完成后，终端 cd 到 blog 文件夹下，依次执行如下命令来发布： hexo ghexo d 如果没有报错 那么就已经发布成功了","text":"常用命令记录记录下来常用命令, 免得每次都要查找 常用指令和发布文章常用指令 hexo new “postName” //新建文章hexo new page “pageName” //新建页面hexo g //生成静态页面至 public 目录hexo server //开启预览访问端口（默认端口 4000，’ctrl + c’关闭 server）hexo deploy //将.deploy 目录部署到 GitHub 常用组合 hexo cleanhexo ghexo dhexo d -g #生成部署hexo s -g #生成预览 发布文章终端 cd 到 blog 文件夹下，执行如下命令新建文章： hexo new “xxx”名为 xxx.md 的文件会建在目录…/blog/source/_posts 下。 ==scaffolds== 文件夹下面存储的是模板文件,可以自定义部分模板, 使用 hexo new temp xxx.md生成新文件 所有的文章都会以 md 形式保存在_post 文件夹中，只要在_post 文件夹中新建 md 类型的文档，就能在执行 hexo g 的时候被渲染。新建的文章头需要添加一些信息，如下所示： 123456---title: xxx //在此处添加你的标题。date: 2016-10-07 13:38:49 //在此处输入编辑这篇文章的时间。tags: xxx //在此处输入这篇文章的标签。categories: xxx //在此处输入这篇文章的分类。--- 文章编辑完成后，终端 cd 到 blog 文件夹下，依次执行如下命令来发布： hexo ghexo d 如果没有报错 那么就已经发布成功了","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"test","slug":"test","permalink":"https://schen1024.github.io/tags/test/"},{"name":"blog","slug":"blog","permalink":"https://schen1024.github.io/tags/blog/"}]},{"title":"Latex-0-latex2word","slug":"Latex-0-latex2word","date":"2019-06-20T20:30:11.000Z","updated":"2023-01-01T13:25:24.231Z","comments":true,"path":"2019/06-20/Latex-0-latex2word.html","link":"","permalink":"https://schen1024.github.io/2019/06-20/Latex-0-latex2word.html","excerpt":"Latex 转 Word虽然 latex 格式很方便，能够满足绝大部分的排版要求，但是在与人沟通的时候不可避免地需要用到其他格式文件，比如来自老板的修改意见。所以还是需要部分时候需要用到 word 文件，经过一番学习，看到了神器– Pandoc。 只需要一句话便能够得到对应的 word 文件，但是 tikz 似乎不能转换， 1pandoc -s example.tex -o example.docx","text":"Latex 转 Word虽然 latex 格式很方便，能够满足绝大部分的排版要求，但是在与人沟通的时候不可避免地需要用到其他格式文件，比如来自老板的修改意见。所以还是需要部分时候需要用到 word 文件，经过一番学习，看到了神器– Pandoc。 只需要一句话便能够得到对应的 word 文件，但是 tikz 似乎不能转换， 1pandoc -s example.tex -o example.docx","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"Latex","slug":"Latex","permalink":"https://schen1024.github.io/tags/Latex/"},{"name":"XeLaTex","slug":"XeLaTex","permalink":"https://schen1024.github.io/tags/XeLaTex/"}]},{"title":"LeetCode-912-SortAnArray","slug":"LeetCode-912-SortAnArray","date":"2019-06-20T20:09:34.000Z","updated":"2023-01-01T13:25:24.234Z","comments":true,"path":"2019/06-20/LeetCode-912-SortAnArray.html","link":"","permalink":"https://schen1024.github.io/2019/06-20/LeetCode-912-SortAnArray.html","excerpt":"题目题目所在链接为 题目名字 题目描述题目描述","text":"题目题目所在链接为 题目名字 题目描述题目描述 输入输出样例Example 1: Input: 123Output: 321 Example 2: Input: -123Output: -321 Example 3: Input: 120Output: 21 备注备注或者提示 解题解题思路解题思路 ==时间复杂度==: $O(log(n))$==空间复杂度==: $O(1)$ 参考链接 blog 具体实现12345678910111213141516171819202122class Solution &#123;public: int reverse(int x) &#123; if (x == 0) return 0; // 输入long long 型 数据 避免溢出 long long sum = 0; while (x!=0) &#123; // 将每一位的数据 升位 加上余数 sum = sum * 10 + x % 10; // 输入数字 降位 x = x / 10; // 判断溢出 if (sum &gt; INT_MAX || sum &lt; INT_MIN) return 0; &#125; return int(sum); &#125;&#125;; 运行结果使用 C/C++实现运行结果 2019-03-27 Runtime: 8 ms, faster than 99.38% of C++ online submissions for Reverse Integer.Memory Usage: 8.2 MB, less than 99.80% of C++ online submissions for Reverse Integer.","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://schen1024.github.io/tags/LeetCode/"},{"name":"Array","slug":"Array","permalink":"https://schen1024.github.io/tags/Array/"},{"name":"easy","slug":"easy","permalink":"https://schen1024.github.io/tags/easy/"}]},{"title":"Interview_ReverseList.md","slug":"Interview-ReverseList","date":"2019-06-06T13:38:15.000Z","updated":"2023-01-01T13:25:24.231Z","comments":true,"path":"2019/06-06/Interview-ReverseList.html","link":"","permalink":"https://schen1024.github.io/2019/06-06/Interview-ReverseList.html","excerpt":"面试题目==经典算法题目== : 反转单链表 reverse list 对于一个普通的单链表,可以定义成结构体形式: 123456// 定义链表节点struct ListNode&#123; int val; ListNode * next;&#125; 请写一个函数实现单链表的翻转","text":"面试题目==经典算法题目== : 反转单链表 reverse list 对于一个普通的单链表,可以定义成结构体形式: 123456// 定义链表节点struct ListNode&#123; int val; ListNode * next;&#125; 请写一个函数实现单链表的翻转 题目解析一般来说,单链表的反转有递归和非递归的方式来进行实现, 此处的反转实现 参考反转链表图示 其中递归方式的实现比较难以理解, 进攻参考 递归方式12345678910111213141516// 递归方式ListNode * ReverseList_re(ListNode * head)&#123; // 如果空链表或者 单节点链表 if(head ==nullptr || head-&gt;next == nullptr) return head; // 依次进行每个节点的执行 ListNode * new_head = ReverseList_re(head-&gt;next); // 对于每一个节点 反转前后实现 head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return new_head;&#125; 非递归方式123456789101112131415161718192021222324252627282930313233343536373839404142434445// ref:[链表反转图文讲解](https://blog.csdn.net/FX677588/article/details/72357389)// 非递归方式ListNode * ReverseList(ListNode *head)&#123; // 如果空链表或者 单节点链表 if(head == nullptr || head-&gt;next == nullptr) return head; // 新建两个节点 P用来遍历head, new_head 为新链表的头 ListNode *p = head, *new_head = nullptr; while(p != nullptr) &#123; ListNode * tmp = p-&gt;next; // 存储当前节点的指针位置 p-&gt;next = new_head; // 将当前节点指向新节点的头 new_head = p; // 新链表 移动头 p = tmp; // 旧链表指针移动 &#125; // 返回新的节点值 return new_head;&#125;// 不返回操作 非递归 反转链表void ReverseList2(ListNode * &amp;head)&#123; // 如果空链表或者 单节点链表 if(head == nullptr || head-&gt;next == nullptr) return ; // 新建两个节点 P用来遍历head, new_head 为新链表的头 ListNode *p = head, *new_head = nullptr; while(p != nullptr) &#123; ListNode * tmp = p-&gt;next; // 存储当前节点的指针位置 p-&gt;next = new_head; // 将当前节点指向新节点的头 new_head = p; // 新链表 移动头 p = tmp; // 旧链表指针移动 &#125; // 复用 head 指针 head = new_head;&#125; 附加内容测试工程 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153// 链表操作类的 测试#include &lt;iostream&gt;using namespace std;// 定义链表节点 值和指针struct ListNode&#123; int val; ListNode *next;&#125;;// 定义链表的 增 删 查 改// CRUD// 创建链表 // 根据首指针 创建首指针节点void CreateHead(ListNode *head, int data)&#123;&#125;// 在链表尾头部添加新节点void AddNode(ListNode * &amp; head,int data)&#123; // 创建 新节点 //申请空间 ListNode *p = (ListNode*) malloc(sizeof(ListNode)); p-&gt;val = data; p-&gt;next = nullptr; // 如果是一个空链表 直接赋值到head 然后返回 if(head == nullptr) &#123; head = p; return ; &#125; // 指向新节点 返回新节点 p-&gt;next = head; head = p;&#125;// 删除节点// 查找节点// 更新节点值// 打印List 所有节点值void PrintList(ListNode *head)&#123; // 从某个节点开始 打印所有节点的值 ListNode *p = head; // 临时节点 便于输出 避免 改变 head 值 while(p != nullptr) &#123; // cout&lt;&lt;(long)p%65536&lt;&lt;\":\"; // 输出指针的一个 数字表示 cout&lt;&lt;p-&gt;val&lt;&lt;\"-&gt;\"; p = p-&gt;next; &#125; cout&lt;&lt;\"NULL\"&lt;&lt;endl;&#125;// 反转链表// ref:[链表反转图文讲解](https://blog.csdn.net/FX677588/article/details/72357389)// 非递归方式ListNode * ReverseList(ListNode *head)&#123; // 如果空链表或者 单节点链表 if(head == nullptr || head-&gt;next == nullptr) return head; // 新建两个节点 P用来遍历head, new_head 为新链表的头 ListNode *p = head, *new_head = nullptr; while(p != nullptr) &#123; ListNode * tmp = p-&gt;next; // 存储当前节点的指针位置 p-&gt;next = new_head; // 将当前节点指向新节点的头 new_head = p; // 新链表 移动头 p = tmp; // 旧链表指针移动 &#125; // 返回新的节点值 return new_head;&#125;// 不返回操作 非递归 反转链表void ReverseList2(ListNode * &amp;head)&#123; // 如果空链表或者 单节点链表 if(head == nullptr || head-&gt;next == nullptr) return ; // 新建两个节点 P用来遍历head, new_head 为新链表的头 ListNode *p = head, *new_head = nullptr; while(p != nullptr) &#123; ListNode * tmp = p-&gt;next; // 存储当前节点的指针位置 p-&gt;next = new_head; // 将当前节点指向新节点的头 new_head = p; // 新链表 移动头 p = tmp; // 旧链表指针移动 &#125; // 复用 head 指针 head = new_head;&#125;// 递归方式ListNode * ReverseList_re(ListNode * head)&#123; // 如果空链表或者 单节点链表 if(head ==nullptr || head-&gt;next == nullptr) return head; // 依次进行每个节点的执行 ListNode * new_head = ReverseList_re(head-&gt;next); // 对于每一个节点 反转前后实现 head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return new_head;&#125;// 主函数 测试 demo#define LENGTH 20int main(void)&#123; ListNode *head = nullptr; // 生成随机链表 for(int i=0;i&lt;LENGTH;++i) AddNode(head,rand()%LENGTH); PrintList(head); // 反转链表 并输出 head = ReverseList(head); PrintList(head); // 反转链表 并输出 ReverseList2(head); PrintList(head); // 反转链表 并输出 递归实现 head = ReverseList_re(head); PrintList(head); // system(\"pause\"); return 0;&#125;","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://schen1024.github.io/tags/Interview/"},{"name":"C++","slug":"C","permalink":"https://schen1024.github.io/tags/C/"},{"name":"Work","slug":"Work","permalink":"https://schen1024.github.io/tags/Work/"},{"name":"Job","slug":"Job","permalink":"https://schen1024.github.io/tags/Job/"}]},{"title":"面试-仿射变换","slug":"interview-zhongwang","date":"2019-06-05T18:53:03.000Z","updated":"2023-01-01T13:25:24.770Z","comments":true,"path":"2019/06-05/interview-zhongwang.html","link":"","permalink":"https://schen1024.github.io/2019/06-05/interview-zhongwang.html","excerpt":"面试题目仿射变换,给出一个点在平面旋转$\\theta$角的仿射矩阵. 题目内容仿射变换(ATF,Affine Transformation) 是图像的线性变换,对于一个集合$X$ 的仿射变换可以表示为: $$f(x) = Ax+b, x \\in X.$$ 对于我们需要处理的图像集合而言,可以表示为: $$g(x,y) = Af(x,y)+b.$$ 其中$A$矩阵就是仿射变换矩阵.","text":"面试题目仿射变换,给出一个点在平面旋转$\\theta$角的仿射矩阵. 题目内容仿射变换(ATF,Affine Transformation) 是图像的线性变换,对于一个集合$X$ 的仿射变换可以表示为: $$f(x) = Ax+b, x \\in X.$$ 对于我们需要处理的图像集合而言,可以表示为: $$g(x,y) = Af(x,y)+b.$$ 其中$A$矩阵就是仿射变换矩阵. 仿射变换内容介绍可以参考链接:仿射变换介绍 常用的仿射变换包括:缩放: Scale旋转: Rotate平移: Transform反射: Reflection错切: Shear 可以参考图: 仿射变换中集合中的一些性质保持不变：（1）凸性（2）共线性：若几个点变换前在一条线上，则仿射变换后仍然在一条线上（3）平行性：若两条线变换前平行，则变换后仍然平行（4）共线比例不变性：变换前一条线上两条线段的比例，在变换后比例仍然步 注：所有的三角形都能通过仿射变化为其他三角形，所有平行四边形也能仿射变换为另一个平行四边形。 由于仿射变换是线性的,所以仿射变换的任意组合仍然是线性的. 仿射变换矩阵推导仿射变换矩阵推导以 矩阵旋转为例,也是面试题目的内容:假设原本点为 $C$ 点,旋转 $\\theta$ 角度之后到达 $B$ 点, 计算旋转矩阵 A. 以二维矩阵为例 对于$C,B$两点表示成极坐标为 $C(r\\cos\\alpha,r\\sin\\alpha)$,$B(r\\cos(\\alpha+\\theta),r\\sin(\\alpha+\\theta))$,对于 $$x_B = r\\cos(\\alpha+\\theta) = r(\\cos\\alpha\\cos\\theta-\\sin\\alpha\\sin\\theta) = (\\cos\\theta -\\sin\\theta)x_C$$ $$y_B = r\\sin(\\alpha+\\theta) = r(\\sin\\alpha\\cos\\theta+\\cos\\alpha\\sin\\theta) = (\\sin\\theta+\\cos\\theta)y_C$$ 所以可以推导出如下矩阵 $$\\left[ \\begin{array}{l} {\\mathrm{x_B}} \\ {y_B} \\end{array}\\right]=\\left[ \\begin{array}{cc} {\\cos \\theta} &amp; {-\\sin \\theta} \\ {\\sin \\theta} &amp; {\\cos \\theta} \\end{array}\\right]\\left[ \\begin{array}{l} {\\mathrm{x_C}} \\ {y_C} \\end{array}\\right]$$ 内容延展","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://schen1024.github.io/tags/Interview/"},{"name":"Work","slug":"Work","permalink":"https://schen1024.github.io/tags/Work/"},{"name":"Job","slug":"Job","permalink":"https://schen1024.github.io/tags/Job/"}]},{"title":"LeetCode-Contest-132-DivisorGame","slug":"LeetCode-Contest-132-DivisorGame","date":"2019-04-14T12:07:01.000Z","updated":"2023-01-01T13:25:24.234Z","comments":true,"path":"2019/04-14/LeetCode-Contest-132-DivisorGame.html","link":"","permalink":"https://schen1024.github.io/2019/04-14/LeetCode-Contest-132-DivisorGame.html","excerpt":"题目题目所在链接为 1025. Divisor Game 题目描述A B 两个人玩游戏,A 先手首先给一个数字 $N$, 每个人可以选择一个数$x$满足$ 0&lt; x &lt; N$ 而且 $N % x == 0$接下来 $N$ 变成 $N-x$依次轮流, 直到无数字可以选择为止 如果 A 赢 返回 True 否则返回 False Alice and Bob take turns playing a game, with Alice starting first. Initially, there is a number $N$ on the chalkboard. On each player’s turn, that player makes a move consisting of: Choosing any $x$ with $0 &lt; x &lt; N$ and $N % x == 0$.Replacing the number $N$ on the chalkboard with $N - x$.Also, if a player cannot make a move, they lose the game. Return True if and only if Alice wins the game, assuming both players play optimally.","text":"题目题目所在链接为 1025. Divisor Game 题目描述A B 两个人玩游戏,A 先手首先给一个数字 $N$, 每个人可以选择一个数$x$满足$ 0&lt; x &lt; N$ 而且 $N % x == 0$接下来 $N$ 变成 $N-x$依次轮流, 直到无数字可以选择为止 如果 A 赢 返回 True 否则返回 False Alice and Bob take turns playing a game, with Alice starting first. Initially, there is a number $N$ on the chalkboard. On each player’s turn, that player makes a move consisting of: Choosing any $x$ with $0 &lt; x &lt; N$ and $N % x == 0$.Replacing the number $N$ on the chalkboard with $N - x$.Also, if a player cannot make a move, they lose the game. Return True if and only if Alice wins the game, assuming both players play optimally. 输入输出样例Example 1: Input: 2Output: trueExplanation: Alice chooses 1, and Bob has no more moves. Example 2: Input: 3Output: falseExplanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves. Example 3: Input: 120Output: 21 备注 A B 足够理性 $1 &lt;= N &lt;= 1000$ 解题解题思路 记录一定赢的数组 wins 首先先加入数字 2 计算数字 N 的因子, 判断是否 N-因子 是否都在数组中 如果有一个因子不在必赢数组中,则该数字必赢, 否则必输 ==时间复杂度==: $O(N)$==空间复杂度==: $O(log(N))$ 参考链接 11960 - Divisor Game 具体实现1234567891011121314151617181920212223242526272829303132class Solution &#123;public: bool divisorGame(int N) &#123; // 维持两个表, 一定赢 的数据存入数组 wins中, // 计算N 减去自己的因子, 如果在数组中 则必输, 否则一定赢 存入数组 unordered_set&lt;int&gt; wins; wins.insert(2); // 计算一下每一个因子 如果存在一个因子不在数组内 则 可以必胜 for(int i=3;i&lt;N+1;i++) &#123; for(int j=1;j&lt;i;j++) &#123; if(i%j == 0) &#123; if(wins.count(i-j) ==0) &#123; wins.insert(i); break; &#125; &#125; &#125; &#125; if(wins.count(N)) return true; return false; &#125;&#125;; 运行结果使用 C/C++实现运行结果 2019-04-14 40 / 40 test cases passed.Status: AcceptedRuntime: 24 msMemory Usage: 8.5 MB 改进优化改进思路所有偶数必定赢, 奇数必输还不知道原理 改进的实现12345678910class Solution &#123;public: bool divisorGame(int N) &#123; if(N%2 ==0 ) return true; return false; &#125;&#125;; 运行结果 40 / 40 test cases passed.Status: AcceptedRuntime: 4 msMemory Usage: 8.1 MB","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://schen1024.github.io/tags/LeetCode/"},{"name":"easy","slug":"easy","permalink":"https://schen1024.github.io/tags/easy/"},{"name":"Contest","slug":"Contest","permalink":"https://schen1024.github.io/tags/Contest/"},{"name":"PrimeNum","slug":"PrimeNum","permalink":"https://schen1024.github.io/tags/PrimeNum/"}]},{"title":"LeetCode-517-SuperWashingMachines","slug":"LeetCode-517-SuperWashingMachines","date":"2019-04-11T20:37:11.000Z","updated":"2023-01-01T13:25:24.233Z","comments":true,"path":"2019/04-11/LeetCode-517-SuperWashingMachines.html","link":"","permalink":"https://schen1024.github.io/2019/04-11/LeetCode-517-SuperWashingMachines.html","excerpt":"题目题目所在链接为 517. Super Washing Machines 题目描述你拥有 n 台超级洗衣机，开始状态每台拥有或者空的衣服。每次操作都只能将某些洗衣机内一件衣服移动到临近洗衣机。给定一个数组标识每个洗衣机的衣服数量，问多少次操作之后才能实现衣服均等。返回最少的操作次数，如果数字不可分，直接返回 -1 。 You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty. For each move, you could choose any m (1 ≤ m ≤ n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time . Given an integer array representing the number of dresses in each washing machine from left to right on the line, you should find the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.","text":"题目题目所在链接为 517. Super Washing Machines 题目描述你拥有 n 台超级洗衣机，开始状态每台拥有或者空的衣服。每次操作都只能将某些洗衣机内一件衣服移动到临近洗衣机。给定一个数组标识每个洗衣机的衣服数量，问多少次操作之后才能实现衣服均等。返回最少的操作次数，如果数字不可分，直接返回 -1 。 You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty. For each move, you could choose any m (1 ≤ m ≤ n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time . Given an integer array representing the number of dresses in each washing machine from left to right on the line, you should find the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1. 输入输出样例Example 1: Input: [1,0,5]Output: 3Explanation:1st move: 1 0 1 1 42nd move: 1 &lt;– 1 2 1 33rd move: 2 1 2 2 2 Example 2: Input: [0,3,0]Output: 2Explanation:1st move: 0 1 2 02nd move: 1 2 –&gt; 0 =&gt; 1 1 1 Example 3: Input: [0,2,0]Output: -1Explanation:It’s impossible to make all the three washing machines have the same number of dresses. 备注洗衣机的数量在 [1, 10000]每台洗衣机内的衣服数量为 [0, 1e5] The range of n is [1, 10000].The range of dresses number in a super washing machine is [0, 1e5]. 解题解题思路 首先计算总数和，计算是否能够整除 用当前衣服数量减去均值得到需要移动到均值的状态操作 计算每一个位置左右两侧的需要衣服的数量， 记为 L，R3.1 如果 L&lt;0 &amp;&amp; R 0 &amp;&amp; R &gt; 0 说明左右两侧都缺少衣服， 移动次数为 abs(L) + abs(R)3.3 如果 (L &lt; 0 &amp;&amp; R &gt; 0) || (L &gt; 0 &amp;&amp; R &lt; 0) 有多余衣服的一侧需要向缺衣服的一侧匀衣服，所以必要移动次数仍然是：max(abs(L), abs(R))。 计算最大移动次数既可 ==时间复杂度==: $O(log(n))$==空间复杂度==: $O(1)$ 参考链接 Super Short &amp; Easy Java O(n) Solution [leetcode] 517. Super Washing Machines [LeetCode] Super Washing Machines 超级洗衣机 具体实现12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int findMinMoves(vector&lt;int&gt;&amp; machines) &#123; /* 1. 首先计算总数和，计算是否能够整除 2. 用当前衣服数量减去均值得到需要移动到均值的状态操作 3. 计算每一个位置左右两侧的需要衣服的数量， 记为 L，R 3.1 如果 L&lt;0 &amp;&amp; R &lt;0 说明左右两侧都多衣服， 移动次数为 max(abs(L),abs(R)) 3.2 如果 L&gt;0 &amp;&amp; R &gt; 0 说明左右两侧都缺少衣服， 移动次数为 abs(L) + abs(R) 3.3 如果 (L &lt; 0 &amp;&amp; R &gt; 0) || (L &gt; 0 &amp;&amp; R &lt; 0) 有多余衣服的一侧需要向缺衣服的一侧匀衣服，所以必要移动次数仍然是：max(abs(L), abs(R))。 4. 计算最大移动次数既可 */ //初始化 位置数据向量 vector&lt;int&gt; tmp_v(machines.size()+2,0); long long int total_sum= 0; for(int i=0;i&lt;machines.size();i++) &#123; total_sum += machines[i]; &#125; if(total_sum % machines.size() != 0) return -1; int res = 0, cnt = 0, avg = total_sum / machines.size(); for (int m : machines) &#123; cnt += m - avg; res = max(res, max(abs(cnt), m - avg)); &#125; return res; &#125;&#125;; 运行结果使用 C/C++实现运行结果 2019-04-11 Runtime: 12 ms, faster than 98.54% of C++ online submissions for Super Washing Machines.Memory Usage: 9.5 MB, less than 100.00% of C++ online submissions for Super Washing Machines.","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://schen1024.github.io/tags/LeetCode/"},{"name":"hard","slug":"hard","permalink":"https://schen1024.github.io/tags/hard/"},{"name":"Math","slug":"Math","permalink":"https://schen1024.github.io/tags/Math/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://schen1024.github.io/tags/Dynamic-Programming/"}]},{"title":"LeetCode-388-LongestAbsoluteFilePath","slug":"LeetCode-388-LongestAbsoluteFilePath","date":"2019-04-02T13:35:40.000Z","updated":"2023-01-01T13:25:24.233Z","comments":true,"path":"2019/04-02/LeetCode-388-LongestAbsoluteFilePath.html","link":"","permalink":"https://schen1024.github.io/2019/04-02/LeetCode-388-LongestAbsoluteFilePath.html","excerpt":"题目题目所在链接为 388. Longest Absolute File Path 题目描述给定一个字符串 包含两种特殊符号 \\n \\t分别对应回车和 tab 可能包含空目录，找到包含最长路径字符串的长度 Suppose we abstract our file system by a string in the following manner: The string “dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext” represents: dirsubdir1subdir2file.extThe directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext. The string “dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext” represents: dirsubdir1file1.extsubsubdir1subdir2subsubdir2file2.extThe directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext. We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is “dir/subdir2/subsubdir2/file2.ext”, and its length is 32 (not including the double quotes). Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0.","text":"题目题目所在链接为 388. Longest Absolute File Path 题目描述给定一个字符串 包含两种特殊符号 \\n \\t分别对应回车和 tab 可能包含空目录，找到包含最长路径字符串的长度 Suppose we abstract our file system by a string in the following manner: The string “dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext” represents: dirsubdir1subdir2file.extThe directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext. The string “dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext” represents: dirsubdir1file1.extsubsubdir1subdir2subsubdir2file2.extThe directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext. We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is “dir/subdir2/subsubdir2/file2.ext”, and its length is 32 (not including the double quotes). Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0. 输入输出样例Example 1: Input: dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext”Output: 20 备注 文件包含拓展名 和 . 假设不会出现 .. 目录 最深的目录不一定是最长的目录 The name of a file contains at least a . and an extension.The name of a directory or sub-directory will not contain a ..Time complexity required: O(n) where n is the size of the input string. Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png. 解题解题思路 遍历字符串， 如果遇到了 \\n 和 \\t 停止 如果遇到了 \\n 提取包含 如果文件名 . 更新长度 = 文件夹基本深度+文件名长度 否则 是文件夹， 更新深度 和下一文件夹的基本深度 ==时间复杂度==: $O(N)$==空间复杂度==: $O(1)$ 参考链接 bl[LeetCode] Longest Absolute File Path 最长的绝对文件路径 og 具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: /* 1. 遍历字符串， 如果遇到了 \\n 和 \\t 停止 2. 如果遇到了 \\n 提取字符串 包含 如果文件名 . 更新长度 = 文件夹基本深度+文件名长度 3. 否则 是文件夹， 更新深度 和下一文件夹的基本深度 */ int lengthLongestPath(string input) &#123; int res=0,level=0; unordered_map&lt;int,int&gt; m&#123;&#123;0,0&#125;&#125;; for(int i=0;i&lt;input.length();i++) &#123; int start =i; // 直到遇到 特殊字符停止 while(i&lt;input.length() &amp;&amp; input[i] != '\\n' &amp;&amp; input[i] != '\\t' ) &#123; i++; &#125; if(i &gt;= input.length() || input[i] == '\\n') &#123; // 当当前目录层级的内容 提出出来 string str = input.substr(start,i-start); // 使用拓展名的. 作为文件识别标志 if(str.find('.') != string::npos) res = max(res,m[level] + (int)str.size() ); else &#123; level ++; m[level] = m[level-1] + (int)str.size() + 1; &#125; level =0; &#125; else level++; &#125; return res; &#125;&#125;; 运行结果使用 C/C++实现运行结果 2019-04-02 Runtime: 4 ms, faster than 100.00% of C++ online submissions for Longest Absolute File Path.Memory Usage: 8.8 MB, less than 88.00% of C++ online submissions for Longest Absolute File Path.","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://schen1024.github.io/tags/LeetCode/"},{"name":"Medium","slug":"Medium","permalink":"https://schen1024.github.io/tags/Medium/"},{"name":"Array","slug":"Array","permalink":"https://schen1024.github.io/tags/Array/"}]},{"title":"LeetCode-345-ReverseVowels","slug":"LeetCode-345-ReverseVowels","date":"2019-04-02T12:18:12.000Z","updated":"2023-01-01T13:25:24.232Z","comments":true,"path":"2019/04-02/LeetCode-345-ReverseVowels.html","link":"","permalink":"https://schen1024.github.io/2019/04-02/LeetCode-345-ReverseVowels.html","excerpt":"题目题目所在链接为 345. Reverse Vowels of a String 题目描述反转一个字符串中的元音字母。第一个和最后一个元音字母交换，第二个和倒数第二个交换……Write a function that takes a string as input and reverse only the vowels of a string.","text":"题目题目所在链接为 345. Reverse Vowels of a String 题目描述反转一个字符串中的元音字母。第一个和最后一个元音字母交换，第二个和倒数第二个交换……Write a function that takes a string as input and reverse only the vowels of a string. 输入输出样例Example 1: Input: “hello”Output: “holle” Example 2: Input: -123Output: -321 Example 3: Input: “leetcode”Output: “leotcede” 备注y 不算是 元音字母 只包含 aeiou AEIOU 解题解题思路 使用双指针来处理字符串的反转 左指针指向 前一个，后指针指向后一个 如果同时 则 交换， 否则依次移动 终止条件 左=右 ==时间复杂度==: $O(log(n))$==空间复杂度==: $O(1)$ 参考链接 【LeetCode】345. Reverse Vowels of a String 解题报告 具体实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: // 写一个 函数 判断是否存在元音字符 // 此处的判断 太慢可以更改 使用hash hash 也很慢 bool containVowels(char c) &#123; return ( 'a' == c || 'e' == c || 'i' == c || 'o' == c || 'u' == c || 'A' == c || 'E' == c || 'I' == c || 'O' == c || 'U' == c ); &#125; // 写一个函数 实现交换字符 // 未做 string reverseVowels(string s) &#123; /* 1. 使用双指针来处理字符串的反转 2. 左指针指向 前一个，后指针指向后一个 3. 如果同时 则 交换， 否则依次移动 4. 终止条件 左=右 */ int l=0,r=s.length()-1; while(l&lt;r) &#123; // 如果同时 则交换 if(containVowels(s[l]) || containVowels(s[r])) &#123; if(containVowels(s[l]) &amp;&amp; containVowels(s[r])) &#123; swap(s[l],s[r]); l++; r--; &#125; else &#123; if(containVowels(s[l])) &#123; r--; &#125; else l++; &#125; &#125; else &#123; l++; r--; &#125; &#125; return s; &#125;&#125;; 运行结果使用 C/C++实现运行结果 2019-04-02 Runtime: 12 ms, faster than 98.02% of C++ online submissions for Reverse Vowels of a String.Memory Usage: 9.8 MB, less than 71.66% of C++ online submissions for Reverse Vowels of a String.","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://schen1024.github.io/tags/LeetCode/"},{"name":"easy","slug":"easy","permalink":"https://schen1024.github.io/tags/easy/"},{"name":"String","slug":"String","permalink":"https://schen1024.github.io/tags/String/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://schen1024.github.io/tags/TwoPointers/"}]},{"title":"LeetCode-154-FindMinimuminRotatedSortedArray","slug":"LeetCode-154-FindMinimuminRotatedSortedArrayII","date":"2019-04-01T14:48:28.000Z","updated":"2023-01-01T13:25:24.232Z","comments":true,"path":"2019/04-01/LeetCode-154-FindMinimuminRotatedSortedArrayII.html","link":"","permalink":"https://schen1024.github.io/2019/04-01/LeetCode-154-FindMinimuminRotatedSortedArrayII.html","excerpt":"题目题目所在链接为 154. Find Minimum in Rotated Sorted Array II 题目描述事先按照升序排序的数组按照未知的某个值进行了旋转， 例如 [0,1,2,4,5,6,7] 变成了 [4,5,6,7,0,1,2]找到最小的元素， 可能包含重复的值 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates.","text":"题目题目所在链接为 154. Find Minimum in Rotated Sorted Array II 题目描述事先按照升序排序的数组按照未知的某个值进行了旋转， 例如 [0,1,2,4,5,6,7] 变成了 [4,5,6,7,0,1,2]找到最小的元素， 可能包含重复的值 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates. 输入输出样例Example 1: Input: [1,3,5]Output: 1 Example 2: Input: [2,2,2,0,1]Output: 0 备注本题目跟 上一个题目Find Minimum in Rotated Sorted Array 的原理有所相同，可以参考 上一篇解题内容重复元素会如何影响复杂度 This is a follow up problem to Find Minimum in Rotated Sorted Array.Would allow duplicates affect the run-time complexity? How and why? 解题解题思路与不重复的原理有所相同，可以参考 上一篇解题 blog 但是由于存在重复元素，导致寻找过程可能比较长 使用二分查找 来定位最小元素 最小值一定位于未排序的那半段 判断中间值 A[mid]与 A[end]的大小 判断数组右半段是否排序如果 A[mid]&lt;A[end] 右半段 排序 最小值一定在左半段如果 A[mid]&gt;A[end] 右半段 未排序 搜索右半段如果 A[mid]== A[end] 无法判断结果位于左右过程 将 end– 继续进行下一步结果判断如果使用 start++ 可能会漏掉 第一个的值 end– 不会数据丢失 只需返回最小值 不考虑最小值的位置 ==时间复杂度==: $O(log(n))$==空间复杂度==: $O(1)$ 参考链接 [leetcode] 154. Find Minimum in Rotated Sorted Array II 解题报告 [LeetCode]Find Minimum in Rotated Sorted Array I, II 具体实现123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; /* 1. 使用二分查找 来定位最小元素 2. 最小值一定位于未排序的那半段 3. 判断中间值A[mid]与A[end]的大小 判断数组右半段是否排序 如果 A[mid]&lt;A[end] 右半段 排序 最小值一定在左半段 如果 A[mid]&gt;A[end] 右半段 未排序 搜索右半段 如果 A[mid]== A[end] 无法判断结果位于左右过程 将 end-- 继续进行下一步结果判断 如果使用start++ 可能会漏掉 第一个的值 end-- 不会数据丢失 只需返回最小值 不考虑最小值的位置 */ int start=0,end=nums.size()-1; // 一直循环直到指针重合 while(start&lt;end) &#123; int mid=(start+end)/2; // 此处可优化，避免溢出 // 由于不存在重复 此处可 只考虑两种情况 if(nums[mid]&lt;nums[end]) end = mid; else if(nums[mid]&gt;nums[end]) start = mid+1; else end--; &#125; return nums[start]; &#125;&#125;; 运行结果使用 C/C++实现运行结果 2019-04-01 Runtime: 8 ms, faster than 99.40% of C++ online submissions for Find Minimum in Rotated Sorted Array II.Memory Usage: 8.7 MB, less than 86.88% of C++ online submissions for Find Minimum in Rotated Sorted Array II.","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://schen1024.github.io/tags/LeetCode/"},{"name":"Array","slug":"Array","permalink":"https://schen1024.github.io/tags/Array/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"https://schen1024.github.io/tags/BinarySearch/"},{"name":"hard","slug":"hard","permalink":"https://schen1024.github.io/tags/hard/"}]},{"title":"LeetCode-153-FindMinimuminRotatedSortedArray","slug":"LeetCode-153-FindMinimuminRotatedSortedArray","date":"2019-04-01T14:27:34.000Z","updated":"2023-01-01T13:25:24.232Z","comments":true,"path":"2019/04-01/LeetCode-153-FindMinimuminRotatedSortedArray.html","link":"","permalink":"https://schen1024.github.io/2019/04-01/LeetCode-153-FindMinimuminRotatedSortedArray.html","excerpt":"题目题目所在链接为 153. Find Minimum in Rotated Sorted Array 题目描述事先按照升序排序的数组按照未知的某个值进行了旋转， 例如 [0,1,2,4,5,6,7] 变成了 [4,5,6,7,0,1,2]找到最小的元素， 数组中不包含重复的值 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array.","text":"题目题目所在链接为 153. Find Minimum in Rotated Sorted Array 题目描述事先按照升序排序的数组按照未知的某个值进行了旋转， 例如 [0,1,2,4,5,6,7] 变成了 [4,5,6,7,0,1,2]找到最小的元素， 数组中不包含重复的值 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. 输入输出样例Example 1: Input: [3,4,5,1,2]Output: 1 Example 2: Input: [4,5,6,7,0,1,2]Output: 0 备注 数组原本是升序的 ，旋转之后可以得到 有一个点的值与其他的完全不同 你可以将使用二分找来得到结果 旋转点的左侧值都大于数组最后一个值，旋转点的右侧值都小于数组第一个 Array was originally in ascending order. Now that the array is rotated, there would be a point in the array where there is a small deflection from the increasing sequence. eg. The array would be something like [4, 5, 6, 7, 0, 1, 2]. You can divide the search space into two and see which direction to go. Can you think of an algorithm which has O(logN) search complexity? All the elements to the left of inflection point &gt; first element of the array.All the elements to the right of inflection point &lt; first element of the array. 解题解题思路 使用双指针加二分查找得到结果 最小值一定位于未排序的那半段 判断中间值 A[mid]与 A[end]的大小 判断数组右半段是否排序如果 A[mid]&lt;A[end] 右半段 排序 最小值一定在左半段如果 A[mid]&gt;A[end] 右半段 未排序 搜索右半段 ==时间复杂度==: $O(log(N))$ 二分查找==空间复杂度==: $O(1)$ 参考链接 LeetCode Solution [LeetCode]Find Minimum in Rotated Sorted Array I, II 具体实现1234567891011121314151617181920212223242526272829class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; /* 1. 使用双指针加二分查找得到结果 2. 最小值一定位于未排序的那半段 3. 判断中间值A[mid]与A[end]的大小 判断数组右半段是否排序 如果 A[mid]&lt;A[end] 排序 最小值一定在左半段 如果 A[mid]&gt;A[end] 未排序 搜索右半段 */ int start=0,end=nums.size()-1; // 一直循环直到指针重合 while(start&lt;end) &#123; int mid=(start+end)/2; // 此处可优化，避免溢出 // 由于不存在重复 此处可 只考虑两种情况 if(nums[mid]&lt;nums[end]) end = mid; else start = mid+1; &#125; return nums[start]; &#125;&#125;; 运行结果使用 C/C++实现运行结果 2019-04-01 Runtime: 4 ms, faster than 100.00% of C++ online submissions for Find Minimum in Rotated Sorted Array.Memory Usage: 8.5 MB, less than 96.46% of C++ online submissions for Find Minimum in Rotated Sorted Array.","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://schen1024.github.io/tags/LeetCode/"},{"name":"Medium","slug":"Medium","permalink":"https://schen1024.github.io/tags/Medium/"},{"name":"Array","slug":"Array","permalink":"https://schen1024.github.io/tags/Array/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"https://schen1024.github.io/tags/BinarySearch/"}]},{"title":"LeetCode-14-LongestCommonPrefix","slug":"LeetCode-14-LongestCommonPrefix","date":"2019-03-29T20:08:39.000Z","updated":"2023-01-01T13:25:24.232Z","comments":true,"path":"2019/03-29/LeetCode-14-LongestCommonPrefix.html","link":"","permalink":"https://schen1024.github.io/2019/03-29/LeetCode-14-LongestCommonPrefix.html","excerpt":"题目题目所在链接为 LeetCode-14:Longest Common Prefix 题目描述写一个函数,找到一组字符串的最长前缀 如果没有公共前缀 返回空字符串 Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”.","text":"题目题目所在链接为 LeetCode-14:Longest Common Prefix 题目描述写一个函数,找到一组字符串的最长前缀 如果没有公共前缀 返回空字符串 Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”. 输入输出样例Example 1: Input: [“flower”,”flow”,”flight”]Output: “fl” Example 2: Input: [“dog”,”racecar”,”car”]Output: “” 备注如果没有公共前缀就返回空字符串 “” 所有的字符都是 小写字符 a-z 解题解题思路方法一 同时遍历每个字符串的同位置字符, 如果出现不一致的情况就直接报错,返回之前的结果 ==时间复杂度==: $ O(n*m) $==空间复杂度==: $ O(m) $m 指最长字符串长度 方法二 比较两个字符串得到公共的之后 跟后面的依次比较.得到公共字符串 ==时间复杂度==: $ O(n*m) $==空间复杂度==: $ O(m) $m 指最长字符串长度 具体实现123456789101112131415161718192021222324252627282930class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; // 解法一 &#123; string prefix = \"\"; // 依次比较所有字符的 同位置字符 if(strs.size() ==0) &#123; return prefix; &#125; // 公共字符长度一定小于每一个字符串的长度 for(int i=0;i&lt;strs[0].length();i++) &#123; for(int j=0;j&lt;strs.size();j++) &#123; if(strs[0][i] != strs[j][i]) return prefix; &#125; prefix = prefix+strs[0][i]; &#125; return prefix; &#125; &#125;&#125;; 运行结果使用 C/C++实现运行结果 2019-03-27 Runtime: 8 ms, faster than 98.87% of C++ online submissions for Longest Common Prefix.Memory Usage: 9 MB, less than 98.54% of C++ online submissions for Longest Common Prefix.","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://schen1024.github.io/tags/LeetCode/"}]},{"title":"LeetCode-13-Roman2Integer","slug":"LeetCode-13-Roman2Integer","date":"2019-03-28T13:14:33.000Z","updated":"2023-01-01T13:25:24.231Z","comments":true,"path":"2019/03-28/LeetCode-13-Roman2Integer.html","link":"","permalink":"https://schen1024.github.io/2019/03-28/LeetCode-13-Roman2Integer.html","excerpt":"题目题目所在链接为 LeetCode-13:Roman to Integer 题目描述罗马数字一般有七个等级 包括: I, V, X, L, C, D and M. Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. 符号表示的值 Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如，2 用罗马数字写成 II，两个 1 相加。12 写成，XII，就是 X + II。27 被写成 XXVII，也就是 XX + V + II。罗马数字通常从左到右由大到小书写。然而，4 的数字不是 IIII。4 写成了 4，因为 1 在 5 之前，所以减 4。同样的原理也适用于数字 9，也就是 9。使用减法有六种情况:I 可以放在 V(5)和 X(10)前面，得到 4 和 9。X 可以放在 L(50)和 C(100)之前，得到 40 和 90。C 可以放在 D(500)和 M(1000)之前，得到 400 和 900。给定一个罗马数字，把它转换成整数。输入保证在 1 到 3999 之间。 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9.X can be placed before L (50) and C (100) to make 40 and 90.C can be placed before D (500) and M (1000) to make 400 and 900.Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.","text":"题目题目所在链接为 LeetCode-13:Roman to Integer 题目描述罗马数字一般有七个等级 包括: I, V, X, L, C, D and M. Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. 符号表示的值 Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如，2 用罗马数字写成 II，两个 1 相加。12 写成，XII，就是 X + II。27 被写成 XXVII，也就是 XX + V + II。罗马数字通常从左到右由大到小书写。然而，4 的数字不是 IIII。4 写成了 4，因为 1 在 5 之前，所以减 4。同样的原理也适用于数字 9，也就是 9。使用减法有六种情况:I 可以放在 V(5)和 X(10)前面，得到 4 和 9。X 可以放在 L(50)和 C(100)之前，得到 40 和 90。C 可以放在 D(500)和 M(1000)之前，得到 400 和 900。给定一个罗马数字，把它转换成整数。输入保证在 1 到 3999 之间。 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9.X can be placed before L (50) and C (100) to make 40 and 90.C can be placed before D (500) and M (1000) to make 400 and 900.Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 输入输出样例Example 1: Input: “III”Output: 3 Example 2: Input: “IV”Output: 4 Example 3: Input: “IX”Output: 9 Example 4: Input: “LVIII”Output: 58 Example 5: Input: “MCMXCIV”Output: 1994 备注特殊规则: 如果 I 在 V 或者 X 之前 则表示 V-I,例 IV=4 如果 X 在 L 或 C 之前 则表示 L-X 例 XL = 40 如果 C 在 D 或 M 之前 则表示 D-X 例 CD = 400 Rules: If I comes before V or X, subtract 1 eg: IV = 4 and IX = 9 If X comes before L or C, subtract 10 eg: XL = 40 and XC = 90 If C comes before D or M, subtract 100 eg: CD = 400 and CM = 900 解题解题思路 将对应的 字符赋予相应的值,使用 map 存储键值对 从前往后的顺序 将结果加起来, 如果遇到倒装(特殊规则 2) 则减去两倍的值 ==时间复杂度==: $O(n)$==空间复杂度==: $O(1)$ 具体实现1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int romanToInt(string s) &#123; // 将结果存储在键值对中便于读取 map&lt;char,int&gt; m&#123; &#123;'I',1&#125;, &#123;'V',5&#125;, &#123;'X',10&#125;, &#123;'L',50&#125;, &#123;'C',100&#125;, &#123;'D',500&#125;, &#123;'M',1000&#125; &#125;; int sum=0; // 按照顺序累加, 如果出现倒装 则减去双倍 for(int i=0;i&lt;s.length();i++) &#123; sum += m[s[i]]; // 首位不需要计算 if(i&gt;0) &#123; // 如果倒装 则需要减去 并减去之前循环加上的 所以减去双倍 if(m[s[i]] &gt; m[s[i-1]]) sum -= 2*m[s[i-1]]; &#125; &#125; return sum; &#125;&#125;; 运行结果使用 C/C++实现运行结果 2019-03-28 Runtime: 28 ms, faster than 98.23% of C++ online submissions for Roman to Integer.Memory Usage: 10.7 MB, less than 97.97% of C++ online submissions for Roman to Integer.","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://schen1024.github.io/tags/LeetCode/"}]},{"title":"LeetCode_9_PalindromeNumber","slug":"LeetCode-9-PalindromeNumber","date":"2019-03-27T22:18:11.000Z","updated":"2023-01-01T13:25:24.233Z","comments":true,"path":"2019/03-27/LeetCode-9-PalindromeNumber.html","link":"","permalink":"https://schen1024.github.io/2019/03-27/LeetCode-9-PalindromeNumber.html","excerpt":"题目题目所在链接为 LeetCode-9:PalindromeNumber 题目描述确定整数是否是回文。当一个整数从前往后读和从后往前读是一致的则认为是回文数 Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.","text":"题目题目所在链接为 LeetCode-9:PalindromeNumber 题目描述确定整数是否是回文。当一个整数从前往后读和从后往前读是一致的则认为是回文数 Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. 输入输出样例Example 1: Input: 121Output: true Example 2: Input: -121Output: falseExplanation: 所以可以判定所有的负数均不是回文数 Example 3: Input: 10Output: false 跟进能不能不通过把数字转化为字符串实现? Coud you solve it without converting the integer to a string? 备注验证一个整数是否为回文，不能把整数变成字符，题目要求不能使用额外空间，也不能反转整数，因为可能会溢出。 可直接对整数进行取整和取余来获得想要的首尾数字，比如: 1221，取整 1221 / 1000，可得首位 1， 取余 1221 % 10， 可得到末尾 1，进行比较，如果相等取中间的 22 继续用此方法比较。 Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. 解题解题思路 通过余数得到最后一位, 计算出来最高的位数 得到首位, 首尾判断得到结果 ==时间复杂度==: $O(log(x))$==空间复杂度==: $O(1)$ 具体实现1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: bool isPalindrome(int x) &#123; // 对于负值 均不回文 if (x &lt; 0) return false; // 个位数 回文 if(x&lt;10) return true; // 计算 整10次幂的值 int dec = 1; while((x / dec) &gt;= 10) &#123; dec *= 10; &#125; while(x&gt;0) &#123; int head = x / dec; int end = x % 10; // 不对应 直接结束 if(head != end) return false; // 将原始数字 两头 x = (x % dec) / 10; // 除数减去两位 dec /= 100; &#125; return true; &#125;&#125;; 运行结果使用 C/C++实现运行结果 2019-03-27 Runtime: 32 ms, faster than 99.96% of C++ online submissions for Palindrome Number.Memory Usage: 8.1 MB, less than 99.67% of C++ online submissions for Palindrome Number.","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://schen1024.github.io/tags/LeetCode/"}]},{"title":"996-ICU","slug":"996-ICU","date":"2019-03-27T21:46:51.000Z","updated":"2023-01-01T13:25:24.183Z","comments":true,"path":"2019/03-27/996-ICU.html","link":"","permalink":"https://schen1024.github.io/2019/03-27/996-ICU.html","excerpt":"日常闲着没事的时候打开Github,想看看有什么好玩的没有, 突然看到一个以前关注的一个非常漂亮的小姐姐Ovilia点赞了一个项目Github/996.ICU, 这个项目是 2019/03/26 创建的. 03/27 看到的时候才 1000 star 截至 03/29 的时候 项目已经 100k start 了. 然后搜了一下看到了一片文章 是 虎嗅的文章谈谈 996.ICU 以一个过来人的身份简述了自己 现在看待 996 的事情.感觉文章不错 其实前天跟室友谈过一句,我问他, 给你多少钱你愿意 996,他说 给多少都不干,然后我说,你现在是 9 点上班 10 点半下班,一周 7 天,比 996 还要累啊. 沉默….","text":"日常闲着没事的时候打开Github,想看看有什么好玩的没有, 突然看到一个以前关注的一个非常漂亮的小姐姐Ovilia点赞了一个项目Github/996.ICU, 这个项目是 2019/03/26 创建的. 03/27 看到的时候才 1000 star 截至 03/29 的时候 项目已经 100k start 了. 然后搜了一下看到了一片文章 是 虎嗅的文章谈谈 996.ICU 以一个过来人的身份简述了自己 现在看待 996 的事情.感觉文章不错 其实前天跟室友谈过一句,我问他, 给你多少钱你愿意 996,他说 给多少都不干,然后我说,你现在是 9 点上班 10 点半下班,一周 7 天,比 996 还要累啊. 沉默…. 读研期间,看到太多加班的事情了,但是更多的是给自己的安慰 反正回去也是玩手机,玩电脑,实验室网还比较好,在这边多好 同实验室的师兄师姐都没走,我回去没啥事 我要多学习一会,这样比他们多学一点,积累着总是好的 老板也从没有说过要我们 997 的干活, 但是对应的有相应的工作,做不玩自然不能休息,你自然就会加班了,而且看到别人都在努力的时候,如果自己有半天时间浪费了都感觉自己太堕落了,自己还不够努力. 现在都在努力向前,哪怕停止不前就是已经落后了. 其实哪有那么多的事情,你只是不愿把时间花在其他地方上罢了 如果你很享受 996 的工作，那应当恭喜你，人生活得有意义。如果你觉得 996 让你痛苦不堪，耽误了你追求更有意思的生活，那么及时止损吧.","categories":[{"name":"Emotion","slug":"Emotion","permalink":"https://schen1024.github.io/categories/Emotion/"}],"tags":[{"name":"github","slug":"github","permalink":"https://schen1024.github.io/tags/github/"},{"name":"ICU","slug":"ICU","permalink":"https://schen1024.github.io/tags/ICU/"},{"name":"996","slug":"996","permalink":"https://schen1024.github.io/tags/996/"},{"name":"Code","slug":"Code","permalink":"https://schen1024.github.io/tags/Code/"}]},{"title":"LeetCode7-ReverseInteger","slug":"LeetCode-7-ReverseInteger","date":"2019-03-27T11:47:56.940Z","updated":"2023-01-01T13:25:24.233Z","comments":true,"path":"2019/03-27/LeetCode-7-ReverseInteger.html","link":"","permalink":"https://schen1024.github.io/2019/03-27/LeetCode-7-ReverseInteger.html","excerpt":"题目题目所在链接为 LeetCode-7:ReverseInteger 题目描述给出一个 32 位的有符号整数, 反向输出一个整型数字 Given a 32-bit signed integer, reverse digits of an integer.","text":"题目题目所在链接为 LeetCode-7:ReverseInteger 题目描述给出一个 32 位的有符号整数, 反向输出一个整型数字 Given a 32-bit signed integer, reverse digits of an integer. 输入输出样例Example 1: Input: 123Output: 321 Example 2: Input: -123Output: -321 Example 3: Input: 120Output: 21 备注假设我们正在处理一个只能在 32 位有符号整数范围内存储整数的环境：[−231, 231 − 1]。出于此问题的目的，假设当反向整数溢出时，函数返回 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 例如 $2^{31} -1 = 2,147,483,647$ 如果 设计的返回的值应该是$ 7,463,847,412 $ 溢出 返回 0 . 解题解题思路 通过余数和除法获取 从尾部 获取数据的每一位,依次成将数据乘 10 得到新的数据 判断符号, 判断是否溢出 ==时间复杂度==: $ O(log(x)) $==空间复杂度==: $ O(1) $ 具体实现12345678910111213141516171819202122class Solution &#123;public: int reverse(int x) &#123; if (x == 0) return 0; // 输入long long 型 数据 避免溢出 long long sum = 0; while (x!=0) &#123; // 将每一位的数据 升位 加上余数 sum = sum * 10 + x % 10; // 输入数字 降位 x = x / 10; // 判断溢出 if (sum &gt; INT_MAX || sum &lt; INT_MIN) return 0; &#125; return int(sum); &#125;&#125;; 运行结果使用 C/C++实现运行结果 2019-03-27 Runtime: 8 ms, faster than 99.38% of C++ online submissions for Reverse Integer.Memory Usage: 8.2 MB, less than 99.80% of C++ online submissions for Reverse Integer. 改进优化改进思路题目底下最好的优化在了空间上的节省, 不用设置 long long 类型的数据, 采用 int 型数据, 但是每次判断依次结果很多数据会导致溢出 直接抛弃掉 可以节省大量的时间 整体流程如下: 如果结果会溢出, 如果是正值 则 $temp = rev*10+pop $ 则$$ rev &gt; \\frac{INTMAX}{10} || (rev == \\frac{INTMAX}{10} \\&amp;\\&amp; pop&gt;7) $$ 如果结果会溢出, 如果是负值 则 $temp = rev*10+pop $ 则$$ rev &lt;&gt; \\frac{INTMIN}{10} || (rev == \\frac{INTMIN}{10} \\&amp;\\&amp; pop&lt;-8) $$ 其中 $ pop = x\\%10 $ 改进的实现1234567891011121314class Solution &#123;public: int reverse(int x) &#123; int rev = 0; while (x != 0) &#123; int pop = x % 10; x /= 10; if (rev &gt; INT_MAX/10 || (rev == INT_MAX / 10 &amp;&amp; pop &gt; 7)) return 0; if (rev &lt; INT_MIN/10 || (rev == INT_MIN / 10 &amp;&amp; pop &lt; -8)) return 0; rev = rev * 10 + pop; &#125; return rev; &#125;&#125;; 运行结果 Runtime: 4 ms, faster than 100.00% of C++ online submissions for Reverse Integer.Memory Usage: 8.1 MB, less than 99.80% of C++ online submissions for Reverse Integer.","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"LeetCode,easy,Overflow","slug":"LeetCode-easy-Overflow","permalink":"https://schen1024.github.io/tags/LeetCode-easy-Overflow/"}]},{"title":"LeetCode-0","slug":"LeetCode-0","date":"2019-03-27T00:00:00.000Z","updated":"2023-01-01T13:25:24.231Z","comments":true,"path":"2019/03-27/LeetCode-0.html","link":"","permalink":"https://schen1024.github.io/2019/03-27/LeetCode-0.html","excerpt":"LeetCode目前 LeetCode 的上面的题目还有很多不会, 之前做过的部分结果也不完善,准备从头开始将 LeetCode 的题目刷遍, 按照一定顺序来刷,可能会先写容易的,后面会把难得给写出来,可能不会是比较好的解答,但是是目前自己能做的一个解答过程,以此记录一下, 20190327-Schen","text":"LeetCode目前 LeetCode 的上面的题目还有很多不会, 之前做过的部分结果也不完善,准备从头开始将 LeetCode 的题目刷遍, 按照一定顺序来刷,可能会先写容易的,后面会把难得给写出来,可能不会是比较好的解答,但是是目前自己能做的一个解答过程,以此记录一下, 20190327-Schen","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://schen1024.github.io/tags/leetcode/"}]},{"title":"学堂在线课程字幕下载","slug":"学堂在线课程字幕下载","date":"2019-02-13T00:01:11.000Z","updated":"2023-01-01T13:25:24.784Z","comments":true,"path":"2019/02-13/学堂在线课程字幕下载.html","link":"","permalink":"https://schen1024.github.io/2019/02-13/%E5%AD%A6%E5%A0%82%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B%E5%AD%97%E5%B9%95%E4%B8%8B%E8%BD%BD.html","excerpt":"事情起因学堂在线工程伦理课程在线学习,没有课件, 考试的时候可能会不方便,做一解决此类问题字幕下载 合成为 Txt 文件或者 word 文件以供学习使用 事情经过 首先想到的是自己写一个爬虫 怕区相应的字幕, 发现是文本形式存储和, 很好做, 但是涉及到登录的 cookie 信息, 暂时不会,没有做 同时找到了 github 上一个爬取学堂在线字幕的项目^[https://github.com/maxujie/xuetang-down] 需要简单配置 cookie 即可, 没有测试, 之后测试一下 找到一个 blog 提供的一个简单的 js 版本的字幕下载^[http://corie.cn/2016/09/29/mooc-js/] 下载得到的是 srt 字幕格式, 不过下载得到的文件是按照后台的文件名存储的, 跟课程顺序 有所不同, 切部分无法获取到完整用户名 手工将文件 重命名 之后 使用程序将 可以找到相应的 srt 转成相应的纯 txt 文本文件 此处有一个 C++ 版本的 srt 转 txt^[https://blog.csdn.net/TimoTolkki1966/article/details/80783801] 此处提供其他的视频或者字幕下载工具,可以之后尝试下载^[https://blog.csdn.net/jiandanjinxin/article/details/23679869]5.","text":"事情起因学堂在线工程伦理课程在线学习,没有课件, 考试的时候可能会不方便,做一解决此类问题字幕下载 合成为 Txt 文件或者 word 文件以供学习使用 事情经过 首先想到的是自己写一个爬虫 怕区相应的字幕, 发现是文本形式存储和, 很好做, 但是涉及到登录的 cookie 信息, 暂时不会,没有做 同时找到了 github 上一个爬取学堂在线字幕的项目^[https://github.com/maxujie/xuetang-down] 需要简单配置 cookie 即可, 没有测试, 之后测试一下 找到一个 blog 提供的一个简单的 js 版本的字幕下载^[http://corie.cn/2016/09/29/mooc-js/] 下载得到的是 srt 字幕格式, 不过下载得到的文件是按照后台的文件名存储的, 跟课程顺序 有所不同, 切部分无法获取到完整用户名 手工将文件 重命名 之后 使用程序将 可以找到相应的 srt 转成相应的纯 txt 文本文件 此处有一个 C++ 版本的 srt 转 txt^[https://blog.csdn.net/TimoTolkki1966/article/details/80783801] 此处提供其他的视频或者字幕下载工具,可以之后尝试下载^[https://blog.csdn.net/jiandanjinxin/article/details/23679869]5.","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[]},{"title":"Changelog","slug":"Changelog","date":"2019-01-24T22:09:00.000Z","updated":"2023-01-01T13:25:24.222Z","comments":true,"path":"2019/01-24/Changelog.html","link":"","permalink":"https://schen1024.github.io/2019/01-24/Changelog.html","excerpt":"About Page网站结构更新log文件, 记录更新中的部分变更, 每次变动过程尽量记录下来, 之后完善之后记录自己的站点历史 按照 时间 顺序 正序时间记录 blog Changelog2019-01-24 22:09 初始化站点 按照官方仓库给出的方法 正常的完成了blog 的搭建, 之前尝试过, 感觉有点麻烦就放弃了, 现在可能要慢慢坚持下来, 作出持续 的成果了 2019-02-12 22:14:23 增加分类与标签 找到一个orzcss的站点, 讲述了,创建分类的方法, 暂时没有将文章分类, 之后一一完成 2019-03-27 19:40 更换主题 按照MaterialX的给出的结果 更换了主题 找到一个站点Hexo 主题设置 的方法 对网页加了相应的特效 2019-11-08 完善程序框架 已经对目前的网站有了比较喜欢的样子了, 后续会继续添加文章, 希望还能继续坚持","text":"About Page网站结构更新log文件, 记录更新中的部分变更, 每次变动过程尽量记录下来, 之后完善之后记录自己的站点历史 按照 时间 顺序 正序时间记录 blog Changelog2019-01-24 22:09 初始化站点 按照官方仓库给出的方法 正常的完成了blog 的搭建, 之前尝试过, 感觉有点麻烦就放弃了, 现在可能要慢慢坚持下来, 作出持续 的成果了 2019-02-12 22:14:23 增加分类与标签 找到一个orzcss的站点, 讲述了,创建分类的方法, 暂时没有将文章分类, 之后一一完成 2019-03-27 19:40 更换主题 按照MaterialX的给出的结果 更换了主题 找到一个站点Hexo 主题设置 的方法 对网页加了相应的特效 2019-11-08 完善程序框架 已经对目前的网站有了比较喜欢的样子了, 后续会继续添加文章, 希望还能继续坚持","categories":[{"name":"xxx","slug":"xxx","permalink":"https://schen1024.github.io/categories/xxx/"}],"tags":[{"name":"test","slug":"test","permalink":"https://schen1024.github.io/tags/test/"},{"name":"changelog","slug":"changelog","permalink":"https://schen1024.github.io/tags/changelog/"},{"name":"history","slug":"history","permalink":"https://schen1024.github.io/tags/history/"}]},{"title":"Hello_Github_blog","slug":"hello-world","date":"2019-01-24T22:09:00.000Z","updated":"2023-01-01T13:25:24.266Z","comments":true,"path":"2019/01-24/hello-world.html","link":"","permalink":"https://schen1024.github.io/2019/01-24/hello-world.html","excerpt":"","text":"简介根据 hexo+github 部署 blog 方法 完成了 blog 搭建工作, 之后会主要将自己做的研究内容以及部分工程文档放在 blog 上展示, 目前使用方式 在 blog/source 下新建 md 文档, 然后使用 小书匠 书写预览, 然后使用 SourceTree 将得到的结果 push 到 github 中 使用==蓝色 #03A9F4== 高亮的部分是软件, 之后可能会出介绍一下这些软件, 真的十分好用,之后学习得到 的结果 一一 post 到 blog 中, 现在还比较少, 之后慢慢完善吧 之前废弃过很多 blog 使用了各种部署 都感觉太麻烦了 自己坚持不下来, 所以之后会慢慢坚持 争取周更 2019.1.24陈","categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"}],"tags":[{"name":"test","slug":"test","permalink":"https://schen1024.github.io/tags/test/"},{"name":"blog","slug":"blog","permalink":"https://schen1024.github.io/tags/blog/"}]}],"categories":[{"name":"Technology","slug":"Technology","permalink":"https://schen1024.github.io/categories/Technology/"},{"name":"Person","slug":"Person","permalink":"https://schen1024.github.io/categories/Person/"},{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/categories/opencv/"},{"name":"Tools","slug":"Tools","permalink":"https://schen1024.github.io/categories/Tools/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://schen1024.github.io/categories/OpenCV/"},{"name":"TODO","slug":"TODO","permalink":"https://schen1024.github.io/categories/TODO/"},{"name":"uncategorized","slug":"uncategorized","permalink":"https://schen1024.github.io/categories/uncategorized/"},{"name":"SSR","slug":"SSR","permalink":"https://schen1024.github.io/categories/SSR/"},{"name":"python","slug":"python","permalink":"https://schen1024.github.io/categories/python/"},{"name":"Emotion","slug":"Emotion","permalink":"https://schen1024.github.io/categories/Emotion/"},{"name":"xxx","slug":"xxx","permalink":"https://schen1024.github.io/categories/xxx/"}],"tags":[{"name":"depurple","slug":"depurple","permalink":"https://schen1024.github.io/tags/depurple/"},{"name":"hexo","slug":"hexo","permalink":"https://schen1024.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://schen1024.github.io/tags/blog/"},{"name":"cnblogs","slug":"cnblogs","permalink":"https://schen1024.github.io/tags/cnblogs/"},{"name":"csdn","slug":"csdn","permalink":"https://schen1024.github.io/tags/csdn/"},{"name":"game","slug":"game","permalink":"https://schen1024.github.io/tags/game/"},{"name":"opencv","slug":"opencv","permalink":"https://schen1024.github.io/tags/opencv/"},{"name":"c++","slug":"c","permalink":"https://schen1024.github.io/tags/c/"},{"name":"histograms","slug":"histograms","permalink":"https://schen1024.github.io/tags/histograms/"},{"name":"qt","slug":"qt","permalink":"https://schen1024.github.io/tags/qt/"},{"name":"imagelab","slug":"imagelab","permalink":"https://schen1024.github.io/tags/imagelab/"},{"name":"server","slug":"server","permalink":"https://schen1024.github.io/tags/server/"},{"name":"html","slug":"html","permalink":"https://schen1024.github.io/tags/html/"},{"name":"asp","slug":"asp","permalink":"https://schen1024.github.io/tags/asp/"},{"name":"php","slug":"php","permalink":"https://schen1024.github.io/tags/php/"},{"name":"VS","slug":"VS","permalink":"https://schen1024.github.io/tags/VS/"},{"name":"soft","slug":"soft","permalink":"https://schen1024.github.io/tags/soft/"},{"name":"tools","slug":"tools","permalink":"https://schen1024.github.io/tags/tools/"},{"name":"mat","slug":"mat","permalink":"https://schen1024.github.io/tags/mat/"},{"name":"C++","slug":"C","permalink":"https://schen1024.github.io/tags/C/"},{"name":"offer","slug":"offer","permalink":"https://schen1024.github.io/tags/offer/"},{"name":"swordoffer","slug":"swordoffer","permalink":"https://schen1024.github.io/tags/swordoffer/"},{"name":"list","slug":"list","permalink":"https://schen1024.github.io/tags/list/"},{"name":"QT","slug":"QT","permalink":"https://schen1024.github.io/tags/QT/"},{"name":"home","slug":"home","permalink":"https://schen1024.github.io/tags/home/"},{"name":"sketchup","slug":"sketchup","permalink":"https://schen1024.github.io/tags/sketchup/"},{"name":"VS2015","slug":"VS2015","permalink":"https://schen1024.github.io/tags/VS2015/"},{"name":"51","slug":"51","permalink":"https://schen1024.github.io/tags/51/"},{"name":"C","slug":"C","permalink":"https://schen1024.github.io/tags/C/"},{"name":"PID","slug":"PID","permalink":"https://schen1024.github.io/tags/PID/"},{"name":"UART","slug":"UART","permalink":"https://schen1024.github.io/tags/UART/"},{"name":"水温控制","slug":"水温控制","permalink":"https://schen1024.github.io/tags/%E6%B0%B4%E6%B8%A9%E6%8E%A7%E5%88%B6/"},{"name":"TODO","slug":"TODO","permalink":"https://schen1024.github.io/tags/TODO/"},{"name":"blog，hexo","slug":"blog，hexo","permalink":"https://schen1024.github.io/tags/blog%EF%BC%8Chexo/"},{"name":"shopping","slug":"shopping","permalink":"https://schen1024.github.io/tags/shopping/"},{"name":"washing machine","slug":"washing-machine","permalink":"https://schen1024.github.io/tags/washing-machine/"},{"name":"latex","slug":"latex","permalink":"https://schen1024.github.io/tags/latex/"},{"name":"template","slug":"template","permalink":"https://schen1024.github.io/tags/template/"},{"name":"learn","slug":"learn","permalink":"https://schen1024.github.io/tags/learn/"},{"name":"matlab","slug":"matlab","permalink":"https://schen1024.github.io/tags/matlab/"},{"name":"data","slug":"data","permalink":"https://schen1024.github.io/tags/data/"},{"name":"cov","slug":"cov","permalink":"https://schen1024.github.io/tags/cov/"},{"name":"theme","slug":"theme","permalink":"https://schen1024.github.io/tags/theme/"},{"name":"github","slug":"github","permalink":"https://schen1024.github.io/tags/github/"},{"name":"action","slug":"action","permalink":"https://schen1024.github.io/tags/action/"},{"name":"PSO","slug":"PSO","permalink":"https://schen1024.github.io/tags/PSO/"},{"name":"robot","slug":"robot","permalink":"https://schen1024.github.io/tags/robot/"},{"name":"algorithm","slug":"algorithm","permalink":"https://schen1024.github.io/tags/algorithm/"},{"name":"proxy","slug":"proxy","permalink":"https://schen1024.github.io/tags/proxy/"},{"name":"SSR","slug":"SSR","permalink":"https://schen1024.github.io/tags/SSR/"},{"name":"pac","slug":"pac","permalink":"https://schen1024.github.io/tags/pac/"},{"name":"overleaf","slug":"overleaf","permalink":"https://schen1024.github.io/tags/overleaf/"},{"name":"Serial","slug":"Serial","permalink":"https://schen1024.github.io/tags/Serial/"},{"name":"python","slug":"python","permalink":"https://schen1024.github.io/tags/python/"},{"name":"batch","slug":"batch","permalink":"https://schen1024.github.io/tags/batch/"},{"name":"file","slug":"file","permalink":"https://schen1024.github.io/tags/file/"},{"name":"SerialPort","slug":"SerialPort","permalink":"https://schen1024.github.io/tags/SerialPort/"},{"name":"HEX","slug":"HEX","permalink":"https://schen1024.github.io/tags/HEX/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://schen1024.github.io/tags/OpenCV/"},{"name":"Utils","slug":"Utils","permalink":"https://schen1024.github.io/tags/Utils/"},{"name":"Logger","slug":"Logger","permalink":"https://schen1024.github.io/tags/Logger/"},{"name":"Bugs","slug":"Bugs","permalink":"https://schen1024.github.io/tags/Bugs/"},{"name":"Window","slug":"Window","permalink":"https://schen1024.github.io/tags/Window/"},{"name":"Cmake","slug":"Cmake","permalink":"https://schen1024.github.io/tags/Cmake/"},{"name":"Protocbuf","slug":"Protocbuf","permalink":"https://schen1024.github.io/tags/Protocbuf/"},{"name":"NameStyle","slug":"NameStyle","permalink":"https://schen1024.github.io/tags/NameStyle/"},{"name":"Plugin","slug":"Plugin","permalink":"https://schen1024.github.io/tags/Plugin/"},{"name":"Crack","slug":"Crack","permalink":"https://schen1024.github.io/tags/Crack/"},{"name":"Atomineer","slug":"Atomineer","permalink":"https://schen1024.github.io/tags/Atomineer/"},{"name":"QT自定义","slug":"QT自定义","permalink":"https://schen1024.github.io/tags/QT%E8%87%AA%E5%AE%9A%E4%B9%89/"},{"name":"串口","slug":"串口","permalink":"https://schen1024.github.io/tags/%E4%B8%B2%E5%8F%A3/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://schen1024.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"图片","slug":"图片","permalink":"https://schen1024.github.io/tags/%E5%9B%BE%E7%89%87/"},{"name":"UnitTest","slug":"UnitTest","permalink":"https://schen1024.github.io/tags/UnitTest/"},{"name":"Doctest","slug":"Doctest","permalink":"https://schen1024.github.io/tags/Doctest/"},{"name":"多线程","slug":"多线程","permalink":"https://schen1024.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"队列","slug":"队列","permalink":"https://schen1024.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"学习","slug":"学习","permalink":"https://schen1024.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"分治","slug":"分治","permalink":"https://schen1024.github.io/tags/%E5%88%86%E6%B2%BB/"},{"name":"数学","slug":"数学","permalink":"https://schen1024.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"Interview","slug":"Interview","permalink":"https://schen1024.github.io/tags/Interview/"},{"name":"Jobs","slug":"Jobs","permalink":"https://schen1024.github.io/tags/Jobs/"},{"name":"bug","slug":"bug","permalink":"https://schen1024.github.io/tags/bug/"},{"name":"intel","slug":"intel","permalink":"https://schen1024.github.io/tags/intel/"},{"name":"test","slug":"test","permalink":"https://schen1024.github.io/tags/test/"},{"name":"Latex","slug":"Latex","permalink":"https://schen1024.github.io/tags/Latex/"},{"name":"XeLaTex","slug":"XeLaTex","permalink":"https://schen1024.github.io/tags/XeLaTex/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://schen1024.github.io/tags/LeetCode/"},{"name":"Array","slug":"Array","permalink":"https://schen1024.github.io/tags/Array/"},{"name":"easy","slug":"easy","permalink":"https://schen1024.github.io/tags/easy/"},{"name":"Work","slug":"Work","permalink":"https://schen1024.github.io/tags/Work/"},{"name":"Job","slug":"Job","permalink":"https://schen1024.github.io/tags/Job/"},{"name":"Contest","slug":"Contest","permalink":"https://schen1024.github.io/tags/Contest/"},{"name":"PrimeNum","slug":"PrimeNum","permalink":"https://schen1024.github.io/tags/PrimeNum/"},{"name":"hard","slug":"hard","permalink":"https://schen1024.github.io/tags/hard/"},{"name":"Math","slug":"Math","permalink":"https://schen1024.github.io/tags/Math/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://schen1024.github.io/tags/Dynamic-Programming/"},{"name":"Medium","slug":"Medium","permalink":"https://schen1024.github.io/tags/Medium/"},{"name":"String","slug":"String","permalink":"https://schen1024.github.io/tags/String/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://schen1024.github.io/tags/TwoPointers/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"https://schen1024.github.io/tags/BinarySearch/"},{"name":"ICU","slug":"ICU","permalink":"https://schen1024.github.io/tags/ICU/"},{"name":"996","slug":"996","permalink":"https://schen1024.github.io/tags/996/"},{"name":"Code","slug":"Code","permalink":"https://schen1024.github.io/tags/Code/"},{"name":"LeetCode,easy,Overflow","slug":"LeetCode-easy-Overflow","permalink":"https://schen1024.github.io/tags/LeetCode-easy-Overflow/"},{"name":"leetcode","slug":"leetcode","permalink":"https://schen1024.github.io/tags/leetcode/"},{"name":"changelog","slug":"changelog","permalink":"https://schen1024.github.io/tags/changelog/"},{"name":"history","slug":"history","permalink":"https://schen1024.github.io/tags/history/"}]}