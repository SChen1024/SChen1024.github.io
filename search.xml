<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2022年终总结</title>
      <link href="/2023/01-01/attachments/2021+2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93_2.html"/>
      <url>/2023/01-01/attachments/2021+2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93_2.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="1e0edeef78809b41c4a3e73df5bd01a1c77f6b92fb9a5f30a74ad82d3b495741">681847c39b6521bb3e6b7f34c9f4fff7dfe378ab4bd615a8b32a0271d97b3b404922deaa691fe03149a74fe34b3a151dbb771aad6e32d6e9ea90d249ed052d678fc8cf170b6276d60c12af5d9821fee98e99ea34c7beeb8953dc17415713676475e178cf6083259e924ce703b1f17fdbc7cfb462da59098298d036a615a89a65ec32caf74acc2f9a69f613aa42c77d692559753681df06312b7795bb99278900978e0192434aa8494f29c47feb97cc6b0c135ec9eadcbbfd1a0461c6c1f6be6ff40165c1d6dcaf1a2c888326d537ba75d2a21f88397fc4e89e1f75ac19c2af036a22eff96b561b3d1512be489230c92c118283debb12c22f52537e08d34f91a4d6b5931ffe19585aa99437061a150b8bfaedb33b6dbcf0aa0438ad4fb21b1aceae595f2b7b14224f1cb9bf48735b04317a38bfbdb46e07dd71da2cce4e5f2d9005029be5905a5d8e85fabeae4d3644ee49dd57d1aeb63eb31f2c58d65e4d3d3b42ba39fe2e344d371087b9b3854c4041c98b95a3934f8977d813e22b97d065341c78d55e7fb9bc7a3a433a45c498467d3b4cb619d247d171d2a6d0261d3fade67debe9c0e17247b5a878c56268abcb48f7011d4f1211f0b9d7eb375e1d02505a775897ec0ec37b4d2e20ec0d1f38a4b7ebdda90c2f914799c557e2388033b8f7b6c937ab7704e52b5714faa9ccc48962b91c49aeeb1798cc6dead6571887239107eae0ba7a206555b09278a0ecd509a17ebed646452a641005187b1f946cd553a5edd1b937a7608dc25abd1c18ea591c780636c448760432280083da304560a40f2e19ffeceae00236349fd898fc4b101fc69b095f1bd4f081faec806f018567c29161cf30b158bddd22018737ffde41268c4bdf94960825c06ed190ccf42487854625ce88c4ad38967b8aa4eb211985d383efaf10be6044c696e69dea77b177383e9e1d483ba6a7b233ac511ee5fd3fcf0e827cbcf2731d7e6511a5684f04a7ebb3581b8812482356e3b7e1abb6bf1cb4f024c0b9477ecd80bab4dd8c1083aaeea415734fc54b982581d19ce409ac6940b751e1c7a384eb32e70c71ca94635f5afe40ddb1045f7d18be00b0ac4af977945d458c1dc214df06ac9e1672b1d9debf3565a772a202c35c69a49d0b6b3c43c6972d2018fd9725ee27520f8c412e99a501d790fdff1237be25a2481a6f1f2ad693c07dee504b66e5a5d4148b72344d4cfc581bad7562e2d3b3de15c4232b47acb589388cf8efa68f492259850c5f434af13d7d1d2ad8d330525f163a79b30134c2f66255634ed091ad8d029d3c0f1c88540b948c7c81014a666ef8f2aa4f41e71fce0be2a73919298491d28418dde1cd50120ee9babd68ee4030e8498dd11e943f2ad3d14301ac5a3edc340c3b484ec088aa6dc6aab2839552c3639a51754e42a78a0df50be379a422545786ab60053ad2c03e6b29d8993bb34ccc2859a8a7ab728f1060a1f3af2842904e87cde764c09277485d4c2253cc9da3ea181932cb06b365d29956a3e1a0464ad14118130de9cf3295c356b33cd6ebd4b328d972ad4a1981751c284d35582b00e5a755c3f4fe762b6c4f72d1b45cb0509e56c0cb40b8574fa524ff5263eee4c145b8831e4c9413164af4b74139a38c517c2be64dab0b7918cc2414c4761c7e02c75b059a97355e98fe2f54ff151714f650204d0d5db434a18a61f2e9bdc555bdb8ff53f635dcc45d3d38c3f8e2049ac2f88e0ff86e2964c496bf099559bb376f4c07a731d0b9f3ecacfa7e72b8bcaaf0f5431ae324a4d4b60e17ceee2a9a2315fe13a6259ff8aabbe4b2b94685f315d2c028fee3c74662c3bc50927bf5c3e01a48f66096a41f069f34169234735854c8416ca8588787c80800b57ad41e62362788917b3652bb2e7570992237dfdff39356355034a7ac9bb0c738718910db281506c6487643f761e848901482fd5337e22c86d1f09b4c37288b29fdc3f1ffef06b622a8864048d5e2c0f8a89b88d1b71d4d9bb4694fc4917552fe8b8a621001d787414b21476a3e820381872ff69807637e0e4da5fcb79dce371f98cac6ce930e856ac45f2dd6578781b191afa5c678dc0264e0cf6cc530c2aee1d87d3fb2a7bb47a34720e771da173f4d4103861dd20d80b85c753cab51eeedced353d09e356c35936cab44a0f4d3efc4b7daed333d07adea822eb39dcac360c2be786e3e2989ded349597c0179feebced60c875d16cffb8d6664db0057cb81f21c06e8710efdeb11af8672bed840f36f5e4211ed38e3b28862f40111ad5ae66c1bddbaedeb31e084d760c822c31365155915a362585f920ab68cf4bca442ea05f6724c03c47e4fe4aa5ec0a85a2bae04311fbee7917156f17b7f622a070a28509d2b04a62789a5b2e163aa86dd24b8b528539b74e11727b0aafe216d8f34b820ff0ac8e670529aa33fa5378c3296727c444f9c25becfb108814c94f4667fc75831eece7a7ca9322bcdf0d7deeea977e9c92fdfe8e8baf6c069e6b516ae0d909de6f296505f73259826837b383dfb393d8d2dd4501419e525ed94c6eeb97cd34912932ef4820a76f1aaa3a93b4cb40e604d57cfd8066e6f5e6c466935214113837c1f957617eed68a2b3eb7eab6bc20e5fc63563faa51e610875754888a4fe0bdc85928e4278972ca03dda76087db0dffae08bd8e945c02a52552bf1100878e0fe0247aff4d4c72e937b97292c42eac972544e249b38f40020f11a15d492522ef956566c17caf822e6b4a808ea2b2e16b1a326253ded7749bf6fc7e26b43611541b3f240d08e7a916dcb05102e06f9bcac1ba4a4bd446d9f68d77b4de5bc8dd0a9a2c993342b38acf2c26e651f5bf08323e533cc9c6291b563fbdff19009d91f5eebb04bec5de3911bf4c4d23481e5bf25907ae04221ce113ad1468c9b6dc1e08fd62d82eb273f8d697951a6e220c4881e403be62cd6eb4097b8bacb299e9dd114608b4ddf55aefd71cd5e94daf2d930a6616b13ea8f866c1de797af021a680ea1c4e1d3895d1bbad6690dc18f80be529d075df26f465c537526b0762b01aad9a69d607d1de2f9532c33c2c09d5f0f804c137247bb49a16c57f6ce5da6cffaca5b907929bae93823a4c5acdfbf78df62d3a48ba556dc9555941b377a59fbb38a9e04255d8ddd2fbd34d22d1612c8d3fe866b47417333c9a302fcc3d161388bc6850e5613b6321a87157898e96e491f9780ea3053fdd2892bbb0b9a6a755ce7d609043a1ea0ab911a128a6af185c332c9d509befe7fae75c26cb725d7ad2728dc81d761bfc6f54d3deb6bfc34b40a2d3ec97f33f5b3b03c6442c9aef8356d019fd7cc78f8f3a6c895b350fb038c4f7248faf42d87d978ae369fe139e1b60aaac139d4922e46b0c771557049ec08e7d794093bbdc3f33d585933287bd4f939b48b04a18433a54f541ae44abdab6fcadbc1d4ee05910d010da694df6df7b7c6c1279d7e8b5fc8a1b4f4f9abdad2c1897f53b7f5b381ced5329228290871a3b14facf49c300b6f0a9c626f21ab82767204c59d8bc360f8785567c63f90d2144959d2de224bb1a89e1a6f2545c916e11f83e5a13c4f0fcc95c55ce824d627cec37418d229a799ad234262a204ab016823bdf4a301d7af970163fd3e2e56585a0b272aada5aa0a5e62a095689f02cac9de63293f36de0923b66454674558eb1bb5b9fb7529ea06a7f46a48aad24409dd42fb147ff317c1203ff1b8b63f71d1d5eec7ca7d226f0e519e5377b6fc49acf7ca9754077747359a6332d744a29ba27f0feaaca0d66eda60a978003ea41501a626ed1ee8ba62eaf7cfd1406574a09e250c164c4a60ab52e0e33bb3657bc3ed09f0945ed5cabf96baebedf81db7436a74ed0fb4220a88e0aaf9eae0f09463e43b2ede22e5ac43a9b08ac4c1500f779ebd24f07dfb8ff3809b80dbbb55b821d6840bdfa9d55f2808a12043c98f5f41f7f1c0833dd45859bfb35ba79c5180e6822877ea4484f1112f5e69f7afeeb10cc200b80d7c44d8499b5f016fb2d4526430e21b0291ded543022dfe3a94dae200946ff2e71b431c42835be5e8031a4632e674ec6074ae173c0166bd0f85d3c5336bb724ae01d21a5d46525fe172429918a1ecc7e9c212abd461e4f31e94dee0785fa33b9cbecb58b65ec5faeee1ca465efb5b732839ed8a7847eb7f7d9ded8cf0cd5b789b271b3a8908643bacd7f489d216435dbcba2826da27192157edceb6a39c850adc2941fccd40894a7127ce68d020ab3a04d9c1d52f2b16ac6da8a794ff2844924ab9844a705b18f74637c5cdefe189cb81253ada3ceddee6c2a96e3db7a2c8a2864e9f5fe737c33420ee088013dfe3c5c54d15bedd9e263467c298293fd9478dd9a4742aaaf109c74ac059c648d2c3925ad8db72e16ea39dde8047e03fd0cd4e44dfcc69afc3379ceb76b86ded74c3205381c71d00c92ddc2b6d0075456796c4faa287507806e0946cf641391b58a1ad6665a88c19fdcff2ea42972c72aaad3ae5cf14965499d3a9f349d93d17c7cc5ff2317552687b764a80d2ebfd34907c222d6d3e98f4fb2548d803acde2a9241a19f880971d7cc6ae8594aec2ccca08e656af9ae919f4a2770fb1bb72c8a3d621f58e842fa9b6440d43fe650891649a61eeb134b3f475abcd66a544598d340304b7f734ab19b8ae29b164f79e399ea21cf87581128c493ba5014184c921a1dd058b287030841ed9f6feccc0d6b35071ed9cbffb7446d2bc19140d10467772024ce0eb1368e5ee243439871deaf1dec2b2af70e13185f47d3b2794548846eb1dac99b7e5d8803e692e158d33933e75aa03bb55602d2e758f7ad595ee71a6f9a332d2f701aecb11b51e97703e40c247a833d4806ba3e572c075add57c6e50e516e49f002e99b9e58add87cd88d49e379e1c334f6dfc6ccbc64a62f304329bb5373ad0da42747850cc2f9b9613ee6d24a44c6d8703cf7050046fc695762bc55cc51f0fde30cefa5861aebf38b17a7b647510d372c57c28b346292b90565fb55e472c651a91ab0ac39bbe2671bf7d03ce2f456ae97ebebf5b0e8def45a5aaa1c2683323118ecb05a4588102a0b2b6a8f198dd5c8d5fff66ac8e6f4e1ed449ac52066ceb8da35afa9f0dc8c3ff36a76dd4de7ce0aecb36de7af670779b7c25c898b34f2be83b487f35296ea416b7b5ccf6f3402f4b214a3f71b08cc132569d7d62e5537695dc01735df6ffb2fb9a7d9b8b217000cde6046f6da3f59abaf05a47d5fd7a16a53a5d072d1941e3e32b2d8c7e5bd0b60ac979ea5b80a1ef3fecee0b8136efd07633affd57e22aaf8f2b8190ac503316467eb2e14d2cc3aa08e5a764ab276986d677c8e2d54ef61afe846152609651ffcf0c83066c420281ec321eba697f90203dc41f6ceebac5d820e1b5e91c9fc4b2994607aa7aca1553bd634189986331f1b5d963a15922266835176fea2b010dee24575830ebe189055486906415869152e78fedb9e29811bf361128159f2832144333242386da8d8ccdb4641a85c2a0040495c6e23e6beaefbbfae2ed22893d261dd40bad671dd6df9b7992de169691a362b18f83a0d5e1ef6623ec4be81d09cf93d560945d2c1c920d1a6fd51554565e58e95c6ee09a6fcaa0fbf4e50429dedcd53c363ad0d974dc6756094a67962e0eba2f2f3c324f27be4a770134f0e1e0c2214771c9ac843c8e622a3c42ef63044e9958c74b369bfff200790b869ef0c3867e86da65bf4d9544b921604dfbb714ba9fd3fb738e76dcb56d72e69edc336c0ba3a80c6436405d59c3e2aa8e5edca24405929569ec47e0fcb429ef6b84703437b5473cbabbd748250104f979ed6c75c00db05d3f1ed22fab7f3e2624046b5e7aacb3f31fcaa058823bbb9f332dd3f17dc6a421db70fcf170c26a1c1c0fbd98a9b5e2bc9ac30528a25620acdc01912f517d9020929ff5cdfc190a61aadad54ebea79f2899c53196c45c54ecb15ae99110b61809cc2a792075fb8361b8b3e481e7a90bd0ebf7c5026c361d71944f2106b62dcd2b5fc3b034e56f35030bbdc7b7cdbadb999f116772fb65594dc823f1c537ab65ff0825013f601d0c1773f868203bdd13be9b14322df92ff173c3b722cabc96390e68de6b5907f324c604e8a5bf4f8d631ce0b6fce1f087c754ec16ec5017af28e880a53504a52925d02818dd508459c835e5db102488b81e54fedac75cf42dd0061b0a154aa24cb516e78e3530af8dec6430bb9f52898e97865a01ae7e64096e7d8e3c28836909db7ff1067b2f613bc048d790bf3facea6253bf6fbf3ed32802428e35bd75568ba5959e65</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Person </category>
          
      </categories>
      
      
        <tags>
            
            <tag> encrypt </tag>
            
            <tag> hide </tag>
            
            <tag> years </tag>
            
            <tag> 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年终总结</title>
      <link href="/2023/01-01/2021+2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html"/>
      <url>/2023/01-01/2021+2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="1e0edeef78809b41c4a3e73df5bd01a1c77f6b92fb9a5f30a74ad82d3b495741">681847c39b6521bb3e6b7f34c9f4fff7dfe378ab4bd615a8b32a0271d97b3b404922deaa691fe03149a74fe34b3a151dbb771aad6e32d6e9ea90d249ed052d678fc8cf170b6276d60c12af5d9821fee98e99ea34c7beeb8953dc17415713676475e178cf6083259e924ce703b1f17fdbc7cfb462da59098298d036a615a89a65ec32caf74acc2f9a69f613aa42c77d692559753681df06312b7795bb99278900978e0192434aa8494f29c47feb97cc6b0c135ec9eadcbbfd1a0461c6c1f6be6ff40165c1d6dcaf1a2c888326d537ba75d2a21f88397fc4e89e1f75ac19c2af036a22eff96b561b3d1512be489230c92c118283debb12c22f52537e08d34f91a4d6b5931ffe19585aa99437061a150b8bfaedb33b6dbcf0aa0438ad4fb21b1aceae595f2b7b14224f1cb9bf48735b04317a38bfbdb46e07dd71da2cce4e5f2d9005029be5905a5d8e85fabeae4d3644ee49dd57d1aeb63eb31f2c58d65e4d3d3b42ba39fe2e344d371087b9b3854c4041c98b95a3934f8977d813e22b97d065341c78d55e7fb9bc7a3a433a45c498467d3b4cb619d247d171d2a6d0261d3fade67debe9c0e17247b5a878c56268abcb48f7011d4f1211f0b9d7eb375e1d02505a775897ec0ec37b4d2e20ec0d1f38a4b7ebdda90c2f914799c557e2388033b8f7b6c937ab7704e52b5714faa9ccc48962b91c49aeeb1798cc6dead6571887239107eae0ba7a206555b09278a0ecd509a17ebed646452a641005187b1f946cd553a5edd1b937a7608dc25abd1c18ea591c780636c448760432280083da304560a40f2e19ffeceae00236349fd898fc4b101fc69b095f1bd4f081faec806f018567c29161cf30b158bddd22018737ffde41268c4bdf94960825c06ed190ccf42487854625ce88c4ad38967b8aa4eb211985d383efaf10be6044c696e69dea77b177383e9e1d483ba6a7b233ac511ee5fd3fcf0e827cbcf2731d7e6511a5684f04a7ebb3581b8812482356e3b7e1abb6bf1cb4f024c0b9477ecd80bab4dd8c1083aaeea415734fc54b982581d19ce409ac6940b751e1c7a384eb32e70c71ca94635f5afe40ddb1045f7d18be00b0ac4af977945d458c1dc214df06ac9e1672b1d9debf3565a772a202c35c69a49d0b6b3c43c6972d2018fd9725ee27520f8c412e99a501d790fdff1237be25a2481a6f1f2ad693c07dee504b66e5a5d4148b72344d4cfc581bad7562e2d3b3de15c4232b47acb589388cf8efa68f492259850c5f434af13d7d1d2ad8d330525f163a79b30134c2f66255634ed091ad8d029d3c0f1c88540b948c7c81014a666ef8f2aa4f41e71fce0be2a73919298491d28418dde1cd50120ee9babd68ee4030e8498dd11e943f2ad3d14301ac5a3edc340c3b484ec088aa6dc6aab2839552c3639a51754e42a78a0df50be379a422545786ab60053ad2c03e6b29d8993bb34ccc2859a8a7ab728f1060a1f3af2842904e87cde764c09277485d4c2253cc9da3ea181932cb06b365d29956a3e1a0464ad14118130de9cf3295c356b33cd6ebd4b328d972ad4a1981751c284d35582b00e5a755c3f4fe762b6c4f72d1b45cb0509e56c0cb40b8574fa524ff5263eee4c145b8831e4c9413164af4b74139a38c517c2be64dab0b7918cc2414c4761c7e02c75b059a97355e98fe2f54ff151714f650204d0d5db434a18a61f2e9bdc555bdb8ff53f635dcc45d3d38c3f8e2049ac2f88e0ff86e2964c496bf099559bb376f4c07a731d0b9f3ecacfa7e72b8bcaaf0f5431ae324a4d4b60e17ceee2a9a2315fe13a6259ff8aabbe4b2b94685f315d2c028fee3c74662c3bc50927bf5c3e01a48f66096a41f069f34169234735854c8416ca8588787c80800b57ad41e62362788917b3652bb2e7570992237dfdff39356355034a7ac9bb0c738718910db281506c6487643f761e848901482fd5337e22c86d1f09b4c37288b29fdc3f1ffef06b622a8864048d5e2c0f8a89b88d1b71d4d9bb4694fc4917552fe8b8a621001d787414b21476a3e820381872ff69807637e0e4da5fcb79dce371f98cac6ce930e856ac45f2dd6578781b191afa5c678dc0264e0cf6cc530c2aee1d87d3fb2a7bb47a34720e771da173f4d4103861dd20d80b85c753cab51eeedced353d09e356c35936cab44a0f4d3efc4b7daed333d07adea822eb39dcac360c2be786e3e2989ded349597c0179feebced60c875d16cffb8d6664db0057cb81f21c06e8710efdeb11af8672bed840f36f5e4211ed38e3b28862f40111ad5ae66c1bddbaedeb31e084d760c822c31365155915a362585f920ab68cf4bca442ea05f6724c03c47e4fe4aa5ec0a85a2bae04311fbee7917156f17b7f622a070a28509d2b04a62789a5b2e163aa86dd24b8b528539b74e11727b0aafe216d8f34b820ff0ac8e670529aa33fa5378c3296727c444f9c25becfb108814c94f4667fc75831eece7a7ca9322bcdf0d7deeea977e9c92fdfe8e8baf6c069e6b516ae0d909de6f296505f73259826837b383dfb393d8d2dd4501419e525ed94c6eeb97cd34912932ef4820a76f1aaa3a93b4cb40e604d57cfd8066e6f5e6c466935214113837c1f957617eed68a2b3eb7eab6bc20e5fc63563faa51e610875754888a4fe0bdc85928e4278972ca03dda76087db0dffae08bd8e945c02a52552bf1100878e0fe0247aff4d4c72e937b97292c42eac972544e249b38f40020f11a15d492522ef956566c17caf822e6b4a808ea2b2e16b1a326253ded7749bf6fc7e26b43611541b3f240d08e7a916dcb05102e06f9bcac1ba4a4bd446d9f68d77b4de5bc8dd0a9a2c993342b38acf2c26e651f5bf08323e533cc9c6291b563fbdff19009d91f5eebb04bec5de3911bf4c4d23481e5bf25907ae04221ce113ad1468c9b6dc1e08fd62d82eb273f8d697951a6e220c4881e403be62cd6eb4097b8bacb299e9dd114608b4ddf55aefd71cd5e94daf2d930a6616b13ea8f866c1de797af021a680ea1c4e1d3895d1bbad6690dc18f80be529d075df26f465c537526b0762b01aad9a69d607d1de2f9532c33c2c09d5f0f804c137247bb49a16c57f6ce5da6cffaca5b907929bae93823a4c5acdfbf78df62d3a48ba556dc9555941b377a59fbb38a9e04255d8ddd2fbd34d22d1612c8d3fe866b47417333c9a302fcc3d161388bc6850e5613b6321a87157898e96e491f9780ea3053fdd2892bbb0b9a6a755ce7d609043a1ea0ab911a128a6af185c332c9d509befe7fae75c26cb725d7ad2728dc81d761bfc6f54d3deb6bfc34b40a2d3ec97f33f5b3b03c6442c9aef8356d019fd7cc78f8f3a6c895b350fb038c4f7248faf42d87d978ae369fe139e1b60aaac139d4922e46b0c771557049ec08e7d794093bbdc3f33d585933287bd4f939b48b04a18433a54f541ae44abdab6fcadbc1d4ee05910d010da694df6df7b7c6c1279d7e8b5fc8a1b4f4f9abdad2c1897f53b7f5b381ced5329228290871a3b14facf49c300b6f0a9c626f21ab82767204c59d8bc360f8785567c63f90d2144959d2de224bb1a89e1a6f2545c916e11f83e5a13c4f0fcc95c55ce824d627cec37418d229a799ad234262a204ab016823bdf4a301d7af970163fd3e2e56585a0b272aada5aa0a5e62a095689f02cac9de63293f36de0923b66454674558eb1bb5b9fb7529ea06a7f46a48aad24409dd42fb147ff317c1203ff1b8b63f71d1d5eec7ca7d226f0e519e5377b6fc49acf7ca9754077747359a6332d744a29ba27f0feaaca0d66eda60a978003ea41501a626ed1ee8ba62eaf7cfd1406574a09e250c164c4a60ab52e0e33bb3657bc3ed09f0945ed5cabf96baebedf81db7436a74ed0fb4220a88e0aaf9eae0f09463e43b2ede22e5ac43a9b08ac4c1500f779ebd24f07dfb8ff3809b80dbbb55b821d6840bdfa9d55f2808a12043c98f5f41f7f1c0833dd45859bfb35ba79c5180e6822877ea4484f1112f5e69f7afeeb10cc200b80d7c44d8499b5f016fb2d4526430e21b0291ded543022dfe3a94dae200946ff2e71b431c42835be5e8031a4632e674ec6074ae173c0166bd0f85d3c5336bb724ae01d21a5d46525fe172429918a1ecc7e9c212abd461e4f31e94dee0785fa33b9cbecb58b65ec5faeee1ca465efb5b732839ed8a7847eb7f7d9ded8cf0cd5b789b271b3a8908643bacd7f489d216435dbcba2826da27192157edceb6a39c850adc2941fccd40894a7127ce68d020ab3a04d9c1d52f2b16ac6da8a794ff2844924ab9844a705b18f74637c5cdefe189cb81253ada3ceddee6c2a96e3db7a2c8a2864e9f5fe737c33420ee088013dfe3c5c54d15bedd9e263467c298293fd9478dd9a4742aaaf109c74ac059c648d2c3925ad8db72e16ea39dde8047e03fd0cd4e44dfcc69afc3379ceb76b86ded74c3205381c71d00c92ddc2b6d0075456796c4faa287507806e0946cf641391b58a1ad6665a88c19fdcff2ea42972c72aaad3ae5cf14965499d3a9f349d93d17c7cc5ff2317552687b764a80d2ebfd34907c222d6d3e98f4fb2548d803acde2a9241a19f880971d7cc6ae8594aec2ccca08e656af9ae919f4a2770fb1bb72c8a3d621f58e842fa9b6440d43fe650891649a61eeb134b3f475abcd66a544598d340304b7f734ab19b8ae29b164f79e399ea21cf87581128c493ba5014184c921a1dd058b287030841ed9f6feccc0d6b35071ed9cbffb7446d2bc19140d10467772024ce0eb1368e5ee243439871deaf1dec2b2af70e13185f47d3b2794548846eb1dac99b7e5d8803e692e158d33933e75aa03bb55602d2e758f7ad595ee71a6f9a332d2f701aecb11b51e97703e40c247a833d4806ba3e572c075add57c6e50e516e49f002e99b9e58add87cd88d49e379e1c334f6dfc6ccbc64a62f304329bb5373ad0da42747850cc2f9b9613ee6d24a44c6d8703cf7050046fc695762bc55cc51f0fde30cefa5861aebf38b17a7b647510d372c57c28b346292b90565fb55e472c651a91ab0ac39bbe2671bf7d03ce2f456ae97ebebf5b0e8def45a5aaa1c2683323118ecb05a4588102a0b2b6a8f198dd5c8d5fff66ac8e6f4e1ed449ac52066ceb8da35afa9f0dc8c3ff36a76dd4de7ce0aecb36de7af670779b7c25c898b34f2be83b487f35296ea416b7b5ccf6f3402f4b214a3f71b08cc132569d7d62e5537695dc01735df6ffb2fb9a7d9b8b217000cde6046f6da3f59abaf05a47d5fd7a16a53a5d072d1941e3e32b2d8c7e5bd0b60ac979ea5b80a1ef3fecee0b8136efd07633affd57e22aaf8f2b8190ac503316467eb2e14d2cc3aa08e5a764ab276986d677c8e2d54ef61afe846152609651ffcf0c83066c420281ec321eba697f90203dc41f6ceebac5d820e1b5e91c9fc4b2994607aa7aca1553bd634189986331f1b5d963a15922266835176fea2b010dee24575830ebe189055486906415869152e78fedb9e29811bf361128159f2832144333242386da8d8ccdb4641a85c2a0040495c6e23e6beaefbbfae2ed22893d261dd40bad671dd6df9b7992de169691a362b18f83a0d5e1ef6623ec4be81d09cf93d560945d2c1c920d1a6fd51554565e58e95c6ee09a6fcaa0fbf4e50429dedcd53c363ad0d974dc6756094a67962e0eba2f2f3c324f27be4a770134f0e1e0c2214771c9ac843c8e622a3c42ef63044e9958c74b369bfff200790b869ef0c3867e86da65bf4d9544b921604dfbb714ba9fd3fb738e76dcb56d72e69edc336c0ba3a80c6436405d59c3e2aa8e5edca24405929569ec47e0fcb429ef6b84703437b5473cbabbd748250104f979ed6c75c00db05d3f1ed22fab7f3e2624046b5e7aacb3f31fcaa058823bbb9f332dd3f17dc6a421db70fcf170c26a1c1c0fbd98a9b5e2bc9ac30528a25620acdc01912f517d9020929ff5cdfc190a61aadad54ebea79f2899c53196c45c54ecb15ae99110b61809cc2a792075fb8361b8b3e481e7a90bd0ebf7c5026c361d71944f2106b62dcd2b5fc3b034e56f35030bbdc7b7cdbadb999f116772fb65594dc823f1c537ab65ff0825013f601d0c1773f868203bdd13be9b14322df92ff173c3b722cabc96390e68de6b5907f324c604e8a5bf4f8d631ce0b6fce1f087c754ec16ec5017af28e880a53504a52925d02818dd508459c835e5db102488b81e54fedac75cf42dd0061b0a154aa24cb516e78e3530af8dec6430bb9f52898e97865a01ae7e64096e7d8e3c28836909db7ff1067b2f613bc048d790bf3facea6253bf6fbf3ed32802428e35bd75568ba5959e65</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Person </category>
          
      </categories>
      
      
        <tags>
            
            <tag> encrypt </tag>
            
            <tag> hide </tag>
            
            <tag> years </tag>
            
            <tag> 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年终总结</title>
      <link href="/2023/01-01/attachments/2021+2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html"/>
      <url>/2023/01-01/attachments/2021+2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="1e0edeef78809b41c4a3e73df5bd01a1c77f6b92fb9a5f30a74ad82d3b495741">681847c39b6521bb3e6b7f34c9f4fff7dfe378ab4bd615a8b32a0271d97b3b404922deaa691fe03149a74fe34b3a151dbb771aad6e32d6e9ea90d249ed052d678fc8cf170b6276d60c12af5d9821fee98e99ea34c7beeb8953dc17415713676475e178cf6083259e924ce703b1f17fdbc7cfb462da59098298d036a615a89a65ec32caf74acc2f9a69f613aa42c77d692559753681df06312b7795bb99278900978e0192434aa8494f29c47feb97cc6b0c135ec9eadcbbfd1a0461c6c1f6be6ff40165c1d6dcaf1a2c888326d537ba75d2a21f88397fc4e89e1f75ac19c2af036a22eff96b561b3d1512be489230c92c118283debb12c22f52537e08d34f91a4d6b5931ffe19585aa99437061a150b8bfaedb33b6dbcf0aa0438ad4fb21b1aceae595f2b7b14224f1cb9bf48735b04317a38bfbdb46e07dd71da2cce4e5f2d9005029be5905a5d8e85fabeae4d3644ee49dd57d1aeb63eb31f2c58d65e4d3d3b42ba39fe2e344d371087b9b3854c4041c98b95a3934f8977d813e22b97d065341c78d55e7fb9bc7a3a433a45c498467d3b4cb619d247d171d2a6d0261d3fade67debe9c0e17247b5a878c56268abcb48f7011d4f1211f0b9d7eb375e1d02505a775897ec0ec37b4d2e20ec0d1f38a4b7ebdda90c2f914799c557e2388033b8f7b6c937ab7704e52b5714faa9ccc48962b91c49aeeb1798cc6dead6571887239107eae0ba7a206555b09278a0ecd509a17ebed646452a641005187b1f946cd553a5edd1b937a7608dc25abd1c18ea591c780636c448760432280083da304560a40f2e19ffeceae00236349fd898fc4b101fc69b095f1bd4f081faec806f018567c29161cf30b158bddd22018737ffde41268c4bdf94960825c06ed190ccf42487854625ce88c4ad38967b8aa4eb211985d383efaf10be6044c696e69dea77b177383e9e1d483ba6a7b233ac511ee5fd3fcf0e827cbcf2731d7e6511a5684f04a7ebb3581b8812482356e3b7e1abb6bf1cb4f024c0b9477ecd80bab4dd8c1083aaeea415734fc54b982581d19ce409ac6940b751e1c7a384eb32e70c71ca94635f5afe40ddb1045f7d18be00b0ac4af977945d458c1dc214df06ac9e1672b1d9debf3565a772a202c35c69a49d0b6b3c43c6972d2018fd9725ee27520f8c412e99a501d790fdff1237be25a2481a6f1f2ad693c07dee504b66e5a5d4148b72344d4cfc581bad7562e2d3b3de15c4232b47acb589388cf8efa68f492259850c5f434af13d7d1d2ad8d330525f163a79b30134c2f66255634ed091ad8d029d3c0f1c88540b948c7c81014a666ef8f2aa4f41e71fce0be2a73919298491d28418dde1cd50120ee9babd68ee4030e8498dd11e943f2ad3d14301ac5a3edc340c3b484ec088aa6dc6aab2839552c3639a51754e42a78a0df50be379a422545786ab60053ad2c03e6b29d8993bb34ccc2859a8a7ab728f1060a1f3af2842904e87cde764c09277485d4c2253cc9da3ea181932cb06b365d29956a3e1a0464ad14118130de9cf3295c356b33cd6ebd4b328d972ad4a1981751c284d35582b00e5a755c3f4fe762b6c4f72d1b45cb0509e56c0cb40b8574fa524ff5263eee4c145b8831e4c9413164af4b74139a38c517c2be64dab0b7918cc2414c4761c7e02c75b059a97355e98fe2f54ff151714f650204d0d5db434a18a61f2e9bdc555bdb8ff53f635dcc45d3d38c3f8e2049ac2f88e0ff86e2964c496bf099559bb376f4c07a731d0b9f3ecacfa7e72b8bcaaf0f5431ae324a4d4b60e17ceee2a9a2315fe13a6259ff8aabbe4b2b94685f315d2c028fee3c74662c3bc50927bf5c3e01a48f66096a41f069f34169234735854c8416ca8588787c80800b57ad41e62362788917b3652bb2e7570992237dfdff39356355034a7ac9bb0c738718910db281506c6487643f761e848901482fd5337e22c86d1f09b4c37288b29fdc3f1ffef06b622a8864048d5e2c0f8a89b88d1b71d4d9bb4694fc4917552fe8b8a621001d787414b21476a3e820381872ff69807637e0e4da5fcb79dce371f98cac6ce930e856ac45f2dd6578781b191afa5c678dc0264e0cf6cc530c2aee1d87d3fb2a7bb47a34720e771da173f4d4103861dd20d80b85c753cab51eeedced353d09e356c35936cab44a0f4d3efc4b7daed333d07adea822eb39dcac360c2be786e3e2989ded349597c0179feebced60c875d16cffb8d6664db0057cb81f21c06e8710efdeb11af8672bed840f36f5e4211ed38e3b28862f40111ad5ae66c1bddbaedeb31e084d760c822c31365155915a362585f920ab68cf4bca442ea05f6724c03c47e4fe4aa5ec0a85a2bae04311fbee7917156f17b7f622a070a28509d2b04a62789a5b2e163aa86dd24b8b528539b74e11727b0aafe216d8f34b820ff0ac8e670529aa33fa5378c3296727c444f9c25becfb108814c94f4667fc75831eece7a7ca9322bcdf0d7deeea977e9c92fdfe8e8baf6c069e6b516ae0d909de6f296505f73259826837b383dfb393d8d2dd4501419e525ed94c6eeb97cd34912932ef4820a76f1aaa3a93b4cb40e604d57cfd8066e6f5e6c466935214113837c1f957617eed68a2b3eb7eab6bc20e5fc63563faa51e610875754888a4fe0bdc85928e4278972ca03dda76087db0dffae08bd8e945c02a52552bf1100878e0fe0247aff4d4c72e937b97292c42eac972544e249b38f40020f11a15d492522ef956566c17caf822e6b4a808ea2b2e16b1a326253ded7749bf6fc7e26b43611541b3f240d08e7a916dcb05102e06f9bcac1ba4a4bd446d9f68d77b4de5bc8dd0a9a2c993342b38acf2c26e651f5bf08323e533cc9c6291b563fbdff19009d91f5eebb04bec5de3911bf4c4d23481e5bf25907ae04221ce113ad1468c9b6dc1e08fd62d82eb273f8d697951a6e220c4881e403be62cd6eb4097b8bacb299e9dd114608b4ddf55aefd71cd5e94daf2d930a6616b13ea8f866c1de797af021a680ea1c4e1d3895d1bbad6690dc18f80be529d075df26f465c537526b0762b01aad9a69d607d1de2f9532c33c2c09d5f0f804c137247bb49a16c57f6ce5da6cffaca5b907929bae93823a4c5acdfbf78df62d3a48ba556dc9555941b377a59fbb38a9e04255d8ddd2fbd34d22d1612c8d3fe866b47417333c9a302fcc3d161388bc6850e5613b6321a87157898e96e491f9780ea3053fdd2892bbb0b9a6a755ce7d609043a1ea0ab911a128a6af185c332c9d509befe7fae75c26cb725d7ad2728dc81d761bfc6f54d3deb6bfc34b40a2d3ec97f33f5b3b03c6442c9aef8356d019fd7cc78f8f3a6c895b350fb038c4f7248faf42d87d978ae369fe139e1b60aaac139d4922e46b0c771557049ec08e7d794093bbdc3f33d585933287bd4f939b48b04a18433a54f541ae44abdab6fcadbc1d4ee05910d010da694df6df7b7c6c1279d7e8b5fc8a1b4f4f9abdad2c1897f53b7f5b381ced5329228290871a3b14facf49c300b6f0a9c626f21ab82767204c59d8bc360f8785567c63f90d2144959d2de224bb1a89e1a6f2545c916e11f83e5a13c4f0fcc95c55ce824d627cec37418d229a799ad234262a204ab016823bdf4a301d7af970163fd3e2e56585a0b272aada5aa0a5e62a095689f02cac9de63293f36de0923b66454674558eb1bb5b9fb7529ea06a7f46a48aad24409dd42fb147ff317c1203ff1b8b63f71d1d5eec7ca7d226f0e519e5377b6fc49acf7ca9754077747359a6332d744a29ba27f0feaaca0d66eda60a978003ea41501a626ed1ee8ba62eaf7cfd1406574a09e250c164c4a60ab52e0e33bb3657bc3ed09f0945ed5cabf96baebedf81db7436a74ed0fb4220a88e0aaf9eae0f09463e43b2ede22e5ac43a9b08ac4c1500f779ebd24f07dfb8ff3809b80dbbb55b821d6840bdfa9d55f2808a12043c98f5f41f7f1c0833dd45859bfb35ba79c5180e6822877ea4484f1112f5e69f7afeeb10cc200b80d7c44d8499b5f016fb2d4526430e21b0291ded543022dfe3a94dae200946ff2e71b431c42835be5e8031a4632e674ec6074ae173c0166bd0f85d3c5336bb724ae01d21a5d46525fe172429918a1ecc7e9c212abd461e4f31e94dee0785fa33b9cbecb58b65ec5faeee1ca465efb5b732839ed8a7847eb7f7d9ded8cf0cd5b789b271b3a8908643bacd7f489d216435dbcba2826da27192157edceb6a39c850adc2941fccd40894a7127ce68d020ab3a04d9c1d52f2b16ac6da8a794ff2844924ab9844a705b18f74637c5cdefe189cb81253ada3ceddee6c2a96e3db7a2c8a2864e9f5fe737c33420ee088013dfe3c5c54d15bedd9e263467c298293fd9478dd9a4742aaaf109c74ac059c648d2c3925ad8db72e16ea39dde8047e03fd0cd4e44dfcc69afc3379ceb76b86ded74c3205381c71d00c92ddc2b6d0075456796c4faa287507806e0946cf641391b58a1ad6665a88c19fdcff2ea42972c72aaad3ae5cf14965499d3a9f349d93d17c7cc5ff2317552687b764a80d2ebfd34907c222d6d3e98f4fb2548d803acde2a9241a19f880971d7cc6ae8594aec2ccca08e656af9ae919f4a2770fb1bb72c8a3d621f58e842fa9b6440d43fe650891649a61eeb134b3f475abcd66a544598d340304b7f734ab19b8ae29b164f79e399ea21cf87581128c493ba5014184c921a1dd058b287030841ed9f6feccc0d6b35071ed9cbffb7446d2bc19140d10467772024ce0eb1368e5ee243439871deaf1dec2b2af70e13185f47d3b2794548846eb1dac99b7e5d8803e692e158d33933e75aa03bb55602d2e758f7ad595ee71a6f9a332d2f701aecb11b51e97703e40c247a833d4806ba3e572c075add57c6e50e516e49f002e99b9e58add87cd88d49e379e1c334f6dfc6ccbc64a62f304329bb5373ad0da42747850cc2f9b9613ee6d24a44c6d8703cf7050046fc695762bc55cc51f0fde30cefa5861aebf38b17a7b647510d372c57c28b346292b90565fb55e472c651a91ab0ac39bbe2671bf7d03ce2f456ae97ebebf5b0e8def45a5aaa1c2683323118ecb05a4588102a0b2b6a8f198dd5c8d5fff66ac8e6f4e1ed449ac52066ceb8da35afa9f0dc8c3ff36a76dd4de7ce0aecb36de7af670779b7c25c898b34f2be83b487f35296ea416b7b5ccf6f3402f4b214a3f71b08cc132569d7d62e5537695dc01735df6ffb2fb9a7d9b8b217000cde6046f6da3f59abaf05a47d5fd7a16a53a5d072d1941e3e32b2d8c7e5bd0b60ac979ea5b80a1ef3fecee0b8136efd07633affd57e22aaf8f2b8190ac503316467eb2e14d2cc3aa08e5a764ab276986d677c8e2d54ef61afe846152609651ffcf0c83066c420281ec321eba697f90203dc41f6ceebac5d820e1b5e91c9fc4b2994607aa7aca1553bd634189986331f1b5d963a15922266835176fea2b010dee24575830ebe189055486906415869152e78fedb9e29811bf361128159f2832144333242386da8d8ccdb4641a85c2a0040495c6e23e6beaefbbfae2ed22893d261dd40bad671dd6df9b7992de169691a362b18f83a0d5e1ef6623ec4be81d09cf93d560945d2c1c920d1a6fd51554565e58e95c6ee09a6fcaa0fbf4e50429dedcd53c363ad0d974dc6756094a67962e0eba2f2f3c324f27be4a770134f0e1e0c2214771c9ac843c8e622a3c42ef63044e9958c74b369bfff200790b869ef0c3867e86da65bf4d9544b921604dfbb714ba9fd3fb738e76dcb56d72e69edc336c0ba3a80c6436405d59c3e2aa8e5edca24405929569ec47e0fcb429ef6b84703437b5473cbabbd748250104f979ed6c75c00db05d3f1ed22fab7f3e2624046b5e7aacb3f31fcaa058823bbb9f332dd3f17dc6a421db70fcf170c26a1c1c0fbd98a9b5e2bc9ac30528a25620acdc01912f517d9020929ff5cdfc190a61aadad54ebea79f2899c53196c45c54ecb15ae99110b61809cc2a792075fb8361b8b3e481e7a90bd0ebf7c5026c361d71944f2106b62dcd2b5fc3b034e56f35030bbdc7b7cdbadb999f116772fb65594dc823f1c537ab65ff0825013f601d0c1773f868203bdd13be9b14322df92ff173c3b722cabc96390e68de6b5907f324c604e8a5bf4f8d631ce0b6fce1f087c754ec16ec5017af28e880a53504a52925d02818dd508459c835e5db102488b81e54fedac75cf42dd0061b0a154aa24cb516e78e3530af8dec6430bb9f52898e97865a01ae7e64096e7d8e3c28836909db7ff1067b2f613bc048d790bf3facea6253bf6fbf3ed32802428e35bd75568ba5959e65</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Person </category>
          
      </categories>
      
      
        <tags>
            
            <tag> encrypt </tag>
            
            <tag> hide </tag>
            
            <tag> years </tag>
            
            <tag> 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年终总结</title>
      <link href="/2021/01-09/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html"/>
      <url>/2021/01-09/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="d42b0535662c6286e7d178b79b01dee65f244a7ae0bfeb1d992fba35e3174ccf">3374c411198d947a9f9e69b4d65d81e9e15225e11b6b103253c3f24f499bba8ff65c9f1c7aa54c256744235c618c9f659b951cb17d3b0d08bb6ae30a6b0a069e4a684f67fcefc40e8b7f98c3dc012760694d425de92339cac2de2f50a11988bccfe393b3443de7dde5141a38b9d585c3453b48e5b3ccfbaa555fce282eeadd0b2d2720d87a80fc3212a24c8148da998fb097618966c42f42acd81c538886470aafc23ca9e9f6fddf2714a5d343d2f653258ec9a60e49f5cfd292b6d71c8b003671940ab4afc8030ed46dad1666bc56ee0a3fc2650030dda0665fb3bb3efeb3a731ea86913dfe4bc66d5032e294abcc18490b6ace691432842b28ae58168eb612b108cfee8d164285def1a0a3cf8a40230eff5909bec415d067867a7cff8817bb873ece27af7bd75ee843a467af3877dbf4fa6c6f46aa29390bdbf198b7a63e0b480576b8c3b4314b84fe84a8c1f0a0fb56473e12c37f84585d5d6de4ada2eb54afb9b1c37a2e93cface6091bf156063d8af4bb946a497df3f3c25bdab820191233f9cab023e3a755518238ce3d2db55a889ae6f78fcfd29bf32857b71f78bf5ea638b9b7f1fb072c1409ce3257b902fe9269f15ab8194d464b79dd1bd6631618d9a36979a77c2a601a107a534d7751bf352fb92c8ad97fc6064918059d45eb16564ea0ea60d1ddd046221321e0f9fd436c3b2db4c6a0b2940bce56e37d06674829d8032f2f477b2b6c14bd4dfa0f07a5faa9b70c5ce24803d44e07cf9b8cd95addeb5006e08bf430e6b6b5424fea6eec8b5b4059919177944b027bc1ba5d665d7209341b860bf966091c261a4e92cb7a1d0569012ffcb326b4b3491a1f355fa6d1608ff065395b75e4de179cd773666e8de18c4ec4f14e7206848654e6774f96b52020e95b5b55240d5c76ed9ac03a406dd69f4cdac38dc8b98a718ec5ecc578032d634133b8a88ce2984036b343f8cab400dd1724b6b303fa20c91dd0c8a16dd17c2b78ed073523345baeb3222c7bffad7ba46bb14fbc19079e949a3663aac8c6c8aa606d6b285870682ca4a5e61fb4384a5be4290320c7be33e2455df8c0334a2a3fb107fab3a9f9ae156d55ff1151a23c5ed4a8bf379069ef5f7e40ee79204d39f0b6c29f9ecf0e7342b3f753a22c92d751bb4645dc797d5d352d7156ff7f1e8ef3c711d6598550fed2dcf6e4748178d4769ba42542ffa7ca9ba71ce4515194f6fd79cffec168e64b8b8ad3f132f3ad60513287b18f21d23c265e2ba479cd71897b30eda85dc9078dd90799dd1eff6256fab085e547fb9d09a3b4f5ab5f7a23b478c1455846b7c00a5accd9458c5b3da9ca8ad90ee79d0b4e03d2562301f23c386abf72d98f0d1fd0b80919633d71bb3a0e5c02a31a2aa6199e68322b60f97b07f9932c139a14c246f807ae0c70a54ec769b53c3b7ef502e8a13774f70df07a30d205239a4610f72cb2a45679c85eea90a4913c2d11f91905c0c13507bc98329b0f4ba331a37d4e7b1087b99cee1c15d8df514ecd46bd45d72d6509c6297253fe481268bca914740bd8b50870e501e5c26e6c714f8102e1c522b9ca84b27b5b5534d298ce8969d26d265768c02f041d44df14674602586d4c08df4f6504dc8003a50cf82a9491de17844779abbd7178406b080375de21e7c1d1734275ebf70bcde10efdebe210de317cd7dc805a4b8686ba0e3d1b339b8e7ebdb47041bc6b2e849cdaf8083f1926d1caa02691f11ac8befe5738768588b4cf302fe375a70aa327df4b5cd9bbc250b942aca001e08e8ef49f62fee253d3670f2601f4f3687a11e8c23ae850e207856f16726ef1fc69252ea6f0d489aae915407f0c23bca2a2fc96b3669daa88dee352f7bcf991a2b09127fd3982a459e38fa85f9b97f06c63d0aecbfe2042449bce3402f7961a6b7133cba6df4f48ca414dd8e4fc82c3140fcd3d9093996fa517ebba0fd88af3da8db9b8c6c424d20edd5d7c986f1e661b4999580d71d9ca94f25b4e8d837b3e132191a212e5a93f2eecf0e051c269148b82e53738f8723264072958b8bd22b8b40e8fde77891ad4931ca302a445460ea1c20b5e84cdc7f6b993cef2a33027590ab53b0bdaaa53df1df261db9ea430c99768a3fe37111d9d2ac1e2bcf05bc04592f44eb52797c6f75608db80069211e7ec942a3420305847dbb9849483cfdff201633d4246a670e9f091a7c65d09a5741074218ce077b20228686ea2da3cd5128bd5998dac6adbaac4011db8475a2e13b44f4409064064d46f2670561955b6753743740fc58c51a54ed339be65c2562bce77b70623ae85f3ed2451c66e97f634773c0afe809c9dbb96f5c6dc1c9b6df25f8075165a813453508ba2c9acba1f9eebc5ee9e5bb39426abb599d5b0ae11bfb2e92bd53cb02e6b7dd028f8486810c3fbc8d9c21f188bbc30829a5b2988a7b962ed5c33c88bf2da9aff991a6efe4e8964d227159124b3f09b784a76cae1920dc2f9bd2e78b52b942534403b9a43a5f845957ba339e2e12bb91e463f195e40766856deb6b1c77c6494ee0f4995b9ec727b6f7cb2d9140fa832148b9ae9958df51ee88ea8d307c5fd53c4c53302fc2f74faf51885fa378efc3dabddbfea10e150dfcf0adecc87da76465a306242a48b20b39e14819a263f997f1712d4d257947d270c205f16929954b43d578669a49302509fef476841328702de2ab613686e315aebf544bd0fca08fb86790bd2164a4404d397a7ac755cc320b6ff13174526070819fe85f5e038d717e5f7c4ecef4c668fa2d4b904cb13b1da12237423d8b3f6de2018b76ca7599dddff6bcb2fc8b55310d6187515c2f88298d3d695818db175f769a3d9b9878798a13a2d88c4802e1997d8bbe3a3843b2a8c655b01a6c844d9f277c74c4cc8ecf0beacd50383b7e712f19b07d5d92f5dafd0d872ba65c7e0f03647cd6a61a06b030daf7464be2772278792d256cb7a63a67add17ce1a7e1de505dff3c81301f2cff8855b0e5f2b5f59d407c55a0ce077fbef82a24cf40eee3e80fcb97b10ab37b36622c9d484653bbbb4ac9039ab45b4742769b1eb64e37da7e52e1531cce8cf0ac6f69c3deba033e78688584a81170d0a1a512015f049ff86c5d57aa550bd3b9145b491d86715de04b41f8e54fed8fb0d6e4a67559342a10417c535acc1efe508743b10466701bd8a2a41e329fd7334744b186c703ca4b57a68930b538c236008afcc94bfe32d68a8d8b9b897067f813a0ca8d10e5cf7d7c40103f8d3622b828dffe36d67d494d029ee3f3544997d525c9f12dd8a82d3efb13773ba27c5317b065aa00153a8f2a37a8b1e2f9621ef0d0188c8ecc92191b0e52bf7674885da57a8975028cd847285926da4e52d71455d6086ef0299ea92a3e7a5de1afcb4b93e2ccf5130bac3d8dfa4768edd48d4153f315bd8d5dca3df5780ab8b69da08f65ec09ad93fa23b8ce484465b39291e433faf69cfa104c4ce924e59f0af1d1b3330d0993403e7d28aa94490e4dd6a194510f1b6d5b7125063ccd61018a3eb5b6f4cd428e7c4880111da8afb7d7cc3442ae1c238f0001cf19ba017933756c5396c195e95fb57190f6e1ca35944d1b1d56446a9d1df2f25db22455e0c28d9e3abb0bcc5c27229d5d6a6f3b8c568be2e49c806a06261ac6a359a735829b9c9fc4fb1b2d5abe639c624044ed4fe8fc761861b3f16d093012bb130f3b1045b81f362a3c28da8551a8152872db9b8ad841528af5d1b7755b04055ae94fd904338d0581ada8a0e3489eec5068fd71e2dc1e48b616fcbe83441a5b8a2bdcb92b495462be9260d78fec4cc357c0971c1a41ec68bf531e48c0030220104716837527618fc2b1d433e1ca47c00668b958a7317dff3c3b2030f9026942588dde60704fa0a2f9e3d9944c1654888db0a300072c4f1e719542bb3c9f1e3997bb879980daa068d0034c9655c0aba56a06332c3f6febe1f36de8b38f9991fa24a20882dd047c61a234d97f3ce0bdcd03497ca18442f872c711ce96ac0363b3275c5bf8d81f0b0ca347bedb92d6635d2feec63bb1e6840d537d34b621a7a79b5c51e8c63348b2de6bcfe838f11872eb4ab2ef664d5a99fd837ab2074fc24e828ee55eaf7a2823438f728765fa659b2a766f08dec7e7ac33ec5a1991c16460e04d876c49e3fcf80196eb83ea51c74482bd1895b878bc6f76bec8aae3cf73eb07493fca813df37aa1568c07d8218b8ee6655b1ca90ad590f57fcce6c128c4baecfaf9d4db0cdbbf3e94f5eb9264d3a2ac041ba4092c14b2973ce6847f3e0a58225c99bf8c71e6e637e4c9c11c72efcd373af5e4847865634eebb8f56ceff29a7f7ef478e5acb99545655030d1d1e9a5fec9074d05e59c204403f2971597a871a56b9e69803be239d270f6f0ebd9ccab88c7112dd213619dd4448d6b8d3851488c73818f7837395c90bfd4d498e74f5bafe3b689376e36431e76d878f54c21ff696532c756bdb56b5afa552496794c34b4a1104e26fe8c9dcf38844af526b003a9737ee68a52dc11b32999dbb39f93c7cdf6327e5157704c329d49d1a54d865f72cdcf9eb3be168391065c4141c21b6950c0c87bee7e0f4e342497d8b59f9dd6f41532ad2c865388ed267ca0a69207297417a88003fe6a76445fb21979a097c3c967d947c46762badbfcbb2bd14bfd94e25c4d0807fe96696d1ab2a31aa975e3b76b4ba39fba112d27e450b03b113485ebc6239927991e0fb59967e4f149ba93bcfb0de7c50d702ce35a7a7040038e579e57c6c338176f4a969c2d6d45df316336d0cd9c68ae9bf59c5bcb22445fea991b22beb4a9a61d70e4d0ed2eadb1b321c63dd10f330794fb6dfbd9dd2d9960db153871a39942e889213048c8548d48477688a37d7cf53eb9baa399414090576b8f6c2b6f559f7e8587eccfbb391e09967a4f2eb9ebda27c6ac8292733347222a3df705d7f6039c9c37f2f542519f825eeed8430bef880d06db16dea5935298ac37f38cdb599fb57a76bede47e900ebf2591d9c48495435e5025a27ca131f19283c172db505d7c06ac5675b24b1eeeff6d885d64c6fa7a61ed86e73cc11d59400b475835221a67f42b43897164853b800b708bcd99575a3b2b50907eafff4ca70d145899cc07673fd92230147d3093af216e5c1b8b376d7a8a5e74c69a2cd21ff0a58ddca2d049dd8740eb53c4abc16ec4a00a3c6d42435bc232ecee49cad31cabce475db72fa9bbd4ece7dc3ea08efdd65a63475188ddcaa24bb8773d929c471cf2a9a4dad034954727e7264286439766c0aaf1f8bb588daf45a3a671392db0907688a2749cb03f394fd12fbff6fbc597ee2d8336ae7212a5c2caa4132c546c6c690d27a89c9c1df63972ab4de86373537be45b8e40853bb1625ac7834e7f413d6e7aeeaababca4f77ee29a7c54578acee5947f788edac20a7bec40ffffc0196e26864019e6f224b6c877d7031ded2b59e91454460dbd9e1cb97f2260dfd510e0aef774efad7b67d961ea8561f4cc8c430b10b564f00713cb0394df0a6150f2c6faacfce3a329a57cedea4f6db9a702d7bff14767b168e0511cfe3db399815c820ab5382858f620799d80a8c23acc16f3e605bfea5e17f510d94b79a12883681b4b99c0c4d253b0f9e8561b7def1b69b140fa447dae129d32b270a2995140d6e3c584502c307a163a51eb3a2a0d564502b3f7878ad595f4e9aedbb71fed38f5240927bf4cb8814ff3e5dd0283bfd07b842230c4c4028e4191e4b0053e590c0ee1a0cb6ff8dfee4e3c4450bf967f4808d432d969bdf729f7ac7e440006cd1b42c9946b2f27def074fc322809b68c051fe34f70f576373bf6aa7de6d8f0215bb6fa4c94cf84b8c92236367f314add023a0fd0bb21757c6772509aae14ff1f762d14a53b49f1351554775123669b4f06ae5805f6501028ac087dadd322544fa3bb11f5b305514b2b192331880e5d8a38a478f6fb77ae11de335360d3c3e6d47045bdd642d7de51634d8a2ce155f60fbe62385a220f5087c587b17b0bf55ff735cc6b02c638fe9942b9304363c2c96cbc9e50ab927e14f41fd1e9b2167cdde5ccee936d12333965156f2cf959ad0c1c18c3b3e22b568d658ea7966542c83a30fd731c6c302cf46a170c29c6ad621c169ceee722035405f8d34bd337127bf6acbdd555093fa12357dfcebc3c8db87726c8f98774be9eccfc42edbca6588e64a56f6fba320bb1abf475514e0bda6893b1c6b5c8608a34c4b71b30069b93ddfc1290c3beb858fea2bf0120884c07eee02efab60f07eefed0b6eb79978d5651edab389326cfe1bbca3c764b0b62f5c9e5351247fa7347ca7787ba4afca4d8f99ddc9919a46e6b7569aeb5</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Person </category>
          
      </categories>
      
      
        <tags>
            
            <tag> encrypt </tag>
            
            <tag> hide </tag>
            
            <tag> years </tag>
            
            <tag> 2020 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>去紫边算法</title>
      <link href="/2020/08-12/%E5%8E%BB%E7%B4%AB%E8%BE%B9%E7%AE%97%E6%B3%95.html"/>
      <url>/2020/08-12/%E5%8E%BB%E7%B4%AB%E8%BE%B9%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h2 id="紫边成因"><a href="#紫边成因" class="headerlink" title="紫边成因"></a>紫边成因</h2><h3 id="相机原因"><a href="#相机原因" class="headerlink" title="相机原因"></a>相机原因</h3><p>color fringing 彩色边缘<br>Chromatic Aberration 色差</p><p>相机的镜头和相机的传感器导致了紫边的出现，使得光产生衍射，出现绿、紫等色差，尤其在大光圈的情况下很容易出现。</p><p><img src="https://i.loli.net/2021/01/01/lobHPShc5X6BDk8.png" alt="光学色差"></p><p><a href="https://zhuanlan.zhihu.com/p/55029984" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/55029984</a></p><p><img src="https://i.loli.net/2021/01/01/2kIsGpAxEVSDyPz.png" alt="纵向色差"></p><p><img src="https://i.loli.net/2021/01/01/dLeClziF8qGTrRP.png" alt="横向色差"></p><a id="more"></a><h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><p>高反差， 大背光图像时候容易出现，</p><p>焦前紫边，焦后绿边</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="LightRoom-去除"><a href="#LightRoom-去除" class="headerlink" title="LightRoom 去除"></a>LightRoom 去除</h3><p>修改照片 -&gt; 镜头校正 -&gt; 手动 -&gt; 去边</p><p>效果图展示</p><p><img src="https://i.loli.net/2021/01/01/eVPyEWhGlI7xYHp.png" alt="左为紫边图像， 右为处理后图像"></p><h2 id="算法处理原理"><a href="#算法处理原理" class="headerlink" title="算法处理原理"></a>算法处理原理</h2><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p><a href="https://github.com/mjambon/purple-fringe" target="_blank" rel="noopener">https://github.com/mjambon/purple-fringe</a><br>从原始图像中的蓝色分量产生模糊的蒙版。<br>使用以下约束，根据模糊蒙版中发现的强度从原始图像中减去一些蓝色和红色：<br>蓝色电平可能不会低于绿色电平。<br>红色电平可能不会低于绿色电平。<br>红色：蓝色比率可能不会降至某个常数以下。</p><p>仅在比原始紫色成分亮的地方减去紫色蒙版。<br>仅从有些紫色的区域中减去紫色，最多直到它们看起来为灰色为止。例如，从像（红色= 0.3，绿色= 0.1，蓝色= 0.3）这样的暗紫色像素中，我们可以考虑使用（0.25、0、0.25）的紫色条纹蒙版。如果直接减去此蒙版，我们将得到（0.05，0.1，0.05），现在像素会变绿！我们通过确保在最坏的情况下将像素变成灰色来避免这种情况。在这种情况下，我们得到的像素将是（0.1，0.1，0.1），这是深灰色而不是不希望的深绿色。</p><h3 id="算法效果"><a href="#算法效果" class="headerlink" title="算法效果"></a>算法效果</h3><p><a href="https://mjambon.github.io/mjambon2016/purple-fringe/examples.html" target="_blank" rel="noopener">https://mjambon.github.io/mjambon2016/purple-fringe/examples.html</a></p><p><img src="https://i.loli.net/2021/01/01/vNVRfoYm59sygQa.png" alt="算法效果展示"></p><p><img src="https://i.loli.net/2021/01/01/fiBjuKsRQXand7M.png" alt="enter description here"></p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> depurple </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新硬盘入手</title>
      <link href="/2020/07-19/%E6%96%B0%E7%A1%AC%E7%9B%98%E5%85%A5%E6%89%8B.html"/>
      <url>/2020/07-19/%E6%96%B0%E7%A1%AC%E7%9B%98%E5%85%A5%E6%89%8B.html</url>
      
        <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ol><li>在张大妈上看到的这款硬盘有优惠, <a href="https://www.smzdm.com/p/23057560/" target="_blank" rel="noopener">https://www.smzdm.com/p/23057560/</a></li><li>在小米有品上 <a href="https://www.xiaomiyoupin.com/detail?gid=121497&amp;source=smzdm_514_0_184__35d5f288db49ca2a_3.smzdm.514_0_184__35d5f288db49ca2a.1595749103578" target="_blank" rel="noopener">https://www.xiaomiyoupin.com/detail?gid=121497&amp;source=smzdm_514_0_184__35d5f288db49ca2a_3.smzdm.514_0_184__35d5f288db49ca2a.1595749103578</a> 购买的商品</li><li>顺丰到家, 拆机</li></ol><a id="more"></a><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1595912523918.png" alt="硬件拆机"></p><ol start="4"><li>根据 <a href="https://www.iplaysoft.com/disk-benchmark-tools.html" target="_blank" rel="noopener">https://www.iplaysoft.com/disk-benchmark-tools.html</a> 给出的软件进行硬件测试</li><li>这里有一个相关参数的内容信息, 够用就好 <a href="https://post.smzdm.com/p/626598/" target="_blank" rel="noopener">https://post.smzdm.com/p/626598/</a></li></ol><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1595912519001.png" alt="CDM测试"></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1595912519074.png" alt="CDI"></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1595912518999.png" alt="AS SSD"></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1595912519068.png" alt="ATTO"></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1595912519075.png" alt="Anvil"></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1595912519076.png" alt="19-____-2020_21-21"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>硬盘总体上比较垃圾, 但是够用就好.</p><!--more-->]]></content>
      
      
      <categories>
          
          <category> Person </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
            <tag> cnblogs </tag>
            
            <tag> csdn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神秘海域系列</title>
      <link href="/2020/06-26/%E7%A5%9E%E7%A7%98%E6%B5%B7%E5%9F%9F%E7%B3%BB%E5%88%97.html"/>
      <url>/2020/06-26/%E7%A5%9E%E7%A7%98%E6%B5%B7%E5%9F%9F%E7%B3%BB%E5%88%97.html</url>
      
        <content type="html"><![CDATA[<h2 id="游戏前准备"><a href="#游戏前准备" class="headerlink" title="游戏前准备"></a>游戏前准备</h2><ul><li>百度会员购买 <a href="https://detail.tmall.com/item.htm?id=586287059156&amp;ali_trackid=2:mm_121879788_43102803_282058237:1593166791_151_1837085262&amp;spm=a2e2e.10720394/brand2.90100100.002&amp;pvid=25089348&amp;ak=25089348" target="_blank" rel="noopener">https://detail.tmall.com/item.htm?id=586287059156&amp;ali_trackid=2:mm_121879788_43102803_282058237:1593166791_151_1837085262&amp;spm=a2e2e.10720394/brand2.90100100.002&amp;pvid=25089348&amp;ak=25089348</a></li></ul><p>【福禄网络】您购买的百度网盘超级会员月卡活动激活码为:pyxp6sf2g9d42v9d，激活地址:<a href="https://url.cn/5wxMFXi，请在2020.6.28晚24点前激活使用，激活前请核对登录账号是否正确！" target="_blank" rel="noopener">https://url.cn/5wxMFXi，请在2020.6.28晚24点前激活使用，激活前请核对登录账号是否正确！</a></p><p><img src="./images/1593167547240.png" alt="enter description here"></p><ul><li>游戏网盘链接： <a href="https://pan.baidu.com/share/link?shareid=1102752313&amp;uk=839856656#list/path=%2F" target="_blank" rel="noopener">https://pan.baidu.com/share/link?shareid=1102752313&amp;uk=839856656#list/path=%2F</a></li></ul><h2 id="游戏内容"><a href="#游戏内容" class="headerlink" title="游戏内容"></a>游戏内容</h2><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Person </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ToDoList-game</title>
      <link href="/2020/06-26/ToDoList.html"/>
      <url>/2020/06-26/ToDoList.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="e879f8ef116fbb6eb07b71f7cac5f7534931b6e7db2c06dc2fdacca25083d86e">51ed69c21307b22a06c456d9947ce8dd289cdf1a7cce29a89ed094891a74e326612ec3937b45c639e70c50fd667583b829aad5982800194f2a7c756b2982c764b43f99c8fe0d5bb668c88a2d5ecb47bdb1e4fccdf0efbf5b5f1431548698449a5e131fb785ec0ee71acc32d130b672762d638a4949ecd7dc1c4ffded49fb3d2d242f5c2fc2378812b5e6774574e00fa360ab7c6e17b79f6466ff57e73cde7c0e49ba203b0e82f8c2f3a6b5cf627730439e7513228cbf9ef2f48ba482121dac686259633074ed226ec85ba20cf386bffa0230450e948074a3644c8e86b3f805af48d39e876e136fe683a2e3e18273ed6173e86e08d4b70af13e123569acea34b0e25514da92621c29e2b0cea452bf10d9d5bfda7e513746211dcdea6a87a70a402c8eaa45b2d004b2669c080c337d5d5e85ef36d90257033f13a78e2cb99ad5a40aff6ea5234db7cc008920c3dab990558e9f04318788f8ec48a69e93c07bf6e900c8034e950df460dd660ea949ca6fb36a9e1513663b7adbfad2e87d063440f59d21dc89dba2e1a4217a16008b78251664c793b9a9e8a72e5efbfab2e89bda4ceb48ae73bac466c25a7beed5a29545ad754a395eced329ccd7a7d9ef77f0f82343a09e48f3a3d9a494513fbcddf149f114efea5f0fe532fdab44bf5ccd99345d0fed4ac24ace81263c778ee111dd61d3090283bef563dcff38a6877fafb6eee0ae88c6fa48ca7fd4aa9b83ca32116625120bd770723d46a272d76ce5516282e8992731122ba57eaba21713104cd4125eadea216daa21386cf2690fb9539e45c9a375da8710dcd086dd21d0a30800cc4d1106eb074737bdaad709db66458ab2da4cf913b22219ae3c083b8e1cb7195820c41820659cf71d0dd2c5502b2a0f60a1e54bd1dff301d80d6a43e71648c40ec8a7f79bd6d9ed06ab6d7db8a30cd486fa6a68db20238a364cc342d8ca3b4661ca96dbdb03429f9533ee54c9d430f19a6f1ac8bea1e2b0b994b9f04589a92f361875f09b153aa73f9ee4ceffaf922b42d17db2a1456ada84e76014f17a7d82d3605c1e773a2c37ded18369af430ef04afe703479084ff2d66d6f0ac7916f255d0271c14ea98505a1897d1dee9a73719a62e32ddd2bd0b376288ff939d13aaba96eb1924ad917fbb6b93c5039476caf3ae11be4d64b8dec211219ab6fff9fb8b910d626c627c11b187cf0549225ff612ef85172ec6a60ad32822d6a891c71bd3ec9d98c96c2e2756de3fa2bbaa9e9e15cf0d2b010022001243e1e9f90d13392d8ee9c48a23007d982fb455e92b21898506b907be40b192493b860435f57cb6ebeeab1a23bf8b2fa8710702930075686508da5c6947a77b3adc1c146a5909830574be8b6bc27db1ceb1208069ef0652677d6056eaeed23713097182b55c3892daee9dec01d4edfe1f3e360f7460ac44f3096e70b127d138866764cb9e0301a9b3d73249265e42c28fb8087ca0de84652152c1ab76c1d11e20077d7698e2d020bd28b26dda029835133003efc07164d90048b9f48aae39fbf22b7c62f9ec85d2947d694b2605c31e5d404fddb07204718c004a9afcf8977c1e8060f5caabb20f098a257e84f2914ee47435c4b603c5ba4bef945c11a18327ee4001725e3b6830830b03b77b2389fb5587456b2118de51294d10f0b98ea2bcd7ad7f41864d51cfb88c45754b14e704e82159b7288f71b815b3e564a0b8337a129b684b5e3ad883fe5d9ea12fa8a1e8da015d4ca15c368279def94e76398c656df7546d439d93de2b04af97e71ac6df4582c617fae5dd445efe2b2ba1015f12df7f2f08851b42449ff450bdd5d4c97123fa9c2d875445f1cd1d619c25660ae773945de82869469b1a18428cfb3c18815ef382fcffd6b833c31f5cc4952d7e9badd5a4be79b4aaf3e494ead9c48cc015b7c12c625ee105116887f92bd5e6d7b3931204a5e08443923dfe1d63e27be104106eb950d95ff912c005a7b31d185d0568d1148cbf83305feb518c4f26dc2f4b2618298e2e2acec6c014ec79e34847979dee8803ee1a35c4092209f32edb1c78ef132bb5fae513d590f3c05fbe86d8774516307f45a04ae5bd04726fd36321595b09367b9dd2ce83f11a5127766a3522ab833d67c90415b52ef36b1144a8ec07a1f011030caa6e0e511cc2fe997b6ea5a66351892cc1884eee35bfa41afcb8cf013764c0cad28dfd1325bd8dc5d5d342bb6bb07fe13553faa2b5c0d4df3c0ecf03d1af4386c74617037dbfc71dcdee33f09f67c89337affea00fc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> TODO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> person </tag>
            
            <tag> encrypt </tag>
            
            <tag> todo </tag>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>休假归来-重新启程</title>
      <link href="/2020/06-10/%E4%BC%91%E5%81%87%E5%BD%92%E6%9D%A5-%E9%87%8D%E6%96%B0%E5%90%AF%E7%A8%8B.html"/>
      <url>/2020/06-10/%E4%BC%91%E5%81%87%E5%BD%92%E6%9D%A5-%E9%87%8D%E6%96%B0%E5%90%AF%E7%A8%8B.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="85efb3d43322466309d289339ebdef9982cdd8378d6d9b2f936c46f71a5c2ed0">c69d458b5be806e1275b581ae7b46a5b4b1cdbf18bb8d8faf805c851b25c609010ca069a2b1764a60d39c53be031376fa62e88129a5f5b8f63131c39a64ae076912e51b3e7ddb0d28217b41a9e65c2f4fc8a49a1eca2cdb264532b6fb43ff7a91a93c6ca3e62366cdbbbfd3346675baf3370a27a59b2010c6837dfd8115190aa18d3d9b4096df3853f85f4c8313f270e64f343bbe5f3420b35e5ddd2da49701f6cedaa4033284a4b1f3eb71703fe8b84ab534908f6070974bf9caab917798d377e77296f0de862f619851adce440e6c90e7321f612b64cf1df8250b4c23d46a90971737267ecbcf4f91a2f81a73dba026b134db785691bc07768c030f40f8b18fc29a83f89574a507b0fb4f56fc92b4cdcce6ff4d301791da1a4637c4603b68c0f290b344eea669b52e11a23bef44364f8ce5a3cc14d1434ce02eaa0c0628b6a074caae178ebbc7c8762b9a8a181a3102ade4c714395ec5a158b0c5bbe641d26b4091e8abb751d56d64439fda6de423ba6c296c6c89a2fc20c06bc91207a772c052b42f2600482d52e2bfce88bf04f6a00daa91a5b3063577ab247a792b95d6dd4c02e7bf1e9f1a3f0c12c7d01c6eb554c57395566cc76d1deb91aa1b6bb29bc8d33a9cf71d1d4271b5cd804fc5afb8b71069264f0eca06f01652ce6cd6efa369a4ce2723f3c5e6cdce26c13b28048da1c90a5ff2b92905f51d8b823d91d3c73c028a62a3062f1692d484384d15e26df729657daf998fa511473625b98f3c96f4c544394ec56f3d6a89573430b24ac083bb6a1f6a0a9595bf5872af58fff9ffde8fc288ecdb0527d0b2020ba9ce97ec08312802576b97082764ee99ec7e33814ec60041a5f3b16f41075afda70a61af0e15d33400cb60cfab35400ae2b86785789ee02b8733d74c7a82e376536578edbbf12a4a5994893acb3433ae77c84d132385d59bb917269f4dff891450aa385ebfb3484bba2623b205721af6ad5f5e7c7c540ffa794aa53ce1bd2c0f99e491345ef949f0a230d8ed13f326125895890ed3d35ce7fd5db0e2b7c983c142364e8f785e2b37124f9a326ae8e579ee4ae1cd2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Person </category>
          
      </categories>
      
      
        <tags>
            
            <tag> encrypt </tag>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv-13-直方图计算</title>
      <link href="/2020/05-21/opencv-13-%E7%9B%B4%E6%96%B9%E5%9B%BE%E8%AE%A1%E7%AE%97.html"/>
      <url>/2020/05-21/opencv-13-%E7%9B%B4%E6%96%B9%E5%9B%BE%E8%AE%A1%E7%AE%97.html</url>
      
        <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>在进行更多的算法操作之前， 有一个很有意思的数据或者工具需要我们提前学习，那就是 直方图</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[toc]</p><h2 id="本文目标"><a href="#本文目标" class="headerlink" title="本文目标"></a>本文目标</h2><ol><li>介绍直方图及其原理</li><li>算法实现直方图统计</li><li>将统计结果进行展示应用</li><li>实现基于直方图的图像均衡化</li></ol><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="直方图原理与实现"><a href="#直方图原理与实现" class="headerlink" title="直方图原理与实现"></a>直方图原理与实现</h3><p>这是一个统计数据， 由基础可知，灰度一共分为256个层级， 给出一副灰度图，我们能够统计不同灰度等级的像素一共有多少个， 或者进一步的我们能够得到</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
            <tag> c++ </tag>
            
            <tag> histograms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武汉大学硕士毕业论文格式</title>
      <link href="/2020/05-15/whumaster.html"/>
      <url>/2020/05-15/whumaster.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="391750bbd226d1baa414b2f570ea292b27d27410fbaedbfc8f9832c5b5848c4c">8461f7898b2290b1304edc4c8480707fcb837656eb2c250add0df8697fd7c97bf26cbcb2846c0cc75ec9ba94e12288d3ddeefca371fa5415ce0c6ef5c86436753934e9cf5494b17306f7e0616f943b36449b1ea38738f7c394b7b919c5d4c2c7ecb9a29df4b1381348e382b9c1a8bbdfbe39178a3360fac62d4d662c4ea2e763446d31bce28ba29afff7f6385b031f9e59006509576a03df24bb284bb42db4ab22c58935c9392adb1442270ffea6974675a26e65e93efa6698da37c45ec97987074cc30ebb2a5b9ffb47fd914ffa7968c6b6bd5fe727df448c083ad51456887730fb8307609b4d4e9dde3addf62010c08f5672ecf9af5d57483edc7c0a284c27555ff151e53e9795bbe476b1ec3543ae397bbb027657183e95e3f484c7b0ebd56f65a05e1191715c32dfa717fb47bb670d878b179b4b1cb48319ab50494eca10eb2195f213bd43aed51f0ba35573635bbc6bf860c2e71d0b3b9fc9ccc77d754dfee740c2a02b492df152a357fd045b789f843e53cb838c0dd0ad1ed5513ba6b7b03a595d4cf83c4578fe61f4152e14178242c73d9de1678c102b7cf92ef3c28b423d28773f487aea30cb933d4040a7a52b063ad1bebd5e636d7ce058ce49b16ead107b3ba92ff74063569f4ae12c0fd7a60e0c5d197e980d230f197a22fbd261039879bd86ef39849c8d2ded8729e492d8236f27f57696be9ce9c99360e547a4ba71b5d4395c35b5e77dd9a27be1562308715bf5e3c235a6d446836b9db09a499bbb35905685f6e9af47518c6930b74a0e48646f44c54754a81e5edaa4c2bad976e9eaa04d2ee8ee095af2a6ff8645e0ca02c3f374af4eec2db2dfde4474b99522dba514ffa1533d85a5b6278fc09809720742bb72cea090ca551d8f875fe42bb46cede7d108e3bb389c45bc8fb7c5e417314851f20a250a09a180ddbf717548e8b4dc5b6fe282a5e04bb23e9b898ebff7c97e55b2adc8ed77d51bd13a68a6d46f257fc8f2b4081d104401908df46b6310a75fe9a0eda9bf516059fdf1487382ddd763585674150b4292dc5cfcbc9d7ee4815df7cd232e14403b61696d37b3fa0cf66ce8b600352ac57748a9188a1972d1194f81adaef57f5cbc61bac5558170e6366ec3c41d140ef7e92dc3f7c2bdff00bebdb37a9c4a000e62c9ee48aedcc5ee923c2eb6663370f2d16f6f420d97109bff89ddb80be22ecf03b1001cd51c393df456441fd2f7285f5072d2f31d809b853fd03c150cd018a523398a77ac8c3f6c0bd2e8442a023f2fb53af3f024449f8253c02d1afae446a6c8413155fffbca7cb04a26029adf804ee6763f5d29b97067921d181ca99e09b83c5b75bc960a43342c87d0544d453beab34442082b35e867d5bf0ff4242775abf771995e84685da230ba04c4be57a0b3671e55cc811c8336f44e7ea0a5738e6a6cfef22cbd5d7b13d2fcfc7d02803d07684d012f93d3979b9c00f75dba80b87d653baa5bb2a1741f674961912b307e537d424da0820eb090eadca4a319fdd782a5d2fd5603f871f4342741d80ea1b95acbd3be31f18be45f04e9bfb310a99acae3b2b72bdc5ecade627b95c05c38d19ddfce119470ef3410a5a781f417eaf6c557f9f635e134e6a61622b0d7572b640d706cb06338203294d0f71be81c55c57931ab3daa5b5def1f265f93bc7d57862a6b926e3437123172b3d1d3b47c2f659255f61bde4778420359dbdba566d034b3c0b741f444d68170c9f1eff3f4d593aa718bbb5c693b28f434ce7852c683aaa2920ae1a0a6a082921bb41cd74aafc37a0c56d146b5900961b0a7abcf955d303711711787e771fa4b150ced70ceb1885c8f4b01bc3ec0f8d33185ab2d4b21b4baba0a569fb0894bc1fd0c5065476137a296c321bfd175ce21b85043768a72ef03879f1fec72c63ea1efafb95c5f46d8fe898cdd0831fe0b641c44a2bc01fc734950fa2070f8a13892d093ab82491a74d3040fa52eb88996cbde9546cdcf356bc9c8a8ee2a931cbf3e5ef025f7a92ce312feb21178f78350e6703ae7a74b643110e0ddf2ed0d52f2dcf11c8744b2ee90ef50cd55259fe5dce7a61145d860679601e0355cd5cbd88aa469d4900e194624351ce9315334fe83f7591fef3de05911a9c736c1853fab8e55e8c120ba52934363cecc0f18901f3fd2a8933451ccc6a4faa5796a886184de79322c9027d5a667513615365b24611ffc14e0b519588632ea18b3cf151c7e9c9402c5592766ac7c3fad4409b2bcdf45c479ef87d96de6e56a5a745b2109f19b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Person </category>
          
      </categories>
      
      
        <tags>
            
            <tag> encrypt </tag>
            
            <tag> hide </tag>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
            <tag> whu </tag>
            
            <tag> master </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次电信诈骗经历</title>
      <link href="/2020/05-13/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%B5%E4%BF%A1%E8%AF%88%E9%AA%97%E7%BB%8F%E5%8E%86.html"/>
      <url>/2020/05-13/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%B5%E4%BF%A1%E8%AF%88%E9%AA%97%E7%BB%8F%E5%8E%86.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="c68688e80ae420871de24f72850865e821e0e7d8f5e2f79eea63b7542760086b">34191281404cd31e685e77dcf28deaf6e17d5ae3f95704bff710d1e5df9da1d395107afc438c926f2f85b1a0ac4ec759a37554abb52944f7ed0a69ee9ec7d8997e6e45956c838189d1138af108970521678a567019c48b3f1c5e0da4814c156da285d87fc2ab8c7bf103204a435f298f5ffa06805c9d15b045eddbb74e921bc6f26e4b68702e870ecbc969070e752e71fe489ef0dfb2829650f4d58e72beee5adee2e9b6922ee80beed62c1aebc725310a840c618d05db64a7c890246fdcdc7f1875fa7570dcc5fdea550ae62d292b2107e27a59b194e2b409c032d0251011c745dc22150e5e48b9dda30daf60600231ae5dbb797dce27c9d1e344dbaeba550e9d5491d9a2c856bd4a3070844ecfa15be359f76fe78ac8bd6a7bbd11e4263c278845e28f26203573055c38add1186c27f5104d00784853430ac4c3839e2a339732f67768cb1d35d380b678a1dc3120fc220b4fa1cd1ce17487f38a77910207095f1ec57237f1cdb516ca03cc2001bc0765a2afa9d9ce3fa5eca88ea77bc5d855de7d8fe51ac32069777d27eaca92ede62fa2495813ebede3cdbb32f078c50a6340657f0dbea0424369369403b2921230c97b01837ea6b5a16ff1e3b9abe16114165162134a1861c7ad6c516288f98196621745c7fd26599a98f27648d4eaa32c72adf0a6d3cc83a6818c234226f980ea227795dc0b7c3243d6dbf1866e88701ccde06487bba91fe4745bff0620b9e564e87fa7ec96c4694d6cb70c70c0e3e5cfd5135433e880b1c809a38e1d8cf0edc3163155c6d507dd9f656b60cf662c192f85924aaea3d3f6ab584408855ecf3f1e94bae427d4e535608a76cdd7e02ee00fa85e063d90b448b7c924cff7611128acbec59442144732d9ba6d279d10c1a24f3f79216a3b5c93a57886f8497c44359b2ff7d971bb3d9d33c49b6d1e1128662d83cecc6eebfa73108cab651c3d07a4d00c85a85f9a4cd0e390a4edf1c41fb3c11c6d1c0805a4a41d4b06cb0cebd6ecb912583db04cc5f30e7cc929073a5bd2d3da77c449c45a799d91198c71ac86d3c60a929ce8ea2d23f1706bddcee5be1453ee53bee9325d179ff92d69ad426d37f5b076d5f54e1e5b51ec77acccba539c26f4d9158cfb3529f55e37b2cc62a3c3f7da73771121025944c9caee40b4a52a131aa17d694ed747ad7c5194e382c2d2e1495c9315611a9a737a49a69391962ca46583d80850cc3d076e020f84757138a404a3c7962a85180ef265a25029b5747483e3226311a6c3b5d1ea626eae79d42175413b06354d06fdc1d9e029281e0a7c6e039bd34e79ee64a0f4a2f68b52fd16a588a20705a3f75020ad83f9173dbc565393e18a98d47bfa3901771c5e06f89f19853986fabdb1206c443b4c96ddc27a8a395a1ddfdf537a9399f09b4aa8ce8ed809f568ce46fbbfdcbb9d0aac722d2ecf5c6ec77b4fad9e83ab02fd58d29030d4a8c00d99e2b95da79f2dfd991bec502a870e15c094ca25b09691342e1206bf685a645cfc255aa563196012b66fee7d10d5360b683ad631aa1d8c19ee0820785e5eced75c3b79535720fac6bea49c56515089e86ab2e161af980794e126ac4b38bba17e47af0abd71809a9b34d0b8766c64ca2f22663c7578d63174f4e7ba19b0b87d69c3b67c0029ab261fb25b750b98f391eb14a4b27385d4dce065fdf5e8c06f05ba4d0c718148cafa9120bb64c10f45064d494ba86c8adf1860503b46761b0f902a68e2b90194dec480795f6f5eb26074ec3f12b116ba66f122195f52a173eebcfb375f33578e20c2cbb26c2fde65cf82886399e97a85413a389e7e1af266b34e1f41449f401f69612b75cc263f94630f7b55165b173df3f9dfeb4a3e88c5c7776c4c105165cac9f705aa94ef1445d581feaa6a231433b73f0e24c71806eddaf6bbd0f71d398e33af440f60eb44cb6cc3cd14cf416d0330facd4c5bac149286ea62d586b2bf6518b748fa9a7953f41b5f2ae4b83f6a0478a6f99cc9343a9d720cefd7fb0fc113db978ce077c66ab9763814b04cd24c70a8555d0b88737df6388ef4f8561ecc280d0dfa49c016b96b2a2f5d58926df7a8766d12ccc00cbdb35be92c68778471b526536400dfef72f328025175e936399e5c6779b4eea3c94d3e98db49433a679bea94f692870291ff42aed4968aaba407d0d4ed453bc2a87107d63d8e3728bbc2ad875a859d3e69c35ac66b6ba9011ab375176e7ce35275d2537f371bf6da38d2e526415195ae6413f6b9651b5342472bcd906b1e370a884e338fbd177ee529fc99cdc535a82d34a23c8bf0d7cc17a0275247b857ac40ccf82eb486a0d77343629452659bbe6d2396dafe1fa5c8fcee7e038355cc86fdaa81ae4cf842a5bb769158a21092a2fb5acbd337fd7fc20362260fd4831365935f18496aed30d7461b58b951f20e14d4ba854caf6e9eff8f67fbe478939c75348546564f6eeacdbf99716855a9e8af146d56b189729da2e5f58ebb1da0dc536c99c464604e127621e56754027ef2393daed594236b4ba7cafc1d242848cc478f464c1318cffd02644a01d61477392f8e85bd2fa236d053a27cbdb9fbb05f5f4e57624ab36cf95d5dd069bb6864fc54db6875af9c4cfc8cdca7e9b2acc70237088be3bb06326f186eed69fbea494cb55bef23ae6ea2b7ea3d94cc6c4fc505ee39405173c03400ad96938316790a33e7f065bc2f1285e5ec5533c1ecdf2cd73f89bc55b1fe32c6b84728fd9d0a9ef75251d4d89a1497b4c0967f1b7f445450d9c4bcfa6f874756f496f91a59143a2d3f345bf605a2023bdd9c1060aadd2a227c2da07d8d3551882f2fbf11921bccc44a5b7450e0e559a520a498704328054fafc373e7f16cbd751d08d69517d69b8026bb20faafbc7ea8410116e4de9fc8eb6d496359ad71cbee879457d343a7833d99239c743704afd78e9565233e42bca5a858c78e36b1ac7a1f33c043a74825ee6fbf5dc6a45fce7bce37521177077671e1749bb3fb941967ca003e70c281c05417a5973ad91c3fab883a0e2f6b2eed7d9acceeef84eebe267a6bfe672d619a1dd77596569f7c3b93a3566b7d2c89b1475073535847076d949701929924749a37e9530d1d39e9838371634e337a69a59c22fbcffbdd524ed00f3f5c66f8fb7476724406f33b70c8275ce99d39c527831bdd941526c96de5945dafc0eb53e70faee6aebceace60d4f63c070e0926e5f0eaf9980822188efdd273fd22be806fce347c837886c82cba7f9cbc77f14c81223e51e018ecf48762ad407b6b975dfa87c1450accb77f52c6c8a730306db614aea11784355af3fa39a4c304b0b9a72c59456f87ab00ba5494d7714ec7c02320f2e560e6d20a3ecdb7ab59646c3fb3ac421fa68906bdae8eea73de489011d447f17408e9f6d2e11a0df22b70a43be1aab19ffac6e9f5a11cc53cb8282b48f0fa09b6b6dfb23f57e650392ef48c584fb543f8594d4d07fbe66271bdcb7acc5e4103bf530206c412abecc20b476c57fd3e561c0517932f6b12eed395cbf480f01f2d84ed66612c5c6cd9aa7dd40e1d22152d05449d40d8198a3a245d19325f759e6e6aefb584aa7ff882c9c08aa3ff00d48894d15652e4a32f26f66bb86c964e35cb5bdd31aaaec2cabfaef0df2ea49ab4becd41753a17b22eab4aada0fd852753b9e3b153759457f6a3152ba08c9c017fcf23a509ccb6bb2bfb71a62b982d14e97052df249fe632d451b71796506a4467b0cfe5a0dc61a169b98a7b0a155ce8be8985905d311cd4b75b65557ddf5e7edcc5b150c4569e29c642660ba2a53c0dcc0c65ded5fbe8070801ebdcc6c33f293ec5d77f5ca6c0064c12510f0f5504393712932ed5ff34d66a4c191fa2f49a11e787ef6ca6dfb324ad9edaa0ae86a894e8ff3f125171ed8a75ade11164be56c55a8d70e99f645269511049a317ee81d64d0e13e3ec710495e3ba3eaa2f13cabf98842c072f339deecef8ece1713768fa7628d8f916e50617f5282dd280ef8b5b65a566edcb3d9e8683b063d6aec9f981f5bef1db4e1cf73d0e12f955be2c019e9dfa0fecd604882673b7cd522f54259358d4fe977beffef4a5c00e2dc9fe5c743c5a9b8113dc8e0985aca6952eb619c9187cf6ece06253c41aa8b693321f3759b170b7e8065b4347d99c8de367f5ccccc08b054ab353459ed54194aa076615ebd5b928ca4859b78832d1746d8c26216e815275dd89607c448d93a6fbac4bfa412a3f8b5210b7b2c947876e14c8005fe4bf187c1df70a54dd801f1037d79b34d62116b3e5123f00e317c969315ee261cd012e171e5168a27dc6ab917b4976787d3c55d23dcb16eee030fd0713f3d9f322bd43993fd693d80e619e18852c6bff80efd782db6b69</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Person </category>
          
      </categories>
      
      
        <tags>
            
            <tag> person </tag>
            
            <tag> encrypt </tag>
            
            <tag> hide </tag>
            
            <tag> fraud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv-12-高斯滤波-双边滤波(附C++代码实现)</title>
      <link href="/2020/05-10/opencv-12-filter.html"/>
      <url>/2020/05-10/opencv-12-filter.html</url>
      
        <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>这几天由于自己的原因没有写, 一个是因为自己懒了, 一个是感觉这里遇到点问题不想往下写了, 我们先努力结束这个章节吧, 之前介绍了比较常用而且比较好理解的均值和中值滤波,  但是呢,在例程<a href="https://docs.opencv.org/4.3.0/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html" target="_blank" rel="noopener">Smoothing Images</a>, 还有给出的其他的滤波方式, 主要是高斯滤波和双边滤波,</p><p>我们这一次完结掉滤波与平滑的这个部分, 写的有点多了,反而不想再写了, 加油</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[toc]</p><h2 id="本文目标"><a href="#本文目标" class="headerlink" title="本文目标"></a>本文目标</h2><p>本文主要是介绍</p><ul><li>高斯滤波</li><li>双边滤波</li></ul><p>和之前介绍的一样, 我们仍然还是 介绍一下原理, 给出一下具体的形式, 然后使用 opencv 进行一下实现的过程, 最后使用我们之前的图像进行测试 进行算法的分析与总结.</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="高斯滤波-Gaussian-Filter"><a href="#高斯滤波-Gaussian-Filter" class="headerlink" title="高斯滤波(Gaussian Filter)"></a>高斯滤波(Gaussian Filter)</h3><p>我们在之前介绍了中值滤波是统计排序的结果, 属于非线性的结果, 均值滤波是使用模板核进行的操作, 我们在的文章中也提到了均值滤波在计算的过程中必须要考虑权重的问题, 进而提出了加权的均值滤波的操作, 比如最常见的加权均值滤波的操作核.<br>$$<br>M = \frac{1}{16} \left [<br>        \begin{array}{c}<br>            1 &amp; 2 &amp; 1 \ 2&amp; 4 &amp; 2 \ 1 &amp; 2 &amp; 1<br>        \end{array}<br>\right ]<br>$$</p><p>其实呢,这个核也就是高斯滤波器在 <code>3*3</code>窗口的离散取整的结果值, 最明显的特点就是模板的系数随着距离模板中心的距离而变换, 能够有效的抑制噪声,平滑图像, 相比均值滤波能够更好的平滑图像, 保留图像边缘. </p><h4 id="高斯滤波原理"><a href="#高斯滤波原理" class="headerlink" title="高斯滤波原理"></a>高斯滤波原理</h4><p>由于我们的图像是二维的, 但是高斯分布是一维的, 那我们先考虑一维的高斯分布, 就是我们常用的正太分布曲线,<br>$$<br>G(x) = \frac{1}{\sqrt{2\pi \sigma}} e^{-\frac{x^2}{2\sigma^2}}<br>$$</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1589099908842.png" alt="一维高斯分布"></p><p>对于二维的高斯分布其实可以考虑成两个方向的运算相叠加的得到的结果<br>$$<br>G(x,y) = \frac{1}{2\pi \sigma^2} e^{-\frac{x^2+y^2}{2\sigma^2}} = G(x)*G(y)<br>$$</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1589099908844.png" alt="二维高斯分布"></p><p>考虑到图像的计算实际上是离散的座标, 对于窗口大小为 $(2k + 1) \times (2k + 1)$ 模板, 我们可以表示成<br>$$<br>G{i,j} = \frac{1}{2\pi \sigma ^ 2}e ^{-\frac{(i - k - 1)^2 + (j - k - 1)^2}{2 \sigma ^ 2}}<br>$$</p><p>可以参考<a href="https://www.cnblogs.com/wangguchangqing/p/6407717.html" target="_blank" rel="noopener">图像处理基础(4)：高斯滤波器详解</a><br>里面给出的方法, 使用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateGaussianTemplate</span><span class="params">(<span class="keyword">double</span> window[][<span class="number">11</span>], <span class="keyword">int</span> ksize, <span class="keyword">double</span> sigma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="keyword">int</span> center = ksize / <span class="number">2</span>; <span class="comment">// 模板的中心位置，也就是坐标的原点</span></span><br><span class="line">    <span class="keyword">double</span> x2, y2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ksize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x2 = <span class="built_in">pow</span>(i - center, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ksize; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            y2 = <span class="built_in">pow</span>(j - center, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">double</span> g = <span class="built_in">exp</span>(-(x2 + y2) / (<span class="number">2</span> * sigma * sigma));</span><br><span class="line">            g /= <span class="number">2</span> * pi * sigma*sigma;<span class="comment">// </span></span><br><span class="line">            window[i][j] = g;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> k = <span class="number">1</span> / window[<span class="number">0</span>][<span class="number">0</span>]; <span class="comment">// 将左上角的系数归一化为1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ksize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ksize; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            window[i][j] *= k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">生成了$<span class="number">3</span> \times <span class="number">3</span>, \sigma = <span class="number">0.8</span>$ 的高斯模板, 对应的将其取整就得到了</span><br><span class="line">$$</span><br><span class="line">M = \frac&#123;<span class="number">1</span>&#125;&#123;<span class="number">16</span>&#125; \left [ </span><br><span class="line">        \begin&#123;<span class="built_in">array</span>&#125;&#123;c&#125;</span><br><span class="line">            <span class="number">1</span> &amp; <span class="number">2</span> &amp; <span class="number">1</span> \\ <span class="number">2</span>&amp; <span class="number">4</span> &amp; <span class="number">2</span> \\ <span class="number">1</span> &amp; <span class="number">2</span> &amp; <span class="number">1</span></span><br><span class="line">        \end&#123;<span class="built_in">array</span>&#125;</span><br><span class="line">\right ]</span><br><span class="line">$$</span><br><span class="line">上面给出的文章同样的详细介绍了 $\sigma$ 在统计学中的意义, 可以去参考学习</span><br><span class="line">不过根据高中的知识, 我们可以看到 正态分布的曲线</span><br><span class="line"></span><br><span class="line">![正态分布曲线](https:<span class="comment">//gitee.com/schen00/BlogImage/raw/master/image/1589099908845.png)</span></span><br><span class="line"></span><br><span class="line">#### C++ 实现</span><br><span class="line">在我们之前提到的[图像处理基础(<span class="number">4</span>)：高斯滤波器详解](https:<span class="comment">//www.cnblogs.com/wangguchangqing/p/6407717.html) 这里给出了基于 opencv 的代码实现, 这里是$O(m*n*k^2)$ 的算法实现</span></span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">// 来源链接: https://www.cnblogs.com/wangguchangqing/p/6407717.html</span></span><br><span class="line"><span class="keyword">void</span> GaussianFilter(<span class="keyword">const</span> Mat &amp;src, Mat &amp;dst, <span class="keyword">int</span> ksize, <span class="keyword">double</span> sigma)</span><br><span class="line">&#123;</span><br><span class="line">    CV_Assert(src.channels() || src.channels() == <span class="number">3</span>); <span class="comment">// 只处理单通道或者三通道图像</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">double</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="comment">// 根据窗口大小和sigma生成高斯滤波器模板</span></span><br><span class="line">    <span class="comment">// 申请一个二维数组，存放生成的高斯模板矩阵</span></span><br><span class="line">    <span class="keyword">double</span> **templateMatrix = <span class="keyword">new</span> <span class="keyword">double</span>*[ksize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ksize; i++)</span><br><span class="line">        templateMatrix[i] = <span class="keyword">new</span> <span class="keyword">double</span>[ksize];</span><br><span class="line">    <span class="keyword">int</span> origin = ksize / <span class="number">2</span>; <span class="comment">// 以模板的中心为原点</span></span><br><span class="line">    <span class="keyword">double</span> x2, y2;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ksize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x2 = <span class="built_in">pow</span>(i - origin, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ksize; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            y2 = <span class="built_in">pow</span>(j - origin, <span class="number">2</span>);</span><br><span class="line">            <span class="comment">// 高斯函数前的常数可以不用计算，会在归一化的过程中给消去</span></span><br><span class="line">            <span class="keyword">double</span> g = <span class="built_in">exp</span>(-(x2 + y2) / (<span class="number">2</span> * sigma * sigma));</span><br><span class="line">            sum += g;</span><br><span class="line">            templateMatrix[i][j] = g;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ksize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ksize; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            templateMatrix[i][j] /= sum;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; templateMatrix[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将模板应用到图像中</span></span><br><span class="line">    <span class="keyword">int</span> border = ksize / <span class="number">2</span>;</span><br><span class="line">    copyMakeBorder(src, dst, border, border, border, border, BorderTypes::BORDER_REFLECT);</span><br><span class="line">    <span class="keyword">int</span> channels = dst.channels();</span><br><span class="line">    <span class="keyword">int</span> rows = dst.rows - border;</span><br><span class="line">    <span class="keyword">int</span> cols = dst.cols - border;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = border; i &lt; rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = border; j &lt; cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> sum[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a = -border; a &lt;= border; a++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> b = -border; b &lt;= border; b++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (channels == <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        sum[<span class="number">0</span>] += templateMatrix[border + a][border + b] * dst.at&lt;uchar&gt;(i + a, j + b);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (channels == <span class="number">3</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Vec3b rgb = dst.at&lt;Vec3b&gt;(i + a, j + b);</span><br><span class="line">                        <span class="keyword">auto</span> k = templateMatrix[border + a][border + b];</span><br><span class="line">                        sum[<span class="number">0</span>] += k * rgb[<span class="number">0</span>];</span><br><span class="line">                        sum[<span class="number">1</span>] += k * rgb[<span class="number">1</span>];</span><br><span class="line">                        sum[<span class="number">2</span>] += k * rgb[<span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channels; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum[k] &lt; <span class="number">0</span>)</span><br><span class="line">                    sum[k] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum[k] &gt; <span class="number">255</span>)</span><br><span class="line">                    sum[k] = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (channels == <span class="number">1</span>)</span><br><span class="line">                dst.at&lt;uchar&gt;(i, j) = <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (channels == <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Vec3b rgb = &#123; <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">0</span>]), <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">1</span>]), <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">2</span>]) &#125;;</span><br><span class="line">                dst.at&lt;Vec3b&gt;(i, j) = rgb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放模板数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ksize; i++)</span><br><span class="line">        <span class="keyword">delete</span>[] templateMatrix[i];</span><br><span class="line">    <span class="keyword">delete</span>[] templateMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后同样的给出了分离的实现, 将图像进行水平运算之后再进行竖直运算, 计算的时间上会有一定的速度提升<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来源链接: https://www.cnblogs.com/wangguchangqing/p/6407717.html</span></span><br><span class="line"><span class="comment">// 分离的计算</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">separateGaussianFilter</span><span class="params">(<span class="keyword">const</span> Mat &amp;src, Mat &amp;dst, <span class="keyword">int</span> ksize, <span class="keyword">double</span> sigma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CV_Assert(src.channels()==<span class="number">1</span> || src.channels() == <span class="number">3</span>); <span class="comment">// 只处理单通道或者三通道图像</span></span><br><span class="line">    <span class="comment">// 生成一维的高斯滤波模板</span></span><br><span class="line">    <span class="keyword">double</span> *matrix = <span class="keyword">new</span> <span class="keyword">double</span>[ksize];</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> origin = ksize / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ksize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 高斯函数前的常数可以不用计算，会在归一化的过程中给消去</span></span><br><span class="line">        <span class="keyword">double</span> g = <span class="built_in">exp</span>(-(i - origin) * (i - origin) / (<span class="number">2</span> * sigma * sigma));</span><br><span class="line">        sum += g;</span><br><span class="line">        matrix[i] = g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 归一化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ksize; i++)</span><br><span class="line">        matrix[i] /= sum;</span><br><span class="line">    <span class="comment">// 将模板应用到图像中</span></span><br><span class="line">    <span class="keyword">int</span> border = ksize / <span class="number">2</span>;</span><br><span class="line">    copyMakeBorder(src, dst, border, border, border, border, BorderTypes::BORDER_REFLECT);</span><br><span class="line">    <span class="keyword">int</span> channels = dst.channels();</span><br><span class="line">    <span class="keyword">int</span> rows = dst.rows - border;</span><br><span class="line">    <span class="keyword">int</span> cols = dst.cols - border;</span><br><span class="line">    <span class="comment">// 水平方向</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = border; i &lt; rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = border; j &lt; cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> sum[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = -border; k &lt;= border; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (channels == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum[<span class="number">0</span>] += matrix[border + k] * dst.at&lt;uchar&gt;(i, j + k); <span class="comment">// 行不变，列变化；先做水平方向的卷积</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (channels == <span class="number">3</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Vec3b rgb = dst.at&lt;Vec3b&gt;(i, j + k);</span><br><span class="line">                    sum[<span class="number">0</span>] += matrix[border + k] * rgb[<span class="number">0</span>];</span><br><span class="line">                    sum[<span class="number">1</span>] += matrix[border + k] * rgb[<span class="number">1</span>];</span><br><span class="line">                    sum[<span class="number">2</span>] += matrix[border + k] * rgb[<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channels; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum[k] &lt; <span class="number">0</span>)</span><br><span class="line">                    sum[k] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum[k] &gt; <span class="number">255</span>)</span><br><span class="line">                    sum[k] = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (channels == <span class="number">1</span>)</span><br><span class="line">                dst.at&lt;uchar&gt;(i, j) = <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (channels == <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Vec3b rgb = &#123; <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">0</span>]), <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">1</span>]), <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">2</span>]) &#125;;</span><br><span class="line">                dst.at&lt;Vec3b&gt;(i, j) = rgb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 竖直方向</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = border; i &lt; rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = border; j &lt; cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> sum[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = -border; k &lt;= border; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (channels == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum[<span class="number">0</span>] += matrix[border + k] * dst.at&lt;uchar&gt;(i + k, j); <span class="comment">// 列不变，行变化；竖直方向的卷积</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (channels == <span class="number">3</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Vec3b rgb = dst.at&lt;Vec3b&gt;(i + k, j);</span><br><span class="line">                    sum[<span class="number">0</span>] += matrix[border + k] * rgb[<span class="number">0</span>];</span><br><span class="line">                    sum[<span class="number">1</span>] += matrix[border + k] * rgb[<span class="number">1</span>];</span><br><span class="line">                    sum[<span class="number">2</span>] += matrix[border + k] * rgb[<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channels; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum[k] &lt; <span class="number">0</span>)</span><br><span class="line">                    sum[k] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum[k] &gt; <span class="number">255</span>)</span><br><span class="line">                    sum[k] = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (channels == <span class="number">1</span>)</span><br><span class="line">                dst.at&lt;uchar&gt;(i, j) = <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (channels == <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Vec3b rgb = &#123; <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">0</span>]), <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">1</span>]), <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">2</span>]) &#125;;</span><br><span class="line">                dst.at&lt;Vec3b&gt;(i, j) = rgb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的算法都是 上面提到的<a href="https://www.cnblogs.com/wangguchangqing/p/6407717.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangguchangqing/p/6407717.html</a>  这篇文章, 具体可以去看内容</p><h4 id="opencv-高斯滤波"><a href="#opencv-高斯滤波" class="headerlink" title="opencv 高斯滤波"></a>opencv 高斯滤波</h4><p>其实这篇文章<a href="https://blog.csdn.net/L_inYi/article/details/8915116" target="_blank" rel="noopener">图像处理–高斯滤波</a>写的很好<br>其实主要的结构也就是他给出的过程</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1589099909152.png" alt="高斯函数调用图"></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1589099908858.png" alt="高斯滤波函数调用简图"></p><p>其实整个高斯滤波的过程就是创建高斯核, 然后使用 filter2D 的方法进行的滤波操作, 具体要深入的话可以看函数的调用图, 实现起来也是一样的思路, 很简单的操作, 我们之后测试一下效果..<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /modules\imgproc\src\smooth.dispatch.cpp:600</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GaussianBlur</span><span class="params">(InputArray _src, OutputArray _dst, Size ksize,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">double</span> sigma1, <span class="keyword">double</span> sigma2,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> borderType)</span></span></span><br></pre></td></tr></table></figure></p><ul><li>src    ‪输入图像</li><li>dst    输出图像</li><li>ksize    核的尺寸 奇数</li><li>sigmaX    x 方向 的 sigma 值</li><li>sigmaY    ‪y 方向 的 sigma 值</li><li>borderType    边界处理的方式</li></ul><h4 id="高斯滤波效果对比"><a href="#高斯滤波效果对比" class="headerlink" title="高斯滤波效果对比"></a>高斯滤波效果对比</h4><p>我们还是使用之前的高椒盐噪声图像, 然后直接进行算法滤波, 计算结果就好, 跟之前的测试图像很相似, 这里</p><p><img src="./images/1589100238500.png" alt="测试结果图"></p><p>这里的四张图分别对应 高噪声图像, 直接高斯滤波的结果, 分离xy方向进行滤波结果,以及opencv 自带的高斯滤波效果图, 这里是预览图像, 实际的检测结果就是上面给出的参数值, 实际上效果只能说一般, 我们之后再进行算法层面的对比.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353</span><br><span class="line">image-noise: psnr:26.3155, mssim: B:0.584585 G:0.617172 R:0.812303</span><br><span class="line">image-noise: psnr:26.1721, mssim: B:0.574719 G:0.607494 R:0.809844</span><br><span class="line">image-noise: psnr:26.4206, mssim: B:0.598176 G:0.630657 R:0.819658</span><br></pre></td></tr></table></figure><h3 id="双边滤波-Bilateral-Filter"><a href="#双边滤波-Bilateral-Filter" class="headerlink" title="双边滤波(Bilateral Filter)"></a>双边滤波(Bilateral Filter)</h3><h4 id="双边滤波原理"><a href="#双边滤波原理" class="headerlink" title="双边滤波原理"></a>双边滤波原理</h4><p>我们在上面提出了高斯滤波的原理是对于距离模板中心 距离不同给予不同的权重, 而双边滤波则不仅考虑图像的空间距离, 还要考虑其灰度距离, 对于越接近中间灰度值的点权重越高, 灰度值相差大的则权重更小.</p><p>双边滤波的原理可以参考<a href="https://blog.csdn.net/Jfuck/article/details/8932978" target="_blank" rel="noopener">双边滤波（Bilateral Filter）详解</a>,<br>可以参考<a href="http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html" target="_blank" rel="noopener">Bilateral Filtering for Gray and Color Images</a></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1589099908862.png" alt="双边滤波原理"></p><p>在文章<a href="https://www.cnblogs.com/wangguchangqing/p/6416401.html" target="_blank" rel="noopener">图像处理基础(5)：双边滤波器</a>详细介绍了双边滤波<br>其实跟上面给出的滤波演示一致, 都是在保证图像边缘信息的情况下进行噪声的滤波..</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1589099909153.png" alt="双边滤波原理"></p><p>可以参考<a href="https://blog.csdn.net/guyuealian/article/details/82660826" target="_blank" rel="noopener">bilateral filter双边滤波器的通俗理解</a> 给出的双边滤波的数学表达<br>$$<br>g(x,y) = \frac{\sum_{kl}f(k,l)w(i,j,k,l)}{\sum_{kl}w(i,j,k,l)}<br>$$</p><p>对于不同的模板系数又有两个部分, 主要是 空间域模板权值 $w_d$ 和 灰度域 模板权值 $w_r$,<br>$$<br>\begin{array}{rl}<br>w_d(i,j,k,l) &amp;= e^{-\frac{(i-k)^2 +(j-l)^2}{2\sigma_d^2}} \<br>w_r(i,j,k,l) &amp;= e^{-\frac{\left | f(i,j) - f(k,l) \right |} {2\sigma_r^2}}  \<br>w &amp;= w_d * w_r<br>\end{array}<br>$$<br> 其中，$q(i,j)$ 为模板窗口的其他系数的坐标，$f(i,j)$ 表示图像在点$q(i,j)$ 处的像素值；$p(k,l)$ 为模板窗口的中心坐标点，对应的像素值为$f(k,l)$ ；$\sigma_r$ 为高斯函数的标准差。</p><h4 id="C-实现-双边滤波"><a href="#C-实现-双边滤波" class="headerlink" title="C++ 实现 双边滤波"></a>C++ 实现 双边滤波</h4><p>感觉这里写的挺好的 <a href="https://www.cnblogs.com/wangguchangqing/p/6416401.html" target="_blank" rel="noopener">图像处理基础(5)：双边滤波器</a>, 手动实现了双边滤波, 我们可以详细的参考, 这里</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考来源: https://www.cnblogs.com/wangguchangqing/p/6416401.html</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myBilateralFilter</span><span class="params">(<span class="keyword">const</span> Mat &amp;src, Mat &amp;dst, <span class="keyword">int</span> ksize, <span class="keyword">double</span> space_sigma, <span class="keyword">double</span> color_sigma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> channels = src.channels();</span><br><span class="line">    CV_Assert(channels == <span class="number">1</span> || channels == <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">double</span> space_coeff = <span class="number">-0.5</span> / (space_sigma * space_sigma);</span><br><span class="line">    <span class="keyword">double</span> color_coeff = <span class="number">-0.5</span> / (color_sigma * color_sigma);</span><br><span class="line">    <span class="keyword">int</span> radius = ksize / <span class="number">2</span>;</span><br><span class="line">    Mat temp;</span><br><span class="line">    copyMakeBorder(src, temp, radius, radius, radius, radius, BorderTypes::BORDER_REFLECT);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; _color_weight(channels * <span class="number">256</span>); <span class="comment">// 存放差值的平方</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; _space_weight(ksize * ksize); <span class="comment">// 空间模板系数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _space_ofs(ksize * ksize); <span class="comment">// 模板窗口的坐标</span></span><br><span class="line">    <span class="keyword">double</span> *color_weight = &amp;_color_weight[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">double</span> *space_weight = &amp;_space_weight[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span>    *space_ofs = &amp;_space_ofs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; channels * <span class="number">256</span>; i++)</span><br><span class="line">        color_weight[i] = <span class="built_in">exp</span>(i * i * color_coeff);</span><br><span class="line">    <span class="comment">// 生成空间模板</span></span><br><span class="line">    <span class="keyword">int</span> maxk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = -radius; i &lt;= radius; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = -radius; j &lt;= radius; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> r = <span class="built_in">sqrt</span>(i*i + j * j);</span><br><span class="line">            <span class="keyword">if</span> (r &gt; radius)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            space_weight[maxk] = <span class="built_in">exp</span>(r * r * space_coeff); <span class="comment">// 存放模板系数</span></span><br><span class="line">            space_ofs[maxk++] = i * temp.step + j * channels; <span class="comment">// 存放模板的位置，和模板系数相对应</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 滤波过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; src.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> uchar *sptr = temp.data + (i + radius) * temp.step + radius * channels;</span><br><span class="line">        uchar *dptr = dst.data + i * dst.step;</span><br><span class="line">        <span class="keyword">if</span> (channels == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.cols; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> sum = <span class="number">0</span>, wsum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> val0 = sptr[j]; <span class="comment">// 模板中心位置的像素</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; maxk; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> val = sptr[j + space_ofs[k]];</span><br><span class="line">                    <span class="keyword">double</span> w = space_weight[k] * color_weight[<span class="built_in">abs</span>(val - val0)]; <span class="comment">// 模板系数 = 空间系数 * 灰度值系数</span></span><br><span class="line">                    sum += val * w;</span><br><span class="line">                    wsum += w;</span><br><span class="line">                &#125;</span><br><span class="line">                dptr[j] = (uchar)cvRound(sum / wsum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (channels == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.cols * <span class="number">3</span>; j+=<span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> sum_b = <span class="number">0</span>, sum_g = <span class="number">0</span>, sum_r = <span class="number">0</span>, wsum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> b0 = sptr[j];</span><br><span class="line">                <span class="keyword">int</span> g0 = sptr[j + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> r0 = sptr[j + <span class="number">2</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; maxk; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">const</span> uchar *sptr_k = sptr + j + space_ofs[k];</span><br><span class="line">                    <span class="keyword">int</span> b = sptr_k[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> g = sptr_k[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">int</span> r = sptr_k[<span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">double</span> w = space_weight[k] * color_weight[<span class="built_in">abs</span>(b - b0) + <span class="built_in">abs</span>(g - g0) + <span class="built_in">abs</span>(r - r0)];</span><br><span class="line">                    sum_b += b * w;</span><br><span class="line">                    sum_g += g * w;</span><br><span class="line">                    sum_r += r * w;</span><br><span class="line">                    wsum += w;</span><br><span class="line">                &#125;</span><br><span class="line">                wsum = <span class="number">1.0f</span> / wsum;</span><br><span class="line">                b0 = cvRound(sum_b * wsum);</span><br><span class="line">                g0 = cvRound(sum_g * wsum);</span><br><span class="line">                r0 = cvRound(sum_r * wsum);</span><br><span class="line">                dptr[j] = (uchar)b0;</span><br><span class="line">                dptr[j + <span class="number">1</span>] = (uchar)g0;</span><br><span class="line">                dptr[j + <span class="number">2</span>] = (uchar)r0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="opencv-实现-双边滤波"><a href="#opencv-实现-双边滤波" class="headerlink" title="opencv 实现 双边滤波"></a>opencv 实现 双边滤波</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bilateralFilter</span><span class="params">( InputArray _src, OutputArray _dst, <span class="keyword">int</span> d,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">double</span> sigmaColor, <span class="keyword">double</span> sigmaSpace,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> borderType )</span></span></span><br></pre></td></tr></table></figure><blockquote><ul><li>InputArray src: 输入图像，可以是Mat类型，图像必须是8位或浮点型单通道、三通道的图像。 </li><li>OutputArray dst: 输出图像，和原图像有相同的尺寸和类型。 </li><li>int d: 表示在过滤过程中每个像素邻域的直径范围。如果这个值是非正数，则函数会从第五个参数sigmaSpace计算该值。 </li><li>double sigmaColor: 颜色空间过滤器的sigma值，这个参数的值月大，表明该像素邻域内有越宽广的颜色会被混合到一起，产生较大的半相等颜色区域。 （这个参数可以理解为值域核的）</li><li>double sigmaSpace: 坐标空间中滤波器的sigma值，如果该值较大，则意味着越远的像素将相互影响，从而使更大的区域中足够相似的颜色获取相同的颜色。当d&gt;0时，d指定了邻域大小且与sigmaSpace无关，否则d正比于sigmaSpace. （这个参数可以理解为空间域核的）</li><li>int borderType=BORDER_DEFAULT: 用于推断图像外部像素的某种边界模式，有默认值BORDER_DEFAULT.</li></ul></blockquote><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1589099909156.png" alt="双边滤波函数调用图"></p><h4 id="双边滤波算法对比"><a href="#双边滤波算法对比" class="headerlink" title="双边滤波算法对比"></a>双边滤波算法对比</h4><p>一开始的时候看双边滤波真的搞不懂,  也不知道这么做有什么目的, 最终的结果又代表什么, 我们按照之前的方法去测试我们的图像, 结果真的是几种算法中最差的了, 但是这只是说不适用于我们的图像结果, 在实际使用过程中还是要进行测试之后才能得出结论</p><p>测试结果如下: 对应原始图和 手动实现的结果以及 opencv 的结果 都使用的 是3 的窗口, sigma 的值 为 255<br>, 这篇文章<a href="https://blog.csdn.net/Jfuck/article/details/8932978" target="_blank" rel="noopener">https://blog.csdn.net/Jfuck/article/details/8932978</a>  讲的很好, 介绍了参数对滤波的影响, 可以学习一下..<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353</span><br><span class="line">image-noise: psnr:24.4502, mssim: B:0.538774 G:0.570666 R:0.776195</span><br><span class="line">image-noise: psnr:24.4691, mssim: B:0.539177 G:0.571087 R:0.776461</span><br></pre></td></tr></table></figure></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1589099909397.png" alt="双边滤波算法"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实个人使用双边滤波真的不算很多,  在之前研究导向滤波的时候才了解过很多, 这里写的比较差吧, 只能说勉强能看, 强烈推荐 <a href="https://www.cnblogs.com/wangguchangqing/category/740760.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangguchangqing/category/740760.html</a>  这个系列, 将的很详细, 很多都是博文里面的内容, 可以参考学习,  高斯滤波就比较简单了, 其实复杂的滤波过程主要是理解算法, 然后根据算法的思路进行代码的实现过程, 最后做一定的程序上的优化就好, 理解第一, 实现其次.. 希望带给读者一点点启发..</p><p>我这里一开始不准备写这么多的, 结果越写越多, 导致自己收不住了, 很多自己说不上很了解的地方, 这一次也是深入的了解了一下,  但是还是很僵硬, 只能说能用而已, 这里还是推荐看我给出的链接或者自己去查阅相关的内容, 我这里只是给出一个大略的介绍, 如果有错误还请指名, 十分感谢</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li>《快速高斯滤波、高斯模糊、高斯平滑(二维卷积分步为一维卷积)<em>人工智能</em>青城山小和尚-CSDN博客》. 见于 2020年5月10日. <a href="https://blog.csdn.net/qq_36359022/article/details/80188873" target="_blank" rel="noopener">https://blog.csdn.net/qq_36359022/article/details/80188873</a>.</li><li>《双边滤波 - 旗亭涉的博客 | Qitingshe Blog》. 见于 2020年5月10日. <a href="https://qitingshe.github.io/2018/06/14/%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2/" target="_blank" rel="noopener">https://qitingshe.github.io/2018/06/14/%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2/</a>.</li><li>《双边滤波（Bilateral Filter）详解_人工智能_Jfuck的专栏-CSDN博客》. 见于 2020年5月10日. <a href="https://blog.csdn.net/Jfuck/article/details/8932978" target="_blank" rel="noopener">https://blog.csdn.net/Jfuck/article/details/8932978</a>.</li><li>《雙邊濾波器》. 收入 维基百科，自由的百科全书, 2019年11月16日. <a href="https://zh.wikipedia.org/w/index.php?title=%E9%9B%99%E9%82%8A%E6%BF%BE%E6%B3%A2%E5%99%A8&amp;oldid=56898678" target="_blank" rel="noopener">https://zh.wikipedia.org/w/index.php?title=%E9%9B%99%E9%82%8A%E6%BF%BE%E6%B3%A2%E5%99%A8&amp;oldid=56898678</a>.</li><li>《图像处理–高斯滤波_网络_L-inYi的专栏-CSDN博客》. 见于 2020年5月10日. <a href="https://blog.csdn.net/L_inYi/article/details/8915116" target="_blank" rel="noopener">https://blog.csdn.net/L_inYi/article/details/8915116</a>.</li><li>《图像处理基础(4)：高斯滤波器详解 - Brook_icv - 博客园》. 见于 2020年5月10日. <a href="https://www.cnblogs.com/wangguchangqing/p/6407717.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangguchangqing/p/6407717.html</a>.</li><li>《图像处理基础(5)：双边滤波器 - Brook_icv - 博客园》. 见于 2020年5月10日. <a href="https://www.cnblogs.com/wangguchangqing/p/6416401.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangguchangqing/p/6416401.html</a>.</li><li>《图像处理－线性滤波－3 高斯滤波器 - Tony Ma - 博客园》. 见于 2020年5月10日. <a href="https://www.cnblogs.com/pegasus/archive/2011/05/20/2052031.html" target="_blank" rel="noopener">https://www.cnblogs.com/pegasus/archive/2011/05/20/2052031.html</a>.</li><li>《【转】高斯图像滤波原理及其编程离散化实现方法_Smile_Gogo_新浪博客》. 见于 2020年5月10日. <a href="http://blog.sina.com.cn/s/blog_640577ed0100yz8v.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_640577ed0100yz8v.html</a>.</li><li>《bilateral filter双边滤波器的通俗理解_网络_pan_jinquan的博客-CSDN博客》. 见于 2020年5月10日. <a href="https://blog.csdn.net/guyuealian/article/details/82660826" target="_blank" rel="noopener">https://blog.csdn.net/guyuealian/article/details/82660826</a>.</li><li>《Bilateral Filtering》. 见于 2020年5月10日. <a href="http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html" target="_blank" rel="noopener">http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html</a>.</li><li>《Cv图像处理 - OpenCV China ：图像处理,计算机视觉库,Image Processing, Computer Vision》. 见于 2020年5月10日. <a href="http://wiki.opencv.org.cn/index.php/Cv%e5%9b%be%e5%83%8f%e5%a4%84%e7%90%86" target="_blank" rel="noopener">http://wiki.opencv.org.cn/index.php/Cv%e5%9b%be%e5%83%8f%e5%a4%84%e7%90%86</a>.</li><li>《o(1)复杂度之双边滤波算法的原理、流程、实现及效果。 - 云+社区 - 腾讯云》. 见于 2020年5月10日. <a href="https://cloud.tencent.com/developer/article/1011738" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1011738</a>.</li></ol><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
            <tag> c++ </tag>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv-11-中值滤波及自适应中值滤波</title>
      <link href="/2020/05-02/opencv-11-%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2.html"/>
      <url>/2020/05-02/opencv-11-%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2.html</url>
      
        <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>在上一篇我们实现了读取噪声图像, 然后 进行三种形式的均值滤波得到结果, 由于我们自己写的均值滤波未作边缘处理, 所以效果有一定的下降, 但是总体来说, 我们得到的结果能够说明我们的算法执行之后得到的图像噪声更低, 图像更清晰. 但是也会造成图像的模糊, 导致部分细节丢失. 在这一章中,我们介绍一下中值滤波及其实现</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>首先介绍了中值滤波的原理, 给出其实现思路,并根据思路实现了 C++ 的代码, 然后 同样测试 opencv 自带的中值滤波, 同样的测试图像, 得到对比结果, 分析代码的实现过程, .</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="中值滤波原理"><a href="#中值滤波原理" class="headerlink" title="中值滤波原理"></a>中值滤波原理</h3><p>中值滤波(Media Filter)就是对于图像的每一个点计算其邻域窗口的像素序列中值, 可以表示为:<br>$$<br>g(x,y) = meida_{(i,j) \in S}f(i,j)<br>$$<br>核心就是将相应窗口内的像素值进行排列, 我们之前也说过, 我们选择的窗口为奇数尺寸, 所以我们能够保证窗口内的像素个数也是奇数个, 这样我们可以保证取得唯一的中值, 相应的设置为该点的目标值就行了.</p><h3 id="C-实现中值滤波"><a href="#C-实现中值滤波" class="headerlink" title="C++ 实现中值滤波"></a>C++ 实现中值滤波</h3><p>我们来实现一下, 这方面还是能够找到不少结果的, 感觉这个博主写的还是很不错的,有兴趣的可以看下<a href="https://www.cnblogs.com/ranjiewen/p/5699395.html" target="_blank" rel="noopener">数字图像处理——中值滤波</a>,还有<a href="https://www.cnblogs.com/qiqibaby/p/5281743.html" target="_blank" rel="noopener">图像处理之中值滤波介绍及C实现</a>, 或者 <a href="https://blog.csdn.net/liyuanbhu/article/details/48502005" target="_blank" rel="noopener">中值滤波器（Median filter）特性及其实现</a>, 这里我就不再造轮子了, 我们来看下 C++的实现<br>, 主要参考 第一篇文章, 可以看下效果</p><p>这里有一点点需要讨论的, 对于彩色图像的三个通道怎么处理, 自己的思路就是分成三个通道进行处理, 然后分别得到三个图之后进行合并三个通道, 得到结果图像.   查了下 目测大家都是这么做的, 可以看<a href="https://blog.csdn.net/cyf15238622067/article/details/88718615" target="_blank" rel="noopener">OpenCV 彩色图像的自适应中值滤波 C++</a> 和 <a href="https://blog.csdn.net/liyuqian199695/article/details/70050852" target="_blank" rel="noopener">彩色图像空间滤波（MATLAB）</a> 这两篇文章, 思路都是一样的, 我们来实现一下.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中值滤波：C++ 代码实现 // 处理单通道图像 // 参考 https://www.cnblogs.com/ranjiewen/p/5699395.html</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">medianFilterGray</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;src, <span class="keyword">int</span> ksize = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat dst = src.clone();</span><br><span class="line">    <span class="comment">//0. 准备：获取图片的宽，高和像素信息，</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>  num = ksize * ksize;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;uchar&gt; <span class="title">pixel</span><span class="params">(num)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相对于中心点，3*3领域中的点需要偏移的位置</span></span><br><span class="line">    <span class="keyword">int</span> delta[<span class="number">3</span> * <span class="number">3</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123; <span class="number">-1</span>, <span class="number">-1</span> &#125;, &#123; <span class="number">-1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">-1</span>, <span class="number">1</span> &#125;, &#123; <span class="number">0</span>, <span class="number">-1</span> &#125;, &#123; <span class="number">0</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">-1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span> &#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//1. 中值滤波，没有考虑边缘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; src.rows - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; src.cols - <span class="number">1</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//1.1 提取领域值 // 使用数组 这样处理 8邻域值 不适合更大窗口</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; num; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                pixel[k] = src.at&lt;uchar&gt;(i+delta[k][<span class="number">0</span>], j+ delta[k][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//1.2 排序  // 使用自带的库及排序即可</span></span><br><span class="line">            <span class="built_in">std</span>::sort(pixel.begin(), pixel.end());</span><br><span class="line">            <span class="comment">//1.3 获取该中心点的值</span></span><br><span class="line">            dst.at&lt;uchar&gt;(i, j) = pixel[num / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路还是那个思路, 不过在写的过程中, 我在想, 能不能直接处理彩色的图像呢, 对于彩色图像最麻烦的地方就是排序了, 我们没办法考虑颜色的高低值, 所以 那我们自定义一个比较函数应该就行了吧.  我们使用三个颜色的和值 做比较<br>这里使用了C++ 的sort 自定义函数的方法, 这边采用的比较函数的方式, 还有别的方式实现两个元素的比较, 可以参考<a href="https://blog.csdn.net/aastoneaa/article/details/8471722" target="_blank" rel="noopener">c++中vector自定义排序的问题</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义两个像素的比较函数,  // 使用和值 排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> cv::Vec3b &amp;p1, <span class="keyword">const</span> cv::Vec3b &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p1[<span class="number">0</span>] + p1[<span class="number">1</span>] + p1[<span class="number">2</span>]) &lt; (p2[<span class="number">0</span>] + p2[<span class="number">1</span>] + p2[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试彩色图像, 中值排序使用三个通道的和排序</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">medianFilterColor</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;src, <span class="keyword">int</span> ksize = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat dst = src.clone();</span><br><span class="line">    <span class="comment">//0. 准备：获取图片的宽，高和像素信息，</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>  num = ksize * ksize;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Vec3b&gt; <span class="title">pixel</span><span class="params">(num)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相对于中心点，3*3领域中的点需要偏移的位置</span></span><br><span class="line">    <span class="keyword">int</span> delta[<span class="number">3</span> * <span class="number">3</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123; <span class="number">-1</span>, <span class="number">-1</span> &#125;, &#123; <span class="number">-1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">-1</span>, <span class="number">1</span> &#125;, &#123; <span class="number">0</span>, <span class="number">-1</span> &#125;, &#123; <span class="number">0</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">-1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span> &#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//1. 中值滤波，没有考虑边缘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; src.rows - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; src.cols - <span class="number">1</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//1.1 提取领域值 // 使用数组 这样处理 8邻域值 不适合更大窗口</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; num; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                pixel[k] = src.at&lt;cv::Vec3b&gt;(i + delta[k][<span class="number">0</span>], j + delta[k][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//1.2 排序  // 使用自定义的排序函数排序彩色图像</span></span><br><span class="line">            <span class="built_in">std</span>::sort(pixel.begin(),pixel.end(),comp);</span><br><span class="line">            <span class="comment">//1.3 获取该中心点的值</span></span><br><span class="line">            dst.at&lt;cv::Vec3b&gt;(i, j) = pixel[num / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="opencv-中值滤波"><a href="#opencv-中值滤波" class="headerlink" title="opencv 中值滤波"></a>opencv 中值滤波</h3><p>这里还是之前的方法, 一样的接口, 实现起来很简单, opencv 提供的 函数还是很丰富的, 很厉害<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// opencv 中值滤波</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">mediaFilterDefault</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;src, <span class="keyword">int</span> ksize = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat dst;</span><br><span class="line">    cv::medianBlur(src, dst, ksize);</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="中值滤波算法对比"><a href="#中值滤波算法对比" class="headerlink" title="中值滤波算法对比"></a>中值滤波算法对比</h3><p>我们这里就跟之前均值算法的计算很相似了, 我们已经写了三种算法的实现, 然后测试就好了, 趁着功夫, 将上一章一直重复的两个图比较并输出参数的部分写成了一个函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对比两个图像 然后输出 参数信息</span></span><br><span class="line"><span class="function">QString <span class="title">compareImages</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;I1,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> cv::Mat &amp;I2,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QString str = <span class="string">"noise"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QString str_temp = <span class="string">"image-%1: psnr:%2, mssim: B:%3 G:%4 R:%5"</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> psnr_ = getPSNR(I1, I2);</span><br><span class="line">    cv::Scalar mssim_ = getMSSIM(I1, I2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 输出模板 生成参数信息</span></span><br><span class="line">    QString res_str = str_temp.arg(str)</span><br><span class="line">        .arg(psnr_)</span><br><span class="line">        .arg(mssim_.val[<span class="number">0</span>])</span><br><span class="line">        .arg(mssim_.val[<span class="number">1</span>])</span><br><span class="line">        .arg(mssim_.val[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res_str;</span><br><span class="line">    <span class="comment">// cv::imwrite(IMAGE_DIR + "dst_" + std::to_string(i + 1) + ".png", dst[i]);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>没什么难度, 就是用来拼接一个字符串, 用来显示在界面上, 或者 输出输出来, </p><p>这样的我们就能很容易的去写测试的函数了, 三种方法依次去实现, 比较麻烦的是第一种, 需要将彩色图像分成三个通道的灰度图像, 然后分别进行中值滤波, 最后合并结果,得到结果图像.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 测试 中值 滤波 三种方式的不同</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> TEST = <span class="number">1</span>; <span class="comment">// 使用统一的图进行测试 暂时使用 高 椒盐噪声图像</span></span><br><span class="line">    QString res_str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 噪声图像的参数值</span></span><br><span class="line">    res_str = compareImages(gSrcImg, gNoiseImg[TEST]);</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line"></span><br><span class="line">    cv::Mat test_img = gNoiseImg[TEST];</span><br><span class="line"></span><br><span class="line">    cv::Mat dst[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 中值滤波 拆分三个通道进行中值滤波然后合并图像</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Mat&gt; <span class="title">bgr</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    cv::split(test_img, bgr);</span><br><span class="line">    bgr[<span class="number">0</span>] = medianFilterGray(bgr[<span class="number">0</span>]);</span><br><span class="line">    bgr[<span class="number">1</span>] = medianFilterGray(bgr[<span class="number">1</span>]);</span><br><span class="line">    bgr[<span class="number">2</span>] = medianFilterGray(bgr[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    cv::merge(bgr, dst[<span class="number">0</span>]);     <span class="comment">// 第一种方式</span></span><br><span class="line">    dst[<span class="number">1</span>] = medianFilterColor(test_img);   <span class="comment">// 第二种 彩色直接 计算中值滤波</span></span><br><span class="line">    dst[<span class="number">2</span>] = mediaFilterDefault(test_img);  <span class="comment">// opencv 实现 中值滤波</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别计算三种方式得到的滤波的效果 (结果图与 原始图比较)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res_str = compareImages(gSrcImg, dst[i]);</span><br><span class="line">        <span class="comment">// 噪声的参数值</span></span><br><span class="line">        ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line"></span><br><span class="line">        cv::imwrite(IMAGE_DIR + <span class="string">"dst_media_"</span> + <span class="built_in">std</span>::to_string(i+<span class="number">1</span>)+<span class="string">".png"</span>,dst[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们仍然选择高椒盐噪声图像用于测试,  先看下结果, 分别对应噪声图的参数, 以及三种方法进行的参数结果.<br>第三行的结果就是我们进行自定义排序的图像处理, </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353</span><br><span class="line">image-noise: psnr:33.3725, mssim: B:0.896859 G:0.915976 R:0.912563</span><br><span class="line">image-noise: psnr:31.2668, mssim: B:0.866162 G:0.901717 R:0.879337</span><br><span class="line">image-noise: psnr:34.3125, mssim: B:0.902338 G:0.921419 R:0.91531</span><br></pre></td></tr></table></figure><p>我们看一下结果图像, 原始图像可以看 <a href="https://gitee.com/schen00/BlogImage/raw/master/image/1588468343599.png" target="_blank" rel="noopener">https://gitee.com/schen00/BlogImage/raw/master/image/1588468343599.png</a> 这里, </p><blockquote><p>gitee 限制了 1M 以上的图的显示, 所以有需要的去看这个就好. </p><blockquote><p>最近一直用的图拼接使用的 <a href="http://www.zuohaotu.com/image-merge.aspx" target="_blank" rel="noopener">做好图 在线拼接图片</a>  主要是懒得自己写了, <a href="http://www.zuohaotu.com/image-merge.aspx" target="_blank" rel="noopener">http://www.zuohaotu.com/image-merge.aspx</a> 链接在这里了 有需要自取</p></blockquote></blockquote><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1588468342493.png" alt="中值滤波处理结果图像预览图"></p><p>这里的第一副图是噪声图像, 第二副是我们拆分通道处理后拼接起来了的, 没有处理边缘的细节问题, 第三章图就是我们进行自定义中值排序得到的图, 部分点处理不掉 甚至还复制了出来, 不过整体效果还是不错的, 第四章图就是opencv 自带的中值滤波的处理. </p><h3 id="中值滤波算法优化"><a href="#中值滤波算法优化" class="headerlink" title="中值滤波算法优化"></a>中值滤波算法优化</h3><p>类似均值滤波, 处理的时候考虑变化了的边界就好了, 那中值滤波怎么优化呢, 感觉这一块做的人还挺多, 中值滤波的优化主要是使用自适应中值滤波, 和在中值滤波的方法上进行加速运算, </p><h4 id="自适应中值滤波"><a href="#自适应中值滤波" class="headerlink" title="自适应中值滤波"></a>自适应中值滤波</h4><p>可以参考<a href="https://blog.csdn.net/hongbin_xu/article/details/79780967" target="_blank" rel="noopener">自适应中值滤波及实现</a>, 我感觉介绍的还是比较详细的, 主要的思路就是如果噪声比较严重时, 窗口获取到的中值可能是噪声值, 这时候增大窗口, 然后重新进行中值滤波,直到找到比较符合的中值.<br>引用他给出的部分叙述</p><blockquote><p>在自适应中值滤波算法中，A步骤里面会先判断是否满足 $Zmin&lt;Zmed&lt;ZmaxZmin&lt;Zmed&lt;Zmax$。这一步骤实质是判断当前区域的中值点是否是噪声点，通常来说是满足 $Zmin&lt;Zmed&lt;ZmaxZmin&lt;Zmed&lt;Zmax$ 这个条件的，此时中值点不是噪声点，跳转到B；考虑一些特殊情况，如果 $Zmed=ZminZmed=Zmin或者Zmed=ZmaxZmed=Zmax$ ，则认为是噪声点，应该扩大窗口尺寸，在一个更大的范围内寻找一个合适的非噪声点，随后再跳转到B，否则输出的中值点是噪声点；<br>接下来考虑跳转到B之后的情况：判断中心点的像素值是否是噪声点，判断条件为 $Zmin&lt;Zxy&lt;ZmaxZmin&lt;Zxy&lt;Zmax$，原理同上，因为如果$Zxy=ZminZxy=Zmin$或者$Zxy=ZmaxZxy=Zmax$，则认为是噪声点。如果不是噪声点，我们可以保留当前像素点的灰度值；如果是噪声点，则使用中值替代原始灰度值，滤去噪声。</p></blockquote><p>同样的, <a href="https://www.cnblogs.com/wangguchangqing/p/6379646.html" target="_blank" rel="noopener">图像处理基础(2)：自适应中值滤波器(基于OpenCV实现)</a>, 这篇文章写的更好一点, 并给出了 opencv 的实现代码, 我们来看一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自适应中值滤波窗口实现  // 图像 计算座标, 窗口尺寸和 最大尺寸</span></span><br><span class="line"><span class="function">uchar <span class="title">adaptiveProcess</span><span class="params">(<span class="keyword">const</span> Mat &amp;im, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> kernelSize, <span class="keyword">int</span> maxSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;uchar&gt; pixels;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = -kernelSize / <span class="number">2</span>; a &lt;= kernelSize / <span class="number">2</span>; a++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = -kernelSize / <span class="number">2</span>; b &lt;= kernelSize / <span class="number">2</span>; b++)</span><br><span class="line">        &#123;</span><br><span class="line">            pixels.push_back(im.at&lt;uchar&gt;(row + a, col + b));</span><br><span class="line">        &#125;</span><br><span class="line">    sort(pixels.begin(), pixels.end());</span><br><span class="line">    <span class="keyword">auto</span> min = pixels[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">auto</span> max = pixels[kernelSize * kernelSize - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">auto</span> med = pixels[kernelSize * kernelSize / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">auto</span> zxy = im.at&lt;uchar&gt;(row, col);</span><br><span class="line">    <span class="keyword">if</span> (med &gt; min &amp;&amp; med &lt; max)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// to B</span></span><br><span class="line">        <span class="keyword">if</span> (zxy &gt; min &amp;&amp; zxy &lt; max)</span><br><span class="line">            <span class="keyword">return</span> zxy;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> med;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        kernelSize += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (kernelSize &lt;= maxSize)</span><br><span class="line">            <span class="keyword">return</span> adaptiveProcess(im, row, col, kernelSize, maxSize); <span class="comment">// 增大窗口尺寸，继续A过程。</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> med;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自适应均值滤波</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">adaptiveMediaFilter</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;src, <span class="keyword">int</span> ksize = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minSize = <span class="number">3</span>; <span class="comment">// 滤波器窗口的起始尺寸</span></span><br><span class="line">    <span class="keyword">int</span> maxSize = <span class="number">7</span>; <span class="comment">// 滤波器窗口的最大尺寸</span></span><br><span class="line">    cv::Mat dst;</span><br><span class="line">    <span class="comment">// 扩展图像的边界</span></span><br><span class="line">    cv::copyMakeBorder(src, dst, maxSize / <span class="number">2</span>, maxSize / <span class="number">2</span>, maxSize / <span class="number">2</span>, maxSize / <span class="number">2</span>, cv::BorderTypes::BORDER_REFLECT);</span><br><span class="line">    <span class="comment">// 图像循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = maxSize / <span class="number">2</span>; j &lt; dst.rows - maxSize / <span class="number">2</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = maxSize / <span class="number">2</span>; i &lt; dst.cols * dst.channels() - maxSize / <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dst.at&lt;uchar&gt;(j, i) = adaptiveProcess(dst, j, i, minSize, maxSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cv::Rect r = cv::Rect(cv::Point(maxSize / <span class="number">2</span>, maxSize / <span class="number">2</span>), cv::Point(dst.rows-maxSize / <span class="number">2</span>, dst.rows-maxSize / <span class="number">2</span>));</span><br><span class="line">    cv::Mat res = dst(r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里还是使用的分离三个通道然后进行自适应均值滤波, 参数就使用默认的3, 最大窗口设为7, 我们测试还是跑的之前的高椒盐噪声图像, 下面给出的最后一行就是我们使用自适应中值滤波得到的结果, 至少从 psnr 的参数上我们能看到图像质量的提升, 我们给出图像结果, 肉眼上能看出稍微一点的区别, 对比之前的已经完全不存在白点了, 图像已经比较接近真实图像了..<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拆分三个通道 计算自适应中值滤波</span></span><br><span class="line">cv::split(test_img, bgr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">truebgr[i] = adaptiveMediaFilter(bgr[i]);</span><br><span class="line">cv::merge(bgr, dst[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353</span><br><span class="line">image-noise: psnr:33.3725, mssim: B:0.896859 G:0.915976 R:0.912563</span><br><span class="line">image-noise: psnr:31.2655, mssim: B:0.86636 G:0.901517 R:0.879384</span><br><span class="line">image-noise: psnr:34.3125, mssim: B:0.902338 G:0.921419 R:0.91531</span><br><span class="line">image-noise: psnr:37.4024, mssim: B:0.946158 G:0.958146 R:0.953884</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1588477728759.png" alt="自适应中值滤波图像结果"></p><h4 id="中值滤波计算加速"><a href="#中值滤波计算加速" class="headerlink" title="中值滤波计算加速"></a>中值滤波计算加速</h4><p>由于中值滤波无论多大的窗口都是用来将窗口内的像素进行排序, 这里的优化有两个方向 一个是窗口的优化, 一个计算的加速, </p><p>我真的 imageshop 的这篇文章 <a href="https://www.cnblogs.com/Imageshop/archive/2013/04/26/3045672.html" target="_blank" rel="noopener">任意半径中值滤波（扩展至百分比滤波器）O(1)时间复杂度算法的原理、实现及效果。</a><br>已经写的比较完全了, 我都不想在写了, </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1588477728325.png" alt="图像窗口滑动"></p><p>再从<a href="https://blog.csdn.net/linj_m/article/details/35780163" target="_blank" rel="noopener">中值滤波的快速算法</a> 偷一张图, </p><p><img src="./images/1588478054028.png" alt="中值滤波算法流程"></p><p>感兴趣的可以看一下的链接<br><a href="https://www.jianshu.com/p/eb0b856286f2" target="_blank" rel="noopener">OpenCV源码分析（四）：中值滤波</a> 这里详细介绍了 opencv 中怎么实现的 中值滤波<br><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1588477728321.png" alt="中值滤波函数调用图"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>算是从中值滤波的基础上做了一个开始, 介绍了一下中值滤波的原理, 然后根据原理使用C++ 进行了实现, 之后再进行 opencv 的实现, 然后我们根据之前的程序上加入了中值滤波的实现效果, 最后在中值滤波的基础上进行优化, 做了自适应中值滤波的实现,测试发现结果还要更好, 最后我稍微提了一下中值滤波的优化加速, 这一块做的很多, 可以去参考里面去找,  算是完成了中值滤波的章节, 如果这里搞懂了我再来完善这一章节..</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《绘制函数调用图（call graph）（4）：doxygen + graphviz_运维_许振坪的专栏-CSDN博客》. 见于 2020年5月2日. <a href="https://blog.csdn.net/benkaoya/article/details/79763668" target="_blank" rel="noopener">https://blog.csdn.net/benkaoya/article/details/79763668</a>.</li><li>《任意半径中值滤波（扩展至百分比滤波器）O(1)时间复杂度算法的原理、实现及效果。 - Imageshop - 博客园》. 见于 2020年5月3日. <a href="https://www.cnblogs.com/Imageshop/archive/2013/04/26/3045672.html" target="_blank" rel="noopener">https://www.cnblogs.com/Imageshop/archive/2013/04/26/3045672.html</a>.</li><li>《数字图像处理——中值滤波 - ranjiewen - 博客园》. 见于 2020年5月2日. <a href="https://www.cnblogs.com/ranjiewen/p/5699395.html" target="_blank" rel="noopener">https://www.cnblogs.com/ranjiewen/p/5699395.html</a>.</li><li>《【算法随记三】小半径中值模糊的急速实现（16MB图7.5ms实现） + Photoshop中蒙尘和划痕算法解读。 - Imageshop - 博客园》. 见于 2020年5月3日. <a href="https://www.cnblogs.com/Imageshop/p/11087804.html" target="_blank" rel="noopener">https://www.cnblogs.com/Imageshop/p/11087804.html</a>.</li><li>《图像处理基础(2)：自适应中值滤波器(基于OpenCV实现) - Brook_icv - 博客园》. 见于 2020年5月3日. <a href="https://www.cnblogs.com/wangguchangqing/p/6379646.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangguchangqing/p/6379646.html</a>.</li><li>《图像处理之原理 - 中值滤波 - tanfy - 博客园》. 见于 2020年5月2日. <a href="https://www.cnblogs.com/tanfy/p/median_filter.html" target="_blank" rel="noopener">https://www.cnblogs.com/tanfy/p/median_filter.html</a>.</li><li>《图像处理之中值滤波介绍及C实现 - 淇淇宝贝 - 博客园》. 见于 2020年5月2日. <a href="https://www.cnblogs.com/qiqibaby/p/5281743.html" target="_blank" rel="noopener">https://www.cnblogs.com/qiqibaby/p/5281743.html</a>.</li><li>《中值滤波的快速算法_网络_LinJM-机器视觉-CSDN博客》. 见于 2020年5月3日. <a href="https://blog.csdn.net/linj_m/article/details/35780163" target="_blank" rel="noopener">https://blog.csdn.net/linj_m/article/details/35780163</a>.</li><li>《中值滤波器》. 收入 维基百科，自由的百科全书, 2017年9月8日. <a href="https://zh.wikipedia.org/w/index.php?title=%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%99%A8&amp;oldid=46098815" target="_blank" rel="noopener">https://zh.wikipedia.org/w/index.php?title=%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%99%A8&amp;oldid=46098815</a>.</li><li>《中值滤波器（Median filter）特性及其实现_人工智能_Ivan 的专栏-CSDN博客》. 见于 2020年5月2日. <a href="https://blog.csdn.net/liyuanbhu/article/details/48502005" target="_blank" rel="noopener">https://blog.csdn.net/liyuanbhu/article/details/48502005</a>.</li><li>《自适应中值滤波及实现_人工智能_hongbin_xu的博客-CSDN博客》. 见于 2020年5月3日. <a href="https://blog.csdn.net/hongbin_xu/article/details/79780967" target="_blank" rel="noopener">https://blog.csdn.net/hongbin_xu/article/details/79780967</a>.</li><li>GitHub. 《ARM-Software/ComputeLibrary》. 见于 2020年5月3日. <a href="https://github.com/ARM-software/ComputeLibrary" target="_blank" rel="noopener">https://github.com/ARM-software/ComputeLibrary</a>.</li><li>《c++中vector自定义排序的问题_C/C++_Stone_Sky-CSDN博客》. 见于 2020年5月2日. <a href="https://blog.csdn.net/aastoneaa/article/details/8471722" target="_blank" rel="noopener">https://blog.csdn.net/aastoneaa/article/details/8471722</a>.</li><li>《OpenCV 彩色图像的自适应中值滤波 C++_人工智能_cyf15238622067的博客-CSDN博客》. 见于 2020年5月3日. <a href="https://blog.csdn.net/cyf15238622067/article/details/88718615" target="_blank" rel="noopener">https://blog.csdn.net/cyf15238622067/article/details/88718615</a>.</li><li>《‪opencv: ‪Image Filtering》. 见于 2020年5月3日. <a href="http://schen.xyz:89/opencv/d4/d86/group__imgproc__filter.html#gad7c87bbc46b97e7eafa71357916ab568" target="_blank" rel="noopener">http://schen.xyz:89/opencv/d4/d86/group__imgproc__filter.html#gad7c87bbc46b97e7eafa71357916ab568</a>.</li><li>知乎专栏. 《OpenCV图像处理专栏九 | 基于直方图的快速中值滤波算法》. 见于 2020年5月3日. <a href="https://zhuanlan.zhihu.com/p/98092747" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/98092747</a>.</li><li>简书. 《OpenCV源码分析（四）：中值滤波》. 见于 2020年5月2日. <a href="https://www.jianshu.com/p/eb0b856286f2" target="_blank" rel="noopener">https://www.jianshu.com/p/eb0b856286f2</a>.</li></ol><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
            <tag> c++ </tag>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv-10-图像滤波-噪声添加与均值滤波-含opencv C++ 代码实现</title>
      <link href="/2020/04-29/opencv-10-%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2.html"/>
      <url>/2020/04-29/opencv-10-%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2.html</url>
      
        <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>再说上一篇文章中, 我们想按照噪声产生, 然后将降噪的, 但是限于篇幅, 我就放在这一篇里面了,<br>说起图像的噪声问题就又回到了我们上一章的内容, 把噪声当作信号处理, 实际上数字图像处理实际上也是在进行数字信号的处理过程, 我们这一章就是将滤除信号的过程,</p><p>根据上一章的方式, 我们对图像添加噪声, 然后计算 PSNR 与 SSIM 参数, 然后通过降噪, 再从新计算参数值, 比较我们算法的效果 对比我们的算法效果, 看正文吧</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[toc]</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我们在上一章给出了两种噪声的添加方式, 可以根据我们的需求添加椒盐噪声和高斯噪声, 但是由于我们的噪声添加使用了随机数 , 导致我们在每次进行的结果可能不一致, 所以我们提前设计好噪声情况, 将图片存储起来, 后面我们进行滤波的时候, 都使用一样的照片, 这样我们能够保证每次的结果是一致的, 这样就能进行算法的对比了,  </p><h3 id="生成噪声图像"><a href="#生成噪声图像" class="headerlink" title="生成噪声图像"></a>生成噪声图像</h3><p>我们在上一章给出了不同噪声情况下图像结果, 也给出了一个链接, 对比了更多情况下的图像噪声情况, 可以参考, 所以我们考虑五种情况吧 分别是低椒盐噪声, 高椒盐噪声,低高斯噪声, 高高斯噪声,低椒盐混合低高斯噪声, 高椒盐混合高高斯噪声. 我们分别将图片进行存储便能够得到结果</p><p>说明一下: 之前的算法使用的 lena 图像 忘记从那搞来的了, 今天对比了一下, 发现图像不太对, 我现在找到opencv的一个标准图像<a href="https://raw.githubusercontent.com/opencv/opencv/master/samples/data/lena.jpg" target="_blank" rel="noopener">Lena.jpg</a>, 我下载下来了, 转换成了 lena.png 的图像, 可以见<a href="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588298950276.png" target="_blank" rel="noopener">lena.png</a> 这幅图, 可以直接访问链接 <a href="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588298950276.png" target="_blank" rel="noopener">https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588298950276.png</a> 直接下载即可.. </p><p>这里的处理算法比较简单, 我们来看代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 用于生成 测试图像 一共6幅图像</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Mat&gt; <span class="title">noise_img</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 初始化为原始图像</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;m: noise_img)</span><br><span class="line">        m = gSrcImg.clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别添加 低, 高, 低混合, 高混合 共6幅图像</span></span><br><span class="line">    addSaltNoise(noise_img[<span class="number">0</span>],<span class="number">1000</span>);</span><br><span class="line">    addSaltNoise(noise_img[<span class="number">1</span>],<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    addGaussianNoise(noise_img[<span class="number">2</span>],<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    addGaussianNoise(noise_img[<span class="number">3</span>],<span class="number">100</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    addSaltNoise(noise_img[<span class="number">4</span>],<span class="number">1000</span>);</span><br><span class="line">    addGaussianNoise(noise_img[<span class="number">4</span>],<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    addSaltNoise(noise_img[<span class="number">5</span>],<span class="number">10000</span>);</span><br><span class="line">    addGaussianNoise(noise_img[<span class="number">5</span>],<span class="number">100</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 6幅图像的  psnr 和 ssim 然后存储结果值</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">psnr</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Scalar&gt; <span class="title">mssim</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    QString res_temp = <span class="string">"image-%1: psnr:%2, mssim: B:%3 G:%4 R:%5 "</span>;</span><br><span class="line">    QString res_str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个图像的 参数值, 然后存储起来</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        psnr[i] = getPSNR(gSrcImg, noise_img[i]);</span><br><span class="line">        mssim[i] = getMSSIM(gSrcImg, noise_img[i]);</span><br><span class="line">        res_str = res_temp.arg(i+<span class="number">1</span>)</span><br><span class="line">                            .arg(psnr[i])</span><br><span class="line">                            .arg(mssim[i].val[<span class="number">0</span>])</span><br><span class="line">                            .arg(mssim[i].val[<span class="number">1</span>])</span><br><span class="line">                            .arg(mssim[i].val[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line">        cv::imwrite(<span class="string">"../testimages/noise/lena-"</span> + <span class="built_in">std</span>::to_string(i+<span class="number">1</span>) + <span class="string">".png"</span>, noise_img[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们将图片输出, 然后输出了每幅图的参数, 同时将结果图存储下来, 由于我们在实际进行图像处理的时候会有很多<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">image-1: psnr:29.4922, mssim: B:0.880587 G:0.888243 R:0.944992 </span><br><span class="line">image-2: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353 </span><br><span class="line">image-3: psnr:46.8705, mssim: B:0.991138 G:0.991732 R:0.991185 </span><br><span class="line">image-4: psnr:9.15966, mssim: B:0.492354 G:0.482311 R:0.680167 </span><br><span class="line">image-5: psnr:29.2807, mssim: B:0.874794 G:0.881488 R:0.935624 </span><br><span class="line">image-6: psnr:8.92587, mssim: B:0.392531 G:0.393254 R:0.655795</span><br></pre></td></tr></table></figure><br>我这里使用之前提到的 图像”拼接” 的方式将图像拼接起来, 这样我们可以更为直观的比较, 图像尺寸都是 $512*512$, 如果需要可以裁剪出来,</p><blockquote><p>CSDN 上传会自己转存图片, 上传资源比较麻烦, 懒得搞, 我这边的图片都存在了 gitee 的图床上, 原图存储的 , 有需要的可以自己取用</p></blockquote><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1588391819059.png" alt="噪声图像&quot;拼接&quot;图"></p><h3 id="传统图像降噪算法及其对比"><a href="#传统图像降噪算法及其对比" class="headerlink" title="传统图像降噪算法及其对比"></a>传统图像降噪算法及其对比</h3><p>之前提到过的<a href="https://zhuanlan.zhihu.com/p/51403693" target="_blank" rel="noopener">【技术综述】一文道尽传统图像降噪方法</a><br> 这篇文章讲的还比较详细, 大概的给我们讲了一下传统的降噪的方法,<br> 这里我想将各种滤波分开进行实现, 但是比较麻烦, 我就直接在一篇文章中写了吧.. </p><p> 目前常用的降噪的方法主要可以分为空域降噪与频域降噪, 空域滤波也是我们常用的使用空间处理的方式,计算量小, 简单易用. 频域比较难理解,计算量也比较大, 但是在很多情况结果比较有效.. </p><p> 所以我们主要的部分也是空间域处理的方式, 也比较直观. opencv 的例程中<a href="https://docs.opencv.org/4.3.0/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html" target="_blank" rel="noopener">Smoothing Images</a> 章节大概讲了一下目前使用的模糊方式, 其实模糊是相对的, 也是进行降噪的一个有利手段, 在处理掉噪声的同时, 会导致原始图像的细节模糊, 进而丢失一部分图像信息,我们之后看下图像测试结果. 同时在例程中还提到了一本书<a href="http://szeliski.org/Book" target="_blank" rel="noopener">Computer Vision: Algorithms and Applications, 1st ed.</a> 有中译版本, 内容还不错, 可以学习</p><h3 id="opencv-核表示的算法操作"><a href="#opencv-核表示的算法操作" class="headerlink" title="opencv 核表示的算法操作"></a>opencv 核表示的算法操作</h3><p>在之前的内容中, 我们介绍了 opencv 核操作的方式, 对于图像的每个像素点的领域操作都可以使用 opencv 提供的 <code>filter2D</code> 方式进行指定核的运算, 我们能够很容易核的操作, 也就是说我们将图像的算法操作都可以转换成图像的矩阵相乘的运算, 可以表示成<br>$$<br>g(x,y) = M \cdot f(x,y)<br>$$<br>$g(x,y)$ 用来表示结果图像, $f(x,y)$ 表示原始图像,  (x,y) 表示 列行座标, M 就是我们的图像运算矩阵,<br>我们后续都不再重复这些默认的操作, 希望能够明白</p><p>一般来说, 我们进行矩阵运算的时候都会选择方阵, 这样不会由于矩阵的方向性导致的处理结果不同, 所以我们在一般情况下都会选择<br>方阵, 比如上面进行的滤波 采用的就是 $3x3$ 尺寸的图像, 而且由于我们的图像都是离散的, 所以 实际山采用的滤波的窗口边长也是奇数值, 类似于 $3,5,7,9…(2k+1)$ 的形式</p><h3 id="均值滤波及C-代码实现"><a href="#均值滤波及C-代码实现" class="headerlink" title="均值滤波及C++ 代码实现"></a>均值滤波及C++ 代码实现</h3><h4 id="算术均值滤波"><a href="#算术均值滤波" class="headerlink" title="算术均值滤波"></a>算术均值滤波</h4><p>均值滤波(Mean Filter)的算法就是对于每一个像素点, 将其设定为取其邻域窗口内的所有像素的平均值<br>我们考虑一般形式的均值滤波器<br>$$<br>g(x,y) = \frac{1}{mn} \sum_{(i,j) \in S_{xy}} f(i,j)<br>$$</p><p>那我们开始转换一下, 则可以得到下相应的 均值滤波的矩阵<br>$$<br>M = \frac{1}{9} \left [<br>        \begin{array}{c}<br>            1 &amp; 1 &amp; 1 \ 1&amp; 1 &amp; 1 \ 1 &amp; 1 &amp; 1<br>        \end{array}<br>\right ]<br>$$</p><h4 id="加权均值滤波"><a href="#加权均值滤波" class="headerlink" title="加权均值滤波"></a>加权均值滤波</h4><p>上面给出的均值滤波让人容易的就会想一个问题, 对于不同的像素位置, 应该要赋予不同的权重值, 靠近中间的位置我们必须要考虑权重的问题, 这就是我们使用加权的均值滤波了, 一般来说我们最常用的矩阵为<br>$$<br>M = \frac{1}{16} \left [<br>        \begin{array}{c}<br>            1 &amp; 2 &amp; 1 \ 2&amp; 4 &amp; 2 \ 1 &amp; 2 &amp; 1<br>        \end{array}<br>\right ]<br>$$<br> 这种矩阵对于中心元素的权重更高, 边缘的较弱, 符合人的感觉, 具体的参数值可以自己调整, 前面的系数为矩阵内各个元素的总和, 是为了保证系数的归一.</p><p>其实均值滤波器还有很多, 有兴趣的推荐看<a href="https://www.cnblogs.com/wangguchangqing/p/6399293.html" target="_blank" rel="noopener">图像处理基础(3)：均值滤波器及其变种</a> 这篇文章, 写的很好,介绍的很详细, </p><h5 id="C-手动实现均值滤波"><a href="#C-手动实现均值滤波" class="headerlink" title="C++手动实现均值滤波"></a>C++手动实现均值滤波</h5><p>我们这里还是使用基础的 算术均值滤波, 实现起来简单一点, 边界问题也不考虑, 这样的话,我们处理的图像区域就稍微内缩小一个像素(1,1)- (m-2,n-2), 至于边界问题, 处理起来还是要看<br>看起来还是比较简单的, 我们按照给出的方法写一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认 尺寸为3的  均值滤波 // 自定义实现 暂时不考虑参数异常等 处理</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">meanFilter</span><span class="params">(<span class="keyword">const</span> cv::Mat src, <span class="keyword">int</span> ksize = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 边界不处理, 直接忽略掉 使用原始图, 拷贝, 避免直接修改</span></span><br><span class="line">    cv::Mat dst = src.clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接出, 强制向下取整, // 暴力计算每一个 邻域区间的值</span></span><br><span class="line">    <span class="keyword">int</span> k0 = ksize/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> sum[<span class="number">3</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k0;i&lt;dst.rows-k0<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=k0;j&lt;dst.cols-k0<span class="number">-1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 清空 和数组</span></span><br><span class="line">            <span class="built_in">memset</span>(sum,<span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算三个通道的结果 和值 并计算 均值写入目标图像</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>;c&lt;<span class="number">3</span>;c++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>;m&lt;ksize;m++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;ksize;n++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        sum[c] += src.at&lt;cv::Vec3b&gt;(i-k0+m,j-k0+n)[c];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 计算均值写入</span></span><br><span class="line">                dst.at&lt;cv::Vec3b&gt;(i,j)[c] = cv::saturate_cast&lt;uchar&gt;((<span class="keyword">float</span>)sum[c] /(ksize*ksize));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中间部分写的比较暴力,直接计算的窗口的和值, 然后进行均值得到的结果, 其实这里如果要考虑窗口的和值, 我们没必要重复计算一次, 每次计我们移动窗口后变化的两个边界差值即可, 这样计算上的一点点速度优化, 我们这里实现的只是一个 小小的demo , 有一定的效果即可</p><h4 id="opencv-实现均值滤波"><a href="#opencv-实现均值滤波" class="headerlink" title="opencv 实现均值滤波"></a>opencv 实现均值滤波</h4><p>我们在之前的章节提到了 使用 <code>filter2D</code> 代替普通操作的方法,在这里自然而然的想到怎么去实现, 我们还是一样的构造一个核, 然后计算结果即可, 这里使用的核还是 上面提到的 算术均值滤波的核</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filter2D 实现 meanfilter</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">meanFilterByFilter2D</span><span class="params">(<span class="keyword">const</span> cv::Mat src, <span class="keyword">int</span> ksize = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat kernel = (cv::Mat_&lt;<span class="keyword">float</span>&gt;(ksize,ksize) &lt;&lt; <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    kernel = kernel / <span class="number">9.0f</span>;</span><br><span class="line">    cv::Mat dst;</span><br><span class="line">    cv::filter2D(src,dst,src.depth(),kernel);</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里实现起来真的很简单, 这里的 <code>Mat</code> 可以直接进行矩阵的操作, 每个元素都除以了9,这样就简单很多了,  </p><p>接下来呢, opencv 对于这种基础且常见的算法肯定自己去在做了实现呀, 在我们上面也提到了opencv 的例程<a href="https://docs.opencv.org/4.3.0/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html" target="_blank" rel="noopener">Smoothing Images</a>, 提到了 一个模糊的函数, <code>cv::blur</code>, 这个函数可以调用盒式滤波器, 其实也就是均值滤波的通用形式, 前面的系数不一定而已, 我们先实现一下看下效果,  这里跟上面写成一样的形式, 看起来好看一点, 其实只需要一句话便可以实现了 没什么难度,  至于效果, 我们马上来对比<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 blur 均值滤波</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">meanFilterByBlur</span><span class="params">(<span class="keyword">const</span> cv::Mat src, <span class="keyword">int</span> ksize = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat dst;</span><br><span class="line">    cv::blur(src,dst,cv::Size(ksize,ksize));</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="均值滤波算法对比"><a href="#均值滤波算法对比" class="headerlink" title="均值滤波算法对比"></a>均值滤波算法对比</h4><p>我们上面提到了构造噪声图像, 然后我们存储了起来, 这里我们选择了一副图像进行直接给结果,  这里我们选择 高椒盐噪声的图像进行测试, 然后先看结果, 第一行表示噪声图像与原始图像的参数值, 后面的三行依次是我们进行上面提到的三种实现出来的滤波方式得到的图像与原始图像进行的对比分析, 这里还是能看到比较明显的结果的, </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353 </span><br><span class="line">image-1: psnr:26.505, mssim: B:0.603292 G:0.63888 R:0.806963 </span><br><span class="line">image-2: psnr:26.7208, mssim: B:0.605704 G:0.641344 R:0.809115 </span><br><span class="line">image-3: psnr:26.7208, mssim: B:0.605704 G:0.641344 R:0.809115</span><br></pre></td></tr></table></figure><p>我们看一下测试的代码, 还是之前的界面里面的第二个按钮执行的函数,  这里我们第一个按钮是去读取我们之前存储的噪声图像, 按名称读取,<br>然后结果的时候, 我们是按照每幅图像进行的, 这里暂时 高椒盐噪声的图像, 可以在上面给出的图中看到<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局 噪声图像数组, psnr 数组 mssim 数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> IMAGE_DIR =<span class="string">"../testimages/noise/"</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Mat&gt; <span class="title">gNoiseImg</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> psnr[<span class="number">6</span>];</span><br><span class="line">cv::Scalar mssim[<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 用于读取 测试图片</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        gNoiseImg[i] = cv::imread(IMAGE_DIR + <span class="string">"lena-"</span> + <span class="built_in">std</span>::to_string(i+<span class="number">1</span>) + <span class="string">".png"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qDebug(<span class="string">"ReadOK"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString res_temp = <span class="string">"image-%1: psnr:%2, mssim: B:%3 G:%4 R:%5 "</span>;</span><br><span class="line">    QString res_str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 均值滤波 三种方式的不同</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> TEST = <span class="number">1</span>; <span class="comment">// 使用统一的图进行测试 暂时使用 高 椒盐噪声图像</span></span><br><span class="line">    psnr[TEST] = getPSNR(gSrcImg, gNoiseImg[TEST]);</span><br><span class="line">    mssim[TEST] = getMSSIM(gSrcImg,gNoiseImg[TEST]);</span><br><span class="line"></span><br><span class="line">    res_str = res_temp.arg(<span class="string">"noise"</span>)</span><br><span class="line">            .arg(psnr[TEST])</span><br><span class="line">            .arg(mssim[TEST].val[<span class="number">0</span>])</span><br><span class="line">            .arg(mssim[TEST].val[<span class="number">1</span>])</span><br><span class="line">            .arg(mssim[TEST].val[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 噪声的参数值</span></span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line"></span><br><span class="line">    cv::Mat dst[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    dst[<span class="number">0</span>] = meanFilter(gNoiseImg[TEST]);</span><br><span class="line">    dst[<span class="number">1</span>] = meanFilterByFilter2D(gNoiseImg[TEST]);</span><br><span class="line">    dst[<span class="number">2</span>] = meanFilterByBlur(gNoiseImg[TEST]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别计算三种方式得到的滤波的效果 (结果图与 原始图比较)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        psnr[TEST] = getPSNR(gSrcImg, dst[i]);</span><br><span class="line">        mssim[TEST] = getMSSIM(gSrcImg,dst[i]);</span><br><span class="line"></span><br><span class="line">        res_str = res_temp.arg(i+<span class="number">1</span>)</span><br><span class="line">                .arg(psnr[TEST])</span><br><span class="line">                .arg(mssim[TEST].val[<span class="number">0</span>])</span><br><span class="line">                .arg(mssim[TEST].val[<span class="number">1</span>])</span><br><span class="line">                .arg(mssim[TEST].val[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 噪声的参数值</span></span><br><span class="line">        ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line"></span><br><span class="line">        cv::imwrite(IMAGE_DIR + <span class="string">"dst_"</span> + <span class="built_in">std</span>::to_string(i+<span class="number">1</span>)+<span class="string">".png"</span>,dst[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的参数也能看出来, 后面两种方法得到的结果图像是一模一样的, 我们就不再进行展示, 先看 我们实现的均值滤波与自带的均值滤波的图像区别</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1588391774254.png" alt="自己实现的均值滤波与自带的均值滤波区别"></p><p>其实吧, 总体的结果上是看不出来区别的,  主要是我们的算法上没有进行边界的处理部分, 能在图的中间部分看到稍微的几个噪声点没有处理掉, 这可能也是我们的结果参数要稍微小一点的原因, 总体来说, 我们的算法还是能够进行均值滤波的, 而且跟自带的处理结果也是一致的.</p><p>我这里就有了一个疑问, 为什么我们后面的结果就一模一样了呢,blur 去调用了 filter2D? 然后我去看两个函数的调用图,  感觉问题应该是出在 <code>cv::FilterEngine::apply</code> 函数上,在后面就没去研究了</p><blockquote><p>其实这里看了好久, 看得不是很懂, 就不再叙述了, 给出这两张函数的调用图 有兴趣的自己去看</p></blockquote><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1588391773655.png" alt="filter2D 调用图"></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1588391773641.png" alt="blur 函数调用图"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实这里原本是计划一起写完的, 但是真的太伤了, 慢慢来吧, 中间容易跑偏, 因为这边还要做比较多的东西, 所以写的越来越慢, 不过至少目前兴致还是很高的 , 昨天发在博客园的文章还被 <a href="https://www.cnblogs.com/Imageshop/" target="_blank" rel="noopener">ImageShop</a> 大佬点赞, 还是很开心的,</p><p>其实越写感觉自己越虚, 很多深入的东西自己都不能说摸透了, 还是要深入去研究了 但是写的深入了看得就少了一点, 其实我尽量写的浅一点, 因为很多人最开始就是搜索 blog 找答案的, 能看懂就行,<br>我会在后面将常用的都给写完的, 尽量更新的快, 现在每天要花大量的时间去查, 去看还要写, 希望我还能坚持下去, 加油.</p><h2 id="广告"><a href="#广告" class="headerlink" title="广告"></a>广告</h2><p>就是我这里还有之前的 函数调用图都是自己使用 doxygen 和graphiz  参考<a href="https://blog.csdn.net/benkaoya/article/details/79763668" target="_blank" rel="noopener">绘制函数调用图（call graph）（4）：doxygen + graphviz</a> 自己重新生成的opencv 的文档图, 至少在用起来还是比较简单的 这个就是一个静态的网页, 我把它放在了我的 服务器上, 这样别人也能访问有需要的可以看下, 基于 opencv 4.3.0 版本的文档图 <a href="http://schen.xyz:89/opencv" target="_blank" rel="noopener">http://schen.xyz:89/opencv</a>   </p><blockquote><p>没有备案, 也没有做防护, 别搞我</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《高斯噪声_百度百科》. 见于 2020年4月30日. <a href="https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0" target="_blank" rel="noopener">https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0</a>.</li><li>《绘制函数调用图（call graph）（4）：doxygen + graphviz_运维_许振坪的专栏-CSDN博客》. 见于 2020年5月2日. <a href="https://blog.csdn.net/benkaoya/article/details/79763668" target="_blank" rel="noopener">https://blog.csdn.net/benkaoya/article/details/79763668</a>.</li><li>知乎专栏. 《【技术综述】一文道尽传统图像降噪方法》. 见于 2020年4月29日. <a href="https://zhuanlan.zhihu.com/p/51403693" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/51403693</a>.</li><li>知乎专栏. 《可复现的图像降噪算法总结》. 见于 2020年4月29日. <a href="https://zhuanlan.zhihu.com/p/32502816" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32502816</a>.</li><li>《图像噪声的成因分类与常见图像去噪算法简介_Java_qq_27606639的博客-CSDN博客》. 见于 2020年4月30日. <a href="https://blog.csdn.net/qq_27606639/article/details/80912071" target="_blank" rel="noopener">https://blog.csdn.net/qq_27606639/article/details/80912071</a>.</li><li>《最小均方滤波器》. 收入 维基百科，自由的百科全书, 2018年3月9日. <a href="https://zh.wikipedia.org/w/index.php?title=%E6%9C%80%E5%B0%8F%E5%9D%87%E6%96%B9%E6%BB%A4%E6%B3%A2%E5%99%A8&amp;oldid=48602322" target="_blank" rel="noopener">https://zh.wikipedia.org/w/index.php?title=%E6%9C%80%E5%B0%8F%E5%9D%87%E6%96%B9%E6%BB%A4%E6%B3%A2%E5%99%A8&amp;oldid=48602322</a>.</li><li>《Computer Vision: Algorithms and Applications, 1st ed.》 见于 2020年5月1日. <a href="http://szeliski.org/Book/" target="_blank" rel="noopener">http://szeliski.org/Book/</a>.</li><li>《OpenCV: Smoothing Images》. 见于 2020年5月1日. <a href="https://docs.opencv.org/4.3.0/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html" target="_blank" rel="noopener">https://docs.opencv.org/4.3.0/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html</a>.</li><li>《openCV之中值滤波&amp;均值滤波（及代码实现）<em>人工智能</em>林小默-CSDN博客》. 见于 2020年5月1日. <a href="https://blog.csdn.net/weixin_37720172/article/details/72627543" target="_blank" rel="noopener">https://blog.csdn.net/weixin_37720172/article/details/72627543</a>.</li></ol><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
            <tag> c++ </tag>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Imagelab-1-QT 工程重构</title>
      <link href="/2020/04-29/Imagelab-1-QTopencv.html"/>
      <url>/2020/04-29/Imagelab-1-QTopencv.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="6a333a986f47f9659f0da474f6ce148376621420a997feb8e710cbd7b08de41c">bd25ed9264b080267271e137e33d0ce1adc3c6b2bac6ceb0572e33f68e974c79e34a7374044cfdd6dd6cda34443dc29b66e05da005317270a00d4a8380d153e8e349bbba3aeb2543391b9b42d90dc286d8beef59fc4f15f66e60c2592e6407fcd70b569c3bf4bdc3deca05f0147db48fa3de3a4bd0627d8b1962354a7914384b7013716b7d75409cb76495fb10ba8fb6308c5415fc0d9f32202ce15c76d37686619cd2daa317f0f2c809bcbdd825d613d770d60e1279c79e72f38e70601a4202436d6cb3c36fb0258e9a7ae3f53cc362ccb44fc0252e566e79b22c339a88760cb9411b05a0e341f4d2f5723e2a6978302d10690b14f2563caad2bbaebe213777008cd30adb77d59881c50258af19b0f914fee20092b45314fffaf3c35e3df9d0550c87b9614c4f565423b74417846c96199a910d1d3a6668019b965e21aeea136dc314b1d5ae675e4cc3e354a06a3bf2bddf9e394bce03c4e7dd316316c71926dc4394f1a114324ca86e84c9d3da824fc8678be694c3fb09366dca0a081d75a9ae81e53b93e297c6a46d2bbcd7038b6739a6964537740201a6b31a1866dbd3041bfe96376dc774fafc07313971f796b2fa8fd5853bd8a2433bb04977d116e7832b80c2505a7bb6ad80ddb0be98ff8a8d7627097d02a04fa7ef4fb4f06a4a7c29d4d622a288ecee895d6f0c97f63cfcff1022ddaee223bc4b18961ed8056d41ba40f3ff107f6b1225877ab73501e73c9c173de941b8cd4261851cbbb882b552083dd93e7bec943d89f81b03e336940891bae5d78973d822d853246dff48654fcdf134a3bcd466ac1e61dc2fe1ea7e2d1532ff6d6e11cfb4461496e163da95b18a3e7fd2cbddb3d569a190cb5cc93a5849c8c1e7b5c7704dead6dd69116dbb42088b8bfb7142aded51c56c53d89aeea6359bb9ed7f518a1ecd87430fc5db6e887401683febcd566a72f778431624b1edd6d4f479de685eaa813b921491c7d6ee60ec29ee2919e249ee0862d3ec105a596db270ad594393dff1cbac04a67cba300f67e3c6167b084203a9f20fe98659b124f0e71431c7ac37fa499e4f65be9e44d268aef90be1784250d94d00d0983dfefdabd0472763f53c3cdb69354c7238f94ee84a18e5a6de5b350ad0b15f49ed7f91cc141e39a9b33d610492347e78eb7eeedc4ee1f3349f49350a662853b37fece120651cef8ffff871f531d0e0457931ee002437cd40c21af8745dfccc564f4731985aa52ba82ccba18c812f10f369ede871864442255e449f8f878e2aa8d624b167079f5332a9703c59bae1e1ddd6462b864d6e15c8962944d6238cb5b3a0f26c5594d7eba5209142d432d965e92797b4b0dc3374eea33f13dc4a9643eb39245bc3612e6e9be0f4b0461103a5df1b91bb9ddd4a16b35abd4f8da02c8c411be50e1e5a4194a7a846ad6a275926ac1c21133d3555ee259f2fcb1d25ae73fcf1eac02b3c62487d84a62ceab540b7fad343f99accf50ff51e9fb5031415831e45641f3e2375fbd816d4066247f8e31e2e25ecc5aa10347bb6bf00dcb48bd9e99e20bf</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> encrypt </tag>
            
            <tag> hide </tag>
            
            <tag> opencv </tag>
            
            <tag> c++ </tag>
            
            <tag> qt </tag>
            
            <tag> imagelab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv-9-图像噪声以及评估指标 PSNR 与SSIM</title>
      <link href="/2020/04-28/opencv-9-noise.html"/>
      <url>/2020/04-28/opencv-9-noise.html</url>
      
        <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>我们在将 opencv 的图像显示在了 qt 的label 上, 我们能够将图显示在label 上, 用于显示我们的算法,<br>我们在 opencv 上一篇文章中介绍了 opencv 的核操作, 我们这里就要进入一个很重要的章节了,图像滤波操作, 也是图像核操作应用的一个很重要的章节, </p><p>那我们就从降噪的角度完整的讲一下, 并通过 opencv 核的方式进行图像算法操作, <a href="https://zhuanlan.zhihu.com/p/51403693" target="_blank" rel="noopener">【技术综述】一文道尽传统图像降噪方法</a> 这篇文章写的还算比较完整, 也是传统的算法的一个综述过程, </p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数字成像过程中由于电噪声以及其他因素, 导致我们获取到的图像存在噪声,噪声出现在输入部分, 在后续的每个步骤都会受到影响, 所以在数字图像处理的前面必须要进行的一个步骤就是 <a href="https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F%E9%99%8D%E5%99%AA/4136566" target="_blank" rel="noopener">图像降噪</a> </p><p>每个做信号处理的都会接触到一类问题 , 信号降噪, 让人最头疼的一门课,真是感谢老师给过, 但是后面自己用到的时候反而感觉真的好用, 原来是这样, 然后就慢慢学会了怎么使用吧..(感觉还是弱鸡)<br>知乎<a href="https://zhuanlan.zhihu.com/p/32502816" target="_blank" rel="noopener">可复现的图像降噪算法总结</a>这篇文章列出了一个能够复现的图像降噪操作算法列表, 近年来实现了的算法可以见<a href="https://github.com/wenbihan/reproducible-image-denoising-state-of-the-art" target="_blank" rel="noopener">reproducible-image-denoising-state-of-the-art</a>, 之后使用相应的文章进行算法实现吧.( 又立了一个 flag )</p><h2 id="图像降噪理论基础"><a href="#图像降噪理论基础" class="headerlink" title="图像降噪理论基础"></a>图像降噪理论基础</h2><p>图像降噪主要的目的是在进行去除图像噪声的同时保留尽可能多的主要特征, 对于人眼来说, 区分噪声还算比较容易, 但是对于计算机来说,输入的都是数据, 我怎么区分哪个是噪声, 哪个不是噪声呢, 这里就要引入噪声的理论基础了</p><h3 id="图像噪声的产生"><a href="#图像噪声的产生" class="headerlink" title="图像噪声的产生"></a>图像噪声的产生</h3><p>我们在之前的章节介绍了图像的程序系统, 实际上在成像过程中可能由于点噪声, 量化过程等造成噪声,<br>实际上的噪声主要分为三种: </p><ol><li>加性噪声: 与输入无关,  $f(x,y) = g(x,y) +n(x,y)$</li><li>乘性噪声: 与输入信号有关, $f(x,y) =  g(x,y) + n(x,y) \cdot g(x,y)$</li><li>量化噪声: 与输入无关, 在图像量化过程噪声的量化误差导致的噪声, </li></ol><p>实际上后两种很难解决, 目前处理的都是以 加性噪声为主, 属于随机的噪声信号, 根据统计学的观点, 噪声在无限长时间窗内的噪声和为0, 在第一类中的 $n(x,y)$ 随着时间存在正负信号的不确定变化.</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588225720321.png" alt="噪声零和特点"></p><blockquote><p>上图所示虚线代表真实信号，红蓝线表示的就是随机噪声信号，所有的随机噪声信号求和后结果为0。</p></blockquote><p>这里关于噪声的说明可以参考<a href="https://www.cnblogs.com/CCBB/archive/2011/01/06/1929033.html" target="_blank" rel="noopener">图像去噪算法简介</a></p><blockquote><p>噪声在理论上可以定义为“不可预测，只能用概率统计方法来认识的随机误差”。因此将图像噪声看成是多维随机过程是合适的，因而描述噪声的方法完全可以借用随机过程的描述，即用其概率分布函数和概率密度分布函数。但在很多情况下，这样的描述方法是很复杂的，甚至是不可能的。而实际应用往往也不必要。通常是用其数字特征，即均值方差，相关函数等。因为这些数字特征都可以从某些方面反映出噪声的特征。</p></blockquote><p>我认为<a href="https://blog.csdn.net/qq_27606639/article/details/80912071" target="_blank" rel="noopener">图像噪声的成因分类与常见图像去噪算法简介</a>这篇文章关于噪声的分类部分讲的还比较细, 可以参考</p><h3 id="图像噪声的模型"><a href="#图像噪声的模型" class="headerlink" title="图像噪声的模型"></a>图像噪声的模型</h3><p>由于我们认为噪声在时间尺度的随机性, 但是我们可以使用噪声的概率分布与概率密度函数进行描述, 那么我们就能将噪声根据其分布特点进行分类,<br>我们稍微介绍一下常见的噪声模型吧</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588225720295.png" alt="一些重要的噪声概率密度函数"></p><p>噪声模型主要可以分为: </p><ul><li>高斯噪声，高斯噪声模型经常被用于实践中。</li><li>脉冲噪声（椒盐噪声），图像上一个个点，也可称为散粒和尖峰噪声。</li><li>伽马噪声</li><li>瑞利噪声</li><li>指数分布噪声</li><li>均匀分布噪声</li></ul><p>这里能查到的资料很多, 可以看我们的参考部分, 内容都一样, 再写只是浪费时间和精力, 有兴趣的可以自己翻阅</p><h2 id="图像降噪操作"><a href="#图像降噪操作" class="headerlink" title="图像降噪操作"></a>图像降噪操作</h2><p>其实吧, 我就不应该讲那么多, 直接开始图像处理部分就行了, 为了开始进行图像处理, 我们要先进行一点小工作, 我们要按造以下步骤进行降噪算法的比较, </p><ol><li>选择标准图像— lena.png</li><li>添加噪声</li><li>量化噪声</li><li>降噪操作</li><li>量化结果值</li><li>比较结果</li></ol><p>在我们进行算法比对之前, 我们选择的是 lena 的图像, 加入随机噪声, 然后计算出来 一个噪声的比例, 进行降噪操作, 再次计算以下噪声参数, 看下效果值.</p><blockquote><p>如果是进行算法比较的时候, 最好选择现有的降噪的数据集进行比较, 比如, <a href="http://r0k.us/graphics/kodak/" target="_blank" rel="noopener">Kodak</a> , <a href="https://www2.eecs.berkeley.edu/Research/Projects/CS/vision/bsds/" target="_blank" rel="noopener">BSD</a></p></blockquote><h3 id="噪声添加"><a href="#噪声添加" class="headerlink" title="噪声添加"></a>噪声添加</h3><p>我们认为噪声是随机的, 我们生成随机数加在原始图像上便能够得到噪声图像, opencv 没有提供相应的实现, 但是知道原理了, 写起来都比较简单, 我比较喜欢<br><a href="https://www.cnblogs.com/wangguchangqing/p/6372025.html" target="_blank" rel="noopener">图像处理基础(1)：噪声的添加和过滤</a> 使用的方法, 他使用的是 <a href="https://zh.wikipedia.org/zh-hans/%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">梅森旋转算法</a>  来实现的伪随机算法, </p><blockquote><p>其实吧这里我也不懂, 但是随机数能用就行了, 我又不是数学家, 然后看到了 <a href="https://liam.page/2018/01/12/Mersenne-twister/" target="_blank" rel="noopener">谈谈梅森旋转：算法及其爆破</a></p></blockquote><p>这里就不重复造轮子了, 直接复制他给出的代码就好,<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加椒盐噪声 // 生成 随机 num 个 白点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSaltNoise</span><span class="params">(Mat &amp;m, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">true<span class="comment">// 随机数产生器</span></span><br><span class="line">true<span class="built_in">std</span>::random_device rd; <span class="comment">//种子</span></span><br><span class="line">true<span class="function"><span class="built_in">std</span>::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>; <span class="comment">// 随机数引擎</span></span><br><span class="line"></span><br><span class="line">true<span class="keyword">auto</span> cols = m.cols * m.channels();</span><br><span class="line"></span><br><span class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">true&#123;</span><br><span class="line">truetrue<span class="keyword">auto</span> row = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(gen() % m.rows);</span><br><span class="line">truetrue<span class="keyword">auto</span> col = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(gen() % cols);</span><br><span class="line"></span><br><span class="line">truetrue<span class="keyword">auto</span> p = m.ptr&lt;uchar&gt;(row);</span><br><span class="line">truetruep[col++] = <span class="number">255</span>;</span><br><span class="line">truetruep[col++] = <span class="number">255</span>;</span><br><span class="line">truetruep[col] = <span class="number">255</span>;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加Gussia噪声</span></span><br><span class="line"><span class="comment">// 使用指针访问</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addGaussianNoise</span><span class="params">(Mat &amp;m, <span class="keyword">int</span> mu, <span class="keyword">int</span> sigma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">true<span class="comment">// 产生高斯分布随机数发生器</span></span><br><span class="line">true<span class="built_in">std</span>::random_device rd;</span><br><span class="line">true<span class="function"><span class="built_in">std</span>::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="function"><span class="built_in">std</span>::normal_distribution&lt;&gt; <span class="title">d</span><span class="params">(mu, sigma)</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="keyword">auto</span> rows = m.rows; <span class="comment">// 行数</span></span><br><span class="line">true<span class="keyword">auto</span> cols = m.cols * m.channels(); <span class="comment">// 列数</span></span><br><span class="line"></span><br><span class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">true&#123;</span><br><span class="line">truetrue<span class="keyword">auto</span> p = m.ptr&lt;uchar&gt;(i); <span class="comment">// 取得行首指针</span></span><br><span class="line">truetrue<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">truetrue&#123;</span><br><span class="line">truetruetrue<span class="keyword">auto</span> tmp = p[j] + d(gen);</span><br><span class="line">truetruetruetmp = tmp &gt; <span class="number">255</span> ? <span class="number">255</span> : tmp;</span><br><span class="line">truetruetruetmp = tmp &lt; <span class="number">0</span> ? <span class="number">0</span> : tmp;</span><br><span class="line">truetruetruep[j] = tmp;</span><br><span class="line">truetrue&#125;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="噪声量化方法"><a href="#噪声量化方法" class="headerlink" title="噪声量化方法"></a>噪声量化方法</h3><p>这里其实涉及到图像质量评估的领域,可以参考<a href="https://blog.csdn.net/qq_23304241/article/details/80953613" target="_blank" rel="noopener">图像质量评价概述（评估指标、传统检测方法）</a>介绍的方法, 存在太多的计算方式, </p><p>我们必须选择一个量化噪声的方式进行图像质量的评估, 一般进行噪声评估手段就是噪声比(Signal to Noise Ratio,SNR),峰值信噪比(Peak Signal to Noise Ratio, PSNR) , 均方差值(Mean Square Error, MSE), 结构相似性(Structural SIMilarity, SSIM),</p><p>我们一个一个来看, 均方差值是用于比较两幅图像 K, I 的均方差值<br>$$<br>MSE=\frac{1}{mn}\sum_{i=0}^{n-1}\sum_{j=0}^{m-1}\parallel K(i,j)-I(i,j)\parallel^{2}<br>$$</p><p>峰值信噪比PSNR衡量图像失真或是噪声水平的客观标准。2个图像之间PSNR值越大，则越相似。普遍基准为30dB，30dB以下的图像劣化较为明显。定义为，<br>$$<br>PSNR=10log_{10}(\frac{MAX^{2}}{MSE})<br>$$<br>其中$MAX^2$ 为图片可能的最大像素值。如果每个像素都由 8 位二进制来表示，那么就为 255。</p><p>SNR用于描述信号与噪声的比值<br>$$<br>SNR (dB)=10 log_{10}<br>\left[<br>\frac{\sum_{x=0}^{m-1} \sum_{y=0}^{n-1}(f(x, y))^{2}}{\sum_{x=0}^{m-1} \sum_{y=0}^{n-1}(f(x, y)-\hat{f}(x, y))^{2}}\right]<br>$$</p><p>SSIM 描述两个图像的相似性, 通过三个进行比较, 亮度,对比度和结构, 参考<a href="https://zhuanlan.zhihu.com/p/50757421" target="_blank" rel="noopener">图像质量评价指标之 PSNR 和 SSIM</a></p><p>$$l(x, y)=\frac{2 \mu_{x} \mu_{y}+c_{1}}{\mu_{x}^{2}+\mu_{y}^{2}+c_{1}} c(x, y)=\frac{2 \sigma_{x} \sigma_{y}+c_{2}}{\sigma_{x}^{2}+\sigma_{y}^{2}+c_{2}} s(x, y)=\frac{\sigma_{x y}+c_{3}}{\sigma_{x} \sigma_{y}+c_{3}}$$</p><p>$$\operatorname{SSIM}(x, y)=\frac{\left(2 \mu_{x} \mu_{y}+c_{1}\right)\left(2 \sigma_{x y}+c_{2}\right)}{\left(\mu_{x}^{2}+\mu_{y}^{2}+c_{1}\right)\left(\sigma_{x}^{2}+\sigma_{y}^{2}+c_{2}\right)}$$<br>一般取$c_3 = \frac{c_2}{2}$。<br>$u_x$ 为 $x$  的均值<br>$u_y$ 为 $y$ 的均值<br>$\sigma_x^2$ 为$x$ 的方差<br>$\sigma_y^2$ 为$y$ 的方差<br>$\sigma_{xy}$ 为$x$ 和$y$ 的协方差<br>$c_1 = (k_1 L)^2, c_2=(k_2 L)^2$ 为两个常数，避免除零<br>$L$ 为像素值的范围，$(0,255)$<br>$k_1 = 0.01, k_2 = 0.03$ 为默认值<br>默认参数$\alpha = 1, \beta = 1, \gamma = 1$ </p><h3 id="opencv-计算-PSNR-和-SSIM"><a href="#opencv-计算-PSNR-和-SSIM" class="headerlink" title="opencv 计算 PSNR 和 SSIM"></a>opencv 计算 PSNR 和 SSIM</h3><p>本来不想写这么多的, 但是 opencv 给出了一个例程<a href="https://docs.opencv.org/4.3.0/dd/d3d/tutorial_gpu_basics_similarity.html" target="_blank" rel="noopener">Similarity check (PNSR and SSIM) on the GPU</a>, 提供了计算的方法, 自己不用去写了, 岂不是很爽, 所以上面就详细介绍了各个方法的使用.<br>官方给出了普通版本以及 GPU 加速的版本, 我们暂时只使用基础的版本就好,<br>PSNR返回一个浮点数，如果两个输入在30到50之间相似（越高越好）。<br>SSIM返回图像的MSSIM。这也是一个介于零和一之间的浮点数（越高越好），但是每个通道都有一个浮点数。因此，我们返回一个Scalar OpenCV数据结构：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPSNR</span><span class="params">(<span class="keyword">const</span> Mat&amp; I1, <span class="keyword">const</span> Mat&amp; I2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat s1;</span><br><span class="line">    absdiff(I1, I2, s1);       <span class="comment">// |I1 - I2|</span></span><br><span class="line">    s1.convertTo(s1, CV_32F);  <span class="comment">// cannot make a square on 8 bits</span></span><br><span class="line">    s1 = s1.mul(s1);           <span class="comment">// |I1 - I2|^2</span></span><br><span class="line">    Scalar s = sum(s1);         <span class="comment">// sum elements per channel</span></span><br><span class="line">    <span class="keyword">double</span> sse = s.val[<span class="number">0</span>] + s.val[<span class="number">1</span>] + s.val[<span class="number">2</span>]; <span class="comment">// sum channels</span></span><br><span class="line">    <span class="keyword">if</span>( sse &lt;= <span class="number">1e-10</span>) <span class="comment">// for small values return zero</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span>  mse =sse /(<span class="keyword">double</span>)(I1.channels() * I1.total());</span><br><span class="line">        <span class="keyword">double</span> psnr = <span class="number">10.0</span>*<span class="built_in">log10</span>((<span class="number">255</span>*<span class="number">255</span>)/mse);</span><br><span class="line">        <span class="keyword">return</span> psnr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Scalar <span class="title">getMSSIM</span><span class="params">( <span class="keyword">const</span> Mat&amp; i1, <span class="keyword">const</span> Mat&amp; i2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> C1 = <span class="number">6.5025</span>, C2 = <span class="number">58.5225</span>;</span><br><span class="line">    <span class="comment">/***************************** INITS **********************************/</span></span><br><span class="line">    <span class="keyword">int</span> d     = CV_32F;</span><br><span class="line">    Mat I1, I2;</span><br><span class="line">    i1.convertTo(I1, d);           <span class="comment">// cannot calculate on one byte large values</span></span><br><span class="line">    i2.convertTo(I2, d);</span><br><span class="line">    Mat I2_2   = I2.mul(I2);        <span class="comment">// I2^2</span></span><br><span class="line">    Mat I1_2   = I1.mul(I1);        <span class="comment">// I1^2</span></span><br><span class="line">    Mat I1_I2  = I1.mul(I2);        <span class="comment">// I1 * I2</span></span><br><span class="line">    <span class="comment">/*************************** END INITS **********************************/</span></span><br><span class="line">    Mat mu1, mu2;   <span class="comment">// PRELIMINARY COMPUTING</span></span><br><span class="line">    GaussianBlur(I1, mu1, Size(<span class="number">11</span>, <span class="number">11</span>), <span class="number">1.5</span>);</span><br><span class="line">    GaussianBlur(I2, mu2, Size(<span class="number">11</span>, <span class="number">11</span>), <span class="number">1.5</span>);</span><br><span class="line">    Mat mu1_2   =   mu1.mul(mu1);</span><br><span class="line">    Mat mu2_2   =   mu2.mul(mu2);</span><br><span class="line">    Mat mu1_mu2 =   mu1.mul(mu2);</span><br><span class="line">    Mat sigma1_2, sigma2_2, sigma12;</span><br><span class="line">    GaussianBlur(I1_2, sigma1_2, Size(<span class="number">11</span>, <span class="number">11</span>), <span class="number">1.5</span>);</span><br><span class="line">    sigma1_2 -= mu1_2;</span><br><span class="line">    GaussianBlur(I2_2, sigma2_2, Size(<span class="number">11</span>, <span class="number">11</span>), <span class="number">1.5</span>);</span><br><span class="line">    sigma2_2 -= mu2_2;</span><br><span class="line">    GaussianBlur(I1_I2, sigma12, Size(<span class="number">11</span>, <span class="number">11</span>), <span class="number">1.5</span>);</span><br><span class="line">    sigma12 -= mu1_mu2;</span><br><span class="line">    Mat t1, t2, t3;</span><br><span class="line">    t1 = <span class="number">2</span> * mu1_mu2 + C1;</span><br><span class="line">    t2 = <span class="number">2</span> * sigma12 + C2;</span><br><span class="line">    t3 = t1.mul(t2);              <span class="comment">// t3 = ((2*mu1_mu2 + C1).*(2*sigma12 + C2))</span></span><br><span class="line">    t1 = mu1_2 + mu2_2 + C1;</span><br><span class="line">    t2 = sigma1_2 + sigma2_2 + C2;</span><br><span class="line">    t1 = t1.mul(t2);               <span class="comment">// t1 =((mu1_2 + mu2_2 + C1).*(sigma1_2 + sigma2_2 + C2))</span></span><br><span class="line">    Mat ssim_map;</span><br><span class="line">    divide(t3, t1, ssim_map);      <span class="comment">// ssim_map =  t3./t1;</span></span><br><span class="line">    Scalar mssim = mean( ssim_map ); <span class="comment">// mssim = average of ssim map</span></span><br><span class="line">    <span class="keyword">return</span> mssim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="算法噪声数据"><a href="#算法噪声数据" class="headerlink" title="算法噪声数据"></a>算法噪声数据</h3><p>我们完成了噪声添加以及噪声的量化, 我们来试一下, 给图像随机添加一定的噪声, 然后看下相应的参数变化情况对比来看就好</p><h4 id="椒盐噪声测试"><a href="#椒盐噪声测试" class="headerlink" title="椒盐噪声测试"></a>椒盐噪声测试</h4><p>我们先来测试椒盐噪声 分别计算没有噪声的图, 以及添加了 1000个 和10000个噪声的数据结果, 并将后面两个显示出来 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 添加椒盐噪声 并计算 PSNR和 SSIM</span></span><br><span class="line">    cv::Mat salt_img;</span><br><span class="line">    <span class="keyword">double</span> psnr = <span class="number">0</span>;</span><br><span class="line">    cv::Scalar mssim;</span><br><span class="line"></span><br><span class="line">    QString res_temp = <span class="string">"Salt-%1 : psnr:%2, mssim: B:%3 G:%4 R:%5 "</span>;</span><br><span class="line">    QString res_str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算三组图像的参数 0, 1000, 10000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制原始图像, 添加噪声, 计算 psnr和ssim  显示在 ui上</span></span><br><span class="line">    salt_img = gSrcImg.clone();</span><br><span class="line">    addSaltNoise(salt_img,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    psnr = getPSNR(gSrcImg, salt_img);</span><br><span class="line">    mssim = getMSSIM(gSrcImg,salt_img);</span><br><span class="line">    res_str = res_temp.arg(<span class="number">0</span>)</span><br><span class="line">                        .arg(psnr)</span><br><span class="line">                        .arg(mssim.val[<span class="number">0</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">1</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">2</span>]);</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line"></span><br><span class="line">    salt_img = gSrcImg.clone();</span><br><span class="line">    addSaltNoise(salt_img,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    psnr = getPSNR(gSrcImg, salt_img);</span><br><span class="line">    mssim = getMSSIM(gSrcImg,salt_img);</span><br><span class="line">    res_str = res_temp.arg(<span class="number">1000</span>)</span><br><span class="line">                        .arg(psnr)</span><br><span class="line">                        .arg(mssim.val[<span class="number">0</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">1</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">2</span>]);</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左侧显示 1000 噪声 右侧显示 10000 噪声</span></span><br><span class="line">    ShowMatOnQtLabel(salt_img,ui-&gt;lb_src);</span><br><span class="line"></span><br><span class="line">    salt_img = gSrcImg.clone();</span><br><span class="line">    addSaltNoise(salt_img,<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    psnr = getPSNR(gSrcImg, salt_img);</span><br><span class="line">    mssim = getMSSIM(gSrcImg,salt_img);</span><br><span class="line">    res_str = res_temp.arg(<span class="number">10000</span>)</span><br><span class="line">                        .arg(psnr)</span><br><span class="line">                        .arg(mssim.val[<span class="number">0</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">1</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">2</span>]);</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line"></span><br><span class="line">    ShowMatOnQtLabel(salt_img,ui-&gt;lb_dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588225720510.png" alt="1000 和 10000 的椒盐噪声对比"></p><p>我们可以直接计算得到椒盐噪声  psnr 和 ssim 都是越大越好的, 可以明显的看到图像质量退化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Salt-0 : psnr:0, mssim: B:1 G:1 R:1 </span><br><span class="line">Salt-1000 : psnr:27.7528, mssim: B:0.865341 G:0.870555 R:0.914122 </span><br><span class="line">Salt-10000 : psnr:17.8062, mssim: B:0.311999 G:0.327485 R:0.493874</span><br></pre></td></tr></table></figure><h4 id="高斯噪声测试"><a href="#高斯噪声测试" class="headerlink" title="高斯噪声测试"></a>高斯噪声测试</h4><p>高斯噪声我们测试了四组 分别使用参数(0,1) (0,10)(10,1)(10,10) 作为高斯参数, 最终得到后面的图, 然后计算得到的结果, 我们做的结果比较简单, 可以参考<a href="https://blog.csdn.net/u012936765/article/details/53200918" target="_blank" rel="noopener">数字图像处理——添加高斯噪声&amp;椒盐噪声</a>, 给出了很多的图, 可以参考学</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 添加高斯噪声 并计算 PSNR和 SSIM</span></span><br><span class="line">    cv::Mat guass_img;</span><br><span class="line">    <span class="keyword">double</span> psnr = <span class="number">0</span>;</span><br><span class="line">    cv::Scalar mssim;</span><br><span class="line"></span><br><span class="line">    QString res_temp = <span class="string">"gauss-%1- %2 : psnr:%3, mssim: B:%4 G:%5 R:%6 "</span>;</span><br><span class="line">    QString res_str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算三组图像的参数 (0,1) (0,10), (10,1), (10,10)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制原始图像, 添加噪声, 计算 psnr和ssim  显示在 ui上</span></span><br><span class="line">    guass_img = gSrcImg.clone();</span><br><span class="line">    addGaussianNoise(guass_img,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    psnr = getPSNR(gSrcImg, guass_img);</span><br><span class="line">    mssim = getMSSIM(gSrcImg,guass_img);</span><br><span class="line">    res_str = res_temp.arg(<span class="number">0</span>)</span><br><span class="line">                        .arg(<span class="number">1</span>)</span><br><span class="line">                        .arg(psnr)</span><br><span class="line">                        .arg(mssim.val[<span class="number">0</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">1</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">2</span>]);</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line">    guass_img = gSrcImg.clone();</span><br><span class="line">    addGaussianNoise(guass_img,<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    psnr = getPSNR(gSrcImg, guass_img);</span><br><span class="line">    mssim = getMSSIM(gSrcImg,guass_img);</span><br><span class="line">    res_str = res_temp.arg(<span class="number">0</span>)</span><br><span class="line">                        .arg(<span class="number">10</span>)</span><br><span class="line">                        .arg(psnr)</span><br><span class="line">                        .arg(mssim.val[<span class="number">0</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">1</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">2</span>]);</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line"></span><br><span class="line">    guass_img = gSrcImg.clone();</span><br><span class="line">    addGaussianNoise(guass_img,<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    psnr = getPSNR(gSrcImg, guass_img);</span><br><span class="line">    mssim = getMSSIM(gSrcImg,guass_img);</span><br><span class="line">    res_str = res_temp.arg(<span class="number">10</span>)</span><br><span class="line">                        .arg(<span class="number">1</span>)</span><br><span class="line">                        .arg(psnr)</span><br><span class="line">                        .arg(mssim.val[<span class="number">0</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">1</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">2</span>]);</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line"></span><br><span class="line">    guass_img = gSrcImg.clone();</span><br><span class="line">    addGaussianNoise(guass_img,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    psnr = getPSNR(gSrcImg, guass_img);</span><br><span class="line">    mssim = getMSSIM(gSrcImg,guass_img);</span><br><span class="line">    res_str = res_temp.arg(<span class="number">10</span>)</span><br><span class="line">                        .arg(<span class="number">10</span>)</span><br><span class="line">                        .arg(psnr)</span><br><span class="line">                        .arg(mssim.val[<span class="number">0</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">1</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">2</span>]);</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588226481095.png" alt="四组高斯测试结果对比"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gauss-0- 1 : psnr:46.8791, mssim: B:0.991811 G:0.991622 R:0.992751 </span><br><span class="line">gauss-0- 10 : psnr:28.1229, mssim: B:0.614219 G:0.608773 R:0.648285 </span><br><span class="line">gauss-10- 1 : psnr:28.5293, mssim: B:0.978448 G:0.980308 R:0.987926 </span><br><span class="line">gauss-10- 10 : psnr:25.3511, mssim: B:0.605665 G:0.600491 R:0.646768</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原本想把滤波一起做了的, 但是越写越, 就不做太多的处理了, 我们算是介绍了噪声的来源, 噪声的模型, 以及个噪声的量化方式,<br>然后介绍了图像添加噪声的方法 我们分别给图像添加椒盐噪声与高斯噪声, 然后分别量化了噪声的结果值, 进行对比展示, </p><p>示例的图不是很多, 程序是在代码库里面的, 可以直接去自己实现, 然后进行 进行更多图的展示</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《高斯噪声_百度百科》. 见于 2020年4月30日. <a href="https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0" target="_blank" rel="noopener">https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0</a>.</li><li>知乎专栏. 《【技术综述】一文道尽传统图像降噪方法》. 见于 2020年4月29日. <a href="https://zhuanlan.zhihu.com/p/51403693" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/51403693</a>.</li><li>知乎专栏. 《可复现的图像降噪算法总结》. 见于 2020年4月29日. <a href="https://zhuanlan.zhihu.com/p/32502816" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32502816</a>.</li><li>《梅森旋转算法》. 收入 维基百科，自由的百科全书, 2019年11月4日. <a href="https://zh.wikipedia.org/w/index.php?title=%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95&amp;oldid=56745942" target="_blank" rel="noopener">https://zh.wikipedia.org/w/index.php?title=%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95&amp;oldid=56745942</a>.</li><li>《实现灰度图像峰值信噪比计算<em>人工智能</em>松子茶的专栏-CSDN博客》. 见于 2020年4月30日. <a href="https://blog.csdn.net/songzitea/article/details/17529445" target="_blank" rel="noopener">https://blog.csdn.net/songzitea/article/details/17529445</a>.</li><li>《数字图像处理-噪声 - Mohanson》. 见于 2020年4月30日. <a href="http://accu.cc/content/pil/noise/" target="_blank" rel="noopener">http://accu.cc/content/pil/noise/</a>.</li><li>《图像处理基础(1)：噪声的添加和过滤 - Brook_icv - 博客园》. 见于 2020年4月30日. <a href="https://www.cnblogs.com/wangguchangqing/p/6372025.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangguchangqing/p/6372025.html</a>.</li><li>《图像处理PSNR及其计算（OpenCV和matlab实现）<em>人工智能</em>无机器不学习-加大码的分享-CSDN博客》. 见于 2020年4月30日. <a href="https://blog.csdn.net/laoxuan2011/article/details/51519062" target="_blank" rel="noopener">https://blog.csdn.net/laoxuan2011/article/details/51519062</a>.</li><li>《图像的 SNR 和 PSNR 的计算 - rldts - 博客园》. 见于 2020年4月30日. <a href="https://www.cnblogs.com/qrlozte/p/5340216.html" target="_blank" rel="noopener">https://www.cnblogs.com/qrlozte/p/5340216.html</a>.</li><li>《图像去噪算法简介 - InfantSorrow - 博客园》. 见于 2020年4月29日. <a href="https://www.cnblogs.com/CCBB/archive/2011/01/06/1929033.html" target="_blank" rel="noopener">https://www.cnblogs.com/CCBB/archive/2011/01/06/1929033.html</a>.</li><li>《图像噪声的成因分类与常见图像去噪算法简介_Java_qq_27606639的博客-CSDN博客》. 见于 2020年4月30日. <a href="https://blog.csdn.net/qq_27606639/article/details/80912071" target="_blank" rel="noopener">https://blog.csdn.net/qq_27606639/article/details/80912071</a>.</li><li>《图像质量评估指标 SSIM / PSNR / MSE_人工智能_兔角与禅-CSDN博客》. 见于 2020年4月30日. <a href="https://blog.csdn.net/edogawachia/article/details/78756680" target="_blank" rel="noopener">https://blog.csdn.net/edogawachia/article/details/78756680</a>.</li><li>《图像质量评价概述（评估指标、传统检测方法）_人工智能_qq_23304241的博客-CSDN博客》. 见于 2020年4月30日. <a href="https://blog.csdn.net/qq_23304241/article/details/80953613" target="_blank" rel="noopener">https://blog.csdn.net/qq_23304241/article/details/80953613</a>.</li><li>《影像降噪》. 收入 维基百科，自由的百科全书, 2018年9月20日. <a href="https://zh.wikipedia.org/w/index.php?title=%E5%BD%B1%E5%83%8F%E9%99%8D%E5%99%AA&amp;oldid=51354600" target="_blank" rel="noopener">https://zh.wikipedia.org/w/index.php?title=%E5%BD%B1%E5%83%8F%E9%99%8D%E5%99%AA&amp;oldid=51354600</a>.</li></ol><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
            <tag> c++ </tag>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Imagelab-0-QT label显示 opencv 图像</title>
      <link href="/2020/04-27/Imagelab-0-init.html"/>
      <url>/2020/04-27/Imagelab-0-init.html</url>
      
        <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>这其实也是 opencv 处理图像的系列, 只是想我们在进一步复杂化我们的代码之前, 每次给出代码我们都要给出很多, 然后窗口的显示上也有很多不必要的东西, 我们为了后面进行更好的算法效果以及算法执行, 我们先规划一下程序, 写出来一个界面程序出来, 这样的话, 我们之后的程序部分只需要给出一个函数的部分就好, 我们的程序算法在增加的时候, 将功能做到一个一个的菜单里面来, 这样一边处理算法, 一边写出界面图像..</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[toc]</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我们主要将图形界面部分使用代码来实现, 这样不需要进行编译便能够大概知道结果..</p><p>我们在进行复杂的界面之前, 我们先实现一个简单的工程, 能够使用 opencv 读取图片, 然后显示在 qt 的 label 控件 上面,</p><h3 id="QT-图像格式"><a href="#QT-图像格式" class="headerlink" title="QT 图像格式"></a>QT 图像格式</h3><p>在 qt 中提供了几种图像显示的方式,可以看这篇文章<a href="https://blog.csdn.net/zzwdkxx/article/details/39480559" target="_blank" rel="noopener">关于 QPixmap/QImage/QPicture</a>, 详细的介绍了几种格式的使用方法,<br>QT 自带的 <code>QImage</code> 和 <code>QPixmap</code>, 都是支持读取图像的,可以直接用于显示图像, 但是呢, 我们后续还要进行复杂的算法实现, 所以我们还是要转回到 opencv 的怀抱中来, 那么我们不可避免的需要进行数据图像格式之间的互相转换, 目前大多说使用的方式都是 opencv 的 Mat 格式与 QT QPixmap 格式之间的转换, 按后显示到 QT 的 label 上面, 我们先来实现一下:</p><h3 id="UI-界面设计"><a href="#UI-界面设计" class="headerlink" title="UI 界面设计"></a>UI 界面设计</h3><p>这里稍微提一下 QT Designer, 我们可以通过托拽的方式实现界面的设计, 也提供了很多组件让我们选择, 我们先暂时使用这种比较简单的方式进行, 后面逐渐介绍更为复杂的操作.</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588137693125.png" alt="QT UI 设计"></p><p>这里我们使用数字 1,2,3,4, 标记了四个区域, 就是我们常用的区域了</p><ul><li><ol><li>编辑区域, 可以编辑与托拽, 能够预览</li></ol></li><li><ol start="2"><li>控件结构树, 各个控件的从属结构, 名称就是 <code>ObjectName</code> 能够在程序使用控件名进行操控</li></ol></li><li><ol start="3"><li>属性区域,能够直接调整相关的参数, 也可以在程序中进行调整各种属性</li></ol></li><li><ol start="4"><li>控件区域, 不同种类的控件, 可以用于托拽, 直接显示在窗口中..</li></ol></li></ul><p>具体的实现方式不用去深究, 且通过托拽改变 <code>.ui</code> 文件, 实际上就是 一个 xml 格式的文件, QT 通过 <code>uic</code> 会将 <code>xxx.ui</code> 转换成 <code>ui_xxx.h</code> 文件, 我们通过引用即可直接操控控件了,</p><blockquote><p>如果我们改变了 ui, 但是运行之后没有更新, 在工程山强制 qmake 一下就能解决了</p></blockquote><p>在我们这个工程中, 我们托拽了两个 <code>QLabel</code> 组件和两个 <code>QPushButton</code> 组件, 相应的可以在上图的 2 区域看到对象名称..</p><ul><li>MainWindow:<ul><li>geometry: 0,0,960,540 : 我们运行的窗口尺寸</li><li>windowsTitle: “ImageLab”</li></ul></li><li>lb_src:<ul><li>geometry: 20,30,400,400 用于指定控件的左上角位置和 尺寸宽高, 我们使用这个参数指定即可</li><li>frameShape: WinPanel</li></ul></li><li>lb_dst:<ul><li>geometry: 470,30,400,400 用于指定控件的左上角位置和 尺寸宽高, 我们使用这个参数指定即可</li><li>frameShape: WinPanel</li></ul></li><li>btn_test1,btn_test2: 都是默认托拽的 , 尺寸默认, 位置 随意就好, 后面用于我们进行一下测试算法 暂时忽略</li><li>pt_log: 多行文本, 用于显示一些结果信息, 测试过程中的一些输出</li></ul><p>我们这个界面也没有布局, 就是很简单的把东西给显示出来, 在编辑之后 按 <code>Shift+Alt+R</code>能够预览界面,<br>如果有布局之类的需要及时查看, 我们这里就是简单的 ui , 布局什么样 得到的就是什么样子</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588137693113.png" alt="预览 UI 界面"></p><p>我们后面的测试可能就是左边显示原始图像, 右边显示运算之后 的图像, 我们来实现一下</p><p>这里关于 ui 界面的设计 只是稍微提一下, 你们可以直接查看其他的文章介绍的使用方法, 简单点的可以看<a href="https://blog.csdn.net/a10929/article/details/78114261" target="_blank" rel="noopener">使用 Qt Designer 来设计界面</a>和<a href="https://blog.csdn.net/weixin_36340947/article/details/75691506" target="_blank" rel="noopener">使用 Qt Designer 创建界面</a></p><h3 id="信号与槽-实现-UI-点击事件"><a href="#信号与槽-实现-UI-点击事件" class="headerlink" title="信号与槽 实现 UI 点击事件"></a>信号与槽 实现 UI 点击事件</h3><p>在我们进行显示图像之前, 我们稍微介绍一下 QT 的信号与槽的实现方式, QT 最 NB 的地方实现了信号与槽 , 简单理解就是, 我们提前将信号与一个槽(函数)声明连接, 然后我们点击一个按钮 会发射一个信号, 然后经过 QT 的信号处理机制 就能够调用我们提前设定的函数了,</p><blockquote><p>PS: 只是粗略 的这么看就行, 具体还要复杂很多, 后面再说</p></blockquote><p>我们简单实现一下 这个功能, 点击输出我们点击可哪个按钮..<br>我们点击 <code>测试按钮1: btn_test1</code>调用一个函数 <code>testFunc1</code>, 然后在结果框输出<code>点击了按钮1</code> ,</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588137693115.gif" alt="点击输出效果预览"></p><p>,我们只看 核心的代码部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainwindow.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_mainwindow.h"</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">   : QMainWindow(parent)</span><br><span class="line">   , ui(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">   ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设定信号与槽 连接</span></span><br><span class="line">   connect(ui-&gt;btn_test1,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;MainWindow::testFunc1);</span><br><span class="line">   connect(ui-&gt;btn_test2,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;MainWindow::testFunc2);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化 ui</span></span><br><span class="line">   ui-&gt;pt_log-&gt;clear();  <span class="comment">// 清除框内输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ui-&gt;pt_log-&gt;appendPlainText(<span class="string">"你点击了 测试按钮 1 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ui-&gt;pt_log-&gt;appendPlainText(<span class="string">"你点击了 测试按钮 2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// mainwindow.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span>;</span> &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span> <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">   Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">testFunc1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">testFunc2</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   MainWindow(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">   ~MainWindow();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行主窗口 用于显示界面 ui</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">   MainWindow w;</span><br><span class="line">   w.show();</span><br><span class="line">   <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看 代码仓库 <a href="https://github.com/SChen1024/Imagelab/releases/tag/V0.1.0" target="_blank" rel="noopener">SChen1024/ImageLab V0.1.0</a></p><p>我们的程序一直是同步提交到 github 和 gitee 的, 有什么问题可以去看代码</p><h3 id="QImage-和-QPixmap-显示图像"><a href="#QImage-和-QPixmap-显示图像" class="headerlink" title="QImage 和 QPixmap 显示图像"></a>QImage 和 QPixmap 显示图像</h3><p>上面就是在简单的测试一下, 那我们 现在就开始正式的工作 首先看下直接读取文件的方式,<br>我们将上一节中 输出语句的函数部分换成加载图片, 能够得到下面的函数部分, 进而运行就能够得到结果图</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图片路径</span></span><br><span class="line">QString lena_img = <span class="string">"../testimages/lena.png"</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QPixmap pixmap;</span><br><span class="line">    pixmap.load(lena_img);</span><br><span class="line"></span><br><span class="line">    ui-&gt;lb_src-&gt;setPixmap(pixmap);</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(<span class="string">"左侧使用 QPixmap load 图像数据1 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QImage <span class="title">image</span><span class="params">(lena_img)</span></span>;</span><br><span class="line">    ui-&gt;lb_dst-&gt;setPixmap(QPixmap::fromImage(image));</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(<span class="string">"右侧使用 QImage 转换成 QPixmap 进行显示2 "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 label 只能显示 pixmap 图像, 而且十分简单操作, 而 QImage 也是转换成 QPixmap 之后才做的显示, 不过在可以去看<a href="https://blog.csdn.net/feiyangyangfei/article/details/8485797" target="_blank" rel="noopener">QImage 与 QPixmap 加载图片 效果 .</a>中介绍了其他的方式显示图像, 我们就不去深究了,</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588137693563.png" alt="加载图像显示"></p><h3 id="QT-显示-opencv-mat-图像"><a href="#QT-显示-opencv-mat-图像" class="headerlink" title="QT 显示 opencv mat 图像"></a>QT 显示 opencv mat 图像</h3><p>终于终于到了我们这篇文章的重点了, 其实经过上面的铺垫, 我们 opencv 读取图像之后要做的就是 将 mat 图像转换成 QImage 或者 QPixmap 图像就好了, 多一步转换过程, 目前没有找到 mat 直接转换成 QPixmap 的方式 , 目前的实现都是 转换成 QImage 然后再转换的方式,</p><p>直接搜索 opencv Mat 转 QImage 能找到很多结果, 其实呢 原理都很简单, 根据原始图像的通道数目将图像转换成相应的 QImage 格式, 比如 3 通道的 rgb 图像转换 <code>QImage image(mat.data, mat.cols, mat.rows,static_cast&lt;int&gt;(mat.step),QImage::Format_RGB888);</code> 我们能够得到这样的结果, 很简单就能实现, 获取图像的宽度, 高度, 以及最重要的 <code>data</code> 也就是图像的数据指针, 然后依次转换成我们需要的 QImage 图像即可, 值得注意的是, opencv 是 BGR 图像的顺序, 所以最后要进行颜色通道的转换, 转换成 rgb 不然颜色会有点奇怪..</p><p>具体的参数可以参考我之前的博文, 关于 mat 的 step 属性可以参考<a href="https://blog.csdn.net/qianqing13579/article/details/45318279" target="_blank" rel="noopener">OpenCV 中 Mat 属性 step，size，step1，elemSize，elemSize1</a></p><p>这里附上 opencv Mat 与 QImage 的互相转换, 这里没有使用 if 为了更好看</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @fn  QImage CvMat2QImage(const cv::Mat &amp; mat)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   将opencv mat 转换成 QT image</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment"> * @date    2019/12/19</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   mat The matrix</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  A QImage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">QImage <span class="title">CvMat2QImage</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;mat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 图像的通道</span></span><br><span class="line">    <span class="keyword">int</span> channel = mat.channels();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设立一个表 直接查询 其中 0 2 是无效值 1 3 4 对应的转换值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, QImage::Format&gt; img_cvt_map &#123;</span><br><span class="line">        &#123; <span class="number">1</span>, QImage::Format_Grayscale8 &#125;,</span><br><span class="line">        &#123; <span class="number">3</span>, QImage::Format_RGB888 &#125;,</span><br><span class="line">        &#123; <span class="number">4</span>, QImage::Format_ARGB32 &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">QImage <span class="title">image</span><span class="params">(mat.data, mat.cols, mat.rows,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(mat.step),</span></span></span><br><span class="line"><span class="function"><span class="params">                 img_cvt_map.at(channel))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三通道图像 值做 通道转换</span></span><br><span class="line">    <span class="keyword">return</span> channel == <span class="number">3</span> ? image.rgbSwapped() : image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @fn  static cv::Mat QImage2CvMat(const QImage &amp;image);</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @brief   QT Image 转换成 cv Mat 结构</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">* @date    2019/12/19</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param   image   The image</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @return  A cv::Mat</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">QImage2CvMat</span><span class="params">(<span class="keyword">const</span> QImage &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat mat;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;QImage::Format, <span class="keyword">int</span>&gt; img_cvt_map&#123;</span><br><span class="line">        &#123; QImage::Format_Grayscale8, <span class="number">1</span> &#125;,</span><br><span class="line">        &#123; QImage::Format_RGB888, <span class="number">3</span> &#125;,</span><br><span class="line">        &#123; QImage::Format_ARGB32, <span class="number">4</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cv::Mat(image.height(), image.width(),img_cvt_map.at(image.format()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了便于区分, 我们在处理图像的时候, 在图上分别显示一个字符串, opencv 的显示图像我们已经介绍过了, QT QPixmap 显示 字符串可以参考<a href="https://www.cnblogs.com/linuxAndMcu/p/11059635.html" target="_blank" rel="noopener">Qt 2D 绘图之三：绘制文字、路径、图像、复合模式</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图片路径</span></span><br><span class="line">QString lena_img = <span class="string">"../testimages/lena.png"</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QPixmap pixmap;</span><br><span class="line">    pixmap.load(lena_img);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在图上绘制文字</span></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(&amp;pixmap)</span></span>;</span><br><span class="line">    painter.setPen(QColor(Qt::yellow));</span><br><span class="line">    painter.drawText(<span class="number">100</span>,<span class="number">100</span>,<span class="string">"QT QPixmap"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ui-&gt;lb_src-&gt;setPixmap(pixmap);</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(<span class="string">"左侧使用 QPixmap load 图像数据1 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat mat = cv::imread(<span class="string">"../testimages/lena.png"</span>);</span><br><span class="line">    <span class="comment">// 在图上显示文字</span></span><br><span class="line">    cv::putText(mat,<span class="string">"OpenCV Mat"</span>,cv::Point(<span class="number">100</span>,<span class="number">100</span>),cv::FONT_HERSHEY_COMPLEX,<span class="number">1.0</span>, cv::Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">    QImage image = CvMat2QImage(mat);</span><br><span class="line"></span><br><span class="line">    ui-&gt;lb_dst-&gt;setPixmap(QPixmap::fromImage(image));</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(<span class="string">"右侧使用 Mat --&gt; QImage --&gt; QPixmap 进行显示2 "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行得到的结果图片</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588137693556.png" alt="QT 显示 opencv 图像"></p><p>opencv 就是 使用 mat 读取图像, 然后 转换成 QImage, 转换通道 ,再转换成 QPixmap 最后显示在 QLabel 上,</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
            <tag> c++ </tag>
            
            <tag> qt </tag>
            
            <tag> imagelab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器站点列表</title>
      <link href="/2020/04-26/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%99%E7%82%B9%E5%88%97%E8%A1%A8.html"/>
      <url>/2020/04-26/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%99%E7%82%B9%E5%88%97%E8%A1%A8.html</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>目前 Aliserver 服务器负责托管 WHUHoude 工程下的所有网站主要分<br>由于网站未进行备案细节, 所以网站无法直接通过80端口访问</p><p>网站的具体配置信息, 可参考博文, 主要是部署了 旧版本的asp 程序和 少量的php 网站</p><h2 id="网站列表"><a href="#网站列表" class="headerlink" title="网站列表"></a>网站列表</h2><p>asp网站使用的是系统自带的 IIS 开启了88 端口, 主要是旧版本的网站可以通过<a href="http://whupmc.cn:88" target="_blank" rel="noopener">whupmc.cn</a> 域名访问, </p><p>php 网站使用的 phpstudy 便携版本搭建的  Apache + MySQL</p><p>主要的网站列表是:</p><p><img src="/2020/04-26/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%99%E7%82%B9%E5%88%97%E8%A1%A8/1587891235527.table.html" alt="表格"></p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Person </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> server </tag>
            
            <tag> html </tag>
            
            <tag> asp </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv-8-图像核与蒙板操作</title>
      <link href="/2020/04-25/opencv-8-kernel.html"/>
      <url>/2020/04-25/opencv-8-kernel.html</url>
      
        <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>在准备开始的时候, 我大概列了一个<a href="https://schen1024.github.io/2020/04-20/opencv-bloglist.html">opencv 章节列表</a>, 按照章节进行写, 写到某些部分的时候再具体调整章节内容,  完成了之后, 会将具体的章节链接更新到这个列表中 算是作为一个目录吧.<br>有的章节写到很快, 有的章节写的很慢,  但是我会坚持一直写下去</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[toc]</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>按照我的写作计划, 之前算是完成了前面的大的章节, 我们开始正式进入图像处理的章节了, 在之前的章节中,我们介绍了图像的遍历操作, 我们从一个基础的问题出发, 我们对于每一点的像素值, 每个点减去他上面边的点的值作为结果值, 那我们会得到什么图呢,</p><h3 id="图像下侧差分"><a href="#图像下侧差分" class="headerlink" title="图像下侧差分"></a>图像下侧差分</h3><p>这我们为了简单运算吧, 我们提前将结果初始化为0, 然后将每一行的像素减去它上面的像素, 作为结果当前点的颜色值 我们看下代码以及跑起来看下会是什么结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置 要显示的图像路径</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lena_png = <span class="string">"./TestImages/lena.png"</span>;</span><br><span class="line">    cv::Mat src_img = cv::imread(lena_png);</span><br><span class="line">    cv::Mat res_img = cv::Mat::zeros(src_img.size(), CV_8UC3);</span><br><span class="line">    <span class="comment">// 初始化所有结果为 0 第一行不存在上一行, 默认为0  彩色图像 每个通道都计算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; src_img.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src_img.cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; src_img.channels(); k++)</span><br><span class="line">            &#123;</span><br><span class="line">                res_img.at&lt;cv::Vec3b&gt;(i, j)[k] = src_img.at&lt;cv::Vec3b&gt;(i, j)[k] - src_img.at&lt;cv::Vec3b&gt;(i<span class="number">-1</span>, j)[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::imshow(<span class="string">"src_img"</span>, src_img);</span><br><span class="line">    cv::imshow(<span class="string">"res_img"</span>, res_img);</span><br><span class="line"></span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// return a.exec();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中核心部分就是计算 <code>res_img.at&lt;cv::Vec3b&gt;(i, j)[k] = src_img.at&lt;cv::Vec3b&gt;(i, j)[k] - src_img.at&lt;cv::Vec3b&gt;(i-1, j)[k];</code> 颜色部分, 我们的 i 从第一行开始的 所以不会出现索引出错, 这个操作比较简单, 我们得到了下面的图像结果, </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587964862334.png" alt="下差分图"></p><h3 id="图像锐化操作"><a href="#图像锐化操作" class="headerlink" title="图像锐化操作"></a>图像锐化操作</h3><p>我们这里说一下, 在之前的章节也都提过, 在图像处理的过程中, 我们一般采用的是灰度图像, 能够有效的获取到图像的细节特征, 而且计算起来比较方便, 所以我们在后续进行一下算法处理的时候会采用灰度图像, 特此说明</p><p>根据opencv 例程<a href="https://docs.opencv.org/4.3.0/d7/d37/tutorial_mat_mask_operations.html" target="_blank" rel="noopener">Mask operations on matrices</a> 中提到的一个案例, 我计算一个点与它四邻域的的差值的 也就是<br>$$<br>g(i,j) = f(i,j) + (f(i,j)-f(i-1,j))+ (f(i,j)-f(i,j-1))+ (f(i,j)-f(i,j+1))+ (f(i,j)-f(i+1,j));<br>$$<br>在线性代数中, 我们的运算都能转换成矩阵的运算, 那么, 我们抽象一下, 我们能够得到这样的一个结果,<br>$$<br>g(i,j) = M\cdot f(i,j),  \quad M = \begin{bmatrix}<br> 0 &amp; -1 &amp; 0 \<br> -1 &amp; 5 &amp; -1 \<br> 0 &amp; -1 &amp; 0<br> \end{bmatrix}<br>$$</p><p>与我们的运算得到的等式是一致的, 我们考虑一下怎么实现, 这里我们也参考 例程里面的实现,<br>我们将算法部分封装起来 这里我们使用<code>cv::Mat res_img = testFunc(src_img);</code> 这样的方法, 然后主要去实现 <code>testFunc</code>函数就行了, 后面我们为了不再重复的贴出代码, 希望之后看到的话 不要有疑问.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="comment">// 引入 opencv 函数头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行 测试 算法</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">testFunc</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;src_img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat res_img = cv::Mat::zeros(src_img.size(), CV_8UC1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; src_img.rows - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; src_img.cols - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            res_img.at&lt;uchar&gt;(i, j) = cv::saturate_cast&lt;uchar&gt;( src_img.at&lt;uchar&gt;(i, j)</span><br><span class="line">                + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i - <span class="number">1</span>, j)</span><br><span class="line">                + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i + <span class="number">1</span>, j)</span><br><span class="line">                + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i, j - <span class="number">1</span>)</span><br><span class="line">                + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i, j + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res_img;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置 要显示的图像路径</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lena_png = <span class="string">"./TestImages/lena.png"</span>;</span><br><span class="line">    cv::Mat src_img = cv::imread(lena_png);</span><br><span class="line">    cv::cvtColor(src_img, src_img, cv::COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">    cv::Mat res_img = testFunc(src_img);</span><br><span class="line"></span><br><span class="line">    cv::imshow(<span class="string">"src_img"</span>, src_img);</span><br><span class="line">    cv::imshow(<span class="string">"res_img"</span>, res_img);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// return a.exec();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们上面提出的算法就是在进行图像的锐化操作,相当于在原始像素的基础上加上了我们原图与四邻域像素的差值, 这样我们能够将边缘梯度过大的区域进行增强, 平滑部分则不会过分处理, 最终得到这样的图像处理结果..</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587964861870.png" alt="锐化增强效果"></p><h3 id="opencv-核操作"><a href="#opencv-核操作" class="headerlink" title="opencv 核操作"></a>opencv 核操作</h3><p>我们在处理的时候实际上没有解决边缘的问题, 在结果图中可以看到四个边缘各有一个像素的黑色边缘, 我们可以考虑计算其他的简化计算方式, 但是太过与繁琐了, 为了优化体验我们就没有处理,  但是 opencv 中提供了 一种通用的方式进行处理 也就是核, 我们先看下实现方式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat kernel = (cv::Mat_&lt;<span class="keyword">char</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">truetruetruetruetruetruetruetruetruetrue<span class="number">-1</span>, <span class="number">5</span>, <span class="number">-1</span>,</span><br><span class="line">truetruetruetruetruetruetruetruetruetrue<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">cv::Mat res_img2;</span><br><span class="line">cv::filter2D(src_img, res_img2, src_img.depth(), kernel);</span><br></pre></td></tr></table></figure><br>我们设定核之后. 可以直接进行操作, 我们可以通过改动核从而进行图像处理,  看下图, 好像得到右侧的图像效果更好</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587964861614.png" alt="锐化效果对比"></p><h3 id="运行时间对比"><a href="#运行时间对比" class="headerlink" title="运行时间对比"></a>运行时间对比</h3><p>两种实现结果是大概一致的, 算法上执行是一样的 , 那时间呢,<br>在之前的章节, 我们介绍了不同的图像遍历的方式进行图像遍历, 时间上差异还是比较大的, 这次我们同样使用了两种方式进行: 索引访问和指针访问进行图像处理, 算法部分的实现是一致的,  我们写了<br><code>testFunc</code>和 <code>testFunc2</code> 两个函数, 相应的代代码可以看下面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="comment">// 引入 opencv 函数头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行 测试 算法</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">testFunc</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;src_img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat res_img = cv::Mat::zeros(src_img.size(), CV_8UC1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; src_img.rows - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; src_img.cols - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            res_img.at&lt;uchar&gt;(i, j) = cv::saturate_cast&lt;uchar&gt;(src_img.at&lt;uchar&gt;(i, j)</span><br><span class="line">                + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i - <span class="number">1</span>, j)</span><br><span class="line">                + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i + <span class="number">1</span>, j)</span><br><span class="line">                + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i, j - <span class="number">1</span>)</span><br><span class="line">                + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i, j + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res_img;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用测试 指针函数</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">testFunc2</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;src_img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat res_img = cv::Mat::zeros(src_img.size(), CV_8UC1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; src_img.rows - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> uchar* p_row_pre = src_img.ptr&lt;uchar&gt;(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">const</span> uchar* p_row_cur = src_img.ptr&lt;uchar&gt;(i);</span><br><span class="line">        <span class="keyword">const</span> uchar* p_row_next = src_img.ptr&lt;uchar&gt;(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        uchar* p_row_res = res_img.ptr&lt;uchar&gt;(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; src_img.cols - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            *p_row_res++ = cv::saturate_cast&lt;uchar&gt;(<span class="number">5</span> * p_row_cur[j]</span><br><span class="line">                - p_row_cur[j<span class="number">-1</span>] - p_row_cur[j+<span class="number">1</span>] - p_row_pre[j] - p_row_next[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res_img;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置 要显示的图像路径</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lena_png = <span class="string">"./TestImages/lena.png"</span>;</span><br><span class="line">    cv::Mat src_img = cv::imread(lena_png);</span><br><span class="line">    cv::cvtColor(src_img, src_img, cv::COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试索引方式进行 锐化运算</span></span><br><span class="line">    <span class="keyword">double</span> t = (<span class="keyword">double</span>)cv::getTickCount();</span><br><span class="line">    cv::Mat res_img = testFunc(src_img);</span><br><span class="line">    t = ((<span class="keyword">double</span>)cv::getTickCount() - t) / cv::getTickFrequency();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sharpen-index: \t\t"</span> &lt;&lt; t &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 指针方式进行 锐化运算</span></span><br><span class="line">    t = (<span class="keyword">double</span>)cv::getTickCount();</span><br><span class="line">    res_img = testFunc2(src_img);</span><br><span class="line">    t = ((<span class="keyword">double</span>)cv::getTickCount() - t) / cv::getTickFrequency();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sharpen-pointer: \t"</span> &lt;&lt; t &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    cv::Mat kernel = (cv::Mat_&lt;<span class="keyword">char</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">5</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    cv::Mat res_img2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 filter 2D 算法时间</span></span><br><span class="line">    t = (<span class="keyword">double</span>)cv::getTickCount();</span><br><span class="line">    cv::filter2D(src_img, res_img2, src_img.depth(), kernel);</span><br><span class="line">    t = ((<span class="keyword">double</span>)cv::getTickCount() - t) / cv::getTickFrequency();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sharpen-filter: \t"</span> &lt;&lt; t &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    cv::imshow(<span class="string">"src_img"</span>, src_img);</span><br><span class="line">    cv::imshow(<span class="string">"res_img"</span>, res_img);</span><br><span class="line">    cv::imshow(<span class="string">"res_img2"</span>, res_img2);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// return a.exec();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法实现上很简单, 就是我们上面提到得到方法, 结果以是接近一致的, 但是时间上差的还是比较多,  使用 <code>filter2D</code> 的方式访问得到的图像还是比较好看的, 运行时间也是要比我们自己通过索引方式进行的算法要快很很多的,  但是相比我们使用指针还是有所不如, </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sharpen-index:          0.0747024 s</span><br><span class="line">sharpen-pointer:        0.0040774 s</span><br><span class="line">sharpen-filter:         0.0416613 s</span><br></pre></td></tr></table></figure><p>我们在 <code>modules\imgproc\src\filter.dispatch.cpp:1403</code> 的位置看到了 <code>filter2D</code> 函数的定义<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">filter2D</span><span class="params">(InputArray _src, OutputArray _dst, <span class="keyword">int</span> ddepth,</span></span></span><br><span class="line"><span class="function"><span class="params">              InputArray _kernel, Point anchor0,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">double</span> delta, <span class="keyword">int</span> borderType)</span></span>;</span><br></pre></td></tr></table></figure></p><p>相应的我们去看 调用图</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587964861606.png" alt="filter2D 函数调用图"></p><p>函数的主要调用使用了加速层的<code>modules\imgproc\src\filter.dispatch.cpp:1307</code> 处的 <code>hal::filter2D</code> 函数<br>这里涉及的部分还比较多, 可能也是由于调用的更底层的以及做了更多的边缘处理的原因 导致实际上花费的时间也更加的长, </p><p>这里暂时不去深究, 如果有机会再做进一步分析</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
            <tag> c++ </tag>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学堂在线字幕下载方法-2020</title>
      <link href="/2020/04-24/%E5%AD%A6%E5%A0%82%E5%9C%A8%E7%BA%BF%E5%AD%97%E5%B9%95%E4%B8%8B%E8%BD%BD%E6%96%B9%E6%B3%95-2020.html"/>
      <url>/2020/04-24/%E5%AD%A6%E5%A0%82%E5%9C%A8%E7%BA%BF%E5%AD%97%E5%B9%95%E4%B8%8B%E8%BD%BD%E6%96%B9%E6%B3%95-2020.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="9db951bc1c4abc8243e459f3a27939c10ab30313eeaadd43941270691a7e7b2e">c6a0e9cbc88ea38ad00619c7f5e082b7159e9f615fe43c06b2e9dce823530e37c58d01b4c41bd397591681f4ee0f50967c86bf09d09c75039a442d81213010ecddc24a520498458ebecd80046ffb61d2791cacf10e173a075a89d10e49b598186ef9d2d8aa7060ad306ac8e8efd71b5ae4df354d55664ab0594fccc8ae4f60f51696955d445dc4503a25772d6d310989058fd83afc95b3056268194240c813006682c43874f5b6878b316efc1642bfe9a9bc70ef158ac6ae9123756ae633cd722d3f9c6c8e702752b58ecb239d35b6449ca16ed19a1aba3c5a24f5302758d264012a9a183029819eda43258e4813dc3c28e526b5e6c05360727c1fcc97136d37534e103329d8ac4c83a354a77a0bf3a2884c89811d1050e0fc77dec11455e36ee33a92b8f8f70c666f8a40be48b9d51426e3ed725c63cdd4a49040bf66b512aadc8ff68540ca253e934e2f3f2a64b5bc4e7f81abbfd974d6fabe7574eb7c073aa73c825f281ef71b6b98a269bddd742bf7e7f9cd908d39b5b2d65bad3a35f5c89c73d577fadb810204fa1ff6b696146061a0eab48310f18060fcd3e1cb501da194ba9913707ad9dd4a0567a4e9a113fcf47182eb9301f2f8a9ec076e6681a9e7b1654910f7553c9625dcfd72b1520325a8f45d6c3c1c1e04c2f468474cc898f719642240a1da67489e64906410e3d7ca0c15c235a8639511aa74c45a776805e2cf8298ae6177b28f6c46f841d04a1f129d2b6c9ffbcddd1901a11b89a030740e19469d2a6f193260e5b78b59ccd51dc5edfc157aee04e8e32e00985608b4f127bb76a19a4b637bc85f619805d2865b172415659b070b43e5b38f28d4adb8bde47645f382cb4a16cd546c7ccc4597dbc39c4a5a99eea17e4784e85f2d74dd6fb25182dea2d3ba924ceb5c7c7d4ec6896a2405e8bbf38ada8a4949ffa9a2a5be4e7e2749191e5664b94c3e7fe13e286459d6b15fb7daddde094292c6c2ee4da7966f7f70667c947bb041d3f93cca87bd53d5d1c8ac8287e47b8844ce99ffdc55e014b048df42134f2a5cc012ea338044ea9c14cd26021ebf761e30773a3d332e136bd8c6e03dd08af4b8cb3add83f16ac172b201159b138b02560b4499b748caf5d31de489dd6ff84b15677cfb2aac408b5b3eb9aa5f64410746f7465c1b1e6cba6831e34c5441b6c6ca027e389324d2dee74148adce4821d3a54f15002a508e2c83c87f42fe3d4023b92ba5f92d37d7e99cf6a8b5b3aeb1afb208ecad6d15f77362eb32b29866efbb38d9a2d4155f8251782967daff0f50c33e8d4a1d1afaf0e58de2943b8b1d4527359e5a9354e522131d12bbb7bc70c680eb7e5ece75ec9bf54e392475984b7463797e3b57fbc1ff290eead62107843b1a498e6c7505a79946ce27c1dfa15395b3e5c2d9ff420b7ed940c7d1b92df28b93e7bf40e25fc1f7da43035aa2c2f42cb25b3f080daeaced12dd3bba775a724bb4fb669eca749b461716d11219cb68bee935cad64a9352758f5772bf88e8defb9fd26c5d748af427536745c2eb98fc7d5009d438b4d5f0d554cf0ed202e34dcfd4dc7daf2d65888c0b2a6ccb7e51543ba200efe007f4cc7bad75e3a5f321023d82d201d473724fd31cd59140d15d668fce8df02b7377de2562cba99b30e1f472a7f02e7dafd963b7da7c38c9374e2f13ab26b112d157190c9008131f2ac3054539282957254ac8c4d8640b048f5b794590e5eff7db7907a16ceba08e9375cafcbcfdb0e0d6b04fc13f9b036eb784234476d8f7e49f10d582533d6e8f13c71e4a7ad3a6325db4b7e132e7b00cead4bbc26bc5cb5e26e7914c03c7c1aa2dbbebb7070f05de76518db7ff742041fc7f9ba0dc71d32424e76c128248643f217d0dcaa12899c40203fb109dad0f2e32db35d90ee575a98797cabbe770ef19f5696de2d9b24480277f512e566b7e9741641586eef31679aec6ff87f463fe0d168b45a30a0d85ed03d46e4faf4ea9c34143b9c2852f12567f869fcd223f547747fc7ea31ffc0cbdf4999545ab20abe9b1c85651aad802bc8e911524c73802c1d8e407e6d884b3cb9d6ce3ce3891fae9319143d8db0f89d1f8f986ab79a87f771089acb7f43640d70125e31ac37c75b4470dc9e6837c3b36e3594007013480c7d974902150f2cf1600956402ee9e634401a119f57a0f6d3f56b3177a7a085d5af83b8ad79c7a38339f1c35da31c3946d925b94b99e68383f041f3c43786cc5cb2dc5d1e1c166ff1a96b301c1d99f8a0105b98b1e85596d1741c4429757e797cdaac2849782f24b26b76d4f1ecd8a63560730d76701536452da89167a53a9a31431529f405d8687b568ff000fbed313e6f1b8bf93f3a6d055f4c773c97b172e418ba89ca9e3c2db6f2ea8a2c58738a03dc14ab091261c8ea508d774f5c4fc493959557ed95f1d13f593caf903bc304b1e474759008342d195cf4bd48b80d3a37b24c8b3d3655ffa76b7b6a314fc73fe5df1e9036b335facd66fc16e91aa5251d45e81c58082c8c436fab735cf5b8758903a70ac2ff1ec5815f765798721a9ed420e4076c2c8faa528052d62fb65b61d3ce38facfc09f277675a580cb73f85971f8d550ee7aedc4cc8b2acc00154b41058baacc3681917954859220b48388760aa31280d9c0d0de2011e7e0e1b2c3cfc7d0e8db721471f2557e7d820200bd7452256ddf6dedcd7c646660603efddd5fcc37c8dec1f5e5588cc943a4f5ed01669da3093eab46a7a2d77e506cc675b91ac8dbcc5930d83230ee744a815c43bc537b74ef2776abb814bb8b25b704add68bfe4e2ab78557954286a2dfedfe1abf2aba667caa2c94818c66fc61c10a7e6c9dfe701e56f00f0ca17fa0d540144ae7c0de8adb47903adda9114c05c8746e9dbbd3b3cbea667eb9daf34aab9895d20f277b7da24d56e67c44db005d67df059ca5bb5c5f3edf0515727d48662208fe59cf86a15428f54ae737aa2502d53f876c4632df299a14b6674fe844372bdbb50cd0df17a2556f7b2aee2102ac41bf249db6af85dc6d6f71940ebc359a22815bfb3f0a4a19340d3932d331a5a4de390142608157b7ab75b1a66c7808f13428605be59fbd3d33e3fb012914a759059ae7409ba521edb0b52e8623fdc4f82a99d4aa4dfbf2407e85284375db875cf9b7b113717557eb2a249ca0cdb736cb10d03ea96c3aa056c613e037766938241719a2bb80b81e41eaf44f0c290dfc41527c45af9696361df3f0cc961e0f79746a023b4b20a2d331e91f6de35d9ceba7e1bc5df6ad6d30a93fbd21309389d7ddff01da7600962202c3ce6cae79e458c592b435ffb7905b145e076b4fd586fa02208d950c67009fd72a455d867dfee4630923d95689a290cfb1b7ec1782c9bfce6a59d317fb1b96e339bafd1f56a045a1b3b28f0bdd8c351ba98ab7c6cfd6fc2cd386335c9e6a399a37e31220850d0bbc8d9b0984586b596071c02d79b79375bb8feafadfbc0b1fd6d9a522d1636b80d4a0554d5abc415cc0c417651e531e3d21066374a65ed916a28245da6e2a90d645f07c63c32060fd97a14574ebf13a2df8e6f7e45451f8164e207170861ce681494053cef61ce3b55bd4b22e9949a06feb408f2efa94702b6fb0065addf6f1fd1ed0c877943d9ddb95331f6da78e4618e2a3e9bb1af6253cfccf9865f2c6c79895507dc2ae52cb3720b4ae6c23b21e3da8ed30fbc5ed48d8ef498d386de0faa8109589b0836dc1c62b65614cc2ac59cba941d0911aabc7090b11b1b63a29fd0a5deacc3e995adc939986d3e63bc58437c970f36f0d4b31007c1f82ed848b3ed456dcfd3ff19cf0c7d18df95eb3e95d5fa66c89641e2d3b0c80e8f0bc06fa951e8fbd6924c9d0ee3b0c3ef023b9c0364de434e4bd5e4c653b0eb8293136f63175b2d0512f92dd0a0a3fbc8742fc878266b73c1777316e600656434c43cbd4ffd2ab4d171c8bf05e0304b52b45ad6ab44f3745d6c5bcb7b3ff9ade4921d0983c5cd6d07adeeca33d7d6342b6032f0e627e3266bf2c711a0de804914a002fe1412e8b9b2b33f104712eff5ef23094a1ea0b848701e1f7ee085caf5eb40fe910ac92c8538995b815c9e7b6527acd275e0f6a9c89b3464a7dee399c7ae4dd74b1bb7f51917d37263cb9fb7d689d19cc5e994eed70a3a0181b4c49233cf8aefe9b5f37cbc047896c5912c632df884d328d77b6fa7f48e4705cdaf313f44a8535f8f9b7a646a7dbbc6125ca11a992c2b75a38ec79c32834de05091f2f5e531ff46e6069984ebf5187049b8908e3beda4844891fa749ea51b338ffb7b0f4fe99bb23dd0295eab2ecc3fc0a6da470eb5ae95f85396c784fea8dbea297ca414a3ec9daa843b7a3310049073b46d27ac1e8074a74bd25e78ed31344a32a15e499342c0d9fcd27aa420167335b743a4848ad8b173a246032c0695e5968cbdf2ca59db508e5cbd4336dbe4e25b26bd8583458ab8545d07734349a1da243ba1edcd1e9d6a68a5a2a4914f7f565c5da2fb1c10b183f0bfeefef30549d33718cfd3ba0c6fb1323a502c75cfa66cf22b1efca36e25a075a1818957aab071d4ed28d039390c2ca3926b7e6784802c62be09762894d8709746b15c22891f6a66b7c443faa013e22ecbd157513d5fe4346122fb7f215a3de3133f704edc5ef9422757d4201b774b2d4e291028d107d273af2ae7e41e3776001cf6bdadf9663aa418a15a89558d2f56e1c61b37444a02b8871ddde0a1e8209d72a349adf540aba970424e49f961e80f1a48e7a29a1bc5f101c9a7b3b34e221bbab9ae35c386f174f1920594db4db21d605e1fb8b7242601022954b7184d9abf78c60712ce456351881798b06f0ade75547fdcc3ea78b458e39d5f81b979fcb1f0dd26eb01bff3255e357e7ef1ee37e0d8385f61b3e317e61bf1153240237e1996c9cc2cc8f3966d8e1e257777c15797c592cee7d1080b997c320b62cb13db939bdeed7ad80602c6d458877cd035a5b65d574acdd7a7be6fafe387a5678f666035d299410fea464da69da85ad521dba5bc19c7b5c89065343e381e76ad67ceb26d331f1851ccdda6552c5fe10e06541d24966ff128d4219baa123ba89b07e67e3ffe4e3fc765283ce3383ff97d3cec9637b986e2b18cbba9f91f3afe1d6117d7dc6a64308758ce296b6e6c7af6b92b286ba8c0b5a73cfea9f3f6aa81dfc7bf4cd4ac7cc464b6ed67ba7820c6888d9548afaf946e01fcea53c0c5a85308cd4494517956bd6046bc40f27b33b59c32037422a9dd94503b1626aefd4c2b0ade4d5985eefba553b94dfa41509c4cb0bfd9f2f9895028b5af20d3e30762af3abf6bc748081258f0192f665b266429e830abfc87221baea55defcc3416be07c0232bf2a19f8ee93f61bca0cd9e4068ad197f8ffd1407c2c2d1860bc08ccabce1df05c96f4ad459c26e1cdc29d8290ed72cd35caa536b9a786b5353768fb99e8a924194ec76075e5a57a55fed08eea241982a880ae29c83e797abf27c1a4c29204b8034360172bf1cf0c8854e74de1861f6833f9a31e86b4709737a450318fec9f8e98047214addb893a5deea9e4fac4cb7d3ce919f225f788dc7ca43a39aea70db8bd9046c4f76f28bda1925980d43b4f25518ea4a5f93dc172f905b6f1b5d1c201e65ef16aaada11c904485f8f65caa4c73fc8fe4db60b6900e4eec309ab12477f4a541716ac99d51</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> encrypt </tag>
            
            <tag> hide </tag>
            
            <tag> blog </tag>
            
            <tag> js </tag>
            
            <tag> script </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv-7-鼠标绘制自定义图形</title>
      <link href="/2020/04-24/opencv-7-%E9%BC%A0%E6%A0%87%E7%BB%98%E5%88%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E5%BD%A2.html"/>
      <url>/2020/04-24/opencv-7-%E9%BC%A0%E6%A0%87%E7%BB%98%E5%88%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E5%BD%A2.html</url>
      
        <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>昨天写了具体的基本的图形绘制, 然后我们使用相应的函数接口进行调用, 便能够在图像上绘制出来相应的图形,  我们以图像绘制为例, 最终都会调用了 <code>Line</code> 函数, 最后都是基于一个 自定义迭代器 <code>LineIterator</code>的形成的路径, 通过设定起始点和目标点, 相当于计算出来的斜率值, 每次累加的之后判断下一个点的位置,  通过 重载累加器的 <code>++</code> 操作, 完成直线点指针的移动, 在相应的位置填入相应的颜色就可以得到 所要绘制的线,  这里是函数的调用图, 可放大查看细节部分</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587791291050.png" alt="Line 函数调用图"></p><p>这里不再深入探讨, 相应的可以去研究具体的实现, 很漂亮的源码, 写的很好<br>我们这个章节 看一个比较高级点的操作, 操作起来比较复杂, 先不去深究其中的原理, 我们先跑起来, 然后再研究</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>主要是处理鼠标的操作就好, 然后使用绘制图像就好, 可以参考博文<a href="https://blog.csdn.net/mars_xiaolei/article/details/89206957" target="_blank" rel="noopener">《OpenCV：鼠标操作（绘制直线、矩形、圆）简单示例》</a><br>和博文<a href="https://blog.csdn.net/qq_37193603/article/details/72901049" target="_blank" rel="noopener">OpenCV鼠标画图例程，鼠标绘制矩形</a>, </p><h3 id="鼠标绘制图像"><a href="#鼠标绘制图像" class="headerlink" title="鼠标绘制图像"></a>鼠标绘制图像</h3><p>我们先梳理一下逻辑, 我们使用两张图片作为轮换, 原始图和临时图, 每次绘制在临时图上, 然后完成之后存入原始图上</p><ul><li>初始原始图像, 绘图标志  flg  false</li><li>鼠标按下, 确定起始点 start_p  标志开始绘图</li><li>鼠标移动, 移动目标点 end_p, 绘制到临时图像上</li><li>鼠标抬起, 确定最后的点, 然后将图替换原始图, 同时 绘图标志结束flg = false</li><li>循环绘制图像, 绘图中的时候 显示临时图像, 绘图之后 显示原始图像,  </li></ul><p>逻辑理清除之后,我们就想要处理一下细节部分了, 我们在之前的博文中介绍了显示图像的方式, <code>imshow</code>即可显示, 然后我们<br>发现问题在于程序的鼠标是件监听了, 这里其实比较深入了, 但是呢, 我们不深入去研究, 只去看实现的过程吧,<br><code>cv::setMouseCallback(windows_name, on_MouseHandle, 0);</code>, 我们第一个 <code>windows_name</code> 是我们打开的窗口名称, 用于显示图像, 也能通过名称进行句柄操作,  第二个参数就是我们的鼠标处理函数了, <code>on_MouseHandle(int event, int x, int y, int flags, void *param)</code>, 这里的函数名称可以自定义, 但是参数类型与个数必须一致,  然后我们就可以通过预定义的事件宏进行确定当前鼠标操作的动作了, 这里 比如<code>cv::EVENT_MOUSEMOVE</code> 宏就是  鼠标移动事件, <code>cv::EVENT_LBUTTONDOWN</code>,和<code>cv::EVENT_LBUTTONUP</code> 分别对应鼠标按下和鼠标抬起的操作,  命名写的很清楚</p><h3 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h3><p>我们在逻辑理清除 之后, 写起来就很简单了, 可以的大傲下面的代码, 注释也比较清除, 能够一看就懂</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="comment">// 引入 opencv 函数头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录鼠标位置点, 以及 正在绘图标志位 flg </span></span><br><span class="line">cv::Point start_p(-1, -1), end_p(-1, -1);</span><br><span class="line"><span class="keyword">bool</span> flg_drawing = <span class="literal">false</span>;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用原始图像与临时图像 存储</span></span><br><span class="line">cv::Mat src_img, temp_img;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//鼠标回调函数 // 记录窗口的x y 位置 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_MouseHandle</span><span class="params">(<span class="keyword">int</span> event, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> flags, <span class="keyword">void</span> *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> cv::EVENT_LBUTTONDOWN:</span><br><span class="line">    &#123;</span><br><span class="line">        start_p = cv::Point(x, y);      <span class="comment">// 确定起始点</span></span><br><span class="line">        temp_img = src_img.clone();     <span class="comment">// 复制原始图, 进行绘图操作</span></span><br><span class="line">        flg_drawing = <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> cv::EVENT_MOUSEMOVE:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (flg_drawing)</span><br><span class="line">            end_p = cv::Point(x, y);        <span class="comment">// 如果在绘制, 则更新移动后的目标点</span></span><br><span class="line">    &#125;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> cv::EVENT_LBUTTONUP:</span><br><span class="line">    &#123;</span><br><span class="line">        end_p = cv::Point(x, y);        <span class="comment">// 确定最终点 </span></span><br><span class="line">        src_img = temp_img.clone();     <span class="comment">// 将图像更新成为原始图 存储下来</span></span><br><span class="line">        flg_drawing = <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回两点之间的距离 直线距离 平方和的开方值</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">distance</span><span class="params">(<span class="keyword">const</span> cv::Point &amp;p1, <span class="keyword">const</span> cv::Point &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cv::<span class="built_in">sqrt</span>((p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//QApplication a(argc, argv);</span></span><br><span class="line">    <span class="comment">//MainWindow w;</span></span><br><span class="line">    <span class="comment">//w.show();</span></span><br><span class="line">    <span class="comment">// 设置 要显示的图像路径</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> img_lena = <span class="string">"./TestImages/lena.png"</span>;</span><br><span class="line">    src_img = cv::imread(img_lena);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> windows_name = <span class="string">"show"</span>;</span><br><span class="line">    cv::namedWindow(windows_name,cv::WINDOW_AUTOSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置窗口 鼠标操作 监听 函数为 on_MouseHandle</span></span><br><span class="line">    cv::setMouseCallback(windows_name, on_MouseHandle, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根据当前点 绘制</span></span><br><span class="line">        <span class="keyword">if</span> (flg_drawing)</span><br><span class="line">        &#123;</span><br><span class="line">            temp_img = src_img.clone();</span><br><span class="line"></span><br><span class="line">            cv::line(temp_img, start_p, end_p, cv::Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>));</span><br><span class="line">            cv::rectangle(temp_img, cv::Rect(start_p, end_p), cv::Scalar(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            cv::circle(temp_img, start_p, distance(start_p,end_p), cv::Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line">            cv::imshow(windows_name, temp_img);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cv::imshow(windows_name, src_img);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置 按 esc 退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (cv::waitKey(<span class="number">30</span>) == <span class="number">27</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// return a.exec();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>然后就到了我们结果的时候了, 运行之后, 鼠标左键点击开始, 拖动实时绘制, 抬起结束绘制, 然后 我们绘制了 直线, 矩形, 和圆, 同时进行了绘制, </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587791291056.gif" alt="鼠标绘制图像"></p><blockquote><p>ps: 这里录制 gif 使用的是 <a href="https://www.screentogif.com/" target="_blank" rel="noopener">ScreenToGif</a> 特别好用</p></blockquote><p>我们实现的比较简单, 可以去看我提到的两篇博文, 以及这一篇<a href="https://opencv.apachecn.org/#/docs/4.0.0/2.4-tutorial_py_mouse_handling0" target="_blank" rel="noopener">鼠标作为画笔</a> 翻译的文档,<br>他们实现的比较复杂, 不仅实现了绘制, 还能够选择绘制什么, 也提供了 随机颜色的方法,  <code>cv::RNG</code><br>可以参考<a href="https://blog.csdn.net/u012750702/article/details/55225091" target="_blank" rel="noopener">OpenCV中随机颜色</a>, 随机颜色的解释, 听简单的, 初始化随机, 自动生成随机颜色就行了,<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随机颜色绘制</span></span><br><span class="line">cv::line(temp_img, start_p, end_p, cv::Scalar(rng.uniform(<span class="number">0</span>, <span class="number">255</span>), rng.uniform(<span class="number">0</span>, <span class="number">255</span>), rng.uniform(<span class="number">0</span>, <span class="number">255</span>)));</span><br><span class="line">cv::rectangle(temp_img, cv::Rect(start_p, end_p), cv::Scalar(rng.uniform(<span class="number">0</span>, <span class="number">255</span>), rng.uniform(<span class="number">0</span>, <span class="number">255</span>), rng.uniform(<span class="number">0</span>, <span class="number">255</span>)));</span><br><span class="line">cv::circle(temp_img, start_p, distance(start_p,end_p), cv::Scalar(rng.uniform(<span class="number">0</span>, <span class="number">255</span>), rng.uniform(<span class="number">0</span>, <span class="number">255</span>), rng.uniform(<span class="number">0</span>, <span class="number">255</span>)));</span><br></pre></td></tr></table></figure></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587791291286.gif" alt="自定义颜色绘制"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><a id="more"></a><!--more-->]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
            <tag> c++ </tag>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云服务器设置</title>
      <link href="/2020/04-22/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE.html"/>
      <url>/2020/04-22/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="f9acdba6773942cf766e7fd8855eb1c8e8d09aed73c233e4fee2cd8302d1202a">263eaf6293ad4853d03e4b745dd61ad2a3b4b477d4fc4af85abdc89f6bcdd9a4bc5e1bfc0472161bd8424978e15d7feb946cb5dc562d666b4e34cd588e0c49bed56043ce01d0e94bdf884371f02140a99da786320c929d53fe808fe4a2fa908e14be9834049ae438ae14c85163f08a396e66376291fdf79e0fa05c32ea1317d67f58e8e62c66703aa53f50fb4fd3905783c0f90eb4c8ba31d1bd599f12b4f8765428d68606755b50145180ee54c2e3a2e649933cc62f46e435c57d1d0e6e36ad61aceffe5854a4c7d38459fa91c12a39a2b42ec7207daf5a22d677446634553d29c0fd5240e010a4fe77ef1bc40fc1a678c34fdc7f2939a8754196fdb087967a749d313b9d12f6c3a2de9000c00dabb6e5b439bd7b61d4c96a66e36e933a5da2be0869a7ff026a7bd6fb84dbfc3a2d9ae58fb8b781afddbed920f1ec00429dc181cf861f6dbee70fe2383880a2e673c8037f491b37f46fb48e47aa56baa54fe60814fbe199f3ebd99d123c909a5cb0f08c5a797345f18c67a3f1eed6a8ba287da46968883576c79b77ca6d93bea9559808302ce5bdec21cf90fb56f71de8dab9a8f9101cf1d0e49412b8137e1456e1900a28d88eab0db1a66fb6122b8b39b80318426e29c45116c127b1e68e03a0e83c05d639344a6c478d164186c934ea1733e7fd25c18ad45a6e82ca4c71b1d826eb40daa6caa4af5f1a6a877d1b535faa87ed4d2bc713d03c8828c15402886ee3fcabed23ab79b409e826f912f9e90e62f566d175f405711cabc4a188846c4377455385673e5d74e267ba53c74e417fc35d107745e2395ca50906dee459abea4d0961417ec9c4487d39c62a047436ac564004a764cf7d6247c468c17a3b527bbf5472c5a2d3ea9485d5dfac62363544508fb88ca2a86bde2c556ca8b548d083d97d058e279d40414e90f4bb1658ac70a671400d36d49432988e1bfeca3db998298e9f46e080cc5d1f01b0dd84b3a589e0663f7fe5443070c3f200a3a25b619416fb73ff3c01242bf96a22e5173a5d91d8bc7f05150b8d7a7a3856851e49c2faf023abacec1ecc9af27c283e54971a0dd1a86b57fce5216f2666f7e553b0af225aac85f0ea10f5dc7838cd6a8499991e4ca1a8ac0eaac14b2789f47bff6fd921ef4ce9b14a5796b1da39aece68104377ba6fa117f9da11e0be6d4a2ff494048a795918693f824bee7e46c0e42660fc8ddfda25b68e5bac0078c433fec5f20295cf9c9cd661633f5c1959b97bc9cb8a68445f86d54c842547ec7634ae6959498920151fd6751ad074d364a60c60f86ce0a0f943f01affb903a284d5920d1a0ad22419ae3fbb6f3a04b2ee0c911fef1a322fba71aa0ac44d19fa12e451d2c354cffc284dc90f091b1aac1adc9261abfe6e218b73e3b698efc264bf17e6c756d465e66284f81b611a81cfdd8cd4e7394b97791f4cd5e854a05c0850d38b57006ec356e917dd9fafc71488f54470c8dfd8e8bfde46988e57cf1df030f51db6428b4fa98ead99191efd6b26229e54ec2a7a2c01c98dd54577beda10daf7ff8c2b55ddf9ada0795ca6961243303fab3368d44bfeb1602883bac66d310a7706655f94e50c1d717debd461d6e1523c24741f165b115f13553e12f76800277913c82cb953c44bec003f47aaa7909c3e67e7a1c2733c24a73226d66572222ad16f8fb52db2a415a18fc1f4d271c1cbbf31bc12e029933ce003047a9274b9ff3d5436e4a6bd5e6fa4539f0245a3a709910680d363ca98544c152c1258d733385757bf9de238fe5e34c87010f43dd82dc62d1e03b2ef1fc381f492ca170a8151fc4a7736f58efcdb9de382ce6935d587815372cf3af2824cec0e1beb2fb953c0df0fe3c98bcd4f2ccaf8090e2f441b6e253c26923fd17743c951eeec40b793c950a4f1bb32259bb631ac88ed5c769b6bac4d55c24e3eb330308a0cddc01775e049f287efb52e06528f878584d5704cacd7da01267fc244aabe95e2672120bc29c8991536e5c42d348fd2616e3a338ea6893e21404855840bef475f9bc3ee0a8b706f65f1c86ac37ab6cf9a5cd359d898d0871797e2bc5489a98e9d396a2973e3825934e62c96154fe54c5ca30b96c9f72499b158fd459b064437bd4737fd1fb945418f37183a2ab0c998be3647666cffc05a66988fb0a2125367bc89a791fc2afbed14cfd85352601ea84195f7c7af9ad0b1c5194eba3ac312d7672888c4ccb46bd5da71116fdb03c1d9fdbe80d943f50016ea1999526f4e5e28cfbe5a1a844f5a2e72a501539a7f4609a3b2b0f5d7d9708203b1ee12c8121a98f8705674fa3921b65cabe2cafe395caf467d259cb997958697d8d0dd54ac7c2fefed5cd8e68a0f2fc659c24ce9d3a422465317f046370061b0c94eb486faba8faa77877876c380f23faa599767f97231af2c43873c08ed8b6c4c426d66ca140bffc151f40c13eeab84c07ae2aa343a853b42e42a013b8582aa54b1de131565c0d8d7fba9ee5868955a6f5615e4edecdc7696eaea22b6ad6930b4c052f1069a1880cae13f037bde7e84be3caa9332c9085759baeebef78853daacd57626f85f6a68d80c05947c8028550d4d8f3e4989665b69ee1377582f907b8d549072305ec7dbdb869b5d47479afe3f7627c0205fccefa0f4c1ee2f36d4a6b5047ef3436a061c89820af56a7c8269e0421a2e1473a81e4979653e6084e11d568c21635e951aa8127a303823a00aea5b4170670755b3a05762bcfc438d61c0c5a16351240888361925820547fc7745c946fe529ab80249809eb76369de1c79b760e26af0e7c9776d9c53259c62db88c75ca3ab117b5874b822c3950b0b80c30ab15c415f51e29d650802e28edbcc7918abd679faf21cabd24711c84c78192f74d0eb526c6be6685dde342456f2c3f2ca0c1d29bf6c7c1ce92729ef5ed89d0f4f003b79e220e3234b3f661c0ebd9a7bfb53d17238ba9bbe98c06c5ec1ce9e428ec0886cc8eeb13a83a6d8a85773060a77114c991079d62c407450e7ddb2e2b11f127bc03f3eeca5a908baafff81392ae99612ccb0899a5d3095dfb30c5e6c519434a5d5a510e294196b5d94157a72e76ea612cf422015e2e87a70557c0be1ec65e1c2c037aaf79e7331652b58b661b7c4408eb001e07c7ab41f351edd74b6060e2267f03b442c0df96c22773bfcd2a07bb99fe35d21c1aec2aab60212bf6794b0602ee6fd7711c71a6202070f3e17b433bb7b6b92adb8c672e52ccab09b8cc32e54d696562d2370442c805016fbb077711aebfd8abeff65ff3f7d60c09ec3fc8ac0eb0c3cb8d08529a401590ec5779a54ac33183c7034777b80b2a7d63718cdc57eec16c010e9e405140100ec5b94b1bb9a8894aebed5032a1f7d3c9bb2074c41b0452eed75e14eb16cc6da8223c25fd813614671d11beb7031da349ebbc5b161bc360b4564b140abc3d267f47476e9070536382ef96e7ab8d8e476cc771679c18a9495d0cc1512ed06e6f1ddd2a93c876b4154cae4671597b03fc648dc009ee52398cea2e39adec40f2d9a84329000807af2bbe6899cf2b57c8b5e3bb4ef9342483b1fba264a8a621d73bd9f78e51502a57dff034c773574372bdf2ef30a2db597c6f65cb403453a20999328b009640f1c23d1d47a56974836ca7e7541b9b52ac016dbe83ee0d8b34f49071113afb2a276a05eba62524cd5cf308bb6e7e6b2e445652aa73592e96404e872cc5867f25ae058397fcf744fa794ef88ae734d837825d547bacee8b44eb50a306c379baefe112956b23b32531b98b82aafedb8ab0a48f04ab4247880aba1d2b0bd9c735a3bde311c832437ff6d34161265be2301d3a1f32bdb0b8c239485b439aa875bd495d19b75ee67af644b923c7badb5db8dd245fca4940e59993da6c3bb5a91ef42276ad769235fe0e86331f7f1e49daaff510109aa44a8ad86db882e3ab839a9a1d97519c3811c32843bd48882579d2461b02cf8c0b4bf4272f6044041912e15d1b316a7cc5efaf57ac86883d78bef9902692b106b6e64b10c40f1233dea0b6fc96582ca3f04083101d908dc9bf6745ac8ed25639580baa0d2e4c175c7b656bf3ad172d6e7bffafebbc38ba01c87e48824b595a27ce02013882179c89b86d37a7e0719359c644aaac2f9c2e0433080526aad154ffde08105712489cf0a6ba5813cb37df144432f81cb2746180f98900a5803157e877b603b9d74462a265fe2bf793ceb1cf2c4b71c854aba74b35b80ebeefebddeeed2c6f80f858f654870861a5bd981f1fe0b055f3ff91ff06c9f90bab9e1af3b2eff829273ed31c6c7971a7ab7a7dfe97ef429b51e7d8d43c4c97b40f1137ae3394687ba6ac6e9e575d1c820f84b5c116fe591520f4f3af17732f4a0eb38c87669f79ac4a99363f586feade0b8b9a33e5f63bbf54e7db6bb0c8257876db5c903b232a92014eacbde3c6df98c910395044417d63b0bba52577d92fdc3a6b1ba4cde30debd7ff1c27874c905e427090e14b7d0efffdfc9493da2b1ca39eb21a898627ccc244d9d87e53f18872826fb55f54f211e8c958815c9346e432337bc77746ffabac47490eedb98d5aecdb4a2e4a69adea7915800025e5088305a53e92357d312c2b331a091d85e5cd24a8ac319d3a8dbf110b64e2f4ef74e8b0bd194f37894bd8fb4651bb3b5d8138631bbb2f12e9e9cca383fddf7e8d8911c59a2d00f28dacd9e98836c5dc4319d194cb1cc21c5b4872eb5457acd67b5da92bde3abc4f425d9158403f1c15466b1d13478990636adf69dedd9d35efc5eb9f7505b7147b14ce54561814b03149e537e10193e8592e53643002ce8ebe2c21f6bb3678461f959a3a9158e808bc9da2a5e4e80a0cecd15f8526903d5e5f70460561eb0e7c5c1647a3ba0baf00db7af2e822ca4b2dce1241a2e255edad7e958c4bbf8e584f6d992efeb41114655d8e8b229cdd4c86f65a563f3dee18bb948da46e5a4f97a6e15537d46b335291bc55d55b524487fbf1119307a7b85112494d100e5b8d149a3e81f72e99282c4382c1d7cde7d919e4a77b0035b1e3d163f6dff72a7b577af7cec2faf6785ba64b08a0e9e5238483f15478312b7ad578e5e80da609752e492cee331421227c872ea15cb4979862b7b71a4e099b0b8276950787a0f64faaa0b97b2aa2dcb7ce831bbaca44dc9359f0fc12490f506b8e44cf1eeec50a2acf00f00c3ac4ec83b4aef1e65b9850a8edc6790949e1bfaf5933c65e364878f17b5198f64125315ec09509070f2b85e785e9525f26c9930125f1fc4456735b04dc28c91fa9b6329d4db03fcfaa69d753840072d01d03148b1c1cf5c577e081afdea043877599185153a76db6aeac9443f5cfb20d167e977bf58e1773228587594c3d4ce2822734d273425bb7036825be95ca380a8b765396f73f6941adc2f781e3ff4cc959f471ed331d3a42f111bd34ee20479ff463ba5be5733bfe3e320dfe6b4fbfbbb6e9dd6dfc25a95726390a11665c2a793c686fba9f236725d07fee3901d95d841d42ffab8e043ead33302d89fa795f53d692dccf8531f365c2b97b03318cd0c2277d0192243d465bd66a1eb1d1cfd9d70dbbc42c98fe9027e3faa301beded1dc8fc1cc53c90f42b00aaf132e69975d1fbe2484651fcb95c262079043486731bad7e545f6e3b55c6b8354e13a0b52285657ee47e337c9584c3ff4357b32c8987183bbfbbc904e509801063a60cbc84490fe61c2015a2f8b7b8a9df78ff3a3a777983b05d6c8e313d2699cba435af9e46930114c6f4faf4f82339c58e50da53b81a5b0a1527274ab03debc7683729c17f0291975778a4e45ec1beb36722294c4c8ced62940294fd06f9b31722b4260420692dd177d5a6be9bda098dc8a5b254b19653784c0907258779821aed26582d6e24202a3565aaf1f2c6082295e903b694d5992c7d7e99b8a6f50955c6e2c0f25602d24ee9d55885fd2c3793b43d7a0edec27defd496d3466863c749c8a6757cf83259ab21e85bd4ddccd678eccc0bc2b954d1e4332e3658a48ccb0857a9769f67b67c0d1edee9a937735a3249f74c010c5edea9905b90af186b07c726e6f519bbf046ea9984c2779dee48b652a978514cf3ee7bb20f33254d47b90ecea81cd395bc3a22a2336a79955c57b1608c6fd957db125d69e8130d600d4e7f12b34c6c43df4cecb2cf4a4b3fea4dce77a2a8a163b3611f5ba193b6b24ab434c8926da5623c3bfcc9aebd7373d5c551d29c48f40b2b40059b9c1539f9e856dcefe2562ae165ce4ae9d89e12457f7920b9474fda7a8254dbc987563273e873384472000153f98f4614cdf8e54ddf1e3d9cca7d49312bdb817e0c5426453e024cfd1356c07dce63ce4307fa1fad6361056103a6b89ccfb3abfb65edbd99ae2b00248e825e475ac3ac3ff98a2dbc29e4c99a2483017dcb2f0a9a004f03a2e7c8105b612a917bd3a4b1fe6b5c79310dd43856cb8381a345dc7de11482887e638f515e362491256f431b77668b5a63cbc36e4cbcb160f4b212749ff406c16fd34bc37f28dfa751d85a0da5089ab8f483032959a1444eb8ceef115b520c3b8902376487148e8e70e5ba62d9eb2e70e8b6903c415ddb83bde3c7464057daf4e522bb5bc8d5b4c3b4b9814255839ffb58ce0fb0ca93b1ef4245b595b49c631dacd96bd9879995dd15d75baaac42d1e8b0d074d1ef5546f8184fc1bd3bb4c38ccb9091f42ecd8ce00f6ffb6a9485bf932cf4320e2665e1719896a57a46be0c3a1f325abccf6a86f12163e5f7f716e13795389ccc6aebd6e4f93ff39864913165ac45063b1db0267dda81b1e3acd9cb862465195ab5de92c28a7d77efcae1c996d9d5eaaed4188b7938b8876d67cb34b15e5aa599f122d8531d9b79309f28e14da40b2e7f91e6145c9fa5ec748bec9cc669d50350626b325a3e8bacd3cb64ac7e86a593704dd217055622da13529af38a41e1f22ac3c950ab061477286ad2174c4e7db6abd3971618ea5e54a0a9c7c06d2d2a6e6b20058a7887ecd63280aa6673f82cd38f2733fbd12b6e892c95fd9822f8d15de71fb697748e975fba5c74c13274c6c9a7979fe16b2674f29fa6fba6e68b47cc53dde04a500d0c6fda371d4aceac3521d8723368895a3a489c6d66278e7397dd671936bbef0a210d0966790ca25204dffa8ad63286168e327b9653fdec213e8b27bc8335bc70f0eb659f51378da0d37df16c68e0434c6140ddb5eef4dadee382804dc1b0718a8cb98524dfb148ab401329a033184a2befe754a6d88b4a516025c2865e856049c27736344342a87f9849a5a86b677f5c7efc81070ab8d3536a1718e64a5dae9cfd53adfc5fc4830f69574ee6faa6f5052d66f32310f5332acb3f956d97f7e35a820d7ba0d6edf10ee511579c5c649813898fba5567b99734b92f5877c70f01e17badc88b174d1ee56d3c7af8e23a9ac37421d62e74695e74d14e85f2f97ebe1ffefed0018084672bc6573f4f32d25fa821e6198b92ca2a7cea0f69b3563306d95013bcdbd90bb793c46e018814741907446b4221dd00cda37ad0cbe6a14bc2351387d87579a4868d67b17571556423a7c6940394e78a8e40588309432d8ae39e8f6b2aca9135c74d9df05ca9500a13b6367bbf1145c81855d199584a42883327757205fc04b65874fc53c521e0c1e895d583cda0accbe31a503ec371a9e9233554f0556112131e23530ccd69feee4b41a21fe56edb91d0a8ce149109fdfbb788cbb44e78bffcbbd15b3e94627ffdc5eed41d87946d09ed60e0b6a471ded7be00a302f9d018efd023074b04a724c0fa1751c8551e17ddc73b74cd0b7d59e7dea0bcbf2866a2225f4010b7220c416e33f181cab8456698693336454510fa3d59a4cb008cc370a84141b92dbacce9a48179d522805acef552b7d63b83b706055eeb1a6d427fb12839b26523ba7338bda0d2923c2af6f81ce4242a440269e1c8a18ab938ac312a6da469ce988bffb73e4f2c3fad4b48f8dddc7192af9568f4ce4ebba160fff0d80290944f2136cfe2112c725dffa6899137c6d442a567573b12534241883dd7df854bb5a8ec1e4ac080d964bec61cb3e33393268e4f0421fa898b2ae1a7455aa7a83d5e6c6935d1b86828bb86ec65603a0e555e11b058a36f240c37b04844d44c3fb7800d64b0c6c7eb38d9f00d33bbe5f660669dbe5ba192b20aaca784c178f65f88e65ca108838744ff2fcd42479268c8ca20d0a290e72ce5c2a0057945a7d0a48b8c15ffab13e77514947a2c7bf1ed37620c6af4b2095af2f2dffe1bf4bf7855cb3742a8dbf249e0d26335cfa3b07531d519e201d8dbd4a2131699203a1e2ed60101fe8a25af3c991d33e1b99575aaa2c1623b2a69959f8349da280f819196885579f68a3e42e07e0d2dc1b4479517a38004efe524851328650b38e56d09d17dfe251b5849f3f6347ebd7d376b05ed4b37aa921105c1be6e7560d26861966cf1d2a5fa931d41b7bdc4e12e2139a1fd19c05c371c37201be738338be3adfe8ecfa2d8b6b39bdcac7d0ef6b01f0a90cc36e57d81988bab6005b425d3b4c9123b569028f1f19678201c1a28e42ebd79a37e1f2537533dc694a2745d95b9c8b8fc393cd2e956e494c309879099e1911db3432e16f94b3dd70d1f0633c44087b624222e0413969c32f96e146d0e830df71412e446cceb27e24bdb70b240aedb3d8a996e19e821571ee90e6962f2937c5f9d5e6f5bb86125ee128fb999543b67461ee150b1c41146fb8c0e2ae928777f5917a1ca9ef8e7555f0793a1cc47392061b10f2ad4e723880f17b2e14bf032de65868036878830c19fc57ce40e7fe10722322f83eb42749c2729d914c5f368c752480f84a49e801203718231f485b40f55a046568de603fe31ad875d92762c9d587aecd67502d6f7ca3ce0d00889a9b7f5eaeeb2a0181060ba26fcbb1d11c444f983f5c017400426d5ba7b6d87781efb1decfc002f78a792b0491e1771ec3c34ac2014c95ae6e1649a02cd96cd0b13e1423fd3b6bfb405380e028cbac435c4fd9dd4ce6073320c235860c4731203c2c8a2ef9fba7732df71a009072783210defdbbaeea339685232cb4d1e897ec07a6420b1bc322f1a51f5d03a2e1a083c36f5ee8a19faf8ad8dfde28e2749b43a505c8ac84beb85af31f009cc89d046b69d59ce7f425a8d15308ece8fed1021c70164c0a69f0ddc1edae60c43f45b40a5d98aca00334874181f72155cda8b9b116bf148d97c1a5de8d83723a5267ee0bfb860b07b6d50c936c00f139c9cae647581a9fd070bb377d2a5cc95f42ebc3b76183f764ef50121bf3a1426e14d6bf8671c333fa02850dc72f7298c73d5e8c52a10bac86d30e78422b3a546d4e2f051104e9271f815f27c8b8674a5e8b0cc53542f2c56a5a2dcebe02cada5f28f62e35b4d1b4ba9f0c0d9a8d19b1062fe548e7a49e899c58247a92d24f440d7e7b9ed21ec52ba913e11022411c66d21e0dd046a18a8bdfad6da12d7e9a9baf5039c5269ed29071b855546b600aa8165e2f1429508bb8df8beb5505a489a2e659fcc784219823151e0a9fb16faa8cb7f592a4f26a6be733b6aca104f9cb01e27570a3d4760f02f9d473508c98d4a6896e2514e5f3fddb41ebc7605dc51e06b56ab26e0f544b69a4eb3453b1bf34313558f37b731c1a0b7e90b5d4feb46f5497bb1e85854286bce639ac67639f293ee38dfcd2b46549073bb5b4a2630dbb8d85cc5a11d2d61febe2a62fa1df091f2138453e71fdf9d7397228118e97d7d06294bab15a26a3f78850448ae760ed9ffbf84de1ca79f51ac86e5ea01a31cf21d3845a11d9fcc17ec027772f1c8e62dbc0f590d85da69f108a2494129055ca03d9a60ec6346b56153291b4098d655491ebcde107a6c0ce675686c9d4343f035d46dfa47891a86e078ab3470d095f7dfa55b0dff9f7028095d478f2712e7d9169eccf2e58e511ebf557ef6ae7a34e387f440c59d2ee02d8e3e27ac9de338715cae024ed2fcae6a547deadc3a62dc9a043f8114b1b00712cc8b30386deeb70974024c8e9f77cb523a2140a0697609aa157e891a802838d85cb63dad4f6ff3e0235522e577f6b4ef175b117ae1f62a85d1a6dec0a8d639ef4abff7ec451e543e3436df711f575026b2aa17d028d2ff2d8c0a6eb647fe31729b8952181bea8913fc964b0dd69bfdfe7057a9a37bd973a14bb61be5568570e99efef9515f8bdc1a6a7dac372f8dafc616405fa1d9674a12d08bcc0475ffb97dd5a0aa83d082c14d260afe036d5347f990d0089b29bb64eb7c6d9bcba75548185bfdfcedccbba2f63c48d1f13c02114ac0933ecaabb725b44de488626af560d6f83a9ed3caa8a619e1c79f52829d911477639ab7df7843576ca8db505a63680d642213e2f0b5c748be9623a0aaca5d5690315394471cd1677ec5bb4e16432ff6dc87b1f0130677b3d012da5cf452a4a32bfe4a2190b4d4187b014170e9b6c17e06f0ac011f8a58c030444eab39c95b98559216f00c44536cdfa97574a58878f517d23164603266a46336bc8134d1a02956943506b55d0ff20c475e039e4001f3aa00adf000fc8ed5c620353d7e2d547e8a78394ee2622414cf5b44c1eb8766cb2c74eb23f83ebe02aa8b06678077e9adf91400f15233646ea411c7a13476391accb44221a098143408fa2d2475587f58b1c6aec16826b645f6a4f5af7ba4e4053442c1c6895ea51859d33f8f5c7abf21b76c728391302fc1ac1ea39b9b13e536f2f280bde494addc85176a96683b08644537c1f4b1fb4f75d8921b6b41d4a0a58916c829b10daf8f9a521392104eaaa994d3206a54e0e6d6f47611e982f1d40597444cbe500df4b406419f46c55b5c608011bf05b726ab3785bb551df95c4a0692af1fee62c0edd3e46e7c039d8b63fcf41948d185b449dafa61b52117b85c1f426bae3cbd35c6a667160b6a3a73d69bdd35d5857f41ac4477d6fac25c7c611d3bec8df9cae1d304ff24e9487603d8daa0c28855c7aa9079fbfcd4f4f6bc5d2a4f1bd9645b2139c9cf25ec06ed703b9baa95cce5bbbee1d2fb402c10ae0b9756adc07e1e5617186058bac38a83f7f3414e9738c49d39f13cf172cad57c1f4d8c5a23bd9f07e53aa1aa6c7e58c2b830cef618dada81f824458a8d02043cddcca1b87f0c591e147b819f1b39ba57f2811711a29645ea06a11917647e402727dc719d99011a0a1a72541d043f51971e63131a7075b24ed8d12c2309506055a765d3e80e870f7ea26d0cbe8d211a63435d37e6956d08618fa6fb64ba7e03b18cbe09dbe68986708666a29866f163816af2ed3f16255600c229ef87c8e7011582ff41c5d7649f5d3ef05e617a0c03ee01c4a15a8251529a12c1c2e6b431d3d5430e34dce8d00c1e78f3c885bee6f4c54b5d6cf10684ae5827dd150a6174d20fdb12cd7a16d15d11023f6298fc5a5a4af5e01d2a06c85a474e80ff2108ff474ac221f0c344544fe8b26a8763bc00d5b6f84240182a6a3cfb9e055fdcacc45ced9218789cf84005a1dbbf8ca74bb812feccc24cab48e72dadf61d90351ce496927407a5aa6ca5ff9543ff01000b662b63dec59e36a751d94469e46bb23b17c7960c19a10f25cd34f668951af51bce50cde4fd8a6745a29aff4ef9158773e4a6623dcab82637b190082dfe8b958c40494d04135efc9ac426bde7a893216051535c0eeadd375af8670021e10e322aa71395ab0a0d37c1d79977357bc401fcf20ea27ebcdda282628799366ae2088489483cfb03bb194c879b6506c801023b2be216b796aa3771c58846dd686bb726800a2b2f87a0306fafe79f4b27681fad7a2b9bfc327b7f7e93b6decbeaeae76e4772fbfbc5c3ba7df92b065cb1a4833dbe51fd758432b2f6c829e21d0b298a6ba9334667f0ef68aa6e60b4fbe16787d63dada9c51aff5118dd528b6e0fa535d8ff3f785b76a71e88c3170ba690faf342397c6a7e455ee5a8666d3ebb7862f41c1b92713e2aa702b5a7f0f99d6c72f695c153bb750a6bf2f29a021c1672dba800f025520f7c1a952e6f519d31f56e77a1feb6d832ba1166743bb9d116ccafb03b70f1375e7995f13cebcf1af413c3f9e35c24495bf3dbb2126c00046a6d71027695aa65a95a36c74faecb942082646d9d4466caf59356f3fd4c6ab20de4876c8d0513fd0f79b3418f532ecb23445b80db2ef1074799b057be126312d307a8f53a393cfcbd37f675aef981ede0a11d77ac8f483fd314fdc9dc64da819109d93de818a52c8815314b6b86648c604442ab4960c21d721ac1a184c7890b898348e1bbdf357d90d76323b4a779fa2e0681a541fdc712a3b021a29381599238941aea93360e25c8abbe70925f603db2b4bc662b46966a791be09e952f880ea564dda791a954e61037de25e0a000e83c9a7de51ba1f7bbb0a4c7e1e1a8c35420aed9fc28653a6c33665910689158b86f76f6a85738a90d73583a51d9428ba4efe15cf0298b79bcabb481831bf1e2529f925e4bed961a6e26f760e5ae28d989a5f3f342a5b1811b0e7cb2accaf0a9e80712a8758c7b8d148f18e1f6fc81273d7b65c117220bc1437a22bb9a5d167d676e3cbdc8f4045bd642c77d93027102e2cf6389c48760e922b5e4020e54e2aa3370ccb188e58b3a71ed8395a8a084d65265b811cdc84e715dc3eb62864c74471d00d942e66bc2c74303535c2509f5fee8914313a5649f0043512d97c82a5bcff2ffd4e980e9bfbcce191aaeea98</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> encrypt </tag>
            
            <tag> hide </tag>
            
            <tag> server </tag>
            
            <tag> aliyun </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv-6-图像绘制与opencv Line 函数剖析</title>
      <link href="/2020/04-22/opencv-6-%E9%BC%A0%E6%A0%87%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F.html"/>
      <url>/2020/04-22/opencv-6-%E9%BC%A0%E6%A0%87%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F.html</url>
      
        <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>越到后面, 写的越慢, 之前还抽空去看了下 学堂在线那篇文章提供的方法,  博客第一个人评论的我, 想想还是要给人家一个交代的, 就想着找到一个方法进行下载, 但是尝试了 还没找到, 估计我要花时间自己写一个了, 不是很难, 但是 就是要花时间, 安排到日程上了, 应该会有结果的, 到时候再写博文记录.</p><p>之前都是空的, 写起来很快, 后面的话我还要去写具体的代码实现,  争取都能够复现出来, 这样更有实际意义, 所以接下来可能更新的更慢了, 不过应该不会断, 我计划的很长, 但是我想 至少写够20篇吧, 加油.</p><p>在这篇文章以及后续的文章中,我们都会 说明一些代码出现的地方,  头文件对应的 opencv 库引用目录 include 文件夹下面的文件 源文件则是 opencv 4.3.0 下的 Source 文件夹里面的文件<br>同样的, 文件的后面使用 <code>:xx</code>  标识, 在文件的xx 行的地方</p><blockquote><p>头文件 <code>opencv2/opencv.hpp:100</code> 在 opencv.hpp 第100 行开始的地方<br>源文件 <code>modules/imgproc/src/drawing.cpp:1000</code> 则是在 1000 行的地方</p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[toc]</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在上一篇中, 我们能够进行像素点的操作了, 那么, 很明显的一个问题, 我能不能在图像上画一条线呢, 或者在图像上自己用鼠标绘制呢,  当然可以, opencv 提供了这些功能,</p><p>在opencv 的文档中 <a href="https://docs.opencv.org/4.3.0/d3/d96/tutorial_basic_geometric_drawing.html" target="_blank" rel="noopener">Basic Drawing</a>, 基础绘图章节, 有相关的例程, </p><p>我们在之前的文章中提到了 opencv 座标系的问题</p><ul><li>以左上角为起始点</li><li>横向为x, 纵向为y</li><li>使用 at(rows,cols) 确定座标值  对应的是 (行,列)</li><li>使用 point(x,y)  定位, 使用的是 (列, 行) </li></ul><p>这两个定位是不一样的 ,所一定要注意, opencv 在 绘制图形的时候 使用的是 Point 来进行的定位, 我们可以使用 <code>cv::Point p = cv::Point(20,30)</code> 直接初始化, 或者使用 <code>cv::Point p; p.x = 20,p.y=30;</code> 初始化后进行赋值操作.</p><h3 id="在图像上绘制标准图形"><a href="#在图像上绘制标准图形" class="headerlink" title="在图像上绘制标准图形"></a>在图像上绘制标准图形</h3><p>我们还以 lena 为例, 在图片上绘制 以 (x,y) 座标的图形</p><ul><li>直线: 起点(100,200) - 终点(500,300)   绿色</li><li>直线: 起点 (100,500) - 终点(500,100)  蓝色</li><li>圆:  圆心 (200,300)   半径 200      红色</li><li>矩形: 左上角点 (100,120)  右下角点(400,450);  白色</li><li>文字: 起始点: (100,200), 文字: OpenCV  </li><li>….</li></ul><p>在我们绘制之前, 我们要说明一个函数 <code>cv::Scalar</code> 是opencv 的颜色函数,  按照 <code>BGR</code> 的顺序传入三个参数,  用于指名绘制图形的颜色</p><blockquote><p>note: 实际上是 4个参数, 一般我们不使用最后一个参数即可^[《OpenCV: Basic Drawing》. 见于 2020年4月24日. <a href="https://docs.opencv.org/4.3.0/d3/d96/tutorial_basic_geometric_drawing.html.]" target="_blank" rel="noopener">https://docs.opencv.org/4.3.0/d3/d96/tutorial_basic_geometric_drawing.html.]</a></p></blockquote><h3 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h3><p>我们根据上面给出的顺序  依次 编写代码, 将图形绘制到 lena 图的上面,<br> 我们可以得到这样的程序, 就是一条一条的写,  我们只需要调用 相应的opencv 函数就能绘制了,  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//QApplication a(argc, argv);</span></span><br><span class="line">    <span class="comment">//MainWindow w;</span></span><br><span class="line">    <span class="comment">//w.show();</span></span><br><span class="line">    <span class="comment">// 设置 要显示的图像路径</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> img_lena = <span class="string">"./TestImages/lena.png"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取两幅彩色图像  512*512</span></span><br><span class="line">    cv::Mat lena_bgr = cv::imread(img_lena);</span><br><span class="line">    <span class="comment">// 声明结果图像 1020*1020</span></span><br><span class="line">    cv::Mat res_bgr = cv::Mat::zeros(cv::Size(<span class="number">512</span>,<span class="number">512</span>), CV_8UC3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制基本图形</span></span><br><span class="line">    cv::line(lena_bgr, cv::Point(<span class="number">100</span>, <span class="number">200</span>), cv::Point(<span class="number">500</span>, <span class="number">300</span>), cv::Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>));</span><br><span class="line">    cv::line(lena_bgr, cv::Point(<span class="number">100</span>, <span class="number">500</span>), cv::Point(<span class="number">500</span>, <span class="number">100</span>), cv::Scalar(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    cv::circle(lena_bgr, cv::Point(<span class="number">200</span>, <span class="number">300</span>), <span class="number">200</span>, cv::Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line">    cv::rectangle(lena_bgr, cv::Rect(cv::Point(<span class="number">100</span>, <span class="number">120</span>), cv::Point(<span class="number">400</span>, <span class="number">500</span>)), cv::Scalar(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">    cv::putText(lena_bgr, <span class="string">"OpenCV"</span>, cv::Point(<span class="number">100</span>, <span class="number">200</span>), cv::FONT_HERSHEY_COMPLEX,<span class="number">1.0</span>, cv::Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">    cv::imshow(<span class="string">"lena_bgr"</span>,lena_bgr);</span><br><span class="line"></span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// return a.exec();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终我们运行之后 ,便能够得到这样的一副图像, 很简单, 具体的参数部分自己选择就好,  这里只是给出一个示例, </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587733292407.png" alt="opencv 基本图形绘制"></p><h3 id="line-函数-源码分析剖析"><a href="#line-函数-源码分析剖析" class="headerlink" title="line 函数 源码分析剖析"></a>line 函数 源码分析剖析</h3><p>其实opencv 还能绘制其他的图形, 太多了, 可以在<a href="https://docs.opencv.org/4.3.0/d6/d6e/group__imgproc__draw.html#ga5126f47f883d730f633d74f07456c576" target="_blank" rel="noopener">Drawing Functions</a>页面去查看, 基本没啥用, 很多时候是需要了自己造个轮子就行了, 不查文档我都不知道能绘制这么多</p><p>只需要知道直线, 圆, 矩形怎么绘制的就行了, 多了也用不到</p><p>后续的部分 主要是 opencv 怎么去实现的 line 函数了, 涉及到比较基础的, 看不看不影响你的使用, 不想看的就关闭即可..</p><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>我们以 绘制直线为例, 这个简单, 我们使用了 <code>cv::line</code> 就绘制出来了一条直线<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::line</span><span class="params">(InputOutputArray img,</span></span></span><br><span class="line"><span class="function"><span class="params">Point pt1,</span></span></span><br><span class="line"><span class="function"><span class="params">Point pt2,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> Scalar &amp; color,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> thickness = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> lineType = LINE_8,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> shift = <span class="number">0</span> </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure><br>各个参数意义其实名称还是能够 看出来的 </p><ul><li>img: 输入输出图像, 直接在这个图像上绘制</li><li>pt1: 起始点 (x,y) 座标</li><li>pt2: 终止点 (x,y) 座标</li><li>color: Scalar 参数生成的颜色</li><li>*thickness: 直线宽度</li><li>*lineType: 绘制的线的形式  4邻域 8邻域等</li><li>*shift: 精度, 点座标中的小数点等级(第一次看到这个参数, 暂时不管他什么意思)</li></ul><p>一般我们只需要前面的四个参数就行了,  一般就是我们程序中的 <code>cv::line(lena_bgr, cv::Point(100, 200), cv::Point(500, 300), cv::Scalar(0, 255, 0));</code>   </p><p>座标颜色我们都说过了, 那我们去看下 他的源码:<br>在 <code>modules\imgproc\srcdrawing.cpp:1772</code> 中, 我们能够看到 直线的绘制函数, </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">line</span><span class="params">( InputOutputArray _img, Point pt1, Point pt2, <span class="keyword">const</span> Scalar&amp; color,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> thickness, <span class="keyword">int</span> line_type, <span class="keyword">int</span> shift )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CV_INSTRUMENT_REGION();</span><br><span class="line"></span><br><span class="line">    Mat img = _img.getMat();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( line_type == CV_AA &amp;&amp; img.depth() != CV_8U )</span><br><span class="line">        line_type = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    CV_Assert( <span class="number">0</span> &lt; thickness &amp;&amp; thickness &lt;= MAX_THICKNESS );</span><br><span class="line">    CV_Assert( <span class="number">0</span> &lt;= shift &amp;&amp; shift &lt;= XY_SHIFT );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> buf[<span class="number">4</span>];</span><br><span class="line">    scalarToRawData( color, buf, img.type(), <span class="number">0</span> );</span><br><span class="line">    ThickLine( img, pt1, pt2, buf, thickness, line_type, <span class="number">3</span>, shift );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个只是一个封装, 将颜色分成一个double 数组, 然后 调用了一个新的函数 <code>ThickLine</code></p><p>这里 实际上 这里的<code>scalarToRawData</code> 函数也是根据图像的通道进行调用了, <code>scalarToRawData_</code> 的函数, 将颜色结构体的四个值分别存入数组中, 也为了兼容以前的版本, 所以采用的这种接口.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scalarToRawData_</span><span class="params">(<span class="keyword">const</span> Scalar&amp; s, T * <span class="keyword">const</span> buf, <span class="keyword">const</span> <span class="keyword">int</span> cn, <span class="keyword">const</span> <span class="keyword">int</span> unroll_to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; cn; i++)</span><br><span class="line">        buf[i] = saturate_cast&lt;T&gt;(s.val[i]);</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; unroll_to; i++)</span><br><span class="line">        buf[i] = buf[i-cn];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>去看了下 opencv 的矩形 <code>rectancle</code> 函数是实际上是基于 <code>polyline</code> 多边形绘制, 而它则是基于 <code>ThickLine</code>的,  opencv 的函数都是这样基于最简单的元素来实现的, 所以我们继续看这个实现就好<br>感觉线形状的绘制最终都是调用的这个, 那我们去看下具体的实现.</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587733292180.png" alt="opencv drawing 调用图"></p><p>在文件 <code>modules\imgproc\src\drawing.cpp:1602</code> 是这个函数的实现, </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">ThickLine( Mat&amp; img, Point2l p0, Point2l p1, <span class="keyword">const</span> <span class="keyword">void</span>* color,</span><br><span class="line">           <span class="keyword">int</span> thickness, <span class="keyword">int</span> line_type, <span class="keyword">int</span> flags, <span class="keyword">int</span> shift )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> INV_XY_ONE = <span class="number">1.</span>/XY_ONE;</span><br><span class="line"></span><br><span class="line">    p0.x &lt;&lt;= XY_SHIFT - shift;</span><br><span class="line">    p0.y &lt;&lt;= XY_SHIFT - shift;</span><br><span class="line">    p1.x &lt;&lt;= XY_SHIFT - shift;</span><br><span class="line">    p1.y &lt;&lt;= XY_SHIFT - shift;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( thickness &lt;= <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( line_type &lt; CV_AA )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( line_type == <span class="number">1</span> || line_type == <span class="number">4</span> || shift == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                p0.x = (p0.x + (XY_ONE&gt;&gt;<span class="number">1</span>)) &gt;&gt; XY_SHIFT;</span><br><span class="line">                p0.y = (p0.y + (XY_ONE&gt;&gt;<span class="number">1</span>)) &gt;&gt; XY_SHIFT;</span><br><span class="line">                p1.x = (p1.x + (XY_ONE&gt;&gt;<span class="number">1</span>)) &gt;&gt; XY_SHIFT;</span><br><span class="line">                p1.y = (p1.y + (XY_ONE&gt;&gt;<span class="number">1</span>)) &gt;&gt; XY_SHIFT;</span><br><span class="line">                Line( img, p0, p1, color, line_type );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Line2( img, p0, p1, color );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LineAA( img, p0, p1, color );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Point2l pt[<span class="number">4</span>], dp = Point2l(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">double</span> dx = (p0.x - p1.x)*INV_XY_ONE, dy = (p1.y - p0.y)*INV_XY_ONE;</span><br><span class="line">        <span class="keyword">double</span> r = dx * dx + dy * dy;</span><br><span class="line">        <span class="keyword">int</span> i, oddThickness = thickness &amp; <span class="number">1</span>;</span><br><span class="line">        thickness &lt;&lt;= XY_SHIFT - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">fabs</span>(r) &gt; DBL_EPSILON )</span><br><span class="line">        &#123;</span><br><span class="line">            r = (thickness + oddThickness*XY_ONE*<span class="number">0.5</span>)/<span class="built_in">std</span>::<span class="built_in">sqrt</span>(r);</span><br><span class="line">            dp.x = cvRound( dy * r );</span><br><span class="line">            dp.y = cvRound( dx * r );</span><br><span class="line"></span><br><span class="line">            pt[<span class="number">0</span>].x = p0.x + dp.x;</span><br><span class="line">            pt[<span class="number">0</span>].y = p0.y + dp.y;</span><br><span class="line">            pt[<span class="number">1</span>].x = p0.x - dp.x;</span><br><span class="line">            pt[<span class="number">1</span>].y = p0.y - dp.y;</span><br><span class="line">            pt[<span class="number">2</span>].x = p1.x - dp.x;</span><br><span class="line">            pt[<span class="number">2</span>].y = p1.y - dp.y;</span><br><span class="line">            pt[<span class="number">3</span>].x = p1.x + dp.x;</span><br><span class="line">            pt[<span class="number">3</span>].y = p1.y + dp.y;</span><br><span class="line"></span><br><span class="line">            FillConvexPoly( img, pt, <span class="number">4</span>, color, line_type, XY_SHIFT );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( flags &amp; (i+<span class="number">1</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( line_type &lt; CV_AA )</span><br><span class="line">                &#123;</span><br><span class="line">                    Point center;</span><br><span class="line">                    center.x = (<span class="keyword">int</span>)((p0.x + (XY_ONE&gt;&gt;<span class="number">1</span>)) &gt;&gt; XY_SHIFT);</span><br><span class="line">                    center.y = (<span class="keyword">int</span>)((p0.y + (XY_ONE&gt;&gt;<span class="number">1</span>)) &gt;&gt; XY_SHIFT);</span><br><span class="line">                    Circle( img, center, (thickness + (XY_ONE&gt;&gt;<span class="number">1</span>)) &gt;&gt; XY_SHIFT, color, <span class="number">1</span> );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    EllipseEx( img, p0, Size2l(thickness, thickness),</span><br><span class="line">                               <span class="number">0</span>, <span class="number">0</span>, <span class="number">360</span>, color, <span class="number">-1</span>, line_type );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p0 = p1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在讲函数的实现之前, 我们先看几个参数, 线形: <code>linetype</code> 以及线宽 <code>thickness</code></p><p>其中 <code>linetype</code> 这里可以看<a href="https://blog.csdn.net/lly1122334/article/details/88913758" target="_blank" rel="noopener">OpenCV线型lineType</a> 这篇博客, 他做了几种线形的对比, </p><p>在 头文件<code>opencv2\imgproc.hpp:804</code> 中,  定义了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> LineTypes &#123;</span><br><span class="line">    FILLED  = <span class="number">-1</span>,</span><br><span class="line">    LINE_4  = <span class="number">4</span>, <span class="comment">//!&lt; 4-connected line</span></span><br><span class="line">    LINE_8  = <span class="number">8</span>, <span class="comment">//!&lt; 8-connected line</span></span><br><span class="line">    LINE_AA = <span class="number">16</span> <span class="comment">//!&lt; antialiased line</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>对应的: </p><ul><li>FILLED: 填充</li><li>LINE_4: 四邻域直线, </li><li>LINE_8: 8邻域直线</li><li>LINE_AA: 抗锯齿直线</li></ul><p>再看两个宏, 在<code>modules\imgproc\src\drawing.cpp:46</code> 定义了</p><ul><li>XY_SHIFT: 16</li><li>XY_ONE: 1 &lt;&lt; XY_SHIFT    表示左移16位 = 65536</li></ul><p>我们在进行转换之前, 有一个小点需要关注一下, 我们<code>line</code> 函数输入的点是 <code>Point2i</code>, 而<code>ThickLine</code> 函数输入的点变成了 <code>Point2l</code>, 有意思,<br>在<code>\modules\core\include\opencv2\core\types.hpp:190</code>, 我们找到了这样的定义,  其实是一样的 , 就是定义的必须是 64长度的 int 类型, 为什么, 好用于移位呀,<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Point_&lt;<span class="keyword">int</span>&gt; Point2i;</span><br><span class="line"><span class="keyword">typedef</span> Point_&lt;int64&gt; Point2l;</span><br><span class="line"><span class="keyword">typedef</span> Point2i Point;</span><br></pre></td></tr></table></figure><br>这里有一段程序, 是这样的 , 我们去掉 if 再看一下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p0.x &lt;&lt;= XY_SHIFT - shift;</span><br><span class="line">p0.y &lt;&lt;= XY_SHIFT - shift;</span><br><span class="line">p1.x &lt;&lt;= XY_SHIFT - shift;</span><br><span class="line">p1.y &lt;&lt;= XY_SHIFT - shift;</span><br><span class="line"></span><br><span class="line">p0.x = (p0.x + (XY_ONE&gt;&gt;<span class="number">1</span>)) &gt;&gt; XY_SHIFT;</span><br><span class="line">p0.y = (p0.y + (XY_ONE&gt;&gt;<span class="number">1</span>)) &gt;&gt; XY_SHIFT;</span><br><span class="line">p1.x = (p1.x + (XY_ONE&gt;&gt;<span class="number">1</span>)) &gt;&gt; XY_SHIFT;</span><br><span class="line">p1.y = (p1.y + (XY_ONE&gt;&gt;<span class="number">1</span>)) &gt;&gt; XY_SHIFT;</span><br></pre></td></tr></table></figure><br>shift 的 默认参数是 0,  这里的shift 实际上是座标移位的一个作用, 实际上结果就是移位得到结果  这里加上一般是为了<code>XY_ONE&gt;&gt;1</code> 实际上 加上0.5  向上取整而已</p><blockquote><p>个人分析, 不一定是真实意图</p></blockquote><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587733292824.png" alt="shift = 0,1,2,3 绘制的直线"> </p><p>由于绘制函数的 <code>ThickLine</code> 函数考虑了线宽,  我们先以基础的线宽为例:  上面一通操作只是给座标进行了变换,得到了有效的座标, 然后 来到了我们最终的 进行绘制的函数,<code>Line</code> ,首写字母大写的呦, 这里的核心就是 构建一个直线迭代器, 在每个点的位置上依次填入颜色即可,<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">Line( Mat&amp; img, Point pt1, Point pt2,</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">void</span>* _color, <span class="keyword">int</span> connectivity = <span class="number">8</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( connectivity == <span class="number">0</span> )</span><br><span class="line">        connectivity = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( connectivity == <span class="number">1</span> )</span><br><span class="line">        connectivity = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">LineIterator <span class="title">iterator</span><span class="params">(img, pt1, pt2, connectivity, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i, count = iterator.count;</span><br><span class="line">    <span class="keyword">int</span> pix_size = (<span class="keyword">int</span>)img.elemSize();</span><br><span class="line">    <span class="keyword">const</span> uchar* color = (<span class="keyword">const</span> uchar*)_color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; count; i++, ++iterator )</span><br><span class="line">    &#123;</span><br><span class="line">        uchar* ptr = *iterator;</span><br><span class="line">        <span class="keyword">if</span>( pix_size == <span class="number">1</span> )</span><br><span class="line">            ptr[<span class="number">0</span>] = color[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( pix_size == <span class="number">3</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            ptr[<span class="number">0</span>] = color[<span class="number">0</span>];</span><br><span class="line">            ptr[<span class="number">1</span>] = color[<span class="number">1</span>];</span><br><span class="line">            ptr[<span class="number">2</span>] = color[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">memcpy</span>( *iterator, color, pix_size );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么, 还没到最后, 我们继续 在 <code>modules\imgproc\src\drawing.cpp:160</code> 的地方, 找到了 <code>LineIterator</code> 类的 构造函数,<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Initializes line iterator.</span></span><br><span class="line"><span class="comment">   Returns number of points on the line or negative number if error.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LineIterator::LineIterator(<span class="keyword">const</span> Mat&amp; img, Point pt1, Point pt2,</span><br><span class="line">                           <span class="keyword">int</span> connectivity, <span class="keyword">bool</span> left_to_right)</span><br><span class="line">&#123;</span><br><span class="line">    count = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    CV_Assert( connectivity == <span class="number">8</span> || connectivity == <span class="number">4</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( (<span class="keyword">unsigned</span>)pt1.x &gt;= (<span class="keyword">unsigned</span>)(img.cols) ||</span><br><span class="line">        (<span class="keyword">unsigned</span>)pt2.x &gt;= (<span class="keyword">unsigned</span>)(img.cols) ||</span><br><span class="line">        (<span class="keyword">unsigned</span>)pt1.y &gt;= (<span class="keyword">unsigned</span>)(img.rows) ||</span><br><span class="line">        (<span class="keyword">unsigned</span>)pt2.y &gt;= (<span class="keyword">unsigned</span>)(img.rows) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( !clipLine( img.size(), pt1, pt2 ) )</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = img.data;</span><br><span class="line">            err = plusDelta = minusDelta = plusStep = minusStep = count = <span class="number">0</span>;</span><br><span class="line">            ptr0 = <span class="number">0</span>;</span><br><span class="line">            step = <span class="number">0</span>;</span><br><span class="line">            elemSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> bt_pix0 = img.elemSize(), bt_pix = bt_pix0;</span><br><span class="line">    <span class="keyword">size_t</span> istep = img.step;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dx = pt2.x - pt1.x;</span><br><span class="line">    <span class="keyword">int</span> dy = pt2.y - pt1.y;</span><br><span class="line">    <span class="keyword">int</span> s = dx &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( left_to_right )</span><br><span class="line">    &#123;</span><br><span class="line">        dx = (dx ^ s) - s;</span><br><span class="line">        dy = (dy ^ s) - s;</span><br><span class="line">        pt1.x ^= (pt1.x ^ pt2.x) &amp; s;</span><br><span class="line">        pt1.y ^= (pt1.y ^ pt2.y) &amp; s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        dx = (dx ^ s) - s;</span><br><span class="line">        bt_pix = (bt_pix ^ s) - s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr = (uchar*)(img.data + pt1.y * istep + pt1.x * bt_pix0);</span><br><span class="line"></span><br><span class="line">    s = dy &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line">    dy = (dy ^ s) - s;</span><br><span class="line">    istep = (istep ^ s) - s;</span><br><span class="line"></span><br><span class="line">    s = dy &gt; dx ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* conditional swaps */</span></span><br><span class="line">    dx ^= dy &amp; s;</span><br><span class="line">    dy ^= dx &amp; s;</span><br><span class="line">    dx ^= dy &amp; s;</span><br><span class="line"></span><br><span class="line">    bt_pix ^= istep &amp; s;</span><br><span class="line">    istep ^= bt_pix &amp; s;</span><br><span class="line">    bt_pix ^= istep &amp; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( connectivity == <span class="number">8</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        assert( dx &gt;= <span class="number">0</span> &amp;&amp; dy &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        err = dx - (dy + dy);</span><br><span class="line">        plusDelta = dx + dx;</span><br><span class="line">        minusDelta = -(dy + dy);</span><br><span class="line">        plusStep = (<span class="keyword">int</span>)istep;</span><br><span class="line">        minusStep = (<span class="keyword">int</span>)bt_pix;</span><br><span class="line">        count = dx + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* connectivity == 4 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        assert( dx &gt;= <span class="number">0</span> &amp;&amp; dy &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        err = <span class="number">0</span>;</span><br><span class="line">        plusDelta = (dx + dx) + (dy + dy);</span><br><span class="line">        minusDelta = -(dy + dy);</span><br><span class="line">        plusStep = (<span class="keyword">int</span>)(istep - bt_pix);</span><br><span class="line">        minusStep = (<span class="keyword">int</span>)bt_pix;</span><br><span class="line">        count = dx + dy + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;ptr0 = img.ptr();</span><br><span class="line">    <span class="keyword">this</span>-&gt;step = (<span class="keyword">int</span>)img.step;</span><br><span class="line">    <span class="keyword">this</span>-&gt;elemSize = (<span class="keyword">int</span>)bt_pix0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>做稍微一点的 简化, 实际上就是考虑正负符号的处理呀,  这里主要使用的就是 异或 (xor) 和 与 运算(&amp;)<br>这里要考虑计算顺序, 注意就好 运算优先级为如下</p><ul><li>11    a&amp;b    逐位与</li><li>12    ^    逐位异或（互斥或）</li><li>13    |    逐位或（可兼或）</li></ul><p>可以参考文章<a href="https://blog.csdn.net/ice110956/article/details/12746819" target="_blank" rel="noopener">异或的妙用</a> 和文章<a href="https://blog.csdn.net/sinat_35121480/article/details/53510793" target="_blank" rel="noopener">位运算总结(按位与,或,异或)</a>, 算是一个基础的x 运算吧 </p><p>在计算中, 巧妙的加入了 s 作为符号,  这样减少每次计算正负的比较, </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> bt_pix0 = img.elemSize(), bt_pix = bt_pix0;</span><br><span class="line"><span class="keyword">size_t</span> istep = img.step;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx = pt2.x - pt1.x;</span><br><span class="line"><span class="keyword">int</span> dy = pt2.y - pt1.y;</span><br><span class="line"><span class="keyword">int</span> s = dx &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">dx = (dx ^ s) - s;</span><br><span class="line">dy = (dy ^ s) - s;</span><br><span class="line">pt1.x ^= (pt1.x ^ pt2.x) &amp; s;</span><br><span class="line">pt1.y ^= (pt1.y ^ pt2.y) &amp; s;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录起点的指针, </span></span><br><span class="line">ptr = (uchar*)(img.data + pt1.y * istep + pt1.x * bt_pix0);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用符号, 巧妙的得到 绝对值</span></span><br><span class="line">s = dy &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line">dy = (dy ^ s) - s;</span><br><span class="line">istep = (istep ^ s) - s;</span><br><span class="line"></span><br><span class="line">s = dy &gt; dx ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有符号的 值交换 交换 dx dy  与 bt_pix istep</span></span><br><span class="line"><span class="comment">/* conditional swaps */</span></span><br><span class="line">dx ^= dy &amp; s;</span><br><span class="line">dy ^= dx &amp; s;</span><br><span class="line">dx ^= dy &amp; s;</span><br><span class="line"></span><br><span class="line">bt_pix ^= istep &amp; s;</span><br><span class="line">istep ^= bt_pix &amp; s;</span><br><span class="line">bt_pix ^= istep &amp; s;</span><br><span class="line"></span><br><span class="line">err = dx - (dy + dy);</span><br><span class="line">plusDelta = dx + dx;</span><br><span class="line">minusDelta = -(dy + dy);</span><br><span class="line">plusStep = (<span class="keyword">int</span>)istep;</span><br><span class="line">minusStep = (<span class="keyword">int</span>)bt_pix;</span><br><span class="line">count = dx + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这里的处理真的 很巧妙, 有符号的值交换, 然后设置相应的符号mask, 及其这里求绝对值的方式,  不懂的话 就个8位的数字 代入进行运算, 可以得到想要的结果, 跑一遍就会了<br>我之后写一篇文章 看下这里的符号运算吧,  真厉害!   </p><p>在这里完成了起始点的确定, 给出了一共有多少点的存在<code>count=dx+1</code>, 通过确定了 我们可以假定 dx 会沿着一个方向依次相加 但是dy呢,   我们还是没有解决怎么确定的一条直线,<br>在<code>Line</code> 函数的这一句, <code>for( i = 0; i &lt; count; i++, ++iterator )</code> 这里的迭代器是累加的, 但是,迭代器是我们自己自定义的, 那么, <code>++</code> 操作会不会也是自定义的呢,<br>在<code>modules\imgproc\include\opencv2\imgproc.hpp:4673</code> 行的地方, 我们看到了这里重载了操作符号, 这样我们在进行加加操作的时候,  这里的err 就会自己调节了, </p><ul><li>err &gt;= 0  mask = 0  err += -2dy  ptr += minusStep</li><li>err &lt; 0  mask = -1   err += -2dy + 2dx 这里会 得到一个正的值,<br>这里更加的巧妙, 具体的公式或者过程需要慢慢推导, </li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line">LineIterator&amp; LineIterator::<span class="keyword">operator</span> ++()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = err &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line">    err += minusDelta + (plusDelta &amp; mask);</span><br><span class="line">    ptr += minusStep + (plusStep &amp; mask);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">LineIterator LineIterator::<span class="keyword">operator</span> ++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    LineIterator it = *<span class="keyword">this</span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之就是 巧妙的使用了两个变量, 使得我们的累加根据斜率进行累加过程, 完成执行,  很巧妙, </p><p>我这里 不再进行后续推导了, , 后续有机会在做… </p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
            <tag> c++ </tag>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好用工具--VirtualAssistX</title>
      <link href="/2020/04-22/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90--VirtualAssistX.html"/>
      <url>/2020/04-22/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90--VirtualAssistX.html</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>VSX 真的是  VS上写 C++ 最好用的插件了,  狂吹</p><p>VSX  我一般称为 番茄插件, 因为他的图标是一个番茄, </p><p>感觉这位博主写的很详细看<a href="https://zhuanlan.zhihu.com/p/26643499" target="_blank" rel="noopener">Visual Assist 特性和技巧 (2017)</a> 这篇文章 , 是一位 常年使用的人写的 , 自然比我写的好, </p><p>而我只会感觉好用, 真 NB, 推荐,, 他从细节的地方都介绍了, </p><p>如果只是入门介绍的话, 推荐<a href="https://wiki.jikexueyuan.com/project/visual-studio/7.html" target="_blank" rel="noopener"></a> 这篇文章, 讲的很细节, 但是很好用</p><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>由于 VSX 属于付费软件, 可以选择付费购买, 看这篇文章的方法</p><blockquote><p><a href="https://blog.csdn.net/qq_43551263/article/details/88559554" target="_blank" rel="noopener">vs 2017插件visual assist 10.9.2238破解版安装指南及百度云链接</a>, 做了详细的安装方法</p></blockquote><p>或者直接选择在 VS 的拓展界面进行能够联机安装</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><img src="./images/1587521098471.png" alt="安装之后的菜单"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> VS </tag>
            
            <tag> soft </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记梦器-0422</title>
      <link href="/2020/04-22/%E8%AE%B0%E6%A2%A6%E5%99%A8.html"/>
      <url>/2020/04-22/%E8%AE%B0%E6%A2%A6%E5%99%A8.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a573ce50a490410caf70f61d62bd011159ac5b14ced8901ffb8112b5a1ff4ca6">35889bf2af8f9c463676f35c334c6f989b64c2e508ba386ff533d8f04ae9e2f298b628fce98a06d18e29ee67bf7cbe2f36143e691f24cf49dce7ba99a098e73184c19da318bbc35fa50aa701eca1aa4b0a146966c1213d5e5219848e6d06bfed1574380cee032f3b4b13dfa6cf3f9185fb35b79619c180c1235c4e6ef06a6d54f414e93143a1e1c9930b20ff650a91d7a769f47732ee71825402c019a0fca74ece3b9a831ae7ca383982b7a4a33d05556a55d35c010b4472432249ad603e5b954daa2c0e95b9910c7179b86030f4214f1334f2ec7694531b2a777579641116b77fed6caccb73b5f0bd78d2e5cfaade5b40f0d3cdf8f0922f7b50bd4deb40fde8ae02835732411c422f026d9cbbce5d4f3b83f04207c2d51c69bd1e1d540bb017b27f5e5cf88474749420a6ca6d046ac31388d0060ff5b8c428189171efee6a401999ca7301a38329a191cd4c87b333f44952b5620eb95b38eadf1e258f58671e0b86ea331d1321f445b6cb61c535290a581c63961ab50ef2a4ff52b75c0fe88697a434f4ac3616771775c09840d1e339999a6f3dd4283e7722ddb54b7ed372b2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Person </category>
          
      </categories>
      
      
        <tags>
            
            <tag> person </tag>
            
            <tag> encrypt </tag>
            
            <tag> hide </tag>
            
            <tag> dream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv-5-图像遍历与图像改变</title>
      <link href="/2020/04-21/opencv-5-matpx.html"/>
      <url>/2020/04-21/opencv-5-matpx.html</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[toc]</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="图像的像素点访问与遍历"><a href="#图像的像素点访问与遍历" class="headerlink" title="图像的像素点访问与遍历"></a>图像的像素点访问与遍历</h3><p>我们在上一篇文章中已经 大概介绍了 mat 图像的数据格式, 实际上可以理解为一个二维数组的格式, 那么 <del>茴香豆的茴字一共有几种写法</del>  访问一个像素点有几种方式呢<br>在opencv 的官方文档:  <a href="https://docs.opencv.org/4.3.0/db/da5/tutorial_how_to_scan_images.html" target="_blank" rel="noopener">How to scan images, lookup tables and time measurement with OpenCV</a><br>说了一共有三种, 常用的做法, 也可以参考<a href="https://blog.csdn.net/qq_29540745/article/details/52443697" target="_blank" rel="noopener">Opencv访问图像像素的三种方法</a> 这篇文章, </p><h4 id="opencv-座标定义"><a href="#opencv-座标定义" class="headerlink" title="opencv 座标定义"></a>opencv 座标定义</h4><p>opencv 对于图像数据的 座标是从左上角开始 的, </p><ul><li>纵向的座标 y 也称为行 rows </li><li>横座标 y 也称为 列  cols<br>座标范围: (0,0)– (rows-1,cols-1)  我们一般使用 (行,列) 的方式进行访问, </li></ul><p>也比如 我们使用 $cv::Size(rows,cols)$ 设置 行列尺寸的</p><p>但是对于 二维点, $cv::Point(x,y)$ 实际上是 以 列行做 的尺寸, 此处也要进行注意</p><h4 id="下标访问"><a href="#下标访问" class="headerlink" title="下标访问"></a>下标访问</h4><p>对于二维数组, 肯定是使用 下标索引访问了  </p><p>比如我们在上一篇文章中, 使用 <code>lena_rgb.at&lt;cv::Vec3b&gt;(i, j)</code> 进行彩色图像的访问, 使用<code>lena_gray_avg.at&lt;uchar&gt;(i, j)</code> 进行灰度图像的访问.</p><p>也就是  <code>Mat</code> 的 <code>at()</code> 方法进行图像的访问, 具体还要考虑灰度图像或者 彩色图像, 因为对于灰度图像只有一个值, 彩色图像每一个位置是有3个值的, 我们可以使用  <code>lena_rgb.at&lt;cv::Vec3b&gt;(i, j)[k]</code> $k=0,1,2$  来 访问对应的 BGR 的值, </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587531020606.png" alt="BGR 图像访问"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历每一个像素进行灰度化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lena_rgb.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lena_rgb.cols; j++)</span><br><span class="line">true&#123;</span><br><span class="line">truetrueimg_brg.at&lt;cv::Vec3b&gt;(i,j)[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 蓝色通道设为0 </span></span><br><span class="line">truetrueimg_gray.at&lt;uchar&gt;(i,j) = <span class="number">0</span>;<span class="comment">// 灰度设为 0</span></span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指针访问"><a href="#指针访问" class="headerlink" title="指针访问"></a>指针访问</h4><p>图像数据是每行存储存储的, 我们可以每次获取到一行的数据 然后把行数据作为一维数组访问, 使用指针的方式就变得很简单了, 也是目前是最快的访问方式,  </p><p>对于 灰度图像, 我们可以使用 <code>uchar* pdata = img_gray.ptr&lt;uchar&gt;(i)</code> 访问灰度图像一行的数据, 使用 <code>cv::Vec3b* pdata = img_gray.ptr&lt;cv::Vec3b&gt;(i)</code> 访问一行数据,  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat img_gray = cv::Mat::zeros(lena_rgb.size(), CV_8UC1);</span><br><span class="line">cv::Mat img_bgr = cv::Mat::zeros(lena_rgb.size(), CV_8UC3);</span><br><span class="line"><span class="comment">// 使用指针进行图像访问</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lena_rgb.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line">trueuchar *p_gray = img_gray.ptr&lt;uchar&gt;(i);</span><br><span class="line">truecv::Vec3b *p_bgr = img_bgr.ptr&lt;cv::Vec3b&gt;(i);</span><br><span class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lena_rgb.cols; j++)</span><br><span class="line">true&#123;</span><br><span class="line">truetruep_gray[j] = <span class="number">0</span>;</span><br><span class="line">truetruep_bgr[j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过行的索引, 获取到 第 i 行的数据指针, 然后使用作为一维数组的访问方式进行指针数据的访问,<br> 功能强度, 十分快速, 但是可能会由于指针出现访问出错, </p><h4 id="迭代器法访问"><a href="#迭代器法访问" class="headerlink" title="迭代器法访问"></a>迭代器法访问</h4><p>迭代器是 C++ 11(不确定) 之后的方案, 通过迭代器能够访问不连续的数据, 这样, 我们只需要给出图像的 开始地址与 结束地址就能完成图像的访问, 也是目前最安全的方案, 不会出现越界的错误</p><p>对于灰度图像或者 彩色图像, 我们都能够使用迭代器进行访问, </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器访问</span></span><br><span class="line"><span class="keyword">for</span> (cv::Mat_&lt;cv::Vec3b&gt;::iterator it = img_bgr.begin&lt;cv::Vec3b&gt;();</span><br><span class="line">trueit != img_bgr.end&lt;cv::Vec3b&gt;(); it++)</span><br><span class="line">&#123;</span><br><span class="line">true(*it)[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历访问时间对比"><a href="#遍历访问时间对比" class="headerlink" title="遍历访问时间对比"></a>遍历访问时间对比</h4><p>在 opencv 的文档中, 给出了一个时间的对比方式,  通过获取 CPU 的运行时间 对比算法, </p><p>上面中, 我们给出了访问图像数据的三种方式,  这样我们就能进行一个一个像素的访问数据了,<br>其实, 我们在每个遍历的前后添加时间 测量程序, 最后得到这样的程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="comment">// 引入 opencv 函数头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//QApplication a(argc, argv);</span></span><br><span class="line">    <span class="comment">//MainWindow w;</span></span><br><span class="line">    <span class="comment">//w.show();</span></span><br><span class="line">    <span class="comment">// 设置 要显示的图像路径</span></span><br><span class="line">    <span class="comment">//std::string test_pic = "./TestImages/lena.png";</span></span><br><span class="line">    <span class="keyword">double</span> time_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> time_s = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取图像</span></span><br><span class="line">    <span class="comment">// cv::Mat lena_rgb = cv::imread(test_pic);</span></span><br><span class="line">    <span class="comment">// 声明 彩色图像 和灰度图像  // 设置 10000*10000 尺寸的图像, 避免出错</span></span><br><span class="line">    cv::Mat img_bgr = cv::Mat::zeros(cv::Size(<span class="number">1000</span>, <span class="number">1000</span>), CV_8UC3);</span><br><span class="line"></span><br><span class="line">    time_cnt = cv::getTickCount();</span><br><span class="line">    <span class="comment">// 遍历每一个像素进行灰度化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; img_bgr.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; img_bgr.cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            img_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    time_s = ((<span class="keyword">double</span>)cv::getTickCount() - time_cnt) / cv::getTickFrequency();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"index scan image time: \t\t %f second \n"</span>, time_s);</span><br><span class="line"></span><br><span class="line">    time_cnt = cv::getTickCount();</span><br><span class="line">    <span class="comment">// 使用指针进行图像访问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; img_bgr.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cv::Vec3b *p_bgr = img_bgr.ptr&lt;cv::Vec3b&gt;(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; img_bgr.cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            p_bgr[j][<span class="number">0</span>] = <span class="number">0</span>;    <span class="comment">// 访问(i,j) 的第一个通道</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    time_s = ((<span class="keyword">double</span>)cv::getTickCount() - time_cnt) / cv::getTickFrequency();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pointer scan image time: \t %f second \n"</span>, time_s);</span><br><span class="line"></span><br><span class="line">    time_cnt = cv::getTickCount();</span><br><span class="line">    <span class="comment">// 使用迭代器访问</span></span><br><span class="line">    <span class="keyword">for</span> (cv::Mat_&lt;cv::Vec3b&gt;::iterator it = img_bgr.begin&lt;cv::Vec3b&gt;();</span><br><span class="line">        it != img_bgr.end&lt;cv::Vec3b&gt;(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        (*it)[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    time_s = ((<span class="keyword">double</span>)cv::getTickCount() - time_cnt) / cv::getTickFrequency();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"iterator scan image time: \t %f second \n"</span>, time_s);</span><br><span class="line"></span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// return a.exec();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后,运行之后便能够得到我们的运行时间,  指针访问还是最快的方式,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index scan image time:           0.040871 second</span><br><span class="line">pointer scan image time:         0.015297 second</span><br><span class="line">iterator scan image time:        0.561931 second</span><br></pre></td></tr></table></figure><br>差别还是有点大的, 使用 指针的方式是最快的,  迭代器是最安全的 , 但是 迭代器在较大尺寸的图的时候 是真的慢, 我们测试 的是 <code>1000*1000</code> 尺寸的图像, 时间差别还是比较大的,  在图像处理的过程中欧能够, 遍历图像还是比较常用的手段的, 所以 可以考虑考虑自己最熟悉的方式进行 图像遍历.. 性能情况下要多使用 指针方式访问, 注意具体的访问越界即可.</p><h3 id="图像操作"><a href="#图像操作" class="headerlink" title="图像操作"></a>图像操作</h3><p>我们在能够实现图像的像素点访问之后, 会想到干什么呢, opencv的 例程中给出了两个有用的案例</p><ul><li><a href="https://docs.opencv.org/4.3.0/d5/dc4/tutorial_adding_images.html" target="_blank" rel="noopener">Adding (blending) two images using OpenCV</a></li><li><a href="https://docs.opencv.org/4.3.0/d3/dc1/tutorial_basic_linear_transform.html" target="_blank" rel="noopener">Changing the contrast and brightness of an image!</a></li></ul><p>一个是将两幅图像做 混合叠加, 另外一个是处理图像的亮度和对比度</p><h4 id="图像叠加"><a href="#图像叠加" class="headerlink" title="图像叠加"></a>图像叠加</h4><p>我们找两个等大的图像, 对于每一个点,像素相加除以2 得到平均值, 然后 生成新的图像</p><h5 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h5><p>感觉就是访问两幅图像, 然后叠加就好了, 跟上面讲的一样, 没有太多难度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 要显示的图像路径</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> img_panda = <span class="string">"./TestImages/panda.png"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> img_lena = <span class="string">"./TestImages/lena.png"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取两幅彩色图像  512*512</span></span><br><span class="line">cv::Mat panda_bgr = cv::imread(img_panda);</span><br><span class="line">cv::Mat lena_bgr = cv::imread(img_lena);</span><br><span class="line"><span class="comment">// 声明结果图像</span></span><br><span class="line">cv::Mat res_bgr = cv::Mat::zeros(lena_bgr.size(), CV_8UC3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lena_bgr.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lena_bgr.cols; j++)</span><br><span class="line">true&#123;</span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">0</span>] = (panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">0</span>] + lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">0</span>]) / <span class="number">2</span>;</span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">1</span>] = (panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">1</span>] + lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">2</span>] = (panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">2</span>] + lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">2</span>]) / <span class="number">2</span>;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line">cv::imshow(<span class="string">"panda_bgr"</span>, panda_bgr);</span><br><span class="line">cv::imshow(<span class="string">"lena_bgr"</span>, lena_bgr);</span><br><span class="line">cv::imshow(<span class="string">"res_bgr"</span>, res_bgr);</span><br><span class="line">cv::waitKey(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h5 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h5><p>这种就是单纯像素的叠加, 没有什么深入的点, 理解就好了</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587531024475.png" alt="执行结果"></p><h4 id="图像”拼接”"><a href="#图像”拼接”" class="headerlink" title="图像”拼接”"></a>图像”拼接”</h4><p>考虑一种拼接, 我们只是 将两幅图像并起来, 不考虑复杂的图像匹配, 我们可以简单的写一下, 也很简单</p><p>其实代码也很简单<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 要显示的图像路径</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> img_panda = <span class="string">"./TestImages/panda.png"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> img_lena = <span class="string">"./TestImages/lena.png"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取两幅彩色图像  512*512</span></span><br><span class="line">cv::Mat panda_bgr = cv::imread(img_panda);</span><br><span class="line">cv::Mat lena_bgr = cv::imread(img_lena);</span><br><span class="line"><span class="comment">// 声明结果图像 1020*1020</span></span><br><span class="line">cv::Mat res_bgr = cv::Mat::zeros(cv::Size(<span class="number">1024</span>,<span class="number">1024</span>), CV_8UC3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lena_bgr.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lena_bgr.cols; j++)</span><br><span class="line">true&#123;</span><br><span class="line">truetrue<span class="comment">// 复制第一副图像</span></span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">0</span>] = (panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">0</span>]);</span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">1</span>] = (panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">1</span>]);</span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">2</span>] = (panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">truetrue<span class="comment">// 在第一副图下面 拼接 反色图像</span></span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(<span class="number">512</span>+i, j)[<span class="number">0</span>] = (<span class="number">255</span>- panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">0</span>]);</span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(<span class="number">512</span>+i, j)[<span class="number">1</span>] = (<span class="number">255</span> - panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">1</span>]);</span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(<span class="number">512</span>+i, j)[<span class="number">2</span>] = (<span class="number">255</span> -panda_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">truetrue<span class="comment">// 复制第二幅图像 </span></span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, <span class="number">512</span>+j)[<span class="number">0</span>] = (lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">0</span>]);</span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, <span class="number">512</span>+j)[<span class="number">1</span>] = (lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">1</span>]);</span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, <span class="number">512</span>+j)[<span class="number">2</span>] = (lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">truetrue<span class="comment">// 在第二副图下面 拼接 反色图像</span></span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(<span class="number">512</span> + i, <span class="number">512</span>+j)[<span class="number">0</span>] = (<span class="number">255</span> - lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">0</span>]);</span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(<span class="number">512</span> + i, <span class="number">512</span>+j)[<span class="number">1</span>] = (<span class="number">255</span> - lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">1</span>]);</span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(<span class="number">512</span> + i, <span class="number">512</span>+j)[<span class="number">2</span>] = (<span class="number">255</span> - lena_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587531026812.png" alt="&quot;拼接&quot; 图像"></p><h4 id="图像-相减"><a href="#图像-相减" class="headerlink" title="图像 相减"></a>图像 相减</h4><p>在考虑一种情况, 我们彩色图像的三个通道值有大有小, 那所有值减去最小值会得到什么呢, </p><p>看 代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lena_bgr.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lena_bgr.cols; j++)</span><br><span class="line">true&#123;</span><br><span class="line">truetrue<span class="comment">// 求出最小值</span></span><br><span class="line">truetruecv::Vec3b tmp_px = lena_bgr.at&lt;cv::Vec3b&gt;(i, j);</span><br><span class="line">truetrue<span class="keyword">int</span> min_c = <span class="built_in">std</span>::min(<span class="built_in">std</span>::min(tmp_px[<span class="number">0</span>], tmp_px[<span class="number">1</span>]), tmp_px[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">truetrue<span class="comment">// 每个通道减去最小值</span></span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">0</span>] = tmp_px[<span class="number">0</span>] - min_c;</span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">1</span>] = tmp_px[<span class="number">1</span>] - min_c;</span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">2</span>] = tmp_px[<span class="number">2</span>] - min_c;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587531022034.png" alt="图像相减"></p><h4 id="亮度和对比度操作"><a href="#亮度和对比度操作" class="headerlink" title="亮度和对比度操作"></a>亮度和对比度操作</h4><p>上面的两个操作只是玩玩,  opencv 的例程中 关于<br>亮度和对比度的操作还是可以试试的<a href="https://docs.opencv.org/4.3.0/d3/dc1/tutorial_basic_linear_transform.html" target="_blank" rel="noopener">Changing the contrast and brightness of an image!</a></p><p>亮度是指 数字图像的明暗程度<br>对比度是值 图像最高亮度与最低亮度的差值<br>锐度: 图像边缘像素的对比度<br>可以参考文章<a href="https://zhuanlan.zhihu.com/p/44813768" target="_blank" rel="noopener">【数字图像处理系列二】亮度、对比度、饱和度、锐化、分辨率</a></p><p>其实吧, 知道就行了,  具体深究也可以看这篇<a href="https://blog.csdn.net/qijitao/article/details/80271507" target="_blank" rel="noopener">一次搞懂清晰度、对比度以及锐化的区别</a>, 有很多图片可以查看,  还能通过图像进行对比.</p><h5 id="亮度操作"><a href="#亮度操作" class="headerlink" title="亮度操作"></a>亮度操作</h5><p>回到正题, 我们要进行 亮度变换 其实就是在进行 图像灰度值的调节过程.</p><p>$$<br>g(i,j) = \alpha \cdot f(i,j) + \beta<br>$$<br>$\alpha$ 是原始图像 灰度放大倍数 , $\beta$ 是灰度的偏置 bias </p><p>我们来实现一下, 看下效果:<br>参数选择 例程中的 $\alpha = 2.2$ , $\beta = 50$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">2.2f</span>, b = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lena_bgr.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lena_bgr.cols; j++)</span><br><span class="line">true&#123;</span><br><span class="line">truetrue<span class="comment">// 取出原始图像 灰度值</span></span><br><span class="line">truetruecv::Vec3b tmp_px = lena_bgr.at&lt;cv::Vec3b&gt;(i, j);  </span><br><span class="line">truetrue<span class="comment">// 每个通道减去最小值</span></span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">0</span>] = cv::saturate_cast&lt;uchar&gt;(a * tmp_px[<span class="number">0</span>] + b);</span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">1</span>] = cv::saturate_cast&lt;uchar&gt;(a * tmp_px[<span class="number">1</span>] + b);</span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">2</span>] = cv::saturate_cast&lt;uchar&gt;(a * tmp_px[<span class="number">2</span>] + b);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果图: </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587531022043.png" alt="亮度提升"></p><p>这里使用的是 <code>cv::saturate_cast&lt;uchar&gt;</code> 进行的结果转换, 都是转换成 uchar 数据, 如果<br>直接使用 uchar 转换 得到的结果图像会很奇怪, 例如: <code>res_bgr.at&lt;cv::Vec3b&gt;(i, j)[0] = (uchar)(a * tmp_px[0] + b);</code></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587531023651.png" alt="直接使用 uchar 转换结果"></p><h4 id="伽马矫正-Gamma"><a href="#伽马矫正-Gamma" class="headerlink" title="伽马矫正(Gamma)"></a>伽马矫正(Gamma)</h4><p>线性变化还有很多, 灰度转换, 截取, 反色等等操作, 但是有一种非线性变化, 必须要进行介绍, 那就是 伽马矫正, 用来对于矫正输入图像的亮度值, </p><p>具体的公式表示为:<br>$$<br>g(i,j) = (\frac{f(i,j)}{255})^{\gamma} \times 255<br>$$</p><p>对于不同的 $\gamma$ 值, 我们绘制输入输出曲线可以得到这个图, </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587531020652.png" alt="gamma 矫正"></p><p>我们测试一下代码试试, 例程中使用了 一个 LUT的函数,<br>因为看上面的变换公式, 涉及到了指数运算, 如果我们每个像素值都计算一次 会比较花时间, 反正对于一个像素值, 计算出来的gamma 值是一样的 , 我提前计算好, 之际查找不就好了吗, </p><p>我们在最开始计算出来每个 灰度值的结果表,<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义 gamma 参数</span></span><br><span class="line"><span class="keyword">float</span> gamma = <span class="number">0.4</span>;</span><br><span class="line"><span class="comment">// 生成gamma 查找表</span></span><br><span class="line">uchar table[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">truetable[i] = <span class="built_in">std</span>::<span class="built_in">pow</span>(i / <span class="number">255.0f</span>, gamma) * <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lena_bgr.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lena_bgr.cols; j++)</span><br><span class="line">true&#123;</span><br><span class="line">truetrue<span class="comment">// 取出原始图像 灰度值</span></span><br><span class="line">truetruecv::Vec3b tmp_px = lena_bgr.at&lt;cv::Vec3b&gt;(i, j);  </span><br><span class="line">truetrue<span class="comment">// 每个通道减去最小值</span></span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">0</span>] = table[tmp_px[<span class="number">0</span>]];</span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">1</span>] = table[tmp_px[<span class="number">1</span>]];</span><br><span class="line">truetrueres_bgr.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">2</span>] = table[tmp_px[<span class="number">2</span>]];</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587531023657.png" alt="lena 进行 gamma = 0.4 的运算结果"></p><p>这个效果不是很好, 可以参考 opencv 例程里面的图, 效果真的很不错</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587531026798.png" alt="opencv 例程 gamma "></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
            <tag> c++ </tag>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv-4-成像系统与Mat图像颜色空间</title>
      <link href="/2020/04-21/opencv-4-Mat.html"/>
      <url>/2020/04-21/opencv-4-Mat.html</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>知道 opencv 处理图像数据的格式</li><li>介绍 mat 基础内容</li><li>知道 BGR 颜色 显示</li><li>颜色转换  BGR 到 灰度图像</li></ol><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>Opencv 主要是图像处理, 在进行图像处理的过程中有一个必须要解决的问题: 图像的内存存储, 最简单的方式就是使用二维数组来存储了. opencv 在1.0时代使用的是二维数组, 然后使用 <code>IplImage</code> 的指针指向数据起始的地址, 指针很强大, 但是对于新手不是很友好, 容易出现各种奇怪的问题.. </p><p>opencv 从2.0 时代就开始使用 Mat 格式 来存储图像数据, 相当于从 C 版本的接口 升级到了 C++ 的接口, 到了后面就逐渐开始移除 C 接口了, 开始了 C++ 的接口, 不再需要自己去维护内存, 让它来做, 让我们不再去考虑太过底层的实现, 专注与我们自己的 算法实现上来..</p><p>VS2017 下面有一个插件 <a href="https://www.zhihu.com/question/20617534" target="_blank" rel="noopener">Image Watch</a>,  可以在调试过程中查看 内存中的 opencv Mat 数据. </p><p>我们在VS 的调试过程中, 点击 <code>视图--其他窗口--ImageWatch</code> 会弹出窗口 我们能够看到图像的预览与实际, 点击可以使用滚轮进行放大, 比如 </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587465652378.png" alt="lena预览与眼睛部分放大"></p><p>我们将其放大到一定程度就发现图像数据是一个一个的”格子”, 也就是我们称为的像素, </p><p>对于我们原始的 lena 图像 就是一个 $512px*512px$尺寸的图像</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587465652671.png" alt="原始lena 图像"></p><p>px 是  图像像素的单位, 可以理解为 <code>512*512</code> 个小格子 </p><p>图像数据不是矢量数据, 不能够无限放大, 能够满足我们的日常实现即可</p><h3 id="Mat-图像数据格式"><a href="#Mat-图像数据格式" class="headerlink" title="Mat 图像数据格式"></a>Mat 图像数据格式</h3><p>一般来说, Mat 是一种对象, 有着相应的成员, 或者可以理解为属性,  可以理解为, 我们使用二维数组存储图像数据, 可以通过一些方法直接获取到这些二维数组的参数信息以及其他信息, 便于后续实现</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587465652002.png" alt="lena_img 属性"></p><p>比如 Mat类 常用的有以下几种^[《Opencv学习（三）简记Mat中的数据类型_人工智能_hjxu2016的博客-CSDN博客》. 见于 2020年4月21日. <a href="https://blog.csdn.net/hjxu2016/article/details/81116040.]" target="_blank" rel="noopener">https://blog.csdn.net/hjxu2016/article/details/81116040.]</a></p><ul><li>type: CV_8UC3  图像数据类型和通道数目</li><li>depth: 图像的精度, 用于表示每一个像素每一个通道的精度值 8U 表示 无符号 $2^8$ 精度, 最高256个灰度等级</li><li>channels: 通道数目  表示图像每个像素的数目</li><li>cols: 图像数据宽度   横向 </li><li>rows: 图像数据高度  纵向</li><li>size(): 返回(cols, rows) 数据</li><li>data: 指向二维数组的首地址, 指向图像数据最开始的地方</li><li>step: = stride 表示图像数据每一行的字节大小</li><li>…</li></ul><p>不再意义列举, 常用的就这么多</p><h3 id="成像系统"><a href="#成像系统" class="headerlink" title="成像系统"></a>成像系统</h3><p>在<a href="http://camera.geek-docs.com/camera-isp/digital-camera-system-intro.html" target="_blank" rel="noopener">数字成像系统概述</a> 这篇文章中, 详细介绍了数字的成像系统^[《数字成像系统概述|Camera》. 见于 2020年4月21日. <a href="http://camera.geek-docs.com/camera-isp/digital-camera-system-intro.html" target="_blank" rel="noopener">http://camera.geek-docs.com/camera-isp/digital-camera-system-intro.html</a>.<br>], 我们以这幅图为例</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587465652372.png" alt="成像系统"></p><p>成像系统 满足高斯公式 $\frac{1}{u} + \frac{1}{v} = \frac{1}{f}$,</p><h3 id="传感器成像"><a href="#传感器成像" class="headerlink" title="传感器成像"></a>传感器成像</h3><p>我们只看成像传感器部分, 传感器实际上是分为了每一个很小的格子, 每一个格子都会受到光照, 根据光照强度不同, 产生不同的电压信号, 通过放大电路被我们采集便能够得到整幅图像的电压, 转换以下辨识我们得到的图像数据了, </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587465653007.png" alt="图像传感器"></p><p>但是这里最重要的问题是, 光电传感器只能感受到光的强度, 不能感受到光的颜色, 所以 传感器上会附加 透镜, 每一个传感器只会感受到一种颜色光的强度, 组合以下便能够得到 颜色了, </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587465652324.png" alt="传感器滤镜"></p><h3 id="颜色混合模型"><a href="#颜色混合模型" class="headerlink" title="颜色混合模型"></a>颜色混合模型</h3><p>这里又有一个概念, 颜色混合模型,<br>其实每个概念都是很深的东西, 但是如果不是专业涉及的话, 我们暂时不做太深入的了解 ,有兴趣的可以看<a href="https://www.zhihu.com/question/22423020/answer/855340553" target="_blank" rel="noopener">CMYK 和 RGB 这两种色彩模式本质与区别在哪？</a> 和这篇文章<a href="https://zhuanlan.zhihu.com/p/89894469" target="_blank" rel="noopener">从“减色法”的本质，到广色域输出的可能性</a></p><p>主要有两种颜色模型, 加色和减色,  可以去参考<br>参考<a href="https://99designs.com/blog/tips/correct-file-formats-rgb-and-cmyk/" target="_blank" rel="noopener">RGB vs CMYK: What’s the difference?</a>这篇文章, </p><p>减色模型  一般情况下可以了理解为 CMYK 模型, 一般用于印刷,<br><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587465652373.png" alt="enter description here"></p><p>加法模型 一般是指  RGB  颜色加法混合模型 可以用于颜色 的表示, 符合人眼的颜色感觉</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587465652374.png" alt="加法模型"></p><p>跑的有点远了, 收回来</p><p>我们使用三种颜色等量叠加便能够得到白色, 对应的, 使用不同比例的颜色叠加便能够得到不同的颜色, </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587465652371.png" alt="颜色叠加"></p><p>对应的, 我们在lena 显示的时候,  放大之后得到的数字就是我们图像的演示的 “RGB” 值, </p><h3 id="颜色深度"><a href="#颜色深度" class="headerlink" title="颜色深度"></a>颜色深度</h3><p>这里还要再做一点介绍, 颜色深度,<br>数字图像, 自然所有的东西都是数字了, 考虑到实际计算机存储一个字节的数据为 8个bit,  1Byte = 8 bit , 每一个bit 可以表示成0或者1 则, 我们可以将每一个颜色分为 $2^8 = 256$ 种颜色进行表示, 这样即能够有效的利用数据, 也能方便的进行运算. </p><p>对于灰度图像, 一共有 256个层级 使用$[0-255]$进行表示,  对于彩色图像, 我们每一个颜色都能表示成256个颜色, 则可以得到 $256<em>256</em>256=16777216$ 种颜色,  我们可以使用 $ RGB(255,255,255)$ 来表示白色, 或者类似与 html 中使用 16进制来表示颜色一样 使用<code>#ffffff</code> 来分别表示 RGB的 颜色值.  用于表示白色</p><h3 id="opencv-颜色空间"><a href="#opencv-颜色空间" class="headerlink" title="opencv 颜色空间"></a>opencv 颜色空间</h3><p><strong>opencv 的大坑</strong></p><p>由于历史遗留问题,  opencv 3通道彩色图像的数据格式 为 BGR的顺序, 而不是常用的RGB顺序, 在我们进行实际上的颜色选择方面一定要注意这一点, 至于为什么, 只能说为了兼容某些硬件设备, 统一一个顺序, 定下来的一个标准, 后面的又为了兼容以前的版本..  具体的可以参考<a href="https://www.learnopencv.com/why-does-opencv-use-bgr-color-format/" target="_blank" rel="noopener">Why does OpenCV use BGR color format ?</a></p><blockquote><p>Why did they choose BGR color space in OpenCV ?<br>The reason the early developers at OpenCV chose BGR color format is that back then BGR color format was popular among camera manufacturers and software providers. E.g. in Windows, when specifying color value using COLORREF they use the BGR format 0x00bbggrr.</p></blockquote><p>实际上我们注意就好, <strong>opencv 的颜色顺序为 BGR</strong></p><p>一般来说, 我们在 opencv 中表示各种颜色</p><ul><li>蓝色 BGR(255,0,0);</li><li>红色 BGR(0,0,255);</li><li>绿色 BGR(0,255,0);</li><li>青色 BGR(255,255,0);</li><li>紫色 BGR(255,0,255);</li><li>黄色 BGR(0,255,255);</li><li>白色 BGR(255,255,255);</li><li>黑色 BGR(0,0,0);</li><li>中等灰色 BGR(128,128,128 );</li></ul><h3 id="彩色图像灰度化"><a href="#彩色图像灰度化" class="headerlink" title="彩色图像灰度化"></a>彩色图像灰度化</h3><p>我感觉这篇文章<a href="https://www.cnblogs.com/finlay/p/3665302.html" target="_blank" rel="noopener">图像处理：图像灰度化</a> 做了很多介绍, 其实 颜色对于图像处理来说意义不大, 更多的是给人的一种颜色的感觉,  所以很多时候进行图像处理的过程都是进行灰度化处理了, </p><p>由我们的成像系统可以得知, 每一个像素的位置存在三种颜色的值,  灰度化的过程就是将三个值变成一个值, 就是我们所谓的灰度化, 将原本三通道的像素值转换为1通道的像素值,<br>一般来说, 我们就考虑颜色灰度的平均得到灰度值即可,<br>$$<br>Gray(i,j) = \frac{R(i,j) + G(i,j) + B(i,j)}{3}<br>$$<br>这就是平均值的方式,<br>但是呢, 人眼对于绿色比较敏感 进而提出了给出不同权重的灰度化过程,  属于一个心理学公式<br>$$<br>Gray(i,j) = 0.299<em> R(i,j) + 0.587 </em> G(i,j) + 0.114 * B(i,j)<br>$$</p><p>这个权重值是一个目前使用最多的比例, 但是也有其他人提出的权重参数, 详细可以见[Grayscale wiki 页面](<a href="https://en.wikipedia.org/wiki/Grayscale" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Grayscale</a></p><p>进而我比较喜欢是这篇文章<a href="https://blog.csdn.net/xdrt81y/article/details/8289963" target="_blank" rel="noopener">从RGB色转为灰度色算法</a>, 给出了一个比较有效的 整数移位算法, 减少整数计算带来的精度损失以及浮点运算的低效率.<br>参照他给出的数据,  得到一个有趣的公式, 可以去详细看下,<br>$$<br>Gray(i,j) = (38<em>R(i,j) + 75</em>(G(i,j) + 15*B(i,j)) &gt;&gt; 7<br>$$</p><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><h3 id="编辑代码"><a href="#编辑代码" class="headerlink" title="编辑代码"></a>编辑代码</h3><p>我们这里为了对比 不同的灰度化做了一个展示, 其实很简单, 这里用到的 图像遍历的方式, 对于每一个像素点进行处理 三种灰度化的方式, 存入到三副图像中, 然后一起显示出来用于对比, </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 opencv 函数头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MainWindow w;</span><br><span class="line">    w.show();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 要显示的图像路径</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> test_pic = <span class="string">"./TestImages/lena.png"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取图像</span></span><br><span class="line">    cv::Mat lena_rgb = cv::imread(test_pic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明三个灰色的图像</span></span><br><span class="line">    cv::Mat lena_gray_avg = cv::Mat::zeros(lena_rgb.size(), CV_8UC1);</span><br><span class="line">    cv::Mat lena_gray_weighted = cv::Mat::zeros(lena_rgb.size(), CV_8UC1);</span><br><span class="line">    cv::Mat lena_gray_shift = cv::Mat::zeros(lena_rgb.size(), CV_8UC1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每一个像素进行灰度化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lena_rgb.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lena_rgb.cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cv::Vec3b tmp_px = lena_rgb.at&lt;cv::Vec3b&gt;(i, j);</span><br><span class="line">            lena_gray_avg.at&lt;uchar&gt;(i, j) = (uchar)((tmp_px[<span class="number">0</span>] + tmp_px[<span class="number">1</span>] + tmp_px[<span class="number">2</span>]) / <span class="number">3</span>);</span><br><span class="line">            lena_gray_weighted.at&lt;uchar&gt;(i, j) = (uchar)((<span class="number">0.299f</span> * tmp_px[<span class="number">0</span>] + <span class="number">0.587f</span> * tmp_px[<span class="number">1</span>] + <span class="number">0.114f</span> * tmp_px[<span class="number">2</span>]));</span><br><span class="line">            lena_gray_shift.at&lt;uchar&gt;(i, j) = (uchar)((<span class="number">38</span> * tmp_px[<span class="number">0</span>] + <span class="number">75</span> * tmp_px[<span class="number">1</span>] + <span class="number">15</span> * tmp_px[<span class="number">2</span>]) &gt;&gt; <span class="number">7</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图像</span></span><br><span class="line">    cv::imshow(<span class="string">"lena_rgb"</span>, lena_rgb);</span><br><span class="line">    cv::imshow(<span class="string">"lena_gray_avg"</span>, lena_gray_avg);</span><br><span class="line">    cv::imshow(<span class="string">"lena_gray_weighted"</span>, lena_gray_weighted);</span><br><span class="line">    cv::imshow(<span class="string">"lena_gray_shift"</span>, lena_gray_shift);</span><br><span class="line"></span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p>最后运行出来的结果就是下图了, 很简单, 但是 很有效,  </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587465653681.png" alt="运行效果展示"></p><p>对应最开始的图, 我们选取lena 眼镜部分, 查看 lena_gray_shift 的眼镜细节, 得到图</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587466182089.png" alt="灰度图 眼镜部分细节放大"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>我们稍微介绍了成像的系统, 然后介绍了opencv 的 成像方法, 以及具体的颜色表示, 在后面我们就要进行 稍微深入的像素操作与图形操作了.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
            <tag> c++ </tag>
            
            <tag> qt </tag>
            
            <tag> mat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv-3-图片存储与相对路径</title>
      <link href="/2020/04-21/opencv-3-showimageandwrite.html"/>
      <url>/2020/04-21/opencv-3-showimageandwrite.html</url>
      
        <content type="html"><![CDATA[<p>在上一篇文章<a href="https://schen1024.github.io/2020/04-20/opencv-2-vsqt.html">opencv 显示第一副图像</a> 中, 我们完成了一副图像的显示,  包括使用VS,和QT 进行显示.. 本文将展示如何进行图像的显示与存储过程, 主要以 QT为例, 附带介绍一下  VS的实现方法</p><h2 id="图像显示与存储程序"><a href="#图像显示与存储程序" class="headerlink" title="图像显示与存储程序"></a>图像显示与存储程序</h2><p>我们以上一章节的显示图像为例</p><blockquote><p>一定要注意 路径的位置,  windows 下面的  \  斜杠 为 C++ 里面的转义符号, 换成 / 或者 \  来表示</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 opencv 函数头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MainWindow w;</span><br><span class="line">    w.show();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 要显示的图像路径</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> test_pic = <span class="string">"D:\\Project\\Vision\\ImageLab\\TestImages\\lena.png"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取图像</span></span><br><span class="line">    cv::Mat lena_img = cv::imread(test_pic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图像</span></span><br><span class="line">    cv::imshow(<span class="string">"图像显示窗口"</span>, lena_img);</span><br><span class="line">    <span class="comment">// cv::waitKey(100);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储图像</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> write_pic = <span class="string">"D:\\Project\\Vision\\ImageLab\\TestImages\\lena_write.png"</span>;</span><br><span class="line"></span><br><span class="line">    cv::imwrite(write_pic,lena_img);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用  <code>imread</code> 函数 去读取文件, 使用 <code>imshow</code> 显示图像, 使用 <code>imwrite</code> 将图像存储到文件中.  </p><p>我们运行能够显示 lena 图像, 然后点击右上角 关闭窗口之后,  可以在文件夹看到生成的图像, <code>write_lena.png</code> 图像, 和原始图像一模一样, </p><p><img src="./images/1587431534376.png" alt="生成文件"></p><h2 id="程序运行目录"><a href="#程序运行目录" class="headerlink" title="程序运行目录"></a>程序运行目录</h2><p>在我们的程序运行过程中, 为了避免一些不必要的解释, 我们都使用的是  绝对路径,<br>但是如果我们需要做迁移, 到别的电脑上, 大概率是运行不成功的, 会显示文件无法找到等问题, 所以 程序中尽量使用相对路径<br>具体的路径的差别可以参考<a href="https://blog.csdn.net/Yeoman92/article/details/52736504" target="_blank" rel="noopener">相对路径和绝对路径</a></p><h3 id="相对路径与绝对路径"><a href="#相对路径与绝对路径" class="headerlink" title="相对路径与绝对路径"></a>相对路径与绝对路径</h3><p>绝对路径就是 从硬盘开始的, 一直到某个文件夹的路径, 类似于 <code>D:\Project\Vision\ImageLab</code> 的形式,<br>相对路径是从当前文件开始的, 使用 <code>./</code> 表示当前目录, <code>../</code> 表示上一层目录,<br>对于我们 QT 工程来说, 原始运行目录为: <code>D:\Project\Vision\ImageLab</code></p><ul><li><code>./</code> 表示  <code>D:\Project\Vision\ImageLab</code></li><li><code>../</code> 表示  <code>D:\Project\Vision</code></li><li><code>./TestImages</code> 表示 <code>D:\Project\Vision\ImageLab\TestImages</code></li><li><code>../ImageLab</code>  又表示回来了当前目录   <code>D:\Project\Vision\ImageLab</code></li><li><code>./Depend/opencv/lib</code> 可以表示到 opencv 的lib 库文件夹 <code>D:\Project\Vision\ImageLab\Depend\opencv\lib</code></li></ul><p>多用就好, 很容易就上手学会了.</p><h3 id="QT-运行路径"><a href="#QT-运行路径" class="headerlink" title="QT  运行路径"></a>QT  运行路径</h3><p>QT 默认的构建目录 可以在 <code>工具--选项--构建与运行-- 默认构建目录</code>  里面设置, 默认里面是<br><code>../%{JS: Util.asciify(&quot;build-%{CurrentProject:Name}-%{CurrentKit:FileSystemName}-%{CurrentBuild:Name}&quot;)}</code><br>这里是 QT 进行的一些宏的解析, <code>%{CurrentProject:Name}</code> 表示当前工程名 ImageLab , <code>%{CurrentKit:FileSystemName}</code> 是运行环境 <code>Desktop_Qt_5_14_2_MSVC2017_64bit</code>,  <code>%{CurrentBuild:Name}</code> 是 Debug, 最后 解析成  <code>../build-ImageLab-Desktop_Qt_5_14_2_MSVC2017_64bit-Debug</code>, 会在当前文件夹的上一层目录里面建立 <code>build-ImageLab-Desktop_Qt_5_14_2_MSVC2017_64bit-Debug</code> 文件夹, 把所有的编译文件和生成文件放进去, </p><p>我不是很喜欢这种方式, 不过建立好工程之后, 可以在 左侧的 项目里面, 选择你的编译套件, 然后设置 构建目录<br><img src="./images/1587430855357.png" alt="QT 编译路径"></p><p>我们将其设置成为 <code>D:\Project\Vision\ImageLab\Debug</code> , 这样, 我们在程序执行过程中可以将读写的文件路径改为 <code>../TestImages/lena.png</code>, 和 <code>../TestImages/lenalena_write.png</code> 文件, 同样的程序也能够运行成功.  再次看到 lena </p><h3 id="VS-运行路径"><a href="#VS-运行路径" class="headerlink" title="VS 运行路径"></a>VS 运行路径</h3><p>VS 的构建目录可以通过设置中间目录和输入目录设定,  VS 的工程设置都是在解决方案上右键,  设置 <code>调试-- 工作目录</code>  VS 使用 <code>$(ProjectDir)</code> 的形式去解析宏定义,  这个目录表示 VS 工程(不是解决方案) 的路径, 在本工程中表示 就是 <code>D:\Project\Vision\ImageLab</code> 目录, 那我们的 读写文件的路径都要更改, <code>./TestImages/lena.png</code>, 和 <code>./TestImages/lenalena_write.png</code></p><p><img src="./images/1587430801141.png" alt="VS运行目录"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>在VS 和 QT 混合编程的时候 一定要注意相对路径的设置 不要坑到了自己..</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> opencv </tag>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swordoffer-start</title>
      <link href="/2020/04-20/swordoffer-start.html"/>
      <url>/2020/04-20/swordoffer-start.html</url>
      
        <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>再开一个系列, 这两个系列是一直都想写的 , 但是总是只写一部分, 我最喜欢的两个部分就是 算法刷题, 还有就是图像处理, 早上开始了 opencv 的系列, 那现在就开始剑指 offer 这本书的系列吧,</p><p>主要参考</p><ol><li><a href="https://www.nowcoder.com/ta/coding-interviews" target="_blank" rel="noopener">牛客 剑指 offer</a></li><li><a href="https://leetcode-cn.com/problemset/lcof/" target="_blank" rel="noopener">LC 剑指 offer </a></li><li><a href="https://github.com/gatieme/CodingInterviews" target="_blank" rel="noopener">github 剑指 offer</a></li></ol><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>争取完成所有的题目, 然后记录下来, 并写出详细的题解过程. 希望自己能坚持下去.</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> offer </tag>
            
            <tag> swordoffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv-2-VS2017与QT显示图像</title>
      <link href="/2020/04-20/opencv-2-vsqt.html"/>
      <url>/2020/04-20/opencv-2-vsqt.html</url>
      
        <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ol><li>使用 VS 构建第一个 opencv 程序</li><li>使用 QT 构建 第一个 opencv 程序</li><li>VS 导入 QT 程序</li></ol><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>我们需要设置 dll 文件的运行路径, 避免运行的时候找不到相应的库而报错,<br>接下来, 我们需要使用 </p><h3 id="设置运行环境"><a href="#设置运行环境" class="headerlink" title="设置运行环境"></a>设置运行环境</h3><p>我们整理得到了, 我们需要将 我们的dll 文件夹 加入到系统 的Path  路径<br>过程如下: <code>此电脑--右键--属性--高级系统设置--环境变量--系统变量--Path--编辑--新建</code></p><p>然后填入我们 dll 所在的文件夹即可 </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587377837655.png" alt="path 设置过程"></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587377837633.png" alt="path 设置"></p><h3 id="VS2017使用-opencv-程序"><a href="#VS2017使用-opencv-程序" class="headerlink" title="VS2017使用 opencv 程序"></a>VS2017使用 opencv 程序</h3><p>opencv 的官方给出了一个 windows  Visual Studio 使用 opencv 的方法^[《OpenCV: How to build applications with OpenCV inside the 〈Microsoft Visual Studio〉》. 见于 2020年4月20日. <a href="https://docs.opencv.org/4.3.0/dd/d6e/tutorial_windows_visual_studio_opencv.html.]" target="_blank" rel="noopener">https://docs.opencv.org/4.3.0/dd/d6e/tutorial_windows_visual_studio_opencv.html.]</a>,<br>其实都差不多, 在 博客 <a href="https://www.cnblogs.com/jisongxie/p/9316283.html" target="_blank" rel="noopener">Win10, VS2017环境下OpenCV3.4.2的配置</a> 也是使用 包含目录, 库目录, 以及附加依赖项进行的展示过程, </p><p>在后面执行之前, 的opencv 的目录结构是存在 <code>D:\Project\Vision\ImageLab\Depend\opencv</code>目录下面的, 我们在前面介绍了每个文件夹里面的内容<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">opencv430</span><br><span class="line">true- dll</span><br><span class="line">true- lib</span><br><span class="line">true- include</span><br></pre></td></tr></table></figure></p><h4 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h4><p>新建空的VS 项目, imagelab 在解决方案上右键, 点击属性进行配置即可</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587377837634.png" alt="配置属性"></p><p><strong>包含目录与库目录</strong></p><p>添加你的 include 文件夹和 lib 文件夹即可</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587377837635.png" alt="包含目录与库目录"></p><p>这里使用的是我的  绝对路径, 如果使用, 必须更改为你自己的路径, 不然 肯定出错.</p><p><strong>库文件</strong></p><p>此处选择的是相应的 <code>opencv_world430d.lib</code>, opencv 在3.0 的版本之后, 只需要加入一个 world 的lib 文件即可, 不需要添加一系列的库文件, 也可以单独编译得到 值添加单个的库,</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587377837636.png" alt="附加依赖库文件"></p><p>这里建议去看 <a href="https://www.cnblogs.com/jisongxie/p/9316283.html" target="_blank" rel="noopener">Win10, VS2017环境下OpenCV3.4.2的配置</a> 这篇博文, 写的十分详细, </p><h4 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 opencv 函数头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置 要显示的图像路径</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> test_pic = <span class="string">"D:\\Project\\Vision\\ImageLab\\TestImages\\lena.png"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取图像</span></span><br><span class="line">    cv::Mat lena_img = cv::imread(test_pic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图像</span></span><br><span class="line">    cv::imshow(<span class="string">"图像显示窗口"</span>, lena_img);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调试运行"><a href="#调试运行" class="headerlink" title="调试运行"></a>调试运行</h4><p>如果配置没有问题,  注意上面配置 的都是  debug x64, 在编辑页面也要是  一样的吗不能出错, 不然编辑的不对, 点击 <code>生成--生成解决方案</code> 如果程序复制过去的没有问题, 就不会有问题了,</p><blockquote><p>此处我默认看这里的人有了一定的 C++ 程序基础,  不然解释太多的话就很麻烦,</p></blockquote><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587377837638.png" alt="编辑页面配置"> </p><p>点击绿色的 <code>本地 windows 调试器</code> 直接运行 就能看到这个窗口了</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587377838806.png" alt="opencv lena 图片"></p><p>到这里, 我们的 VS 使用 opencv 就完成了 ,  很容易就搞定了..</p><h3 id="QT-使用-opencv-程序"><a href="#QT-使用-opencv-程序" class="headerlink" title="QT 使用 opencv 程序"></a>QT 使用 opencv 程序</h3><p>QT 使用 opencv 更加简单, QT的主要工程文件是  <code>*.pro</code> 文件,  我们可以在文件中加入一些配置信息 便于我们执行 可以参考<a href="https://blog.csdn.net/czl389/article/details/79137566" target="_blank" rel="noopener">Windows下QT Creator配置OpenCV(VC版)</a></p><h4 id="新建工程-1"><a href="#新建工程-1" class="headerlink" title="新建工程"></a>新建工程</h4><p>新建工程 imagelab , 在工程上右键, 添加库<br><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587377837639.png" alt="添加库"></p><p>添加外部库, 点击选择到 lib 文件, 会自动选择 include<br>文件夹, 检查一下是否包含正确, </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587377837640.png" alt="外部库"></p><p>最终会在 <code>*.pro</code>文件中 添加<br><figure class="highlight qt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">win32</span>:<span class="attribute">CONFIG(release, debug|release)</span>: LIBS += -L$$PWD/Depend/opencv/lib/ -lopencv_world430</span><br><span class="line"><span class="attribute">else</span>:<span class="attribute">win32</span>:<span class="attribute">CONFIG(debug, debug|release)</span>: LIBS += -L$$PWD/Depend/opencv/lib/ -lopencv_world430d</span><br><span class="line"></span><br><span class="line">INCLUDEPATH += $$PWD/Depend/opencv/include</span><br><span class="line">DEPENDPATH += $$PWD/Depend/opencv/include</span><br></pre></td></tr></table></figure><br>我们 imagelab.pro 工程在 <code>D:\Project\Vision\ImageLab</code> 文件夹下, 对应的库 <code>D:\Project\Vision\ImageLab\Depend\opencv\lib</code> 文件夹下面, 所以, 这里 <code>$$PWD</code> 是 QT pro 文件的语法, 能够获取到 pro文件所在的目录, 也就是工程的当前目录, </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587377837641.png" alt="qmake 和构建"></p><p>QT 工程 需要首先执行 qmake 生成 编译文件, </p><h4 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h4><p>QT 就是 标准的C++, 只不过 QT 是一套 C++库, 我们能够很容易的使用 界面库, 生成带有界面的程序..</p><p>我们先不考虑界面的实现, 我们在主程序执行 <code>return</code> 把我们的图像读取与显示代码添加进去, 并在开头引入头文件,  就能得到下面的代码文件.<br> 能够实现程序的读取  主体部分和 vs 工程中的程序一样,<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 opencv 函数头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MainWindow w;</span><br><span class="line">    w.show();</span><br><span class="line">true</span><br><span class="line">    <span class="comment">// 设置 要显示的图像路径</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> test_pic = <span class="string">"D:\\Project\\Vision\\ImageLab\\TestImages\\lena.png"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取图像</span></span><br><span class="line">    cv::Mat lena_img = cv::imread(test_pic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图像</span></span><br><span class="line">    cv::imshow(<span class="string">"图像显示窗口"</span>, lena_img);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">true</span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="调试运行-1"><a href="#调试运行-1" class="headerlink" title="调试运行"></a>调试运行</h4><p>点击构建, 最后点击运行, 如果一切顺利, 我们就能看到这幅图像了,  这里图像显示还是 opencv 的窗口,  我们后续会将其显示在opencv 的窗口上, </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587377838809.png" alt="QT opencv 程序"></p><h3 id="VS-导入-QT-工程"><a href="#VS-导入-QT-工程" class="headerlink" title="VS 导入 QT 工程"></a>VS 导入 QT 工程</h3><p>VS 有一个很好用的插件, 叫做 <a href="https://marketplace.visualstudio.com/items?itemName=TheQtCompany.QtVisualStudioTools-19123" target="_blank" rel="noopener">Qt Visual Studio Tools</a>, 可以下载安装,或者在 VS  <code>工具--拓展与更新--联机--搜索</code> 进行安装, 安装之后需要重启 VS</p><blockquote><p>VS 开发 opencv 的程序 必备插件 <a href="https://www.zhihu.com/question/20617534" target="_blank" rel="noopener">Image Watch</a>,  可以在调试过程中查看 内存中的 opencv Mat 数据. 强烈推荐..</p></blockquote><p>点击 设置 QT option 然后添加, 直到我们点击到 QT安装目录下面 的 具体编译器文件夹,<br><code>F:\Fxxk\QT\Qt5.14.2\5.14.2\msvc2017_64</code>  </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587377837652.png" alt="QT设置"></p><p>我们使用 QT 插件导入 <code>*.pro</code> 文件, 会生成相应的工程, </p><p>跟我们直接 VS与 opencv 的工程设置不同, QT 自动生成的文件没有更改 包含目录和库文件<br><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587377837653.png" alt="VC++ 目录"></p><p>而是选择了在 附加包含目录里面增加了, 不仅增加了 opencv 的目录,  而且包含了 QT 的很多库目录, </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587377837657.png" alt="附加包含目录"></p><p>对应的 , 我们仍然使用 附加依赖项 设置 输入 lib 文件</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587377837654.png" alt="附加依赖项"></p><p>这样, 我们就能使用 VS 编译得到 QT 的程序, 编译成功, 运行即可再次看到 lena 图像</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587377838810.png" alt="VS 调试 QT 程序"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>我们后续的开发主要是 QT 进行开发, 用于生成自定义的界面, 便于我们开发过程中的图像展示工作. </p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> opencv </tag>
            
            <tag> qt </tag>
            
            <tag> VS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv-1-QT_OPENCV 安装</title>
      <link href="/2020/04-20/opencv-1-QT_OPENCV.html"/>
      <url>/2020/04-20/opencv-1-QT_OPENCV.html</url>
      
        <content type="html"><![CDATA[<p>既然我们是从头开始的, 那我们就从 opencv 的安装开始吧,  主要环境为: </p><ul><li>win10 1909 - 18363.720 版本</li><li><a href="https://my.visualstudio.com/Downloads?q=visual%20studio%202017" target="_blank" rel="noopener">VS2017 15.9.22</a></li><li><a href="http://download.qt.io/official_releases/qt/5.14/5.14.2/" target="_blank" rel="noopener">QT 5.14.2</a></li><li><a href="https://opencv.org/releases/" target="_blank" rel="noopener">opencv 4.3.0</a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2>由于 QT 默认的 C++ 编译器是 minGW, 而 opencv 编译好的 dll 文件和 lib 文件都是 只有 vc14版本与vc15版本^[《VS(Visual Studio)与VC(Visual C++)版本对应关系_C/C++_aoanng的博客-CSDN博客》. 见于 2020年4月20日. <a href="https://blog.csdn.net/colourful_sky/article/details/79495536" target="_blank" rel="noopener">https://blog.csdn.net/colourful_sky/article/details/79495536</a>.<br>]. </li></ul><p>PS: 如果你使用 minGW  编译 opencv 的程序会 会提示很多错误, 主要是编译得到的库 不支持的原因, 这里要做对照,  VS的版本可以 是 VS2015或者 VS2017 对应 opencv 的 vc14和vc15目录,  VS2019 暂时无法对应QT的版本, 所以一定要注意这里</p><p>个人喜欢的安装顺序是, </p><ol><li>VS2017</li><li>QT</li><li>opencv</li></ol><h3 id="1-VS2017-安装"><a href="#1-VS2017-安装" class="headerlink" title="1. VS2017 安装"></a>1. VS2017 安装</h3><p>自从 VS 2017版本之后, 都是线上安装了, 对于以前的版本如VS2015,需要先下载一个 7G的 iso 文件, 再虚拟光驱的方式安装了, 省事不少.<br><a href="https://my.visualstudio.com/Downloads?q=visual%20studio%202017" target="_blank" rel="noopener">微软官方-VS2017下载</a></p><p>在线安装 安装文件只有几兆, 点击运行之后能够在线下载, 很快很快. 推荐这个方法来, 安装的时候 建议勾选 全部下载后安装. </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587355315311.png" alt="VS installer"></p><p>我已经安装了 VS2017, 所以可以直接启动, 点击可用选择 VS2017 专业版本(VS2017 Professional) 或者 社区(Community) 版本, 后者是免费的, 前者自己选择试用或者 自己搜索方法,<br>具体的版本区别可以看<a href="https://blog.csdn.net/xiang0731/article/details/78718032." target="_blank" rel="noopener">《VS2017各版本区别<em>开发工具</em>大白的求知路-CSDN博客》</a></p><p>VS 系列都比较大, 会安装很多依赖库, 如果C盘比较小的话, 建议安装在其他硬盘, 能够节省一点空间</p><p>其实在安装 VS之后, 我们就能进行opencv 的代码编写了,  具体的可以参考<a href="https://www.cnblogs.com/jisongxie/p/9316283.html" target="_blank" rel="noopener">Win10, VS2017环境下OpenCV3.4.2的配置</a>, 其实大部分的教程都是这么做的, 但是我们是做 的更深入, 所以这里如果只是想使用 opencv 的可以参考链接进行<br>^[《Win10, VS2017环境下OpenCV3.4.2的配置 - Jisongxie - 博客园》. 见于 2020年4月20日. <a href="https://www.cnblogs.com/jisongxie/p/9316283.html.]" target="_blank" rel="noopener">https://www.cnblogs.com/jisongxie/p/9316283.html.]</a>, 我们要做的是一个图像处理的平台, 所以要做的比较深入, </p><p>为了能够在QT 上调试程序, 可以参考这篇文章<a href="https://blog.csdn.net/qq_15647227/article/details/83956160" target="_blank" rel="noopener">QT使用CDB调试程序</a>, 介绍了</p><blockquote><p>windows CDB <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/?redirectedfrom=MSDN" target="_blank" rel="noopener">下载链接</a></p></blockquote><p>先安装, 后面会介绍.</p><h3 id="2-QT-安装"><a href="#2-QT-安装" class="headerlink" title="2. QT 安装"></a>2. QT 安装</h3><p>使用 <a href="http://download.qt.io/official_releases/" target="_blank" rel="noopener">QT官方 release</a>下载相应版本的QT, 我们这里使用的是 <a href="http://download.qt.io/official_releases/qt/5.14/5.14.2/" target="_blank" rel="noopener">QT5.14.2</a></p><p>一路 next , 如果需要必须登录的话, 就去注册一个, 以前好像能跳过的, 现在不能跳过了</p><p>如果出现 必须启用一个资源库之类的提示, 就直接配置就好</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587355315314.png" alt="临时资源组"></p><p>QT的组件不需要全部选择,<br>选择你需要的部分就行了, 其实 MinGW 可以全部取消的 ,暂时先留着, , UWP是 win10 商店的, 其实没人用 , 自己考虑就好, 源代码不需要,  QT的一堆组件其实只有 不到20M, 都很小, 就都装上了, 如果感觉, 红框标出来的最好都勾选, 黄色标记的建议勾选, 其他的随意吧, 个人习惯, </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587355315348.png" alt="QT 组件选择"></p><p>安装可以选择文件夹, 建议选择大点的空间, 我这样选择也是占有 3.6G 的空间,  全选可能有 10G,<br>其实安装完成之后可以去安装文件夹找到 <code>MaintenanceTool.exe</code> 的程序, 能够对QT 程序进行卸载, 自己可以查阅相关博客看到, 不做介绍.</p><p>完成安装之后, 我们打开 <code>QTCreator</code> ^[QT自带的代码 UI IDE]</p><p>依次点击菜单栏上的 <code>工具--选项--Kits--套件</code>, 由于我们先安装VS, QT安装之后会自动检测到相应的版本,  如果失败, 前面会有红色感叹号或者黄色警告, 我们选择 <code>Desktop Qt5.14.2 MSVC2017 64bit</code> , 会列出来具体的参数信息, 我们尽量将 Compiler (编译器这里) 都选择 amd64 的 编译器,  </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587355315371.png" alt="QT套件设置"></p><p>在上面我们让 安装了 CDB, 这里 就是第二个箭头指出来的     <code>cdb.exe</code>, 不然此处无法选择, 就会是 黄色的感叹号了, 也不能使用 QT 调试  程序了, </p><p>PS: 只是不能在 MSVC2017 下调试程序 , cdb 配套 MSVC 编译器,  GDB 配套 MinGW 里面的 gcc 和 g++ 编译器 也能进行程序的调试, 只是如果配置这套工具链, 我们需要参考<a href="https://blog.csdn.net/u010189457/article/details/66478574" target="_blank" rel="noopener">OpenCV+Qt+Win10开发环境配置</a> 这篇文章里面 的步骤去编译 mingw 的opencv ,<br>我的设备需要编译将近一天时间才能完成, 太浪费时间了.</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587355315364.png" alt="MinGW QT 调试"></p><h3 id="3-OpenCV-安装"><a href="#3-OpenCV-安装" class="headerlink" title="3. OpenCV 安装"></a>3. OpenCV 安装</h3><p>opencv 可以在<a href="https://opencv.org/releases/" target="_blank" rel="noopener">官方 release页面</a>直接下载, 我们这里选择下载<a href="https://sourceforge.net/projects/opencvlibrary/files/4.3.0/opencv-4.3.0-vc14_vc15.exe/download" target="_blank" rel="noopener">opencv4.3.0 windows</a> 版本,  下载包有 202M</p><blockquote><p>opencv 真的是越来越大了</p></blockquote><p>opencv 的安装包其实就是一个自解压文件, 点击运行选择目的路径即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">opencv430</span><br><span class="line">+---build</span><br><span class="line">|   +---bin</span><br><span class="line">|   +---etc</span><br><span class="line">|   |   +---haarcascades</span><br><span class="line">|   |   +---lbpcascades</span><br><span class="line">|   |   \---licenses</span><br><span class="line">|   +---include</span><br><span class="line">|   |   \---opencv2</span><br><span class="line">|   |       +---calib3d</span><br><span class="line">|   |       +---core</span><br><span class="line">|   |       +---dnn</span><br><span class="line">|   |       +---features2d</span><br><span class="line">|   |       +---flann</span><br><span class="line">|   |       +---gapi</span><br><span class="line">|   |       +---highgui</span><br><span class="line">|   |       +---imgcodecs</span><br><span class="line">|   |       +---imgproc</span><br><span class="line">|   |       +---ml</span><br><span class="line">|   |       +---objdetect</span><br><span class="line">|   |       +---photo</span><br><span class="line">|   |       +---stitching</span><br><span class="line">|   |       +---video</span><br><span class="line">|   |       \---videoio</span><br><span class="line">|   +---java</span><br><span class="line">|   |   +---x64</span><br><span class="line">|   |   \---x86</span><br><span class="line">|   +---python</span><br><span class="line">|   |   \---cv2</span><br><span class="line">|   \---x64</span><br><span class="line">|       +---vc14</span><br><span class="line">|       |   +---bin</span><br><span class="line">|       |   \---lib</span><br><span class="line">|       \---vc15</span><br><span class="line">|           +---bin</span><br><span class="line">|           \---lib</span><br><span class="line">\---sources</span><br><span class="line">    +--<span class="number">-3</span>rdparty</span><br><span class="line">    |   +---carotene</span><br><span class="line">    |   +---cpufeatures</span><br><span class="line">    |   +---ffmpeg</span><br><span class="line">    |   +---include</span><br><span class="line">    |   +---ippicv</span><br><span class="line">    |   +---ittnotify</span><br><span class="line">    |   +---libjasper</span><br><span class="line">    |   +---libjpeg</span><br><span class="line">    |   +---libjpeg-turbo</span><br><span class="line">    |   +---libpng</span><br><span class="line">    |   +---libtengine</span><br><span class="line">    |   +---libtiff</span><br><span class="line">    |   +---libwebp</span><br><span class="line">    |   +---openexr</span><br><span class="line">    |   +---openvx</span><br><span class="line">    |   +---protobuf</span><br><span class="line">    |   +---quirc</span><br><span class="line">    |   +---tbb</span><br><span class="line">    |   \---zlib</span><br><span class="line">    |       \---patches</span><br><span class="line">    +---apps</span><br><span class="line">    |   +---annotation</span><br><span class="line">    |   +---createsamples</span><br><span class="line">    |   +---interactive-calibration</span><br><span class="line">    |   +---traincascade</span><br><span class="line">    |   +---version</span><br><span class="line">    |   \---visualisation</span><br><span class="line">    +---cmake</span><br><span class="line">    |   +---android</span><br><span class="line">    |   +---checks</span><br><span class="line">    |   +---FindCUDA</span><br><span class="line">    |   +---platforms</span><br><span class="line">    |   \---templates</span><br><span class="line">    +---data</span><br><span class="line">    |   +---haarcascades</span><br><span class="line">    |   +---haarcascades_cuda</span><br><span class="line">    |   +---hogcascades</span><br><span class="line">    |   +---lbpcascades</span><br><span class="line">    |   \---vec_files</span><br><span class="line">    +---doc</span><br><span class="line">    |   +---images</span><br><span class="line">    |   +---js_tutorials</span><br><span class="line">    |   +---pattern_tools</span><br><span class="line">    |   +---py_tutorials</span><br><span class="line">    |   +---tools</span><br><span class="line">    |   \---tutorials</span><br><span class="line">    +---include</span><br><span class="line">    |   \---opencv2</span><br><span class="line">    +---modules</span><br><span class="line">    |   +---calib3d</span><br><span class="line">    |   +---core</span><br><span class="line">    |   +---dnn</span><br><span class="line">    |   +---features2d</span><br><span class="line">    |   +---flann</span><br><span class="line">    |   +---gapi</span><br><span class="line">    |   +---highgui</span><br><span class="line">    |   +---imgcodecs</span><br><span class="line">    |   +---imgproc</span><br><span class="line">    |   +---java</span><br><span class="line">    |   +---js</span><br><span class="line">    |   +---ml</span><br><span class="line">    |   +---objdetect</span><br><span class="line">    |   +---photo</span><br><span class="line">    |   +---python</span><br><span class="line">    |   +---stitching</span><br><span class="line">    |   +---ts</span><br><span class="line">    |   +---video</span><br><span class="line">    |   +---videoio</span><br><span class="line">    |   \---world</span><br><span class="line">    +---platforms</span><br><span class="line">    |   +---android</span><br><span class="line">    |   +---ios</span><br><span class="line">    |   +---js</span><br><span class="line">    |   +---linux</span><br><span class="line">    |   +---maven</span><br><span class="line">    |   +---osx</span><br><span class="line">    |   +---scripts</span><br><span class="line">    |   +---wince</span><br><span class="line">    |   +---winpack_dldt</span><br><span class="line">    |   \---winrt</span><br><span class="line">    \---samples</span><br></pre></td></tr></table></figure><p>我们放置在了  <code>F:\Vision\opencv430</code>文件夹下面, 得到了上面的 文件列表, 主要用到的库文件都是在 build 文件夹内, source 文件夹下面是 源代码, </p><p>实际上 我们在程序中需要用的 只有 这里需要的程序, 动态链接库 dll 文件, 静态库 lib 文件, 以及 包含目录 include 文件夹,<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">opencv430</span><br><span class="line">+---dll</span><br><span class="line">|       opencv_videoio_ffmpeg430_64.dll</span><br><span class="line">|       opencv_world430.dll</span><br><span class="line">|       opencv_world430.pdb</span><br><span class="line">|       opencv_world430d.dll</span><br><span class="line">|       opencv_world430d.pdb</span><br><span class="line">|       </span><br><span class="line">+---include</span><br><span class="line">|   \---opencv2</span><br><span class="line">|       +---calib3d</span><br><span class="line">|       +---core</span><br><span class="line">|       +---dnn</span><br><span class="line">|       +---features2d</span><br><span class="line">|       +---flann</span><br><span class="line">|       +---gapi</span><br><span class="line">|       +---highgui</span><br><span class="line">|       +---imgcodecs</span><br><span class="line">|       +---imgproc</span><br><span class="line">|       +---ml</span><br><span class="line">|       +---objdetect</span><br><span class="line">|       +---photo</span><br><span class="line">|       +---stitching</span><br><span class="line">|       +---video</span><br><span class="line">|       \---videoio</span><br><span class="line">\---lib</span><br><span class="line">        opencv_world430.lib</span><br><span class="line">        opencv_world430d.lib</span><br></pre></td></tr></table></figure></p><p>如果不是需要调试信息的话,  dll 文件夹下面的 pdb 文件可以全部删除,<br>在忽略 dll 文件之后, 我将自己常用的 C++ 的依赖库 都放在了 github上<br><a href="https://github.com/SChen1024/CVDepend" target="_blank" rel="noopener">SChen1024/CVDepend</a><br>有需要的可以去查看下载, </p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>到这里, 我们才算是完成了第一步的安装程序, 后面 开始上手进行使用 opencv 了</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
            <tag> c++ </tag>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv-文章列表</title>
      <link href="/2020/04-20/opencv-bloglist.html"/>
      <url>/2020/04-20/opencv-bloglist.html</url>
      
        <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>由于害怕自己忘记或者拖延, 这篇文章就作为 opencv 系列的一个目录以及 todo 吧, 我会依次添加相应的内容并整理好的.</p><p>大概率还是按照opencv 的文档结构进行 一一的介绍, 尽量完成整个文档的学习, 对于熟悉的模块希望自己能够更深入的了解, 对于用的很少或者自己不熟悉的还希望能指正出来, 共同学习 </p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul><li style="list-style: none"><input type="checkbox" checked> 1. 引导篇系列<ul><li style="list-style: none"><input type="checkbox" checked> opencv-0 项目启程 <a href="https://schen1024.github.io/2020/04-20/opencv-0-start.html">https://schen1024.github.io/2020/04-20/opencv-0-start.html</a></li><li style="list-style: none"><input type="checkbox" checked> opencv-1-QT_OPENCV 安装 <a href="https://schen1024.github.io/2020/04-20/opencv-1-QT_OPENCV.html">https://schen1024.github.io/2020/04-20/opencv-1-QT_OPENCV.html</a></li><li style="list-style: none"><input type="checkbox" checked> opencv第一副图像显示 <a href="https://schen1024.github.io/2020/04-20/opencv-2-vsqt.html">https://schen1024.github.io/2020/04-20/opencv-2-vsqt.html</a></li><li style="list-style: none"><input type="checkbox" checked> opencv-2-VS2017与QT显示图像 <a href="https://schen1024.github.io/2020/04-20/opencv-2-vsqt.html">https://schen1024.github.io/2020/04-20/opencv-2-vsqt.html</a></li><li style="list-style: none"><input type="checkbox"> opencv-3-图片存储与相对路径 <a href="https://schen1024.github.io/2020/04-21/opencv-3-showimageandwrite.html">https://schen1024.github.io/2020/04-21/opencv-3-showimageandwrite.html</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 2. 基础入门<ul><li style="list-style: none"><input type="checkbox"> opencv-4-成像系统与Mat图像颜色空间 <a href="https://schen1024.github.io/2020/04-21/opencv-4-Mat.html">https://schen1024.github.io/2020/04-21/opencv-4-Mat.html</a></li><li style="list-style: none"><input type="checkbox"> opencv-5-图像遍历与图像改变 <a href="https://schen1024.github.io/2020/04-21/opencv-5-matpx.html">https://schen1024.github.io/2020/04-21/opencv-5-matpx.html</a></li><li style="list-style: none"><input type="checkbox"> opencv-6-图像绘制与opencv Line 函数剖析 <a href="https://schen1024.github.io/2020/04-22/opencv-6-%E9%BC%A0%E6%A0%87%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F.html">https://schen1024.github.io/2020/04-22/opencv-6-%E9%BC%A0%E6%A0%87%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F.html</a></li><li style="list-style: none"><input type="checkbox"> opencv-7-鼠标绘制自定义图形 <a href="https://schen1024.github.io/2020/04-24/opencv-7-%E9%BC%A0%E6%A0%87%E7%BB%98%E5%88%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E5%BD%A2.html">https://schen1024.github.io/2020/04-24/opencv-7-%E9%BC%A0%E6%A0%87%E7%BB%98%E5%88%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E5%BD%A2.html</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 4. 图像处理<ul><li style="list-style: none"><input type="checkbox"> 核运算</li><li style="list-style: none"><input type="checkbox"> 图像降噪与平滑</li><li style="list-style: none"><input type="checkbox"> 形态学操作</li><li style="list-style: none"><input type="checkbox"> 图像金字塔与插值运算</li><li style="list-style: none"><input type="checkbox"> 阈值与自适应</li><li style="list-style: none"><input type="checkbox"> 边缘算子</li><li style="list-style: none"><input type="checkbox"> 霍夫直线变换</li><li style="list-style: none"><input type="checkbox"> 霍夫圆变换</li><li style="list-style: none"><input type="checkbox"> 映射操作</li><li style="list-style: none"><input type="checkbox"> 仿射变换</li><li style="list-style: none"><input type="checkbox"> 直方图计算</li><li style="list-style: none"><input type="checkbox"> 直方图均衡</li><li style="list-style: none"><input type="checkbox"> 直方图比较</li><li style="list-style: none"><input type="checkbox"> 模板匹配</li><li style="list-style: none"><input type="checkbox"> 轮廓检测</li><li style="list-style: none"><input type="checkbox"> 凸包</li><li style="list-style: none"><input type="checkbox"> 轮廓包络</li><li style="list-style: none"><input type="checkbox"> 图像分割</li><li style="list-style: none"><input type="checkbox"> 去模糊</li><li style="list-style: none"><input type="checkbox"> 降噪</li><li style="list-style: none"><input type="checkbox"> 配置文件读取与输出</li></ul></li><li style="list-style: none"><input type="checkbox"> . 图像视频输入与输出</li><li style="list-style: none"><input type="checkbox"> . 相机校准与3D重建</li><li style="list-style: none"><input type="checkbox"> . 2D特征检测</li><li style="list-style: none"><input type="checkbox"> . 视频分析</li><li style="list-style: none"><input type="checkbox"> . 对象检测</li><li style="list-style: none"><input type="checkbox"> . 深度神经网络</li><li style="list-style: none"><input type="checkbox"> . 机器学习模块</li><li style="list-style: none"><input type="checkbox"> . 图形API</li><li style="list-style: none"><input type="checkbox"> . 计算摄影</li><li style="list-style: none"><input type="checkbox"> . 图像拼接</li><li style="list-style: none"><input type="checkbox"> . GPU加速计算</li></ul><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
            <tag> c++ </tag>
            
            <tag> qt </tag>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv-0-项目启程</title>
      <link href="/2020/04-20/opencv-0-start.html"/>
      <url>/2020/04-20/opencv-0-start.html</url>
      
        <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>无数次说要开始 opencv 的系列, 但是都由于各种原因没有坚持下去,<br>这次我做最后一次尝试, 也做最后一次坚持, 如果不做下去, 我就再也不开这个坑.</p><p>学习opencv 也有好几年了, 看到别人也写了各种的博文, 也学习了很多, 我也想写一点什么作为自己的一个总结,  我会将自己用到的和能够查到的都尽量写完整, 完善自己的知识库, 进而都整理出来, 完成写作. 工作量可能有点大, 但是我会坚持下去的.<br>希望我能成功了再回看这个项目</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>从 Opencv 的基础开始, 从安装开始, 在到基本的操作, 再到每种算法的起源和发展, 并深入的剖析 opencv 的源码,  对应的还会写处相应的程序来, 这样 能够更为方便的展示效果</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>文章的结构可能会变化, 但是大概的结构还是有的,<br>最开始从 opencv 的文档入手, 也看过很多别人翻译的文档,</p><ul><li><a href="https://docs.opencv.org/4.3.0/" target="_blank" rel="noopener">opencv 官方站点</a></li><li>参与了部分翻译内容的 <a href="https://opencv.apachecn.org/" target="_blank" rel="noopener">OpenCV 中文文档 4.0.0</a></li><li>早期的 opencv 中国  <a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/index.html" target="_blank" rel="noopener">opencv2.3.2 中文文档</a></li><li>个人翻译的 <a href="http://woshicver.com/" target="_blank" rel="noopener">opencv 4.1.0 中文文档</a></li><li><a href="https://www.w3cschool.cn/opencv/" target="_blank" rel="noopener">w3cschoold 文档库 opencv</a></li></ul><p>但是我这次也不是去做文档的翻译工作了, 我要做的更深一点, 往下深挖具体的实现原理并作出演示<br>在文档的基础上, 去查看相关操作的基本原理, 进而分析不同情况下的执行情况, 最后写小的 demo 用于测试, 并给处演示.</p><p>最终的代码会同步在两个仓库中</p><p><a href="https://github.com/SChen1024/Imagelab" target="_blank" rel="noopener">Github/SChen1024/Imagelab</a></p><p><a href="https://gitee.com/schen00/Imagelab" target="_blank" rel="noopener">Gitee/schen00/Imagelab</a></p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li>代码编写: QT+OpenCV<br>图像处理这里的主要内容是学习的Opencv, 个人主要开发是基于CPP的, 所以这里选择了使用 QT 作为桌面程序的开发,  这里选择了最新版本的程序,  涉及到调试部分的话, 使用的是 Visual Studio , 由于版本问题, 这边直接下载的 OpenCV, 编译好的库是 VS2017版本的, 所以在 QT 中 使用对应的 VS 2017_X64  </li></ol><ul><li>QT 5.14.2</li><li>OpenCV 4.3.0</li><li>VS2017 </li></ul><ol start="2"><li>源码阅读: VSCode+ Source Insight<br>VSCode 主要用于查看临时代码 进行少量的代码编写, 也能配置进行编译, 但是我不是很喜欢, 所以主要用于代码展示与 markdown 的编写, 配合 hexo blog 作为自己目前的博客环境<br>Source Insight 4.0 用于进行源代码的查看, 在大的工程查看的时候很好用, 之前用的比较多, 所以现在仍然这样.<!--> 付费软件, 有需要的自己取用 [Source Insight 4.0 最简单的破解安装](https://blog.csdn.net/hzw2017/article/details/82085670)--></li><li><p>博文编写: 小书匠 和 Zotero<br><a href="http://soft.xiaoshujiang.com/" target="_blank" rel="noopener">小书匠</a>是我偶然发现的一款应用, 真的很好用, 功能很强大, 最方便的一点能够很方便的绑定多个图床, 目前的图片主要放在自己的 gitee 仓库里面, 作为图片存留. 能够本地客户端与线上直接同步, 十分方便.<br>Zotero, 可以将自己感觉参考到的网页类似于文献一样的组织起来,能够很方便的使用. 写博客也有种写论文的感觉了. ^[阳志平的网志. 《Zotero（1）：文献管理软件Zotero基础及进阶示范》, 2013年4月4日. <a href="https://www.yangzhiping.com/tech/zotero1.html.]" target="_blank" rel="noopener">https://www.yangzhiping.com/tech/zotero1.html.]</a></p></li><li><p>其他工具</p><ul><li>Chrome , 最好用的浏览器 </li><li>github  学习的地方</li><li>CSDN/cnblogs/简书/知乎   能看到很多前辈的博文,真的很有用, 学到了很多.</li></ul></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>在图像处理的学习过程中, 受到了很多博主的影响</p><ol><li><a href="https://blog.csdn.net/poem_qianmo" target="_blank" rel="noopener">CSDN 浅墨_毛星云</a>, 算是入了门,  学会了使用 opencv 的基础内容</li><li><a href="https://www.cnblogs.com/Imageshop/" target="_blank" rel="noopener">cnblogs ImageShop</a>,  从图像处理的角度给了让我知道了还能这么做, 他个人喜欢最求更快的图像处理技术, 很有趣的一个博主.</li></ol><p>…. 还有很多 博主, 此处不再列举. </p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> opencv </tag>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SketchUp]-绘制自己的家</title>
      <link href="/2020/04-19/sketchup-myhouse.html"/>
      <url>/2020/04-19/sketchup-myhouse.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近已经完成了 毕业论文, 等待盲审的过程中, 将过去几年做的东西也都一一整理了, 硬盘中好几个不敢动的文件夹 也都可以删除了.</p><p>想着这段时间开始将以前落下的东西一一补齐的, 昨天的时候偶然看到了别人发的装修图–<a href="https://post.smzdm.com/p/579425/" target="_blank" rel="noopener">SKETCHUP高精度控制下的室内装修设计 篇一：#原创新人#精装控制篇</a> , 感觉好厉害, 自己<br>心理有点痒痒了, 以前的时候自己尝试过绘制自己的家, 但是不知道什么原因也都放弃了, 这次想着正好有时间, 就自己上手试试. </p><p>然后搜到了<a href="https://post.smzdm.com/p/518266/" target="_blank" rel="noopener">节俭装修不简单 篇四：SketchUp在装修上的应用简说</a>  这篇文章, 做了一个简单的介绍, 一看, 好简单, 然后就上手了</p><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>SketchUp 2020 <del>破解版</del><br>从<a href="https://www.isharepc.com/22469.html" target="_blank" rel="noopener">SketchUp Pro 2020 v20.0破解版</a> 下载的 </p><blockquote><p>SketchUp 2020   <a href="https://pan.baidu.com/s/18ASNkhEkZnIlO46id-buMg" target="_blank" rel="noopener">百度网盘</a> 提取码:mrkh</p></blockquote><p>有需要的自己取用</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="0-上手"><a href="#0-上手" class="headerlink" title="0. 上手"></a>0. 上手</h3><p>我自己有过 一些画图软件的基础, CAD, SolidWorks, ANSYS,<br>所以感觉 SKetchUp 的上手很简单, 就是感觉操作没有我想的那么好玩, 其实三维软件都差不多,<br>注意视角的旋转就好, 鼠标中键真的很好用,<br>我一般喜欢鼠标中键旋转视角, 右键长按 平移视角, 但是这个做的不是很好,  右键没有, 不是很习惯</p><h3 id="1-绘制墙壁和开孔"><a href="#1-绘制墙壁和开孔" class="headerlink" title="1. 绘制墙壁和开孔"></a>1. 绘制墙壁和开孔</h3><p>在这篇文章<a href="https://post.smzdm.com/p/518266/" target="_blank" rel="noopener">节俭装修不简单 篇四：SketchUp在装修上的应用简说</a> 中, 详细介绍了怎么进行平面图形的绘制, 这里可以过去学习一下,</p><p>翻出我家的房产证, 看了下房子的大的尺寸信息,然后就可以开始就开始画了, 画图的时候一定要注意墙壁厚度, 尽量保持在每次只取一边, SU 好像很难更改之间的尺寸, 所以建议定好, 具体的门窗信息考  自己列一个表 带着尺子去一个一个的量就好了.</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587286744936.png" alt="门窗数据"></p><p>这里使用的门窗数据 单位都是 $cm$ , 但是在 SU 里面,画图的时候 是点击起始点, 然后输入参数, 在右下角能够看到, 单位是 $mm$ (具体看你选的模板, 有 $mm$ 和 $inch$ 两种单位).</p><blockquote><p>一般老房子都是 $30cm$ 的墙壁厚度, $3m$ 左右的高度 , 门大概 80cm 宽, 窗户一般距离地面 90cm 高</p></blockquote><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587286744938.png" alt="门窗开孔图"></p><h3 id="2-自定义门"><a href="#2-自定义门" class="headerlink" title="2. 自定义门"></a>2. 自定义门</h3><p>老式房型的门还真不好找, SU 最强大的就是有着无数的<a href="https://3dwarehouse.sketchup.com/" target="_blank" rel="noopener">3D 图库库</a>上找到好看的自己下载  , 可以直接导入到我们的图中, 进行缩放合适的位置就好了</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587286744942.png" alt="老式的门"></p><p>由于我家的门比较老了, 所以我就自己画了一个, 算是上手吧. </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587286744945.png" alt="左开门"></p><p>SU  只有推拉一个操作, 但是可以使用 bool 运算进行组合, 我就直接弄了一个听简单的 , 纹理是 自带的系统染色工具, 点一下就行了, 凑合能看, 做不到SW 的各种渲染效果.</p><p>好像无法进行对称, 所以我又复制出来一个 右开门的门</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587286744939.png" alt="右开门"></p><h3 id="3-自定义窗户"><a href="#3-自定义窗户" class="headerlink" title="3 自定义窗户"></a>3 自定义窗户</h3><p>窗户也一样,  推来得到3D的图, 删除掉中间的部分 然后  加上玻璃就行了, 稍微计算一下具体的尺寸就好, </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587286744941.png" alt="窗户"></p><p>自带的颜色都好丑, 只有这种还算能看吧, 不锈钢 直男的感觉…</p><p>然后我家窗户也很复杂, 自己又做了组合, 得到了 </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587286744944.png" alt="上面带固定的窗户"></p><p>然后室内的窗户是进行了包边的, 然后加上去之后居然看起来还不错…. </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587286744940.png" alt="带木边的窗户"></p><h3 id="4-组装门窗"><a href="#4-组装门窗" class="headerlink" title="4. 组装门窗"></a>4. 组装门窗</h3><p>SU 可以导入别的图 ,然后使用 移动, 缩放工具能不同尺寸的图适应到孔内,  经过复杂的操作, 最终我们完成了家庭房屋的大部分结果, 是不是还行. </p><p>阳台的的窗户真的很难看, 有时间再单独画吧, </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587286744943.png" alt="组装门窗之后的图"></p><h3 id="…"><a href="#…" class="headerlink" title="…."></a>….</h3><p>暂时还没做的其他步骤</p><h3 id="1-渲染出图"><a href="#1-渲染出图" class="headerlink" title="-1. 渲染出图"></a>-1. 渲染出图</h3><p>最后一步, 进行渲染出图,   </p><blockquote><p>抱歉, 你的电脑太垃圾, 无法进行渲染, 请安装好一点的显卡…</p></blockquote><p>就没有然后了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>优点:</p><ul><li>上手容易</li><li>操作简单</li><li>模型丰富</li><li>组合容易</li></ul><p>缺点:</p><ul><li>复杂操作很难实现</li><li>专业性不强</li><li>无法精准控制</li></ul><p>SU 十分适合新手, 或者想玩玩的 , 组装之类的只要能到位看不出来就行,  专业软件则能做的更好,<br>但是上手快呀, 成就感十足,  值得尝试玩玩就好…</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Person </category>
          
      </categories>
      
      
        <tags>
            
            <tag> home </tag>
            
            <tag> soft </tag>
            
            <tag> sketchup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再见VS2015</title>
      <link href="/2020/04-16/byeVS2015.html"/>
      <url>/2020/04-16/byeVS2015.html</url>
      
        <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>我是 15 年开始有的笔记本电脑， 也是那时候开始有的笔记本电脑， 算了算 从那个时候就是开始使用 VS 了， 当时看着真的是一个很大很大的软件， 现如今其他的软件装得多了， 发现并不是很大了。</p><p>使用 VS 有几年了， 总的来说，使用到的功能只是基础， 能进行代码编辑， 编译，调试， 主要的工作了， 安装了很多很多的插件， 越来越舍不得了，</p><h2 id="更好的工具"><a href="#更好的工具" class="headerlink" title="更好的工具"></a>更好的工具</h2><p>其实也没有什么更好的工具， 只是使用新的版本而已， 恰逢毕业之际， 正好对自己的电脑进行一次大的更新， 旧的删除， 新的引入， 也是对自己工作的一个总结吧， 希望在未来能够更好的出产新的东西。</p><h2 id="夸"><a href="#夸" class="headerlink" title="夸"></a>夸</h2><p>VS2015 真的很好用，<br>宇宙第一 IDE</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>卸载方法参考了<a href="https://blog.csdn.net/amusi1994/article/details/53375977" target="_blank" rel="noopener">完美卸载 Visual Studio2015 的方法汇总</a></p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> VS2015 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>websitelist</title>
      <link href="/2020/04-13/websitelist.html"/>
      <url>/2020/04-13/websitelist.html</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>硕士预答辩</title>
      <link href="/2020/04-12/%E7%A1%95%E5%A3%AB%E9%A2%84%E7%AD%94%E8%BE%A9.html"/>
      <url>/2020/04-12/%E7%A1%95%E5%A3%AB%E9%A2%84%E7%AD%94%E8%BE%A9.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="8383fa4c0968eaf6038119388e45c6c820c4a215cfea4284fd07318d59337bed">c69d458b5be806e1275b581ae7b46a5b4b1cdbf18bb8d8faf805c851b25c6090f5c1e3754a9e4dadb5197f3a7f84116a1925058a6d46b2fafc2eee6d1f0dcd8c0c7b6b0bf03eae83aa4d907478b0a4cfb6bb413bfaf6488c227e2eff97e2b0bd1297ea9987941eadfdd0fefaa56f014403680a3bf420befd7ec196d2666d4dafa5360d63cb3a8bcb363d46e6fdbeebb0fd6436a4094d65a30a6840b741fd3dd3f89da384b817dfc52077d48c94913684a6be9922200813b3a0b21570178c5a940dad26e7e611ea197297100894afbd1073fa90698983393f388c00063cee41fb36cf877efcca01232a023fb647d58dc2dad2faa90f1c43cc29425149b5a949c88a14893335a0b87df1fdbe7a8a807f0ab9984f61eb6495ffc3943fd995e1f87ffe1e996e9b759e0a3c74b0df70f82bcb28776dc80e628529aa5282f0bcef771904fe662eb6caa37502b0f188244cc3e08e5bd4bc296f98d622fbeb0e2add525af8fd08c03eb2e09bda1ae28eeec818998febcfd8a79e57cae7112568968d30ef4d1be1e485b2f3be170a11304e770ae81e8e6ba01e0b00dba376a6a9e47ddd28bca89f5f4345b0189c5784907db5b83009dec7752d8d1a9a83fc0e31de46ed938cfd12f658b3fecbbd25be9132a993f34d3011e46dc93f39fc508145e31d70f72cbbbf1bb22f6b42b78a2c0b0a01bb2a6eb5eb7a3ad8e49a4d6b9fba0365e352cfa7276d6a34748b40fea8f712b33452d5697c9f8d006d365fc1892f420eb6061e067cae452fd87ebb70e6a3a271a7bf8b99da64533977159285f5a7bbbc292759036e8baa632f43b48facf3a87840504509a39482678fc6b372e48cfcc376103e4cf8ee4cabc9c04d13e516f6a81770c7e17166ba248a4cef184de1dd8f5f835f5f000ce015cb4bc4618442f1005e3fe6467a84940ef4f46735e7272a757d8d10c98eac95fbc845e30146bc94ebf8de6df7cd0a88be177eafa398930904445f0a6d03b6e19fb0fef6b85a0c84817a152a7da14f5748e31825786f7bbbde66a570afdcbcc3c69491ec63db475f0febfc03d92cb650846a302594fe4eee2656d8ac6b77e8578c72c84b09fee82d2f316b0ebcb708bfdca1c2af2ca9a297156e35c22009bd30649035fc8e40555e433cb92b3468acaeddb3803bdd936022a88a7f5f64482c165f1fc2cc386a8cdee9787f44e505f191bde9c7f7596e7b67d62682da9ccb92cb1a08bd28cdc4849e7c16e30f5b508996bb860d24bc48e9a68f677693984c527e67174dacd8920b33ccf76b719f64b0c2354bce75c2ba63cc50df5fe435ca4dd3d90b0b4d5570a20d5f020165b550fba7abed05c4f535f240869123a2458550c66028520435735e0147b54fdac314982544fc81106eeeaae3ed3abf4e6c167ab5736095c333e4bdce688ae079af835281e71b71e174f82811c5a4099d98f77594b08d18fc2b6ff900f20a5047c6ed0593c64ad8141a642605859e6c1ee9e8b556207342c302f51c5378edd6e860a74dd642c96d75ba1772e6235796b596516291372583840271d54967f1e3e78821c671f9c89cbfe48a278e623fb0bdc624e00a332365eb7463cae6c6150fc70a9b99158ba239138611970f1b8114033ae96e777517a012ca418b296f9ef4eeb741d219582acdeac3948a7f42583c5b9cb7a797635854c0b1a3b9a71a157aa521604cde8cc10190362c910f9d27cf03ff5f03c2407032b3d85c61d2667563899943423cd88509e6e5d29c05fcc7b9072fc2d893f905cd6c9b9e15d4a603a4e24ae2e6264c811e2fa4c76f53870b7c59936ee782ff548b1512decb4e91b11b59f562c3fae1978ba4da47efd4690af57b36be21e58c67875697e4785130960e484ce92ff86c95026d03c23aaa9b16ec1b4f509dd5b060ab9d6368e521983df724ac8837a83de8361c4b0ac188f43af700488713637c2c6a9643aea889aadd93d56913bb915d7eb60efeda772b2617b4edd77db0c318e0940e5b30a7df2576a537577db7782149f93b725ef32fc7987498d597168311484eadec2a50f82f161e9eadebe94ca7604d923a3675cd60eb12019108d304dff2fdf63738091bd0e8f03340272378749e29d5d56f3cbba535f37ec3a9488d6e2910983141db38f7691eeb165423791a71401f9b438482e9849be0844a6cb369d2995d2c26c5b3ec393ae97b0fe4f7cf96705e61e975bc3bf869d0e528b96b031194fd6536747904c24ad53d8494636f7da331149a66d7e00b23e0b25f32cbe54ad9960d0d339235f2cab35ec0acfe710408287b2221d483cc41f00029e08615470f8fc1a6ff5baa2faa515643f7d0f8f3651da4929d25098ac2b7a7a2795c56886c00f87f291a43740ae294859554a887d01b436741c4f7476e208f9bb2ff4fe5aa683879d487b301b67af8fcc554ec2c1b47e09173224167650cd40ed085ad8f0d3a2b9b613dce83c2cd31a96be37ebc87f07e7ed3fec3f60fe4616b46a87c8e89f8db3caec87f7c65af274fbc927d5b71b136da61e599313f2e44efa1c66724768633e502532c13f632efb32a39b58c342b66c40f68c280971f1afec5e9bef2dbd0dffe666202e781625b1d5806222f0ee81eebd6460dd48a5a178c8e0030569a89dd63095163a3240ec7ad959cc32e6b6913fb4cfec501dc19650c2c46a059983d9a9740ccebb39174eb9cdded45da3701e6c9085ee9cd97447ddfb6ca232a08a7a7cecc3b1d8474dff952413dfcbc7b7ab12456ed5bc235508f83dbcce898182b15b4e120e9556e9ed783a072424a328b04b98682564e9ef65f177452d1aeadd5675b0d5698cc3e91cec8db188c072adbd0b4ec21528796fc58c7ee3cd2d35ec12f7dcffec5ac773e476fb214ac7cc51b0023a684e141c41b383ddfb3408e39ee3d5bf804aaaf8d908a010d70f17bac5dcc57e7960c8809eda5b4df9f91851d24fe29500cbb35f43ff344de20ad8b23ff45acaabeee36baf73a791089fa37889e4df772e551ceaef444f3aecfa45a4ee55894b3abbc79ecc4ef3a722381642a6efccd0f6d23d77f17e79d398cba244d5301a65d4e678e730193d896bb7ac874542360c2afc16b92a85ddd5dca693a98e47412a8449aa81b65aa5beca0cbbfdf42d4e6ec5d162a16fd90bce8109135349c5489deaf3ea9a651b37955c022250888185be4178fdbd08e786fa00c78ee2a62670ee59686d8fb89fb87089da0596e004a89ac3c2ed4e263d503a0741cfaaafb311c77c8ef4c7ad891dda0db389fd744bd5c07304b19892f4105708d28fe426360a23b2063a9a7c6b8155727f839cc443fb172b614d077473f6ba63815d7301edf081a3cf368b82306242a20b6414c626b66441e660b6bb8da1e514f6b8273373afb43465a02c05961e05f167f7c7a9792e4091a7c7f19b29e54fc0d3220aa05c0f6670116211e014de91b06d0e32c3699eca7126bd271f0aafe5c7b552f5f10750bb52b534497ff7ea9e5147f3889ce2b1e49d84433e59dbc6b117087eb20665d293fbd3964f167d3e0ee1e29016f5db86eccc30ae0ec6b9a600f59b2d2d2b89e215c1f71a83bacfc4d5f490c5f451a70dfb0de6bf76004f7d4ffedd31c9ce498f571f095a28b6f882032cb065845fe13f4776d7903c83c68e4dde5d2cacfdf9a53a18cbba3a8f424c8bce2207a202b72ad499a4526c19b013d39b9ef851f97630ae81dee9b58ef2039cb08af6e7a28f9698d1104b625b68ad611968b0bcc144a7f67253a803902430c237678270e1ce6335de991372f643afaa01dc9c07a99b76197eec3d851269c55c12345ca7f716698d2864c2b462aa0f15aa9d47c09f4528518949bd13fffb0af47a4e02b259b9cfcf1b52a7102182b7df60acc33d61cf36f0cd3e64032cb562469e1f8added2b97fc02e9844be4c309ea2491fa9be1e2ed7975a351091c90733b3c51855ca5693cfa31aad1b7bde2763a8ebeb52da1d250028490e00a55f117fe1f0f3128056fa8e47af941d0a27aa744151c4ea9b1d940853db449ec8a7bc903261bf25bb6796a1b32e7e6a4e2270ff77d57b3b38beed1901fec93895334484f9ae16bed1e30d8d0c36484c1efd1dbad436a794123dd8894849a5ba8c414f7afa54b432c26a8834ae199b5ff981221e243417098a854a6d52368b95977db37931df73dde9bf6a2da9cc9db08e8d03081effb997ee6d7dd4077873c0bec311fd4ccf0e3cf0334c28886ffb6e714e792bc3589d50705ec49a42d6f9f17587552b0a9cc14d1c8d7d121875be26980d363e89bbfeaf65489664fcdb8356d87b550db073224527ac5db5a53b9e014244132e0ee8ec78b31fd1e75d08e7b5a50895ced9e1a11de7178862c2a2304b14e8df173109caee6e8168a092326cab886496eb458ef8aeee8bfd5f5a5c7153254d6bdbfb2557df9e224fd7bb27ce756736487af7a48a7d4201b319555875b2ab541b0bea045213deaa6373c9dc18d985a9fc9ca557d1829278d3272b98de981dc4982a22aa8ca1734fa566e9d34b58c3144f3818e54cf926ecf422abe63ae007</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Person </category>
          
      </categories>
      
      
        <tags>
            
            <tag> encrypt </tag>
            
            <tag> master </tag>
            
            <tag> ppt </tag>
            
            <tag> outline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C51_PID 水温控制系统</title>
      <link href="/2020/04-05/C51_PID.html"/>
      <url>/2020/04-05/C51_PID.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过 C 语言程序写入 51 单片机实现水的温度的采集,并通过控制器控制加热器给水体加热,对水体的温进行 PID 控制,保证温度在设定值范围内波动<br>最终包括 C51 的视频的内容以及部分参考资料都可以在 百度分享链接内下载</p><p>链接: <a href="https://pan.baidu.com/s/1jpawh31O1gqv9CU_0LXFZQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1jpawh31O1gqv9CU_0LXFZQ</a> 提取码: 2333</p><p>包含店家赠送的 51 的资料以及使用过程中需要用到的部分参考文件以及代码</p><hr><h2 id="1-系统设计"><a href="#1-系统设计" class="headerlink" title="1. 系统设计"></a>1. 系统设计</h2><p>系统硬件部分主要包含主控制器(==89C52RC==),温度传感器(==DS18B20==),加热器,数码管显示,AD 采集以及 DA 输出</p><p><img src="https://i.loli.net/2019/01/05/5c301c0a82c78.jpg" alt="系统总体结构"></p><p><img src="https://i.loli.net/2019/01/05/5c301c136863c.jpg" alt="51系统板接线"></p><h3 id="1-1-主控制器"><a href="#1-1-主控制器" class="headerlink" title="1.1 主控制器"></a>1.1 主控制器</h3><p>主控制器是 89C52 <a href="./attachments/STC89C51RC-RD使用手册.pdf">使用手册下载</a> 也可以在 pdf 文件中找到使用手册<br>本次实验使用的设备是 ==德飞莱 LY-51S V3.0== 可以参考附件中 V2.32 版本的使用手册,实物可以参考京东链接介绍页面^[<a href="https://item.jd.com/29638729865.html]" target="_blank" rel="noopener">https://item.jd.com/29638729865.html]</a>, 基本操作视频在最上方发出的百度分享链接中(2.7G),以及店家附带的关于系统板的参考资料(600M)</p><p>系统控制器的原理图如图 1.1 所示</p><p><img src="https://i.loli.net/2019/01/05/5c301c15ac834.jpg" alt="图1.1 51系统板原理图"></p><p>图 1.2 所示是 51 系统板原始图像,跟本版本几乎一致, 可以参考</p><p><img src="https://i.loli.net/2019/01/05/5c301c040a494.jpg" alt="图1.2 51系统板裸板图像"></p><p>最终只使用到了:数码管显示,只是 LED 小灯,串口模块,AD-DA 模块,循环会一一介绍</p><h3 id="1-2-LED-小灯"><a href="#1-2-LED-小灯" class="headerlink" title="1.2 LED 小灯"></a>1.2 LED 小灯</h3><p>程序里面设计了四个小灯来标识程序执行情况,对应的使用==P10 #F44336==,==P12 #F44336==,==P14 #F44336==,==P16 #F44336==四个端口,这样便于小灯之前区分开,避免识别出错, LED 只需要在程序中将 LED 进行赋值 1 0 即可控制小灯亮灭,由于小灯是==共阳极==, 所以 <strong>设定 LED=1 小灯是灭的 LED=0 实现小灯亮起</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  定义小灯表示输出</span></span><br><span class="line">sbit LED0 = P1^<span class="number">0</span>; <span class="comment">// 程序主循环函数</span></span><br><span class="line">sbit LED1 = P1^<span class="number">2</span>;   <span class="comment">// 读取温度闪灯, 每次读取温度 闪灯一次</span></span><br><span class="line">sbit LED2 = P1^<span class="number">4</span>;   <span class="comment">// 小灯,串口接收信号 闪灯</span></span><br><span class="line">sbit LED3 = P1^<span class="number">6</span>;   <span class="comment">// 小灯,串口接收信号 闪灯</span></span><br></pre></td></tr></table></figure><p>虽然原理图里面显示小灯是不同颜色, 但是在实际显示的时候全部是红色 所以间隔取了 4 个小灯来标识程序执行</p><p><img src="https://i.loli.net/2019/01/05/5c301c0518cdc.jpg" alt="小灯原理图"></p><p>LED0 是程序主循环程序指示灯,亮灭代表程序进入主程序的 while 循环中循环执行, 主循环 控制小灯闪灭,同时循环判断读取温度标识位==ReadTempFlag== 只有满足的情况下会进入执行否则不执行<br>LED1 是温度读取小灯, 标识 程序进入中断函数执行, 设定值是中断函数每 2ms 进入一次中断, 每次中断执行数码管刷新任务,同时每中断 250 次 0.5s 将程序执行标志位==ReadTempFlag== 置位 便于主程序执行,所以程序读取温度周期和程序执行周期都是==0.5s==<br>LED2 标识串口输出数据的小灯,每次串口接收到==一个==数据会将 LED2 进行取反操作 如果输入两个数据则小灯会快速亮灭一次完成操作<br>LED3 标识命令执行小灯,程序里面目前设定的是 5 个字符标识一条指令, 每次满足 5 个字符之后 LED3 小灯会亮起,标识指令输入完成,当不满足的时候灯会灭掉,可以通过此等判断当前状态</p><h3 id="1-3-数码管显示"><a href="#1-3-数码管显示" class="headerlink" title="1.3 数码管显示"></a>1.3 数码管显示</h3><p>数码管显示包含 8 个数据口 P0 的全部端口 P00-P07 以及两个控制控制口==P22 #F44336==,==P23 #F44336==的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DataPort P0 <span class="comment">//定义数据端口 程序中遇到DataPort 则用P0 替换</span></span></span><br><span class="line">sbit LATCH1=P2^<span class="number">2</span>;<span class="comment">//定义锁存使能端口 段锁存</span></span><br><span class="line">sbit LATCH2=P2^<span class="number">3</span>;<span class="comment">//                 位锁存</span></span><br></pre></td></tr></table></figure><p>共阴极数码管原理图 对应的程序可以见程序工程==display.c== 在头文件==display.h==中定义了程序接口,对应的需要将 P0 口的线接到数码管的数据口上==J3== , 同时需要将==J50==接口短接,否则数码管会很暗,几乎不可见同时需要将控制线 <strong>LATCH1 接到==J2==的 B 口, LATCH2 接到==J2==的 A 口</strong></p><p>程序会每次 2ms 循环显示数码管,==showTemp== 显示前面四个字,(-)25.1 的格式显示温度, ==showOuts== 显示后面资格字 会显示-999 到 999 的输出值, 显示计算得到的输出设定值, 输出值的显示会限定在-999 到 999 之间,</p><p><img src="https://i.loli.net/2019/01/05/5c301c06deeb9.jpg" alt="数码管原理图"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 千四个数码管 显示温度 _00.0 格式</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">showTemp</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> TempH,TempL;</span><br><span class="line">    uchar b=<span class="number">0</span>,s=<span class="number">0</span>,g=<span class="number">0</span>,d=<span class="number">0</span>;  <span class="comment">// 百 十 个位显示</span></span><br><span class="line">    <span class="keyword">float</span> t_ = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="comment">// 显示温度值</span></span><br><span class="line">    <span class="keyword">if</span>(temp&amp;<span class="number">0x8000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TempData[<span class="number">0</span>]=<span class="number">0x40</span>;<span class="comment">//负号标志</span></span><br><span class="line">        temp=~temp;  <span class="comment">// 取反加1</span></span><br><span class="line">        temp +=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        TempData[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TempH=temp&gt;&gt;<span class="number">4</span>;</span><br><span class="line">    TempL=temp&amp;<span class="number">0x0F</span>;</span><br><span class="line">    TempL=TempL*<span class="number">6</span>/<span class="number">10</span>;<span class="comment">//小数近似处理</span></span><br><span class="line"></span><br><span class="line">    b = TempH/<span class="number">100</span>;          <span class="comment">// 百位</span></span><br><span class="line">    s = (TempH%<span class="number">100</span>)/<span class="number">10</span>;     <span class="comment">// 十位</span></span><br><span class="line">    g = (TempH%<span class="number">10</span>);         <span class="comment">// 个位</span></span><br><span class="line">    d = TempL;              <span class="comment">// 十分位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(TempH/<span class="number">100</span>==<span class="number">0</span>)</span><br><span class="line">        TempData[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        TempData[<span class="number">1</span>]=dofly_DuanMa[b]; <span class="comment">//十位温度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((b==<span class="number">0</span>)&amp;&amp;(s==<span class="number">0</span>))<span class="comment">//消隐</span></span><br><span class="line">        TempData[<span class="number">1</span>]=<span class="number">0x00</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        TempData[<span class="number">1</span>]=dofly_DuanMa[s]; <span class="comment">//十位温度</span></span><br><span class="line"></span><br><span class="line">    TempData[<span class="number">2</span>]=dofly_DuanMa[g]|<span class="number">0x80</span>; <span class="comment">//个位温度,带小数点</span></span><br><span class="line">    TempData[<span class="number">3</span>]=dofly_DuanMa[d];</span><br><span class="line"></span><br><span class="line">    t_ = b*<span class="number">100</span>+s*<span class="number">10</span>+g+d*<span class="number">0.1</span>;</span><br><span class="line">    <span class="keyword">return</span> t_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示输出值,  取整 最大 999</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showOuts</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 限定在-999~999</span></span><br><span class="line">    num = num&gt;<span class="number">999</span>?<span class="number">999</span>:num;</span><br><span class="line">    num = num&lt;<span class="number">-999</span>?<span class="number">-999</span>:num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TempData[<span class="number">4</span>]=<span class="number">0x40</span>;<span class="comment">//负号标志</span></span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        TempData[<span class="number">4</span>]=<span class="number">0x00</span>;<span class="comment">//正号不显示</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TempData[<span class="number">5</span>]=dofly_DuanMa[num/<span class="number">100</span>]; <span class="comment">//十位温度</span></span><br><span class="line">    TempData[<span class="number">6</span>]=dofly_DuanMa[num%<span class="number">100</span>/<span class="number">10</span>]; <span class="comment">//个位温度,带小数点</span></span><br><span class="line">    TempData[<span class="number">7</span>]=dofly_DuanMa[num%<span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-温度传感器"><a href="#1-4-温度传感器" class="headerlink" title="1.4 温度传感器"></a>1.4 温度传感器</h3><p>温度传感器使用的集成的 DS18B20 模块,有三个接线, 白色是 5V-VCC 黑色是 GND.黄色是信号线,在程序中设定 AD 采集接口是==P36 #F44336==接口 以便进行 AD 采集定义在==18b20.h==文件中,对应的实现包含了传感器的初始初始化以及温度采集函数,通过调用采集函数==ReadTemperature==可以返回 uint 型的温度数据, 其中在==display.c==中包含了==showTemp== 函数中可以将 uint 型的数据进行解码得到==float==型的数据 并显示在数码管的前面四个数字中 按照(-)25.0 的格式显示总共四个格子, 标识当前的温度, 同时串口会实时的将温度输出到串口处, 输出格式为 ==025==的格式输出,实际上每次输出之后 会用一个空格分割每次的值,在串口部分详细介绍</p><p>温度传感器的温度输出值,可以参考 pdf 文件中的温度传感器的中文资料,其中数据与真实温度设定值可以参考下面的标识方式,实际上需要将 uint16 位的数据转换成 float 型的数据<br>==温度传感器需要进行温度标定==,将输出结果与真实温度进行数据标定成一个标准数据,,否则数据可能存在一个误差,</p><p><img src="https://i.loli.net/2019/01/05/5c301c0a5d320.jpg" alt="温度传感器温度值与数据的关系"></p><p>温度传感器的温度读取只在 18b20 文件中, 只需要将==P36==接口接到温度传感器的信号线上便能够读取温度, 不需要使用 i2c 来实现,似乎也不要使用 AD 采集就能得到结果</p><h3 id="1-5-串口-UART"><a href="#1-5-串口-UART" class="headerlink" title="1.5 串口 UART"></a>1.5 串口 UART</h3><p>51 单片机的串口部分包含比较简单,但是硬件部分存在大坑, 建议不要改动相应的程序 可以备份之后再进行修改,需要分开部分进行介绍 包括串口基本部分,以及串口输出部分以及串口接收指令部分<br>由于 51 单片机支持串口下载,可以直接通过 STC 下载器将 hex 下载进 51 中,同时可以打开串口与单片机进行通讯</p><h4 id="1-51-串口基本部分"><a href="#1-51-串口基本部分" class="headerlink" title="1.51 串口基本部分"></a>1.51 串口基本部分</h4><p>51 单片机的串口部分操作比较类似, 目前程序里面使用的是==2400== 波特率 baudrate,可以基本部分进行串口初始化以及实现串口发送单个字符以及发送字符串的功能 由于程序存在 串口初始化和定时器初始化, 所以在初始化过程中可以打开串口中断和定时器中断,初始化成功之后在主程序中使用==EA=1== 开启总中断,使能程序的中断过程避免由于中断导致初始化失败引发的程序假死<br>串口部分的基本部分可以参考程序的注释部分的内容, 程序附带文件夹里面包括了其他的串口的使用介绍例程,部分介绍了 uart 的缓冲区扩充机制,以及一个环形缓冲区的结构设计,以及一个使用 uart 的 modbus 协议的实现,之后可能会用到的内容,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------</span></span><br><span class="line"><span class="comment">                    串口初始化</span></span><br><span class="line"><span class="comment">------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitUART</span>  <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    SCON  = <span class="number">0x50</span>;        <span class="comment">// SCON: 模式 1, 8-bit UART, 使能接收</span></span><br><span class="line">    TMOD &amp;= <span class="number">0x0F</span>;               <span class="comment">//清零T1的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x20</span>;               <span class="comment">// TMOD: timer 1, mode 2, 8-bit 重装</span></span><br><span class="line">    TH1   = <span class="number">0xF3</span>;               <span class="comment">// TH1:  重装值 2400 波特率 晶振 11.0592MHz</span></span><br><span class="line">    ET1  =<span class="number">0</span> ;                    <span class="comment">//禁止T1中断</span></span><br><span class="line">    ES    = <span class="number">1</span>;                  <span class="comment">//打开串口中断</span></span><br><span class="line">    <span class="comment">//EA    = 1;                  //打开总中断</span></span><br><span class="line">    TR1   = <span class="number">1</span>;                  <span class="comment">// TR1:  timer 1 打开</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------</span></span><br><span class="line"><span class="comment">                    发送一个字节</span></span><br><span class="line"><span class="comment">------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uartSendByte</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> dat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SBUF = dat;</span><br><span class="line">    <span class="comment">//while(!TI) ;</span></span><br><span class="line">    <span class="comment">// 延时一定时间 保证发送成功 如果使用上面的循环 等待硬件TI触发 很容易造成程序卡死,建议设定成</span></span><br><span class="line">    DelayMs(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    TI = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------------------------------------------------</span></span><br><span class="line"><span class="comment">                    发送一个字符串</span></span><br><span class="line"><span class="comment">------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendStr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">while</span>(*s!=<span class="string">'\0'</span>)<span class="comment">// \0 表示字符串结束标志，通过检测是否字符串末尾</span></span><br><span class="line">  &#123;</span><br><span class="line">true  uartSendByte(*s);</span><br><span class="line">true  s++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-52-串口输出部分"><a href="#1-52-串口输出部分" class="headerlink" title="1.52 串口输出部分"></a>1.52 串口输出部分</h4><p>串口缓冲器 SBUF 只有一个字节,每次只能存储一个字节, 每次会将接收到的数据存放在 SBUF 中,如果将数据存放在 SBUF 中之后就能够实现输出字节了,下面两个函数 是实现发送一个三位的温度值的实现方法,即将每一位输出出去,显示在串口部分,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送 整型数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendNum</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">true<span class="comment">// xdata 关键字会将数据存在 扩展RAM中 避免主data数据空间不够导致的出错</span></span><br><span class="line">    xdata <span class="keyword">unsigned</span> <span class="keyword">char</span> b1=<span class="number">0</span>;</span><br><span class="line">truexdata <span class="keyword">unsigned</span> <span class="keyword">char</span> s1=<span class="number">0</span>;</span><br><span class="line">truexdata <span class="keyword">unsigned</span> <span class="keyword">char</span> g1=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(num&lt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    uartSendByte(<span class="number">0x2D</span>);  <span class="comment">//发送负号 -</span></span><br><span class="line">    num=-num;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  b1=(num/<span class="number">100</span>)+<span class="number">0x30</span>;</span><br><span class="line">  s1=(num%<span class="number">100</span>)/<span class="number">10</span>+<span class="number">0x30</span>;</span><br><span class="line">  g1=num%<span class="number">10</span>+<span class="number">0x30</span>;</span><br><span class="line"></span><br><span class="line">true<span class="comment">// 将数据直接发送回去  然后 结束</span></span><br><span class="line">trueuartSendByte(b1);</span><br><span class="line">trueuartSendByte(s1);</span><br><span class="line">trueuartSendByte(g1);</span><br><span class="line">trueSendStr(<span class="string">" "</span>); <span class="comment">// 发送空格分割</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 float 数据  3.1f</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendNumF</span><span class="params">(<span class="keyword">float</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">trueuint i_num = <span class="number">0</span>;</span><br><span class="line">trueuint f_num = <span class="number">0.0f</span>;</span><br><span class="line">truei_num = (<span class="keyword">int</span>)num;<span class="comment">//获取整型</span></span><br><span class="line">truef_num = <span class="number">10.0f</span>*(num-i_num);<span class="comment">//获取小数点的值</span></span><br><span class="line"></span><br><span class="line">trueSendNum(i_num);</span><br><span class="line">trueuartSendByte(<span class="number">0x2E</span>); <span class="comment">// 发送给一个点号</span></span><br><span class="line">trueSendNum(f_num);</span><br><span class="line"></span><br><span class="line">trueSendStr(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-53-串口服务函数"><a href="#1-53-串口服务函数" class="headerlink" title="1.53 串口服务函数"></a>1.53 串口服务函数</h4><p>串口中断使用的是中断 4 每次接收到数据之后触发中断,进入中断服务函数中每次接受到数据之后会将串口接收灯置位, 亮灭一次,同时将接受到的字符返回到显示界面, 然后将接收到的字符使用串口处理函数进行处理,处理函数会进行累加,记录当前字符的数目, 设定的存储区域位 5 位的数组,每次会循环覆盖掉之前的数据,当接收满了 5 个字符之后能够将 LED3 电量,表示接受到了一条指令,目前程序下载之后可能需要手动输入空字符等到灯亮起来之后再输入完整指令 目前只支持==T0350==格式的指令,程序会判断第一个字符是否为 T, 如果满足则会将数组的==RE_STR==的 RE_STR[2],RE_STR[3]里面的数据组合成温度值, 表示设定的温度,其余部分暂时没有考虑添加,之后可能会进行处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUM_b 5<span class="comment">// 设定存在值就5个字符</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> xdata RE_STR[MAX_NUM_b]; <span class="comment">//存储显示值的全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------</span></span><br><span class="line"><span class="comment">                     串口中断程序</span></span><br><span class="line"><span class="comment">------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_SER</span> <span class="params">(<span class="keyword">void</span>)</span> interrupt 4 <span class="comment">//串行中断服务程序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> Temp;          <span class="comment">//定义临时变量</span></span><br><span class="line">    <span class="keyword">if</span>(RI)                        <span class="comment">//判断是接收中断产生</span></span><br><span class="line">    &#123;</span><br><span class="line">      RI=<span class="number">0</span>;                      <span class="comment">//标志位清零</span></span><br><span class="line">      Temp=SBUF;                 <span class="comment">//读入缓冲区的值</span></span><br><span class="line">      LED2 = !LED2; <span class="comment">// 亮灭串口接收灯</span></span><br><span class="line">      SBUF=Temp;                 <span class="comment">//把接收到的值 再发回电脑端</span></span><br><span class="line">      handleRE(Temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(TI)                        <span class="comment">//如果是发送标志位，清零</span></span><br><span class="line">    &#123;</span><br><span class="line">        TI=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理接收串口事件  每次接收会 出发函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleRE</span><span class="params">(uchar t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> uchar count_r=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 每次接收数据加1</span></span><br><span class="line">    <span class="comment">// 如果不是 结束符号</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        RE_STR[count_r] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    count_r++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 灯灭 每次程序将灯灭掉</span></span><br><span class="line">    LED3 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(count_r == MAX_NUM_b)</span><br><span class="line">    &#123;</span><br><span class="line">        count_r = <span class="number">0</span>;</span><br><span class="line">        SendStr(<span class="string">"!"</span>);</span><br><span class="line"></span><br><span class="line">truetrue<span class="comment">// 如果首位是T 则  后三位标识 温度 x10</span></span><br><span class="line">truetrue<span class="keyword">if</span>(RE_STR[<span class="number">0</span>] == <span class="string">'t'</span> || RE_STR[<span class="number">0</span>] == <span class="string">'T'</span>)</span><br><span class="line">truetrue&#123;</span><br><span class="line">truetruetruetemp_set = (RE_STR[<span class="number">2</span>]<span class="number">-0x30</span>)*<span class="number">10</span>+(RE_STR[<span class="number">3</span>]<span class="number">-0x30</span>);</span><br><span class="line">truetruetrueSendStr(<span class="string">"T:"</span>);</span><br><span class="line">truetruetrueSendNum(temp_set);</span><br><span class="line">truetrue&#125;</span><br><span class="line">        LED3 = <span class="number">0</span>; <span class="comment">// 灯亮</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-AD-DA-模块"><a href="#1-6-AD-DA-模块" class="headerlink" title="1.6 AD-DA 模块"></a>1.6 AD-DA 模块</h3><p>AD-DA 转换模块可以参考附件文件夹 pdf 中 AD 模块内容, 实际过程中 AD 采集模块 并没有用到,温度采集的部分使用的是==P36==接口, 使用 在 ADC.c 中进行了定义 但是程序中使用了 DA 模块实现了温度的输出值, 此处可以更改温度读取 设定,改用 AD 采集获取信号信号,目前使用的是直接读取结果,</p><p><img src="https://i.loli.net/2019/01/05/5c301c0bbf151.jpg" alt="AD-DA模块"></p><h4 id="1-61-I2C-接口实现"><a href="#1-61-I2C-接口实现" class="headerlink" title="1.61 I2C 接口实现"></a>1.61 I2C 接口实现</h4><p>温度传感器是是 DS18b20 的格式, 器件的初始化 使用 I2C 协议进行操作,参考程序内部的==i2c.c==函数实现,内容比较多,可以直接区程序里面进行参考,数字 I2c 的实现 都差不多,注意时序就好, I2C 的接口需要接到==P20 #F44336==,==P21 #F44336==接口在板上 J8 接口处,使用 I2c 可以控制 系统板上的 4 路 AD 采集以及一路 AD 输出, 函数头定义了 I2C 器件地址, 可以参考附件中介绍,完成数据采集过程.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sbit SDA=P2^<span class="number">1</span>;</span><br><span class="line">sbit SCL=P2^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AddWr 0x90   <span class="comment">//写数据地址</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AddRd 0x91   <span class="comment">//读数据地址</span></span></span><br></pre></td></tr></table></figure><h4 id="1-62-AD-DA-输出实现"><a href="#1-62-AD-DA-输出实现" class="headerlink" title="1.62 AD-DA 输出实现"></a>1.62 AD-DA 输出实现</h4><p>AD 采集函数可以实现 4 路 AD 采集过程,DA 输出只支持 DA 输出, 将==J33==的接口短接之后可以使用 DA 输出 的电压值控制小灯==LED9== 的亮亮度,此小灯是输出到了阴极,如果输出 5V 则小灯是灭的 输出 0 则会亮起来,但是 LED 存在当输出的两端电压差值在 1.5V 以内 小灯则不会亮,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------------------------------------------------</span></span><br><span class="line"><span class="comment">             读AD转值程序</span></span><br><span class="line"><span class="comment">输入参数 Chl 表示需要转换的通道，范围从0-3</span></span><br><span class="line"><span class="comment">返回值范围0-255</span></span><br><span class="line"><span class="comment">------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">ReadADC</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> Chl)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> Val;</span><br><span class="line">   Start_I2c();               <span class="comment">//启动总线</span></span><br><span class="line">   SendByte(AddWr);             <span class="comment">//发送器件地址</span></span><br><span class="line">     <span class="keyword">if</span>(ack==<span class="number">0</span>)<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">   SendByte(<span class="number">0x40</span>|Chl);            <span class="comment">//发送器件子地址</span></span><br><span class="line">     <span class="keyword">if</span>(ack==<span class="number">0</span>)<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">   Start_I2c();</span><br><span class="line">   SendByte(AddWr+<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span>(ack==<span class="number">0</span>)<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">   Val=RcvByte();</span><br><span class="line">   NoAck_I2c();                 <span class="comment">//发送非应位</span></span><br><span class="line">   Stop_I2c();                  <span class="comment">//结束总线</span></span><br><span class="line">  <span class="keyword">return</span>(Val);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/*------------------------------------------------</span></span><br><span class="line"><span class="comment">               写入DA转换数值</span></span><br><span class="line"><span class="comment">输入参数：dat 表示需要转换的DA数值，范围是0-255</span></span><br><span class="line"><span class="comment">------------------------------------------------*/</span></span><br><span class="line"><span class="function">bit <span class="title">WriteDAC</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> dat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Start_I2c();               <span class="comment">//启动总线</span></span><br><span class="line">   SendByte(AddWr);             <span class="comment">//发送器件地址</span></span><br><span class="line">     <span class="keyword">if</span>(ack==<span class="number">0</span>)<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">   SendByte(<span class="number">0x40</span>);            <span class="comment">//发送器件子地址</span></span><br><span class="line">     <span class="keyword">if</span>(ack==<span class="number">0</span>)<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">   SendByte(dat);             <span class="comment">//发送数据</span></span><br><span class="line">     <span class="keyword">if</span>(ack==<span class="number">0</span>)<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">   Stop_I2c();</span><br><span class="line"></span><br><span class="line">true<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-62-PI-控制以及输出"><a href="#1-62-PI-控制以及输出" class="headerlink" title="1.62 PI 控制以及输出"></a>1.62 PI 控制以及输出</h4><p>主循环过程中设置了读取温度标志位后,会进去温度读取过程,, 然后根据显示温度,串口输出温度,之后进行 PI 运算, 最终显示输出值之后之后将电压输出到 电压中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ReadTempFlag==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ReadTempFlag=<span class="number">0</span>;</span><br><span class="line">            temp=ReadTemperature(); <span class="comment">//读取温度</span></span><br><span class="line">            <span class="comment">// num2str(101);</span></span><br><span class="line"></span><br><span class="line">            t_0 = showTemp(temp);   <span class="comment">// 显示温度</span></span><br><span class="line">            SendNum(t_0);           <span class="comment">// 串口输出温度</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//===================================</span></span><br><span class="line">            <span class="comment">// //PID</span></span><br><span class="line">            ek = (temp_set-t_0);</span><br><span class="line">            ei += ek;</span><br><span class="line"></span><br><span class="line">            tp = ek*P;</span><br><span class="line"></span><br><span class="line">            ti = ei*I;</span><br><span class="line"></span><br><span class="line">            out_pi = tp+ti;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//===================================</span></span><br><span class="line">            <span class="comment">//out_pi= out_pi;</span></span><br><span class="line">            showOuts(out_pi);</span><br><span class="line">            out_pi = (out_pi&gt;<span class="number">255</span>?<span class="number">255</span>:out_pi);</span><br><span class="line">            out_pi = (out_pi&lt;<span class="number">0</span>?<span class="number">0</span>:out_pi);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将控制结果输出到灯光的控制中</span></span><br><span class="line">            WriteDAC(out_pi);<span class="comment">// 最后总控制输出电压</span></span><br><span class="line">        &#125;<span class="comment">// end of readTempFlag</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 51 </tag>
            
            <tag> C </tag>
            
            <tag> PID </tag>
            
            <tag> UART </tag>
            
            <tag> 水温控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>待写博文-ToDoList</title>
      <link href="/2020/04-05/ToDO.html"/>
      <url>/2020/04-05/ToDO.html</url>
      
        <content type="html"><![CDATA[<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>有时候会有一些想写的点， 但是当时或者其他有些事情或者时间上无法写， 这里列下来 todo， 等待有时间的时候去写。</p><h3 id="待写博文"><a href="#待写博文" class="headerlink" title="待写博文"></a>待写博文</h3><ul><li style="list-style: none"><input type="checkbox"> latex 标点符号</li><li style="list-style: none"><input type="checkbox" checked> latex 列表缩进问题</li><li style="list-style: none"><input type="checkbox" checked> latex 排版问题</li><li style="list-style: none"><input type="checkbox"> Opencv 系列</li><li style="list-style: none"><input type="checkbox"> </li></ul><h3 id="待更新"><a href="#待更新" class="headerlink" title="待更新"></a>待更新</h3><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> TODO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TODO </tag>
            
            <tag> blog，hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>latex 标点符号</title>
      <link href="/2020/04-05/latex-punctuation.html"/>
      <url>/2020/04-05/latex-punctuation.html</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> home </tag>
            
            <tag> shopping </tag>
            
            <tag> washing machine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>latex-列表环境</title>
      <link href="/2020/03-29/latex-list.html"/>
      <url>/2020/03-29/latex-list.html</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>latex 主要有三种列表环境,进行罗列的实现,</p><ul><li>无序列表 – itemize</li><li>有序列表 – enumerate</li><li>描述列表 – description</li></ul><p>本文进行了一一介绍和演示, 同时添加了嵌套列表环境和自定义列表环境的说明</p><h2 id="latex-列表环境"><a href="#latex-列表环境" class="headerlink" title="latex 列表环境"></a>latex 列表环境</h2><p>latex 的列表环境都是使用例如如下的形式进行的罗列,</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;itemize&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> 条目1</span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> 条目2</span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> 条目3</span><br><span class="line">    <span class="tag">\<span class="name">item</span></span>  .....</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;itemize&#125;</span></span></span><br></pre></td></tr></table></figure><h3 id="无序列表-–itemize-环境"><a href="#无序列表-–itemize-环境" class="headerlink" title="无序列表 –itemize 环境"></a>无序列表 –itemize 环境</h3><p>最基本的无序列表的形势</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">无序列表环境:</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;itemize&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> 条目1</span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> 条目2</span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> 条目3</span><br><span class="line">    <span class="tag">\<span class="name">item</span></span>  .....</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;itemize&#125;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/03/29/X7GRe3FdjYvm2cr.png" alt="无序列表环境"></p><p>默认的前缀是实心的 黑色原点, 但是我们可以在 <code>\item[]</code> 中进行自定义符号, 一般来说, 想要的符号都能够进行显示</p><p>对于列表中没有指定符号的项目, 会使用默认 的符号</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">无序列表环境--自定义符号:</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;itemize&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">item</span><span class="string">[-]</span></span> 条目1</span><br><span class="line">    <span class="tag">\<span class="name">item</span><span class="string">[+]</span></span> 条目2</span><br><span class="line">    <span class="tag">\<span class="name">item</span><span class="string">[x]</span></span> 条目3</span><br><span class="line">    <span class="tag">\<span class="name">item</span><span class="string">[/]</span></span> 条目4</span><br><span class="line">    <span class="tag">\<span class="name">item</span><span class="string">[*]</span></span> 条目5</span><br><span class="line">    <span class="tag">\<span class="name">item</span><span class="string">[a]</span></span> 条目6</span><br><span class="line">    <span class="tag">\<span class="name">item</span><span class="string">[$\circ$]</span></span> 条目7</span><br><span class="line">    <span class="tag">\<span class="name">item</span><span class="string">[$\bigotimes$]</span></span> 条目8</span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> .....</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;itemize&#125;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/03/29/8y6Ba1QC95AYNjf.png" alt="自定义符号--无序列表"></p><h3 id="有序列表-–-enumerate-环境"><a href="#有序列表-–-enumerate-环境" class="headerlink" title="有序列表 – enumerate 环境"></a>有序列表 – enumerate 环境</h3><p>要想使用 有序列表, 需要在导言区 引入 <code>\usepackage{enumerate}</code></p><p>有序列表也是 中间对齐的样式.<br>首先介绍最为基本的有序列表的形式, 默认 使用 数字加. 的形势 如 1.</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">有序列表-- 默认:</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;enumerate&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> 条目1</span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> 条目2</span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> 条目3</span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> .....</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;enumerate&#125;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/03/29/Wt3E7ixpoUPOYBs.png" alt="有序列表默认"></p><p>实际上, 有序列表可以使用 1, A,a,I,i 标记开始有序的开始, 分别对应, 数字, 大小写字母表和大小写罗马数字</p><p>但是其他的字符 只是默认无含义, 当作序号开始的修饰, 既是同样是序列中的字符, 比如 B,b 之类的 ,</p><p>同样的, 如果有两个序号控制字符, 系统会以后面的字符作为控制, 而且, 前面的也会被替换掉, 所以这如果有重复的字符一定要注意</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">有序列表-- 指定样式:</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;enumerate&#125;</span><span class="string">[test(2,B,b,) 1, A, a, i, I,]</span></span></span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> 条目1</span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> 条目2</span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> 条目3</span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> .....</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;enumerate&#125;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/03/29/dYtp5EPnSCzVgb3.png" alt="指定样式"></p><p>同样的, 有序列表的默认是按照等级的, 最低的是直接默认的 1. 其次是 <code>\begin{enumerate}[1,]</code> 后面的序列控制, 最后面的是在单个项目之前的指定符号, <code>\item[*]</code> 如果存在的话, 会覆盖相应的符号, 且, 编号会漏过相应的项目.</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;enumerate&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> 条目1</span><br><span class="line">    <span class="tag">\<span class="name">item</span><span class="string">[*]</span></span> 条目2</span><br><span class="line">    <span class="tag">\<span class="name">item</span><span class="string">[-]</span></span> 条目3</span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> .....</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;enumerate&#125;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/03/29/MbR9OeDIUKq5ks1.png" alt="漏号示意图"></p><h3 id="描述列表-–-description"><a href="#描述列表-–-description" class="headerlink" title="描述列表 – description"></a>描述列表 – description</h3><p>此列表主要用于罗列之后进行解释, 不会有编号 符号, 但是会将括号内的次进行加粗加黑处理 如果当前 item 不存在 描述词, 则 默认显示,如 条目 4 但是样式会比较奇怪,</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;description&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">item</span><span class="string">[条目11]</span></span></span><br><span class="line">    条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1</span><br><span class="line"></span><br><span class="line">    <span class="tag">\<span class="name">item</span><span class="string">[条目22]</span></span></span><br><span class="line">    条目2..</span><br><span class="line"></span><br><span class="line">    <span class="tag">\<span class="name">item</span><span class="string">[条目22]</span></span></span><br><span class="line">    条目3</span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> 条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;description&#125;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/03/29/SCFa6rUVclO32Zt.png" alt="描述列表"></p><h3 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h3><p>latex 不仅可以单独使用, 恶意是可以进行嵌套使用的,<br>嵌套列表</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;description&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">item</span><span class="string">[条目11]</span></span></span><br><span class="line">    条目1条目1条目1条目1条目1条目1条目1</span><br><span class="line"></span><br><span class="line">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;enumerate&#125;</span><span class="string">[A.]</span></span></span><br><span class="line">        <span class="tag">\<span class="name">item</span></span> 条目1     条目1条目1条目1条目1</span><br><span class="line"></span><br><span class="line">        <span class="tag">\<span class="name">begin</span><span class="string">&#123;itemize&#125;</span></span></span><br><span class="line">            <span class="tag">\<span class="name">item</span></span> 条目1</span><br><span class="line">            <span class="tag">\<span class="name">item</span></span> 条目2</span><br><span class="line">            <span class="tag">\<span class="name">item</span></span> 条目3</span><br><span class="line">            <span class="tag">\<span class="name">item</span></span>  .....</span><br><span class="line">        <span class="tag">\<span class="name">end</span><span class="string">&#123;itemize&#125;</span></span></span><br><span class="line"></span><br><span class="line">        <span class="tag">\<span class="name">item</span></span> 条目2</span><br><span class="line">        <span class="tag">\<span class="name">item</span></span> 条目3</span><br><span class="line">        <span class="tag">\<span class="name">item</span></span> .....</span><br><span class="line">    <span class="tag">\<span class="name">end</span><span class="string">&#123;enumerate&#125;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="tag">\<span class="name">item</span><span class="string">[条目22]</span></span></span><br><span class="line">    条目2..</span><br><span class="line"></span><br><span class="line">    <span class="tag">\<span class="name">item</span><span class="string">[条目22]</span></span></span><br><span class="line">    条目3</span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> 条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;description&#125;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/03/29/T7gzLs1q86douZC.png" alt="嵌套列表"></p><h2 id="自定义环境"><a href="#自定义环境" class="headerlink" title="自定义环境"></a>自定义环境</h2><p>借用参考链接 1 中的图, 可以看到各种命令的说明, 以及 latex 进行排版布局的说明</p><blockquote><ol><li>垂直间距<br>topsep       列表环境与上文之间的距离<br>parsep       条目里面段落之间的距离<br>itemsep       条目之间的距离<br>partopsep     条目与下面段落的距离</li><li>水平间距<br>leftmargin       列表环境左边的空白长度<br>rightmargin       列表环境右边的空白长度<br>labelsep       标号与列表环境左侧的距离<br>itemindent       条目的缩进距离<br>labelwidth       标号的宽度<br>listparindent       条目下面段落的缩进距离</li></ol></blockquote><p><img src="https://i.loli.net/2020/03/29/IJMkEc2YN8Wlnav.png" alt="latex item 排版"></p><p>同样的, 我们在描述列表中能够看到缩进问题, 导致的显示比较难看, 这里我们可以参考 链接 2 给出的自定义命令的方式进行解决</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;blindtext&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\deflabel&#125;</span><span class="string">[1]</span><span class="string">&#123;\bf #1\hfill&#125;</span></span><span class="comment">%</span></span><br><span class="line"><span class="tag">\<span class="name">newenvironment</span><span class="string">&#123;newlist&#125;</span><span class="string">[1]</span></span><span class="comment">%</span></span><br><span class="line">&#123;<span class="tag">\<span class="name">begin</span><span class="string">&#123;list&#125;</span><span class="string">&#123;&#125;</span><span class="string">&#123;\settowidth&#123;\labelwidth&#125;</span><span class="string">&#123;\bf #1&#125;</span></span><span class="comment">%</span></span><br><span class="line">            <span class="tag">\<span class="name">setlength</span><span class="string">&#123;\leftmargin&#125;</span><span class="string">&#123;\labelwidth&#125;</span></span><span class="comment">%</span></span><br><span class="line">            <span class="tag">\<span class="name">addtolength</span><span class="string">&#123;\leftmargin&#125;</span><span class="string">&#123;\labelsep&#125;</span></span><span class="comment">%</span></span><br><span class="line">            <span class="tag">\<span class="name">renewcommand</span><span class="string">&#123;\makelabel&#125;</span><span class="string">&#123;\deflabel&#125;</span></span>&#125;&#125;<span class="comment">%</span></span><br><span class="line">&#123;<span class="tag">\<span class="name">end</span><span class="string">&#123;list&#125;</span></span>&#125;</span><br></pre></td></tr></table></figure><p>在导言区设定了新的命令, 我们在文档中直接进行使用就行了, 注意使用的是偶 在 <code>\begin{newlist}</code> 后面的条目最好填上最长的条目, 这样后面每个项目都缩进相应的尺寸, 达到显示美观的结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;newlist&#125;</span><span class="string">&#123;条目11条条目11条&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">item</span><span class="string">[条目11条条目11条]</span></span></span><br><span class="line">    条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1条目1</span><br><span class="line"></span><br><span class="line">    <span class="tag">\<span class="name">item</span><span class="string">[条目22]</span></span></span><br><span class="line">    条目2..</span><br><span class="line"></span><br><span class="line">    <span class="tag">\<span class="name">item</span><span class="string">[条目22]</span></span></span><br><span class="line">    条目3</span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> 条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4条目4</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;newlist&#125;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/03/29/mBr8dYsfh2Dkxiq.png" alt="自定义列表"></p><a id="more"></a><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>最终附上最后的在线工程 <a href="https://www.overleaf.com/read/qsbrgsmcdsxp" target="_blank" rel="noopener">OverLeaf latex-list.tex</a></p><p>可以在 latex-list.tex 看到相应的演示</p><p><img src="./images/1585495675211.png" alt="总体工程截图"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/robert_chen1988/article/details/83179571" target="_blank" rel="noopener">latex 使用 enumitem 宏包调整 enumerate 或 itemize 的上下左右缩进间距</a></li><li><a href="https://zhuanlan.zhihu.com/p/27966371" target="_blank" rel="noopener">description 环境悬挂缩进</a></li><li><a href="https://blog.xulihang.me/use-list-in-latex/" target="_blank" rel="noopener">LaTeX 中列表的使用</a></li><li><a href="https://blog.csdn.net/miracle_fans/article/details/78255223" target="_blank" rel="noopener">Latex-条目、编号、描述</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
            <tag> template </tag>
            
            <tag> learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sword-00-Init</title>
      <link href="/2020/03-28/Sword-00-Init.html"/>
      <url>/2020/03-28/Sword-00-Init.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="1b123c00909231f1d627da4dc6a3fcf244a658652edd2cb9f85e237b09e8b949">2e66cbae239dc21f6628e1e13f86aa883b67bdcd4d9be59c2093f14b39709496f934f0b67c26281d1467840eae3e2b501093c4c891cb468fbb24e379072c530b22479686caefd365e12ecb018872a19dc243a1e919b705fda16df9f89dd34337cbd13a73a3e793e927cc4bbc77596ca3f737db4f367a7cf3b54b3846f561f09d40853c6b5294ca8eacc75548e69d010aede51cfd99e42e9fbdb1358cb4218757ad9ba8c9fc57856b4b1e02efcd0d8d8d8d287ba64d2313b487da5cbe8f2998a75cc5dca2630640dfd1f0953a68f0d42e649dc5765b137693127846c7cd0236e1957b9624ab31c967083a7d13655c399b806c08d7bc1652d7b5ea72ca77a791daab6385d1d74137b0091053f0e23550da47c0053b18cd7af9b133931a13289394452993a3b9faf444df9d74d9f1bd112df963df7d7364108ede995eac434469c3144173575f25b166756fe84375f81802a6f4484a9857a0dcd5b8890655a63c142484c0429875ec1f15df41b221f60ba59bb9e646a693eb93f26c0d4e36b64bb61dfa1c9a0b5c2a280caabda70469485e601741084909ff9cf4436df65882a6750e9aac014f2662f1f5b04e72aa1c38973377cb205af9eca7d7b10e59b62b4e5872736e86b93cba9f257980005421785dd2f33d40c61e8b660cd402e70ec3a5d2154c9b55ea6cbf070a714e9aa59fd049fa8a06591ea17d1c14bd9838ce4732e585db0b9d24900c9fd337aa6e91efbaaf04bb7bc3baa514a424ccca0b6c0544c724043367fc72f7593d5849ad62b94016c9cca6a24dd65fdfaa963fcc47764f37932f6c7e696495d8fd4c078693d8855e41d6fe0279859859dfa7b268fc5f834c199d04d56a0a9f67f5fe2435b8b0dea59e3e230a43461a046f6d6b05c2a4d715ed8c91cbb7f795166d5bb1bf3eea3f5cca0b87558815135b7920b87ad0e1257db79604bd113edaa0ae6d1a943862ac9f20a7da30d91debe6eeea141fc60146adbba574023039f7f26c6878ac696cb96b21ee344ed63a555d2fc5be8b2d54443f11002d014f82edc4dfb11161abe73f910faadf9c13df42f27657d731f68d1af5a6ab9422e969060748e450e626907d2ed6472af2613ec55e4ec8d0b8e4148040dd43b95c81d34c0ad5bc926b3348e52e19a945f54dc79b822378038d8ae1a012a23c5fe010d67b245ca9f48af778d034337b4d111646f1eb5682685cd5dc8d82139640b18f0b5c36417509d891557375b153d449e30805f27329997af197cec9c0a1066ffe273c235d526c9e332a061223e4f749018731d8fc9d20f93800e382515f8e532df81d5e972eefe61d8f636581e7482d5fc1a56b6d57aed5a6e035c683a6332082e6f4c36a34f54188bb0dadc39aa1ec907cf93a25b80758ad6fce9ec943ff7c7a4d337c062ed65f080020f1f501c41d07593dcce04053026865efbb7daeee8de46b7da9667f97938d9effe3f3e34daa976cf64c7d4b101c6c443f95444d96d5df65950d254c065f6206aa0f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> encrypt </tag>
            
            <tag> sword </tag>
            
            <tag> web </tag>
            
            <tag> project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器ConfigData</title>
      <link href="/2020/03-27/ConfigData.html"/>
      <url>/2020/03-27/ConfigData.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="1f127a5e77151ea10d9d89435c2c89fa39715f58c5d53f13b9e5689204e2d37a">56a5ba23e56af2d98fc14b1f660c9d7a90286841863d653b9b4d19702188bd037675d60f8818e134116dfce2676e4d6c5bcbcd3ea6328da6cc0d8c65c174085a0e29e94b314d11337f93441dc4c4896f195edb870ffb3ad84403dc9e4eb606c319304aee15479e858d6f13ac3176bb34f1b1d3a54a63d065417dfed10bb16c293480697f82f980cd37ce89c2a45f03e797969df6a868daf579e88b7ccac9bde24a767b30c7d9c1950b08ae8f3152abeab2171e2558597448edee5bf905877cbfe9884f9b460762d7c2dde660a6c62c963ad3d709cfe58634650f43a0b45d52e1029c8e8a393f944ec1dd36d448e07d6d39d5d3d939cda29a78698bc50806b643c04d0e6611c63dc52ffb46b07eb423686e63c091ab3cd2913ec1c7ddd7060ae449c3f7011d220b7c11b2edb26554bd8ecf0d1d9cbd8c04df648c7e2df58bda2fdfa93829acfd98dd102c3b50c1c40c8a1eebd1632dd4d64dc1f65c68ba54399b4f35c3ef25d1842caac0551c297c1459db72d090dca53f75a37cb0943634b8623f365035e229791a93fe1c8dad9b951e5102bcbb3b22a2feb65089ecb5bfa72a70127a1446a58b85210e08e72311e19d798a25e8a8ed3f4ce0101696bcae4026abd85d2b187b812fccebfc29cabf4f2f4db76cad132816fd07363dcb3457cb6ba1db179a563ae175d6ae5a6a0bd64a37e94d4ade69255600336b13207aea3403af987dd9d7fa61ad5ccca631d8258aa88c444984e7dda8dfa81fa40d1964e6590a51178ddcfb54a3feb4e3a37d5fe9935520e0dbffaf66dc2467d7e239b72d246a293254a30f6cb601412aebf9412232f8a81d5876e07307a6ed3666e335a44d8de61245f42d2bd63b4b8a684f8818ad4be4b3961ce9d6ff0d283f6a92e0bfe0eeeb346cf46b433432f08642c9419fd189b903eeea369657330a9bcfcbd4e9e2808314c4843ae8e37b6e7426cb47911130a2a18b64f24826b23f75e76cecb1476ec24cc1d854ed8f295eb706a6cd5138dbaf95244e9a5400da63f3c5845354b4c58c6f1cbb0117c2459c784e3af8bf1b125bb1ef6807c4101f9618fa88e2e23f0899d2105ca00f9e07cd5bb4a10179c84022544c0f00be53d9b98dcab6a2af0d8b8e01c5e7aa6d201e5926d6baf7fb48fa0e586e48eb523262bcadbd07bcd83e9d842cf0036179f66a241268bf3cc085699eac33b075348935d6f598b05b60721971292b620d12ba932dfe61b4e7481a48b22020de0a63b9f069b400d18ed729c3110308c582ef2b63d63ff7b5ca5ee56a3435db1c40631c09c42dbfcaf85fd6afeceb5821a9672187321cbeb158c97ca68f10a566be2b9a432a49d37bda4b359e0231ea3265af0d0ccf0c57d613e2eea65107332a7b5b03711520a9a3751bd10eab919036e90e6248a2901a46eb7194e0dfbe0a679087355405fecf314b01f0f301934e68cabcf890d7a7c75fc069bd9cc4b3aea42e146e3480f673a7b7f3288aa23fdac44116a8386688141d69e485f04a724decfb1facb6abddf42c79d0e13100d5b478c77340037f38398b2353e801f10389b67ea4cff7050ae92a69c1477f99250f46a17ac8c4fbca23e804c2f4a83febf1e3a91f081e0e10959277e65c7499c6197f4b0286332f0d25d0b2452c7dea045fd3c68166a0ffc22660b3e28eb4d16059bb97937691a751e79f5e4d0a586ee10df75a55c02b0d32a610a16fc702c4bca3dc04b59d6bd5f3390327b5a5d7c6922e6112ca05880b39118df431c99d4c4a2c08c691e404365abc332e905d6bad14a637dbd488e83bc784e5fb415cb5d41a9f956cb7be50019119aa7d34882f6d395301f83715988c5db7b5946c13c988123d943ad19ed82cb5fb7b9c43c5d665becb912162c42bd2098befffcb1ba5238d7b61885068385f2a8bb28851358bdc8fc4bc25567770a819aabd748c2a42cf9eee408eb95aafa3c5a852fb28051d30a509dbf7d6be5e1493d748bc2f3b46e24a0cd256ec2879f54278d1bc7d8f7a33ce751db45a5b9f2e4130c2961a0a359c33f091c3668a593a62af7367e1a5da27ca37287a045408daa9726654d1e328f459393efa0586864fb4724b4c0102a65dd9744e4f33b50565211e359979d2ca0cf9a3603812d15a87fbe2325d55c1d6c8adf71f8d48b082e02cb6b3e624721b29e619917c53de7cbfaadd40a1d77955f6e221d1ab18dcee62d72bf6ccffacdbc4da9c052c526f7d4d553f7711b9f45e9fe87e48d9270b610417512af570325bf6e98d9a187985b4d8cab8aed0a69c3be9a0e429880c55c6d428035af1464f6cc19992a8831ab2be7b5608ab02bc0f55daf6ab3fa60e94b70feb272864cb930da66da6110ff4bd8731bd84794148fdaa94ec566751eae8f282b4171d9d52a90b9fc4d7e1c3316bc8f99dfb2d2644dfb5f32af465376d438770def9abea580ca78ba1f2e375e66258b78c3b9ccda2b05bbc495dc184e52a6c0e7c1fa4c87f386dd8d4c94a947d433eb0ed1cf88e521340ef2704aa68577804f33aef03d79dd2b52f1b08ff26f1f14dc810af1a60eba6768732ad3243e252477819c5d1a0b80f6988c4888e68b5065ba86adff7ac92f5a0be8afdd31a730ec65fa2e613d5d1bf08689647e8583769b02f89b16d2acd0a3beae9eef7c64e71cddeb8cbdcb8596db2ff1556db30ee649c580e18efe21e04790b2c3b5743a27870bca3f8770c48039a2b1cee0d764a020ec7be5738bf829f14098eac95df38b09c5cc828f17f171901c3d33894fc9c1441c6fc7ce06e5e7a026258e94746d83b4f260bb43827548b7f36c6a98b83b960ef63af726a225236beafc88d9c7a0529259304390c0202e8956336be4e543fdeb0b99b96e6a2c5e74cb8b40684dd2cf7710a4e736e9600890cb6eeab3cf93ad972beb554a1d6f69875994e7bb6e073d229e82b65caa2fe86a78be042b4925d06bf47ae115de66e008c947d25f4a0f02c5fc2b5a1aa760dbebbcc57811ec8b3994654b5b75e83cde39a5cb99d03f471c2646135e2fa9e05427787ef5250b2711aa126e33095db12788499892c4a85777fc6b958a4eaf073f509c4815824146aca6657d475a81c064a4f63d08aac582f9f24ec37b0e314128712f50744decb8e92ed77c20c74d2570aefe404e70b45920d691a5d69f13e69ae629add49e1b73a0faa92658e6d6cf3674e7506f3126ac72876fb029e93621d2afb5690f421deb0aa9df031219eece4ac7da3f4613f409aa70ba62e016fc3c3b68504a42d2c08188a6f8a093cbf64120ef260a1c7f02d4e04f852dbddbfd23d2a6caa79a463b1f9f30498465475f5f23916d2d691d431d74a1745eb52707732280d49ac22bc9f20eec4ffede69628f6981ede91988fe013a60b2b1da4de156171ae37fadf44ad2c94d97b51860d72c46b03fa1f64faac48893a9101cd2e5b7478b89d724ca197d6359b7712b2074b944e669f1964657cc3255ed0ecccf0fe7aab353f109f3c7dd07e28aafe97b0b9365087fd6092543e48c087f30e930c92160d2aaed91c23c216121808102de5b3c3767632d229015f61cb7a918536702cc4269636cae41387a5028b387a8bc30b094d5f87d238aef177a4c31249633a694aeaa08753445e9d40a53df24c3898837eec40b58ffd42c7bf0b99810280ac7d53c5a4ba236b1eb6cac487f5da7250dfaff0e7d84dcde8910575800ae9130f94f0ea47b67a5aa42195c135cf78f1ddeff9d8f7efc8c55556b37014a2b80ecc0e70e14bb585892c08224fb4a635615d2bee505c856aa8ad1c7c1d6ec19fa3f3b078357e3b28d700a3a4573e266d48c86be6ae3e76efbf2f2806eefc260c3ae8763c480090cb85b1c457bee0a86d8ae9f882e6448ce95f65c48fc9d4967e1540579f45a667ffe4db71eccd0381725497368b0cab92156b6b162433f1222df88fd89e29cfbaaefdb3966887bb6b1ef8082e5f9235910f5cd67542ce8a335f7da53a0a8aac5f44c427e157172287a0316b3dff40bd81aa200e38e0ea9740f9a7bac28ce7c70fc5a50e9908781daef6fea7b7855d1df940bb7df8d70c752fc2dae86c373062c0aa73c8b12e4d1a3ef8d6b531362b7791116b74d8d69defb7619fae0666967514adb1f3b690e6ff85475ad533aaaafd0744621d04742fa380a6c6030b864778bf1df87c7f564c74c9ec13940f50255dd2d6c17d3594bcd9a0fd9d369df774aab91cde401959ef1aaf4e040778babe06da4363469cd44601fe714ffbc4fac6726e0b36bd5cf20a5447d9a524bba6c9078f208fd25e0a1792c6e989f01d0533e33083d924bd852e173f732a4271e2601efd065402020fa84bbb0d2fc648f854fb2683b16d6482848240b147af2f5ccd4023c08c89376ef20c99bb664077fcdd81298ba6db61533f060209e2060fddb6076970bfacf59eda3a4036d5a0cbc1043ea25abe8e39cf42db8035799dec91129a1818fa24de121fed1f65c1f572307371ae3237bdab8c84af76f54ae6f76cf201374f950b31071e3f0dba8da4e5db1b849d9d31d4bfc8825675f5a23e051d30841d5d165d6066ffee7b0be7c44d951ac50dd9d9a1b449ec249b1c7580d73eaab586625cdb2fd593a94927302954e14d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> encrypt </tag>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nCOV 数据简要分析 (0326)</title>
      <link href="/2020/03-26/COV-data-analysis.html"/>
      <url>/2020/03-26/COV-data-analysis.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>碰巧看到了数据上传, 正在跑数据的我想着要不拟合一下看看, 然后, 就做了两个小时, 这里做一个简单的记录过程, 后续可能做在线的 实时预测,,(坑…)</p><p>这个结果还是不能乱发的, 不然下一个谣言就是我了, 狗命要紧..</p><blockquote><p>时代的一粒尘,落到个人身上就是一座大山,偏偏我们生活在尘土飞扬的时代<br>—— 方方</p></blockquote><blockquote><p>灾难并不是死了两万人这样一件事，而是死了一个人这件事，发生了两万次<br>——-北野武</p></blockquote><p>这是 灾难给我的印象最深的两句话, 愿逝者安息, RIP</p><h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><p>目前数据很多, 我比较信赖的是 JHU 给的一个 全球的数据集 CSSEGISandData/COVID-19 数据[^covid-19], 也有更为详细的国内的数据集比如 DXY-COVID-19-Data[^dxy-cov], 相信之后也会有很多人进行数据分析,</p><p>我这边使用的是 <a href="https://github.com/CSSEGISandData/COVID-19/blob/master/archived_data/archived_time_series/time_series_19-covid-Confirmed_archived_0325.csv" target="_blank" rel="noopener">2020 年 3 月 25 日归档数据</a></p><h2 id="数据整理"><a href="#数据整理" class="headerlink" title="数据整理"></a>数据整理</h2><p>拿到数据之后是一个 <code>502x66</code>的数据, 包括全世界 省/州 62 天来的时间序列数据, 有着国家/省/经纬度 以及时间序列</p><p><img src="https://i.loli.net/2020/03/27/Wq6lvFxOEkCdRih.png" alt="部分数据示例"></p><p>我们不做具体的每个地区的分析, 这里直接纵向累加即可, 最终得到的数据是 <code>501x62</code> 尺寸的数据<br>进而累加之后 进行时间序列的绘制</p><p>这里为了顺手 所以这边分析暂时都是使用的 <code>MATLAB</code></p><p><img src="https://i.loli.net/2020/03/27/xqOKouBaCMRJZ3V.png" alt="自2020-1-22的全球确诊数据"></p><h2 id="数据拟合"><a href="#数据拟合" class="headerlink" title="数据拟合"></a>数据拟合</h2><p>这里避免一些数据问题, 我这单独标记出来了自 25 天的数据,<br>在这之前的数据只有中国的, 这里只取后面的数据进行分析,</p><p>第 25 天也就是 2020 年 2 月 16 日的数据,</p><p>这里使用了 MATLAB 的 cftool 进行曲线拟合[^cftool]</p><p>具体的使用方法见参考链接</p><p>这边使用的是二次的指数拟合</p><p>$$<br>y=a<em>e^{bx} + c</em>e^{dx}<br>$$</p><p>最终得到的结果如图</p><p><img src="https://i.loli.net/2020/03/27/OCf8gzrMRJ9WhnV.png" alt="2月16号之后拟合数据"></p><p>最终的到的拟合结果 三组结果都可以, 一般取第一组数据</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">General model Exp2:</span><br><span class="line">     f(x) = a*<span class="built_in">exp</span>(b*x) + c*<span class="built_in">exp</span>(d*x)</span><br><span class="line">Coefficients (with <span class="number">95</span><span class="comment">% confidence bounds):</span></span><br><span class="line"></span><br><span class="line">a =   <span class="number">7.173e+04</span>  (<span class="number">7.011e+04</span>, <span class="number">7.336e+04</span>)</span><br><span class="line">b =    <span class="number">0.007432</span>  (<span class="number">0.004555</span>, <span class="number">0.01031</span>)</span><br><span class="line">c =       <span class="number">654.7</span>  (<span class="number">443.6</span>, <span class="number">865.9</span>)</span><br><span class="line">d =      <span class="number">0.1647</span>  (<span class="number">0.1564</span>, <span class="number">0.1729</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Goodness of fit:</span><br><span class="line">  SSE: <span class="number">9.988e+07</span></span><br><span class="line">  R-square: <span class="number">0.9994</span></span><br><span class="line">  Adjusted R-square: <span class="number">0.9994</span></span><br><span class="line">  RMSE: <span class="number">1767</span></span><br></pre></td></tr></table></figure><p><strong>SSE</strong> :错误的平方和。此统计量测量响应的拟合值的偏差。接近 0 的值表示更好的匹配。<br><strong>R-square</strong> ：多重测定系数。数值的大小在 0 到 1 之间，越接近 1，表明方程的变量对 y 的解释能力越强。<br><strong>Adjusted R-square</strong> ：自由度调整 r 平方。接近 1 的值表示更好的匹配。当您向模型中添加附加系数时, 它通常是适合质量的最佳指示器。<br><strong>RMSE</strong> ：均方根误差。接近 0 的值表示更好的匹配。</p><p>这里这个数据拟合的已经很好了, 测试发现使用 <code>傅里叶多项式</code>3 次以上也能很好的拟合或者 高斯 4 次以上 都能很好的拟合, 拟合得到的相似程度已经很接近了, 如果单纯的数据分析已经足够了, 真的要去做的话还是要用医学模型进行分析, 这里只是简单的做以下</p><p><img src="https://i.loli.net/2020/03/27/9k4Tb6QPXLAoD7Y.png" alt="傅里叶三次曲线拟合"></p><h2 id="数据预测"><a href="#数据预测" class="headerlink" title="数据预测"></a>数据预测</h2><p>有了数据曲线之后能做的事情就很多了, 按照得到的曲线方程进行后续拟合, 然后看什么时候能够达到 100W 的数据大关</p><p><img src="https://i.loli.net/2020/03/27/uqjfgRvNewAUa1y.png" alt="确诊数据分析与预测"></p><p>如果单纯从数据的角度考虑, 数据拟合的是没有问题的 , 数据显示 大改会在 03/30 号 那天 数据会超过 100W 的情况,</p><p>数据仅供参考, 没有任何意义</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>这个结果没有任何意义, 实际上的模型要复杂很多, 我希望这个数据从明天就不再继续增加了, 然后 所有人都恢复健康,</p><p>希望数据不会成真, 但是我预感这个数据很可能会突破 100W, 应该在 4 月份的上旬或者 中旬左右,</p><p>愿逝者安息, 世间平平安安</p><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>最终附带 分析代码</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% COV data an</span></span><br><span class="line"></span><br><span class="line">[city,day] = <span class="built_in">size</span>(serial);</span><br><span class="line"></span><br><span class="line">time_sum = <span class="built_in">zeros</span>(<span class="number">1</span>,day);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:day</span><br><span class="line">   time_sum(<span class="number">1</span>,<span class="built_in">i</span>) = sum(serial(:,<span class="built_in">i</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(time_sum,<span class="string">'-*'</span>);</span><br><span class="line">days = <span class="number">1</span>:day;</span><br><span class="line">d = <span class="number">25</span>;</span><br><span class="line">l_days = <span class="number">1</span>:day-d;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:day-d</span><br><span class="line">   time_sum2(<span class="number">1</span>,<span class="built_in">i</span>) = sum(serial(:,<span class="built_in">i</span>+d));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">time_sum2 = time_sum2 - time_sum2(<span class="number">1</span>);</span><br><span class="line"><span class="comment">% 运行 2月16号之后的数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"></span><br><span class="line"><span class="comment">% 从 第25天的数据 也就是 02/16日开始</span></span><br><span class="line">init_day = datetime(<span class="number">2020</span>,<span class="number">02</span>,<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = init_day + l_days;</span><br><span class="line"><span class="built_in">plot</span>(t1,time_sum2,<span class="string">'-o'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制 拟合曲线</span></span><br><span class="line">a = <span class="number">7.173e+04</span>;</span><br><span class="line">b = <span class="number">0.007432</span>;</span><br><span class="line">c = <span class="number">645.7</span>;</span><br><span class="line">d = <span class="number">0.1647</span>;</span><br><span class="line"></span><br><span class="line">set_day = <span class="number">45</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">x = <span class="number">1</span>:set_day;</span><br><span class="line">y= a*<span class="built_in">exp</span>(b*x)+c*<span class="built_in">exp</span>(d*x);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制 10000000  边界线</span></span><br><span class="line">y_max = <span class="number">1000000</span>*<span class="built_in">ones</span>(<span class="number">1</span>,set_day);</span><br><span class="line"><span class="built_in">plot</span>(t,y_max);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制 预测线</span></span><br><span class="line">t = init_day+(x);</span><br><span class="line"><span class="built_in">plot</span>(t,y,<span class="string">'-*'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建 xlabel</span></span><br><span class="line">xlabel(&#123;<span class="string">'2月16号 以后日期序列'</span>&#125;);</span><br><span class="line">datetick(<span class="string">'x'</span>,<span class="number">6</span>);</span><br><span class="line"><span class="comment">% 创建 ylabel</span></span><br><span class="line">ylabel(<span class="string">'Confirm 人数'</span>);</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol start="3"><li><a href="COV-data-analysis/time_series_19-covid-Confirmed_archived_0325.csv">2020-03-25 数据存档</a></li></ol><p>[^covid-19]: CSSEGISandData/COVID-19 <a href="https://github.com/CSSEGISandData/COVID-19" target="_blank" rel="noopener">https://github.com/CSSEGISandData/COVID-19</a><br>[^dxy-cov]: DXY-COVID-19-Data <a href="https://github.com/BlankerL/DXY-COVID-19-Data" target="_blank" rel="noopener">https://github.com/BlankerL/DXY-COVID-19-Data</a><br>[^cftool]: matlabcftool 用法及其菜单 <a href="https://blog.csdn.net/misskissC/article/details/8797655" target="_blank" rel="noopener">https://blog.csdn.net/misskissC/article/details/8797655</a></p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
            <tag> data </tag>
            
            <tag> cov </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多平台博客搭建</title>
      <link href="/2020/03-25/%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html"/>
      <url>/2020/03-25/%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html</url>
      
        <content type="html"><![CDATA[<p>慢慢的有了 经营自己的意识, 自己很早就开始博客, 但是很多东西都是 很快的放弃了, 导致自己废掉的计划很多,<br>也算是经历过一些好玩的东西了, 但是很多都没有记录下来, 现在去想反而没有那么好玩了,</p><h2 id="个人经历"><a href="#个人经历" class="headerlink" title="个人经历"></a>个人经历</h2><p>经历过个人博客建站, 时代, 自己去买主机,或者主机空间, 买域名, 部署后台, 然后部署数据库, 最后设计个人站点, 考虑SEO, 做百度提交…..</p><p>每一次动手都会经历一次, 太麻烦了, 后面就只在自己笔记本上写了, 当时也是傻, 好好的博客平台为什么不去写呢, (傻….)</p><p>我的经历就想 网上流传的这段话</p><blockquote><p>喜欢写Blog的人，会经历三个阶段。<br>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。<br>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。<br>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</p></blockquote><p>最开始的博客肯定要算是 <code>wordpress</code> 了, 大名鼎鼎, 但是后面真是太慢了, 后台点一下等三秒, 体验很差 就放弃了,<br>后来转到 emlog, 然后写过一些, 也是逐渐废弃了,<br>在后来就是使用 <code>hexo</code>了, 目前也还在使用,<br>现在呢,则想着多个平台发布自己写的内容, 希望能够帮到别人</p><h2 id="多平台博客"><a href="#多平台博客" class="headerlink" title="多平台博客"></a>多平台博客</h2><p>现阶段主要的协作是本地的 <code>markdown</code> 写作, 主要的写作工具是  <code>VSCode</code>, 然后还有 一个markdown 编辑器 <a href="http://soft.xiaoshujiang.com/" target="_blank" rel="noopener">小书匠</a>, 可以在线写作或者本地软件写作, 而且能够将内容同步保存到多个平台, 真的很方便</p><p>写作完成使用 hexo deploy 到 github-page 或者 直接 push 到私有仓库, 使用 github-action 进行部署, 可以参考我的文章,</p><ol><li><p><a href="https://schen1024.github.io/">hexo 博客</a>, 目前的主博客站点, 除了技术内容还会写一些私密的内容, 太过私人的东西我就加密起来了, 大家都不尴尬</p></li><li><p><a href="https://www.cnblogs.com/hugochen1024/" target="_blank" rel="noopener">cnblogs 博客</a>, 帮助了我很多, 里面东西质量真的很高, 我爱这个平台, 可以使用小书匠-本地客户端 直接使用 metawebapi 直接发布, meta 数据可以直接读取, 感谢</p></li><li><p><a href="https://blog.csdn.net/HugoChen_cs/" target="_blank" rel="noopener">CSDN 博客</a> 博客内容太乱了, 但是总能找到有用的东西, 但是重复的东西太多,而且广告太多, 所以 当作自己的博客引流工具吧, </p></li><li><p>其他, 暂时兴趣不大, </p></li></ol><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>其实有了更多关注之后, 自己应该会更多的发布自己遇到的问题以及自己解决问题的方法, 如有可能, 帮助到别人真是是自己最开心的 部分..</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Person </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
            <tag> cnblogs </tag>
            
            <tag> csdn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-themes-setting</title>
      <link href="/2020/03-24/hexo-themes-setting.html"/>
      <url>/2020/03-24/hexo-themes-setting.html</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo-主题配置管理"><a href="#Hexo-主题配置管理" class="headerlink" title="Hexo 主题配置管理"></a>Hexo 主题配置管理</h2><p>一半有几种方式, 可以删除 git 单独维护<br>也可以使用 hexo 推荐的方式进行维护</p><p>所有需要写在主题配置文件中的配置都可以写在站点配置文件的 theme_config: 中</p><p>通常情况下，Hexo 主题是一个独立的项目，并拥有一个独立的 _config.yml 配置文件。<br>你可以在站点的 _config.yml 配置文件中配置你的主题，这样你就不需要 fork 一份主题并维护主题独立的配置文件。</p><p>以下是一个覆盖主题配置的例子：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="attr">theme_config:</span></span><br><span class="line">  <span class="attr">bio:</span> <span class="string">'My awesome bio'</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># themes/my-theme/_config.yml</span></span><br><span class="line"><span class="attr">bio:</span> <span class="string">'Some generic bio'</span></span><br><span class="line"><span class="attr">logo:</span> <span class="string">'a-cool-image.png'</span></span><br></pre></td></tr></table></figure><p>最终主题配置的输出是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"bio"</span>: <span class="string">"My awesome bio"</span>,</span><br><span class="line">  <span class="attr">"logo"</span>: <span class="string">"a-cool-image.png"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在项目中, 使用 git submodule 添加模块, 便能直接使用了,</p><a id="more"></a><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://volantis.js.org/advanced-settings/" target="_blank" rel="noopener">Advanced Settings「进阶设定」</a></li><li><a href="https://hexo.io/zh-cn/docs/configuration#%E8%A6%86%E7%9B%96%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">hexo 文档–配置</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> theme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GithubAction-Deploy</title>
      <link href="/2020/03-24/GithubAction-Deploy.html"/>
      <url>/2020/03-24/GithubAction-Deploy.html</url>
      
        <content type="html"><![CDATA[<h2 id="使用-github-action-自动化部署"><a href="#使用-github-action-自动化部署" class="headerlink" title="使用 github action 自动化部署"></a>使用 github action 自动化部署</h2><p>创建 GitHub repository 存放源文件<br>在 repo 设置界面里添加 Secrets（本地生成一对公私钥 ssh-keygen，这里填上私钥，命名为 ACTION_DEPLOY_KEY（可以任意命名，但要和 Actions 里的设定$对应)<br>在存放 GitHub pages 的 repo 设定 Deploy keys 为刚生成的公钥<br>在根目录下创建 GitHub Actions workflow 文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">Update</span> <span class="string">Note.junyangz.com</span> <span class="string">for</span> <span class="string">github</span> <span class="string">pages</span></span><br><span class="line"><span class="attr">on:</span> <span class="string">push</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">macOS-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">10.</span><span class="string">x</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">'10.x'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Hexo</span> <span class="string">env</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">ACTION_DEPLOY_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ACTION_DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="comment"># set up private key for deploy</span></span><br><span class="line">          <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">~/.ssh/</span></span><br><span class="line">          <span class="string">echo</span> <span class="string">"$ACTION_DEPLOY_KEY"</span> <span class="string">&gt;</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">          <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">          <span class="string">ssh-keyscan</span> <span class="string">github.com</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line">          <span class="comment"># set git infomation</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">'Junyangz'</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">'junyangz.iie@gmail.com'</span></span><br><span class="line">          <span class="comment"># install dependencies</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">i</span> <span class="string">-g</span> <span class="string">hexo-cli</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">i</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="comment"># generate and depoly</span></span><br><span class="line">          <span class="string">hexo</span> <span class="string">g</span> <span class="string">-d</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://note.junyangz.com/2019/GitHub-Actions-depoly-Hexo/" target="_blank" rel="noopener">GitHub Actions 部署 Hexo 博客</a></li><li><a href="https://mystryl.com/2019/10/github-actions/" target="_blank" rel="noopener">通过 Github Actions 自动部署 Hexo</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> hexo </tag>
            
            <tag> action </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回忆碎片-wl</title>
      <link href="/2020/03-24/%E5%9B%9E%E5%BF%86%E7%A2%8E%E7%89%87-wl.html"/>
      <url>/2020/03-24/%E5%9B%9E%E5%BF%86%E7%A2%8E%E7%89%87-wl.html</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DY直播感想</title>
      <link href="/2020/03-20/DY%E7%9B%B4%E6%92%AD%E6%84%9F%E6%83%B3.html"/>
      <url>/2020/03-20/DY%E7%9B%B4%E6%92%AD%E6%84%9F%E6%83%B3.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="801f66f1dc9527d0bf45f1e9341d1bcb6ccab316c88d1d6e408829092e4652db">a232b9fc6897bfd9b3b6f2fdbea2bf18ec4743239d8633edbfd1ed6f84e9946e1e030c7e17e62a1a72c21272c9e647a2233250a78f56c802b29d8183b749894ce5ad0e9fabcc8aa2c426bfc0ff55ab935f055c097c1d06eb0cbceee29fa987a0aab5b50c38c5b7cc256add64632e6010d6ab3236792538b96b0974d70f809b80d2ce8fc0f8764c6e9bf2fcb203faec5baf535394d2e58ddebb288979c9453d0fd98b176fd284c387cacce41f34fb023d58ef03234375ead111436058cc49bf9d6f2f79ed2f42a7ce18d17f7f7298a85348888317f7ab8cc3c8e764726bc8ba29605ae8bf622f61ca2307d218fefb4ab9cab43998e32e20900a49da98a71e12864df1ca82be6d3299c3aca1e194e8ffb998d80b5c62a973489b41ad7298d09739f7ba3883e0fcdec37d11de4ecd3e72dc4fc1d923b0ae0dad084a39ed7e5787f9815fba198c8eb286b285f5d99018cbac4caa6980fb7dd9e2aff36df9345121e556b97d4b2377d41786f880f91bb735258c9539b3e4b87e363f71dd304e831415d0e76c455ab4686d6508a2666b2491f8ed2647f001449f1766a470e105fa90d8eb1a7ff707c67e5488d742bfc7123e03755a7edb5268b03db285b2bf7b40c78f77f0efe11c2f4714f9c0a827462c1347e18112a6dcf68a31c842cad3689b4007a8c100314b819ad75cb85154075cbb2216db0e1bd39e181a16cb6de8a9bfa15d050101649c9595cb7a4f8cf46c07d9599dc7ae69c7e8062264ab803e9c4fe6beab8ea214d66442fe212ff4d6b190d2ced5c781ec03eda9190056ec396ae7c6924e1fb03543f20ff16d3956bbb91ae301cee1727dd5f34d000d3af61ff008345f94dd42c012d9ad40d02f63ca575072e5f1dfcaf5938755534285e1f7155fc4189dc40e2e3906ec91e8e4113297dedfe880990c4b7903af8cd9ca854ac5480b645624010eb7fae92435b18dd4e145fd7d8d794a52d508c9c09fada260db56fc1caecaf49c2e77be74106be1df670bec375ea4ff0c086bafdeeabd46cc6d90fcb9f9081571bd896d108251854a4276df05eb362ae15e0cb960197fbc45ba90175cadf3662306d974ba27a0a25e04eb7fa7b1b61506fc11bffbbf3408d935004b152205f7462372bb4740043f91410408e89f845f0268fcef55ca7d9e65911794245a0255675736c89de82e17663123115e9e139f0925ebf31991c88f772aa9b78e8fe147a597a3f6d88c3bdb69c426ba333ade832afc6b4db4cee2057e6dc5714ab36fa313923cc8afa15a5018b8157b1cff2f038fb18f1549d9301fcaac2eb2468e9a189b4cdefe62fc8a4366c5afa8342765ba16fca7e1c512e7ebcf803f964cc5545fedafcb80de17bd8893edc0cd8f90166738f0249713eee1eff265a06ac753bdb1a27dcf1a877a336d731ac2be11effe32fc57d7b16d8e43586db99ecbae8696b9dadd2ef6ce83585ea1eeeac4da65221245523328a1b3354c07fe53fc40acb8f7f3ac5c3a3cb18dac73a45ac7ab4e9ce95ea4e021909b63f969b2194ec4f24ef53c80c9523b00020aef5222d63116279e2f9b475ad341046fc4555b1e1f5c2e66ad80df0bff996267f560663ec4802942e34b4c4226465f9e2b3777968d635aad1f471899e94b16ea411f530caa781bfed013b999e9e270312cc06f0f0dce23d569cef43f94e862ff33add13ac9500426a7b71c6a7dd1ac227a8ff1a9f846304f55cb06256a8f4e2da2f4af37fe78178590491abb637de15ecdce89428300488d95ad8eb2077aa4dfdcbb70321d5e9f2ffed2d2ef7fb456b117d9c5b4a2f1e5072efe9ac47813796cb1bfcff774c9831dd1650c2f4a04bf0d2e38f638de6530c242f65e2c54a6c540116f521048cd571b3321ef29bc9270f1ef3a93c054b268dc1efc02412dd5f58b7ed95ac9d7cf0ef72fb5b4468f6eafeca43fc78760ee7ac56a509c284b2b9b525d5dcdf9bbe0eebe7635a7ba5fa9cab41fbd7059770574b8e17bccb16294fcf310a52ddc78dd23dc939e17f8fdbf3955958263e7e17c030164f03f3965ee8efd2c598f27ed1a84609f77cf5c186be40ddd883cdf7c6c740744fd27c9ea5d355a5735f76ed81abaea068415e3d9af47bb266cb65f6e53b24f1f8b35fe9c03c6901bc587407aa304223dd320e1a04781b212424be569a8c04208c4344b10a647cc39e92c7621b06fbea125e3414f76f4fe9c21b41ed61d0ee6704779caa4f96f0fb6d0a641fa9971596a48f40ac7766d7bad9e1877f128e6d2fb996b01743b6ac4e6526d611697e8732b1d4c3b33b4abfa583c9e46d943960c0411489b7a850da0af2878c5f735f0cf6ba262c538f351b575f5ce5e7f0de96b6e8f0c9cc8b34a81b77031245a61354930e191f115d973588ce60ccdad8d5aa57a37110713c95f8c323c6e0d62b879bc68d54a8ae240e0874cc7a74dba30f39c40cd9ce029602969dbe817a9837ac4c640b071acbc9691cb2ea1a27ad42904debddfe194633d6994612ad41135a384cd034f33b1cbc1d4cf2f9fb7ec6b61d679cd432237d6f0116fb890c1f0a6881381111a8f30c2581983f5d2c7afd10ccdd798da89debce84de761566ec4b95cc97350b555804232d2bbe0a57633258b0a0def78cf145c68796ebde4da8934289c3672a236765475c5387442bbc9387a08ae1af352d3697c445c21b0652c4fc9cb2b78f68ae6c60c35d339304e60e9c99df7264052cc6fc4818eec5e71e9a274ce7358ab4d61310962ce986799608edc322f86cf14f5abc74b69be26c9786a46b314f263345970ba39986183dfd52ad1dc5d400254298be05616ed346619454c65301e479f156221aa4182cd427cdb916cdee0c1838e9e1a8b43dbba601d9cf5ec6b286da55fd705cd57019b8f0112377009820925356af09e41e21581236ce09b7503e07a462fdac7f880cd91c04d9f24752a5b8d13c8bbd31d8207621edae0d9c33cfdf25c5182c6008d5d1802095fa9478942a5e099816c88c6c1353a1ec5cd2567cab3f283157969cc601ec823a8a67839803bd2e6f1c298c34c41cc842f834bc4a612bb3df2ba70f7fbe1cf1888e42e3e71acd5659562d39a1635c7ad294492d5d02f6757b2aeefc3aad5868c2065acd143bb50cac970a3448d09f4c8ab8f889c62b8c916ff4b696050cac404bc0660aacffa66d689f060244833231aeeb084accf28ff7c1becc9d96748735874b3100f4cf0f20751db946befe7a378a6f8146b20389961aec66c63ccde943af3e4f260f0327c6a7c09a4d9ad65e873d30a95a46e7bfd60e2ac2b0b9e5e5d35344e1935ba620f999c34d27b12e703e0b4b81cedd60c072676ac3905f3276e20c9b0aadb165332dd0cd67c1df26741e6699332117b47db0b3199657c12d28d8732e560dcf6af09df6b6268778729dd2d4747e5f7778bda4e73c408aa4bf219403ce9bedfcbea194c4e251a69d7fb4f0bb9093ead2459bf9d6aa0f215e88a7fcd40b7d0e9a8ea8336abba6fd6084272b8904f9a96d1cf3292325c8ffdd151ce0e45c7667ecf4f5f77bee4df09dc317da775abce1d172b1512f413dd219ea16fd9b8fc4602ac3703b4a1939bf6bfd9ce65b89177099e3052280a5999ae2dad78057426d6ccac3e1f2aadf09748038f21ffcc0b637d5ed482dc874f82b83c754d8f310b770762c8d4f12f7a4de07b96f6e8a3940c651fe66b42e37cc0b33e8ac5a731d38698155518f7d0383574f2b90d22bd303caa5283ea14269e5050bf151461f0ee07c911104045107cf14f95a5392bc1cf6085c841801b8858d340cba5b6f4a947443882c54dbb8eaa0ec89f9a130fceb41edfe3b9726600a49b3d5f2cbbc55bd011ee64b155828c7292424624119c8636028c7a190f9c3994c5456f4ac0ab400f5dc0caea33b59e3d610ae535d35a2387d359213bb537a376a15e4226ea0bce535724206d5009712402522f29c0c7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Person </category>
          
      </categories>
      
      
        <tags>
            
            <tag> encrypt </tag>
            
            <tag> Live </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZYZD-使用说明</title>
      <link href="/2020/03-20/ZYZD-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html"/>
      <url>/2020/03-20/ZYZD-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="788ed6f7ea5fa3bce8e72390827aa5300bcc19646d1c0190eb3b5a345efce9cc">41e65097621f29ebaf4c77e4ee4bd65f28b0ac1e14373d8101d4be1af34ac4e3405a30a81e5010e0dd4e8b25219e26ab86630a62477de5fd5302e3e5c52bcb12691d964656a4721cdd6b6b6aa1d837475ee5a68907d4b896064900693fc1fcca436e0af56104531a2baa1ed474867dedefc8ae8115da2f5b8d8c0f17955f6176054dad9d7067eae23fb411ddaa30396654c216c1831817cc34022f98c7505f8aef8254af9eabe348735769d795c62fe30a5dbb33783bd788e46f145f49f8cf3e87c00942ea26f22397389b09ec763a0fae75ba18f2278d980d4fd81bb45e16de2be8cd50ffcca99f77482a355721cf5611142b95c614ef2fb5cb897cfb43bd5c043e3d7ed5227cfe82a30fc2b34eefbf7ced556532be97104d6eca597ef0a352e0f5712bb050ca63dc4dc9f4f1d7a4b4daf73950c53c7990176b278bfc7c50810e518af6f96086d396846ba9de47bac4aac864f2782b92f17701d5c6028e22249c45bf121dd9e407453e2cf6d942f2d24ac4ed81f72219ed50104d80c17d55d111c595fb103c04b2a9444444de9dd796c5be3cc2c006ae35a7b060090a97bc01c239ab2131269daa05a63ec9f0974e460aec6eb9717ce4274dac90f23e378f904d6eec417c486ec34ee2c3685df641a1e470bbe5d94cba3ef1896b81cd7b33e2017471384a1b249a87e5197ec9b3caa72a813d10e5a698a3d0598dbaab5ccddcd5dc853b8ead673e604879de701deac9f2e5717d067b86c80c27af7fb890275a713f629aef3f6602e43cc0fd9cec16a09cb767960539bd6250d1f0e9750b2a40c32f854fb1774c697732bc3b9d2f5735080a75159ed6571bdb5a943345b1b5e742f24205a990de99441e713e965b3130b7277a9a3e315bf488b244ab30890ca454d1b49b4ccb426b016b388fc1e2d4a856b190c8d95ef7c3508db6c6ed5eaa5b0d6f84728b8f3f8009295263a22288d953ff6222ef0fd852ea9bdef66b2d311d2aef0a59399cda3daa9d7b423922549246f33c992f9e247d6cd40f4e714e2bc03f75034f5997c1b5be819a76e786e58b88a7b84716d9b2955844e262e68a58d3bb3fc2149302f5246471d840ab6a88f513f68e21bc4cb02af6b633f22190848788a6219f4205e687edfd4712fb122b767b9a0e354f7974bba6b10120d38cc2ba14dd816cfd9f076f3a3aa3c1ce90127f8f120531dff8540de8ee25b16f3d5cee6d5d1250c821eb6e6b2e9fc74c960fa10b5748a16671dcc189fbb98440f99a3a83552e958da934b4864d63ff079370d5eaa17f79eca1596ba54fe570d86ed63bab08d44807af91fd8604d6afbcf7a00901764858ecdb3c14cad43bc48ef23e395b3d894192491361849c6132d7ec23958fd4024bf8b14415462d3a3e3c492b1e3e85af3abf1c8ebd008673f7675305468dffc871f4da6254b8de77ed8236dc8138411ef0fedcde5f06b42deb46c39da1f72514ba52df1f490883450026257bfce57854a9b0ed246551196c86e71ba88fae6e075623ed7e9b4b64d220ed4b286e5a609c4c38350d5c4944775b5cbe80a10eeb5ff3c684a32508e0473eda05923ebbc8e74542e9a78b9a2062a002afca22f8a506bf7fe8b3d727436eb4c9c357a118473e48a126a6e7bd28ef457432c26b4ae5bf38a2027cd950eafced9e786617bdf04a699aa786e3e54bb93526e10338ed8d04892d28a2ec08efdcea753ad5095d03ff0a0d29898d3fdc64d264e4ed391fd33e0bc400d14b941a5dcfa04a0e6571c1e70af39bc1b9481ce8c20d9e4210659837916a95bab5e35df0506e8a3d8a32494aafc721ce36f44c0723ad74b4d0b812e66ee83f2e82bb029c9e4a429439d46efc4e0f2a68b431d4438cbb560786eab4c5832469775359e4026558746a0c04a7b1abd62d7853dfe455787a2304ff2fd67af367a6fc73ef2190a6c174310340e98d4c9d1bd2b63173c4375e713f1d4b1d091ce9a979c2fbdef64b10bec77106257e524282ee87b691cfcd5cea8a2f7a44a3fd6f649e9129642f94d2faa0b08f535310258a15780bac0823babf00c920e5790f88a38d97e9be2eb9090a6a819ad14e8aff82a75f598f7330b2fcb0fde789ed382f2ef20a15b0edeeb52c3bc93b5d7668fac0728e8bc8630cd651638f895a88ee37e0d2c54d9e424c7d3750cc2480b6f89e9367a067c44c7d0663a9117e7561f24b40339e43df33d4fac9c5fa0597c3d4395660c1f09e926b04dec1cf66682d7934a2f53e917149032264ff6347e4772d23db0b0afa612d2c2720dfae3cc47d036f64b7c7b34b36fc23b5e5ede6ac3990cbcbbf99a6fd20d74c2fa15ba0b9c695c864ecc4a6b7a7683235c8356f68dab9b7d12400f1058fadb51958c54d7f11b7202cc52ce83870aed5caf693958bbb12e818ddc91f884fcff6882100d3bccd9c30e233448288c9589f7cabd084e08d09b032fc685bea3575310b2d834cc1668c6e9932796f1c740e4a88f62829c6fcea64c3a726f8a2e54076677c72e46fcbeba15317f10e7ed7a78abca88f6ff086766ba8404225d907a06431dfa75010b2d0f8f372705fd35af645849c48fb6111181ce664cef06bb8d30bcbe6dffeabad14633c9b273372ce0f5aaa24474b5969c5edcd57cdfda562582017522b5ecc1fe7127a574c51f1307e5d63749bff496e9fd4b702263648f8979086c956f90e35a1094b39a29e14b51c59302a91a07070d5d7dab16477800e98540c9d9f8d59fb6d0aa7aba15227c577c8ce9ab7dda53f690dc8a9c4c7016fe1e16bac0bcb7775cc427ad00e5d6368a899490e47309cd96a5988d7fb325289feb7721cc916ecc523d5dcf4a33a430b14c83d0b823bcfe079b63119bc1c59c30e1c5923e6f2cd92d3fb93bb429b7dc876937fb418fa358ee1d8386b18554a704a705cea8e42e3105e981fb985b78501a9fb32ec7c2740a8bf9a6a62687c53ca638b478d5cccd1c61c1bafff6fbfbb2035a9a568d1bf675d64a07518e8cb21239f7257d2e9e05b267faf689eeb3a47da91a941d96153924023f0327558ae7bf18b540b40a45f6626cbd232608204604e462aad1f883293c66acaa2acd77b1e4bed2d8e6efcb822449852b4219b789cbbfa5bdb14f89bc282a562c41a31e3c683574425e7f08c069742a1c3ec8464e8d4f4e68747f69e84cb9131ded9ee12866aad93cc4ea70802d8aef6218829424167bff10c239f1de95118a6b65cbbfbc8681e4526ee3cc834f45340f249251d444f4f429acb595ecd3621734f691c4963aa2a6c1857e4b69bd66f38e3f9ebf456edd046d770acaa0a19bbd2d2bc8d2b4247cb78162121cc2aedfc9a083e9eb4cf1f3d712111fd0f634edba163b14c2aec6e9246550f512de6063c86daa723af0595a2c578b7d6dc0856e5de34d0740808e4e6b1e7f80f5ed385f62e9bcd06dcd3b96e14e4a82f170d4805943c25942135a5898286bfd8dc1cd3c05808404047db0e73225a35626a95790cff9b9c81b21ff4f841df83705d8317b57d886a721ae6d73485efdb784ebc8c37cffc4eceb006b477dbb2c38b056aa2f76a0eb1f06865859e929992c9d5f320c79323ebf318ce327966f7cf0b14cd66cc291674ff9732f945d466b377dc6c9953b035a0c91bb35ed4c962a25140ee3ea708b41a7daf4c02f6b7223581b7cee24cfdd2a37525e77101ec82169497a772fd9e65b59cd505daa568acd185012e8448d3a7e799f70e27265ef2dae3a61bf23d54f150cc9313fba3cb8e5ce0661d051382eef8314df8454e809c55ae57cd8bce81cd1ad527721005d5da3c787976617d57780ad590d40f0e068ba4029002837ab9dbfae2eb4bf907cb25fc84c604e5eea03c4c9446f4180062e9d5fd814f906b0b79c33d2a899bed1d25a66031c80c3b136218c4dcacb2f55fbe1589c5a170b674ea69fbc1e505b2862c0b93f1ac2a18a93bc62825ffd6a87d504db766fcb80ee5c22bd3bde61a5bb3c072364e32f062aa22f1805306c20812ccd22677271c62c32b99c483bcc69ba3bd9294c5d1d2ccf887878619339c42733d054bd700e14fae1e8710d233996a88f2699252bde7fca06e7308bd863c92a291cf8f216fee2bdc3df7449e56f8db23d5f86d05b39342dabd76644ecb4df819db590eaa854a87d3450d9ce1564f0ad79b38e7a18228176bec8248da233bc94f273967075f96e4b40dfe6216a453b6a65a90c8e213e2d84a12412d68709757f8dae9e84553a799db34a6a456f95f24fee160d273c46793c8938157d27480669f6b634f1555d7a0859ea0ae9364642f0eaaacca5d742aa4955897f7d8f4d1f583cde1109032cdef27f7ddc5942d63a2efa65e429f853698f1badf6f26aff6982e56476ff91bf0f12a0547a48c449b489637372a7f4bca5d1c9070e27e37615ae690c8871ad572763f10930e7fa0fe24fd6e9d21ca8c21b273e4823b906351f0b73b11cfcda29145f4d353d581eea9c6bf1c17eb714e4d42096aa822066fbffe7c2ebe9671965b264edecb312d8773fc2d7d2071f8301d11a1bd791d1c5f121ba7296bffe78186ed6bff5744d8d8302a2d243c9c6c16bbc2a1d9df2ab1f279791578642fe697e550952c58a3376782cb8147f4e786583c7d9decffda8f42945ce3f5aa37c31d42656b98022cf984d886c9e9bc96ba918f2a99ee2620853a52c6992874707744f4107a67febf18cdf7571f2f51f19d3bcdbad5c76dd723639716c017c726f8cf022db2f045428127b519aaeef5f03027c312e9ca15e46633d94b2945f707a304cf5cea2afc25602c418ba5ed0281c48edea0908acd46d2008884abd8e545638acdd685d521cc4b437930212a392bf947f1a3f4916fac0b9a4f79e995b8f9f893ab32a6f508c2961af0370a659b0087eb9021444aa20e08c92bb918788cacb9b21198b366686b2e02a3487d6d6245080d9184e73aff3260b049215dcdb5e572e669f486ca91da4ad225762e7e230e00177ec55d0aa26d640e994703fd6a8353b38259be31c4753b43256fbecd690a999326159a9a7c706f125a6d7ea6ee637e2514dbca58e7eb7281c0c9bd893fa6623b45201c9c641b8d1a6bf6801bdf30c2ded4ee689e82d991e8139a4f66ba5e6e61bc1a0e18834a5888ded5ababd6088f84d791b3cb9444ab8a8dcf2be717046913da4384122217956febd37547c7abaa1dab535045348ac67c5d0f74b97a78185f36d6db6f4c9bf03333c57dbc80eea4ea2fca99a452613021808baa6a826fc6ec86b006f50cc1a716eb0badb5dcab742e653bd8be2e3529d0247fd5c4aa9c0ece53b5dbe0086e87b979a5bef6906c7a24e87fa2ce79b64f17bf09e80150728f9c35481c533904100ea736ac3d8592195b37669b776aba3a3e3b6699bb130785ea132bea86cbbce84f21938d15cf6178be258fd8a4263b656271f78a316665dcc1b19745ce37d17b7eea6eb809560d8e9415ec373bcd7fac5b3b51866c553298dfbad5fe0a41af4ee1195d54540c63bfdf5de53701bd09a370e01c13ce61fa18f930a869f9e7520fc17c306028b2b4d8e09b178117c60f43742c44d39ed604d966509b2d8cb0b462e5e45d3cabb0bd2440f13060c2203b43cfb216ea7af3a0d93e1f1d9be0a0717278f9fcce05ef27bc400d73f34e80002b4c0ff7ef8ee73ee3d8e9e414327a04e48725547569c6d11b06c6db743fae390f059503100e677fcd6d8644a4b93487b1015ef5a556492f5ec5a999d807768ec4d08a3ac54e49f498c205959a0f11619d0940ddec2ba2e213b49688438177c86c04a479b3a20a8f6542c9856838de022797380a5628fd09c6c15eba4392c04fc62c5e49af5b88397a7fbc471cf5d34317317565c149965a5a2832aea78ba4b2387ad29765cc78b111cd67cd5a948626a6c81cde6ccc26ce3a4fcae22917837180dfae12f1c0ad5405801982406af7d127a450ff4a7165274dc22e3c8466619947a256d560379842e53a45be82f92bc76832546eb16dd34488d52d06166d125c62ac0d91f3e7b11b76f0efdb2187431e1729d469b5a76689a4eb8f3699203eeef33ff2e4873bf3c78a1ebd479eac0cb42fbf1627381056ac954c9432571285bed93ed1bd29b32304351fd15ce80734b2a976befb2d6a26ad6f5f6b3bd912bb0ed4c8a1af8bb9e5f8ebb39d394bd5f0315946abab4962703c36150e6991a12c0a94a6b1885fbb902ddc7ba18f63cadcf0940ad5c26d84dd8f6e3d400c30928955f0479a3a66e6113d03d251304a6c9ac689d1f00c752c25c9f3379a46ff3b2d2a5c71e83edb7df7f2df07b7840ba7803ed6f73d2c10ecb086d119d3e710f136a7d9d8a3074f523cbf6458a54f5ed9e62a889614671c849b5185c798ceda543467832fe164495adc6bbb685fdeb08405968ac887e43c205331f432b30bc08797c665a9c79cb205620d9ad56ea2074e7528f68bf90d3c016445a519d11dcf47ad2e5dc1a6f34a0873422286e6efad1a5e0ebd52947f8d05f74ae13d331674c2fa7add56421c1bb2f16f95c85f8316e6d690b00d47bab8edb3f75cc2c3948d3a44dabd8221529cac5a2bdc3bcb82b6f5194b8e296a9bac7382c7bb516dc462038a93cd15a53d2f785053b88d19b7ede072a59fa17e7155b0e68430f9e28fc6b530b66e78949057b396e8a426c7ffae7926c7beeb2c033c0ee169c22fd699f494c02facb7066283a87a36091260a32b85a674ac1c1f7a115b98ab078f6bd622fc5db57258511989291ab7ed561362182e370aa4c17c40674cc5e2c3e5f96c17543f0d754125d640d2e26c14d08af1763a2ca1a4a6622502d9ec5bd0b2a3db05d3c250fccea1c714af4b149b612c541cc0ba84511402634bcbfa3f3107c1b9a56eb9808bf4998f3cb5f5821e6a38c0535013ed300872f1c88c0a1b8aaafa21faace69eb1c04da378318c870cb7835074067c41ee4e16eed8209eaa2de2206116838606ea8236e14c42c05eff1837aa7c7a5da2b91085d69bfff4d385ff96ab8177d8a4cc274e0274ecbed98d7626ee1c3ab24a2bc160b206e7af0b31a07060987ddd9ff9a257c7535bf2bfe3b7b280b4c8a5cdfa9742b20e1b76a2ce75e05b5f7eaa4cb2bf824becc3e76de9e669b448737ee7891013a0a66a219a578e5feb853874d6b74387545e4e290855781a7e49dfdaaf2f1d062fed354493c57875f6517b0fbc73999dbd2c7519a821d86106936f70cdc8d273bd017d62fa5b50f7997be3fda007ca882206edb46926d778409a081f049e2776d428c32ceebedea72e0bd205f6f6606c1fc08f4e877eaffaeb1d822e114b47c9ef8e1928530b3aefcdda91cf4c384b8c529be521614a0c2b90dabb4e4c2991cbef9b01433a4e28ae3e07f640fbacb11223a24feee1d7dbfe8f1ba6ef1544c1114325aa483244a236d642a7d9258883e110b200fa27d9dec53584d0368d75f7100725bcfc7e7a98b72cf06340ba737a106491c8b2e3383d999debf31b4a8377d60e951b754bbaa3dca88a5464175d2810ceccc19e97c615f903e5eb96ddb497b69710a55fa74baf23070fb6a5565607444d9b2f5332d7b0ca0fcbc323bbc653f5bec050a0b7e703759a2ceaf73f65b4be63ee716f3458476e7ab87d9d46f56ccaabfc38f41b7df1ac5ba4d00c908bb91d27b1cdeed88bccef80e3de6d174b33457220eeff996485d29460a400a28eec55121c937756d987005e1b4a195e54aad7caeeb58f753421c6f58a1d15916a0aeec5d879390ca61836f88ac2506295b5de52970db62ad3362355c277279e87ee28ea44bf9581d151253600b3525a4dd79cfbf25b3c98597c50145050642e9ea9f7ae2086ac8aecd1502111b637efb1157bc66861085f653c0b549624b94dd2503136fc5f0a2742567b41a3082153b0bb661d86582ccd6a7ebaf2d60402b31751385d21078ec58704345d72eb41c33b2966907da319e0ae03c516d2e56a2f23f8912aa69635688773c60b23226470b112c71f459aa4a11f1127e61c2391b1c05cc628a52b2f8dfe7bc86f54561dc0f9c02caf4ba924937c9b1e7c362baa3124e1f3f2743ce86cf591ea006d0f2ba3b0a6ec2256ec96707a9d5fa8dcb7ce23a3a23e1a50b797ec3780499c04fdf828deac9142668e1d8208506a083580836d53539d98799045513ad0eeafa93ec5dd204c39e98faf82103a134126c822f9fb63a0e73081513a92145f196753ad65670d83b5692f5ca8a2811732eb5f57f775603ad25b52d0005766d5da5a5045033ec6d667ea8972877db87deeec8101ce16574c400e37768c3f60cb04316f2e40ecf30f5ee2b7ee774a74a5c514ec92713f2fc20cb0eca02c17b030a8390fedf98d14f0c7fb8ab85879d35e6ec8a0e19d893733704fb97d809003a69b7a06554c4a3c08ad25298abd03de5e7a42c7243a31406f19cd83d5b7c3a978dbf14b31d9014405628ead0cf3a997ee6b05920e0f656e4a4794eef72a2470e498061aeff8da8936bc55631839b92f8218bde05fa47984eae9c7ddf329daf23fa30d3094db3016a3a36679e4fcc864020b362a66b0680e0179eb4ef03221e0d811561e2d599af9696eab950b4b769c8e2bf0e2c23c1e06f3b4113f1bb18ac9191a5ebfc896b1d6b12932727586c4297c795f2ddaedcfd37fff47c49e2bd0531b261ee9cb6142a3672b01a441a020fa98a42c89fa2c83d31bdcef06c12ec49c21fd75c92d488265050d24278cbfc9b9d333ad0ea14cc8fda7651e0f4a501eba14d7679ab1f19947d096614bcee3b463ae05f7655206f86ae5b1961d381509d64b9b3d6b7f17bbdead7e20067f44eb201ae88f9c7428ea14e4baf1cc1ada3ff8090ce60adbed5fa3a33709ecc1c94ed47ffb28c2261cb8786e22891692d35eef2a6714d58f12c87923b1567f5e719280156be7fb380db19db29aec2612eba753cbf20acf5f6f02026cf4e4a5a01251f56e400dbca4a2410fce986aef8b96ec221e8525c7e9eae1aa87f70277ca3a3ee32bd53e7cdc41fe4edd0ece7369f954d778eb931e4a1d598331d98b50734640861d332fe26f36595b9a78f82673cedb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> encrypt </tag>
            
            <tag> web </tag>
            
            <tag> PBootCMS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZYZD_服务器信息</title>
      <link href="/2020/03-20/ZYZD-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BF%A1%E6%81%AF.html"/>
      <url>/2020/03-20/ZYZD-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BF%A1%E6%81%AF.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="6796bec714e8f6b9c9cbfefcdc5b2a81943c482a75600002046f3ddb9cf1e34d">41e65097621f29ebaf4c77e4ee4bd65f28b0ac1e14373d8101d4be1af34ac4e3564ef7f869d6e1bc7a68255a8f2ee46b527da311e9776dde9019deabfa03482ffad589e51a38ad6dfc4314a3fa0193866aef91f491602a7cd4227b759c2a3978c62ca6c57c888f934f4c16fd4e7d99457f5b5505f288e1b4abf6270f7f0b2a412f23c12706d84e7eef5d806e6c588423fa0621d90035bf1008f6f99f5796f5480cf9886c1837b8029a045527294384a0f6d3c83f9de6d744d54b2e57714273e11c4bf055cda3e0155bf00a17f14891e92d8d1a380861f5643cbb2d462a6e397ee6233273b23dfc8e302138521d6d33f1925755fc46c782d9f934342f8826b00b4d86dbf35a079f4d6d78da1bdc749c5b91e82ae652d6d4f4f4039a843fc3657eccf56345764a8a4b1a45c0495c6623ce82509ed31315abf1a5850f6c2777b51e7c230d32e2797a828961fc33a8fd435c801616a7f420258880f2342c065e6c6fd5333512523a9fa10f00c8381f06d6a5103658f169e600c30c2ced432e828a715e2b29356c718a4d41a6074f076050d9d5cd1ea5c9212238f72bd2617aadee53e94320ac66fd4a90c9945d2ad02a26aa33e66b372c4924da95de2b5b2681961482f2c08d3d8d835573b606565b0b488187bb87976a290a6ae0a1bf6b106daa533eabbf09965eb080d99acc34d2d17622b7a767c3a1dc85bf65daa4392f05182333e1392c4292d944369de1c16cad37e727ab730b55404b4661ae7c557c8d5b87eb6ffbff6511079e70d1ed0586f25ceb10c04c77074a8032fbbe254822f19558367c0c0ffea496ac0e80ce3ff68a9cfe124a7653f7e056bfd4062aba9f8a1d9364f50d0f372fd7cf974006e6bf34482f971d2207d44e50efb73820342453dbb1d4b2857fa36339df177cb6b69032e35227fbe813696a7f279f783c2ed936522c4148f4f90f476703e2e04aae270b0e4011ab34973db8fe998feb047c116cc4a5fa7f3261df8708101ca2e3a15e49730c9dd3f1ed281d31b24f8f1129624b11b42f5b078aa74f6c32889cd0edaddeb9ee1ff9aa60c9abf4897aa028a9d9ad506fbcfae602753b0b77e1904064b76c9b95de62e7ae739c138c250d81305000030f9b33655684bfb21e22090d3c82b8b07ebe8355a83418855185842e50b073f828ba960e851b16cb1d1e7ec73761d18509c26c3b20c935d5e0585790c6038b185d0825382b416208d83ca64a2bc34fe39b86c5b65b6e9f3f24bcd4b3a9c1a41f809b26dc7c6e7e752c8fd9c191d4cf8b15dc2269c54389f17b8f39513b41d9382e6383c20d34bca3e22ac302fe6197e1926fd2c6c4100aa20eb5d5c0e8a6c77c375559adfb38e94ebd687d5e3ebd09ba31a060ecd2d912f20f61868a6378e0f7418a84df0703bd311b0a612a231c9259a4f14c6ea8473a90c7d08a7c00ab564bbe64a98dc6a2314ecf37d1421f04e57cf3d60c947b50072049c427a26858c7ef6fa02d98a96c63deb0670eb15cd541cd68bf1d628e38443f994a6282229911497ceafdd0be44fa2bd9e53efa0143c6ae32fbf830d283f7cad6b93f90c20691dc2edd0511fda17b836789651fd25a3ffd1a203d15d0bf25d78f7dbb6f80d77f406271e63ae10ca3afebbf31481b000860bc8c47c73cae21bb508c85e1b252c4479311fc628f328c83b3ae539aa9c47ba8a0a62a258e718fa57379ec57ea779b3da9e64b7bc3389d77eb721a81a08429878db7b31eee765b9e11661b4160778b5f26f74f2bd62494e1307617a82dad01f8039f9c4f4c51105ec6a3da351f67a36d46d87fc8cb08759d8d3df00c78bc177c51090a448a62dffbde7f20b98fe7c54702a4c11a062445e7e0b791b865b621974bc53d4dccc5f1f0bc7165a9dd27a19f0751939c279152a32b11ee127c62157a2f62c7f2a6af2e23d52d4955df89926feddaeb4ba400488a1835688509e30a852f4c3ae861488431de4a201fe9f3fe66d9424c51e0f809b2daeafe9a214ca0948180ac4193d3aad7c608ada2bf5cbe3539b03f4848e122a91c7905a1c6633d68fe42ee5d12d25fdeacfeb583bb820b472cbb8f297fdc0ef099a8c444da5d1f5fe74dd6078c312ffd2a8439643dee94f54c2abc2b7d3962228429791136a4f209c2e408fc229bce726c1b6fb6cc75beebc46dad66135ff63aa4e30e378fc5f903d3608aca45ebbfa3c88600b366ef71ebcc4d634929cea9eab1932d4317aeea04b93f67f04cb89e380d0fd86f2717ff8ffdf3e750398f8d33d61720242003211d3ae85b6f0ee7817a5b6a55a4347c942dca4ffc96abcc65b5493f05099e80e8be91d472a3f63739a2c6003bf6bfd210fea51165a6cc76e6c0f77740b077be3d27cea711277d2abee9e785a3bb1d76b3783aaf435b2932be6c809fa58451dbc4f4626c7fd7e6144c8ecb4ce7103c7f973378cd9c4be99faf96f3f9b5a0d64b2694adbbd1da91a0b1fbc413413b63d1b79b60527e57b4f268cc06f366e78054b67aead1ba1fc5c6a5101d7ed8a4e2835e284fce7742c0010a60f6137f566624dedbda3045db266e724d111b27855bb9a736e318bd471d4d687f5ebf982ccff709b5d5578619dcfb8c033789809ce2259022413b0298c8c14c887c40597555d97d61ef56e58d27b417517913b385811b741d7686fa559005aa8372aec6ef980e3d2868c2537f328bab1c311af8e719cea8249092bf50569fc390e2f1b7bd20fc081bf65f6e57917e808e33151791135fdc02f4b19c30bec6f6efc7e0bd7aeb77a349ad90ad5f8453cdb70ab1b656a5c925a376bf7c7cf4bff262c460b625c122f518cf7835a4948746f52eafcbdbfdc3dac106ced915d0bd246ae8f6cfd86f6d47f8afe1e3c1fd5118c83aa1977b13feac0520a9a44938f09401240db75affc255483ce9eaaae762536397b8b7d6959a2726067d25ef49023c92fc4af4143519a34eb2b44ba4e36939ca0089e5c89441862383eeed4bd862cbb957f21d6400d8cf6d9d2f47fff8a19df419840611d8a33f0335892665f724f2904b8984479065e3c6d8e5e72ce543b55b014d2249393f4232d8bdebab710e949e79b84f2de9bd60a503a6af0f05066f452507f93dd273764e7b30927a115eb80e216f4a39ff72f84d92732b8f0528e7a9bf4391fbd5c0f3ca0751bf71f1870d3dfcbca8a4279ac8bff75de8c354ea44904c9d92bcf52d2a8710f9dd5aad1bbf721aa0d01a429443a5d069757bc16444eba6ed5a578ba2fbed0f80b837a71d009cd48c2f50e32f9bd43f05fd76ec8ef763779103f87da0565b98ca2ae6c577bdcb16ae6bce92b68f3131d172d931750f19ffa31de72663e7086c7eab21c504482a4541e808868b974490888efb29bd8b6e9ec429de9c9b7099c8940a021c70be43feec658ea55e09909eed753e1264045e5759dd623f00eca981af505905c4c2a1b11ed1f2eb3b7cb2d0dd879494eaa1c24924e44bf9d9d83d2832e4f756db1fad7649d35a9dc3f6e2497bf2dee43f2239fd70b000009c155012388dbca8aa3e640f1b2eb33d77821d2c9a9e534121bebcc460ed6e85a6377c77e9906e3be43262cf4dbf449e73f0e08755805e2a427748fe1892512809854d03cb9f4e5f8181d82e52e226f011861cfb659012f8aa23f5f0db610ad0b64f759ca091829f6c76088a4987c50602524d8f87ba76fda7d381e79c32d8b71b7c26d6057fc558f3ad2716a2fecea2732ac8cdcc94b228fa502c2626b397a4692bc8fad1c7f51e1f5c8cff2e79ff909e9494a6b578f715d6d4a774872b2baa29609e09c1702d8eb04af0739cad4d5b8abb2f841be2d1ab6820743a76d6437358f6b925f9ffc0392710634f28f1d30c12c074b7a9a1d3a1e350a62d5a330a894d51f1365f492347461236ce9a8adbb15f0ecbee5cbc25a41f788ca64eac45abca1304d371d11110d01f513ae86100d60655bcdbcc1167b2fb0fbbc9eacf166c829528d3ad92bcdee1efc28f5cbd131ac9ab495a8ab8c6176092e60273c506e04590173fd48ff5f2d28798b24e7b9966e6916d582f16b25047c5d8fb3fcfdd9ade02fe2e8e8f7d7fbd7845cb5db7f18e95cde4fa01148d559c9283b7014d7ae67a19807ad93b079fcd049a199fc35e3abcd24002e52ff63191958ea4d03bab67775315526be71f33656290ca755fd33a0da29fbba94054cc0b262953b2e25c0ebb62cc4a6784f8926a667e13649ff0d5d0fe0190331c3eeddb60746bda9078089cd0f601e20d9b8cf621b704284dbb6eb01f55b1a101d9cb89fb199f0d11f4b44ac7cc212ce3288503157c50d9056fb72ca000eb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> encrypt </tag>
            
            <tag> PBootCMS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于粒子群优化的仓储机器人</title>
      <link href="/2020/03-05/%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%BE%A4%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E4%BB%93%E5%82%A8%E6%9C%BA%E5%99%A8%E4%BA%BA.html"/>
      <url>/2020/03-05/%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%BE%A4%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E4%BB%93%E5%82%A8%E6%9C%BA%E5%99%A8%E4%BA%BA.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1.绪论"></a>1.绪论</h2><h3 id="1-课题研究背景与意义"><a href="#1-课题研究背景与意义" class="headerlink" title="1.课题研究背景与意义"></a>1.课题研究背景与意义</h3><h3 id="2-仓储机器人的简介与分类"><a href="#2-仓储机器人的简介与分类" class="headerlink" title="2.仓储机器人的简介与分类"></a>2.仓储机器人的简介与分类</h3><h3 id="3-机器人定位与路径规划"><a href="#3-机器人定位与路径规划" class="headerlink" title="3.机器人定位与路径规划"></a>3.机器人定位与路径规划</h3><h3 id="4-课题主要研究内容"><a href="#4-课题主要研究内容" class="headerlink" title="4.课题主要研究内容"></a>4.课题主要研究内容</h3><h2 id="2-路径规划介绍"><a href="#2-路径规划介绍" class="headerlink" title="2.路径规划介绍"></a>2.路径规划介绍</h2><h3 id="路径规划基础"><a href="#路径规划基础" class="headerlink" title="路径规划基础"></a>路径规划基础</h3><pre><code>1. 建图2. 定位</code></pre><h3 id="基础路径规划算法"><a href="#基础路径规划算法" class="headerlink" title="基础路径规划算法"></a>基础路径规划算法</h3><pre><code>1. A*2. D*</code></pre><h3 id="粒子群算法-及其优化"><a href="#粒子群算法-及其优化" class="headerlink" title="粒子群算法 及其优化"></a>粒子群算法 及其优化</h3><pre><code>1. PSO</code></pre><h2 id="3-机器人运行环境设计"><a href="#3-机器人运行环境设计" class="headerlink" title="3. 机器人运行环境设计"></a>3. 机器人运行环境设计</h2><h3 id="1-环境设计"><a href="#1-环境设计" class="headerlink" title="1. 环境设计"></a>1. 环境设计</h3><pre><code>1. 仓库/ 货架 情况设计2. 机器人设计3. 运行策略</code></pre><h3 id="2-定位与建图"><a href="#2-定位与建图" class="headerlink" title="2. 定位与建图"></a>2. 定位与建图</h3><pre><code>1. 室内定位方式2.</code></pre><h2 id="4-仓储机器人路径规划"><a href="#4-仓储机器人路径规划" class="headerlink" title="4. 仓储机器人路径规划"></a>4. 仓储机器人路径规划</h2><h3 id="单机器人运行规划"><a href="#单机器人运行规划" class="headerlink" title="单机器人运行规划"></a>单机器人运行规划</h3><h3 id="多机器人-路径规划"><a href="#多机器人-路径规划" class="headerlink" title="多机器人 路径规划"></a>多机器人 路径规划</h3><h3 id="任务设计"><a href="#任务设计" class="headerlink" title="任务设计"></a>任务设计</h3><ol><li>单任务 (离线 模式) 路径规划</li><li>在线模式, 单机路径规划 连续运行</li></ol><h3 id="不同算法-运行仿真"><a href="#不同算法-运行仿真" class="headerlink" title="不同算法 运行仿真"></a>不同算法 运行仿真</h3><h2 id="5-总结与展望"><a href="#5-总结与展望" class="headerlink" title="5.总结与展望"></a>5.总结与展望</h2>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PSO </tag>
            
            <tag> robot </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssr的pac中加入学校图书馆数据库访问pac</title>
      <link href="/2020/02-29/ssr%E7%9A%84pac%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%AD%A6%E6%A0%A1%E5%9B%BE%E4%B9%A6%E9%A6%86%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AEpac.html"/>
      <url>/2020/02-29/ssr%E7%9A%84pac%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%AD%A6%E6%A0%A1%E5%9B%BE%E4%B9%A6%E9%A6%86%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AEpac.html</url>
      
        <content type="html"><![CDATA[<p>在家的时候, 需要使用代理, 同时要使用图书馆的数据库, 两个代理有点冲突, 自己研究了一下<br>ssr 的规则, 发现比较简单.</p><p>可以页面后贴出的代码进行研究 <a href="https://gist.github.com/SChen1024/f908a9deeabf1cca78532344abdd24b6" target="_blank" rel="noopener">pac.txt</a></p><p>pac 的内部完全就是 js 的语法逻辑, 不是十分熟悉, 写的有点硬, 可以自己考虑优化</p><p>执行从 <code>FindProxyForURL</code> 开始执行, 然后根据具体内容进行代理访问</p><p>按照学校代理的判断方式,  判断一个 url 是否符合图书馆给出的pac 地址,<br>将访问数据库的链接,执行 <code>PROXY proxy2.lib.whu.edu.cn:81</code> 代理链接, 第一次建立链接的时候, 需要使用图书馆 帐号密码进行验证, </p><p>剩余的链接进行 ssr 验证, 进行正常的代理 执行过程. </p><a id="more"></a><h2 id="代码demo"><a href="#代码demo" class="headerlink" title="代码demo"></a>代码demo</h2><!-- Get UTF-8 Size (ANSI C) --><!-- Begin --><p><script src="https://gist.github.com/SChen1024/f908a9deeabf1cca78532344abdd24b6.js"></script><br><!-- End --></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.cnblogs.com/XYDsoft/p/9321311.html" target="_blank" rel="noopener">PAC代理语法含义与书写规范</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> SSR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> proxy </tag>
            
            <tag> SSR </tag>
            
            <tag> pac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo_docker</title>
      <link href="/2020/02-22/hexo-docker.html"/>
      <url>/2020/02-22/hexo-docker.html</url>
      
        <content type="html"><![CDATA[<h2 id="docker-hexo-环境配置"><a href="#docker-hexo-环境配置" class="headerlink" title="docker hexo 环境配置"></a>docker hexo 环境配置</h2><p>安装以下软件</p><ul><li style="list-style: none"><input type="checkbox"> node</li><li style="list-style: none"><input type="checkbox"> yarn</li><li style="list-style: none"><input type="checkbox"> hexo-cli</li><li style="list-style: none"><input type="checkbox"> git</li></ul><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>latex-图文并排</title>
      <link href="/2020/02-20/latex-%E5%9B%BE%E7%89%87%E5%B9%B6%E6%8E%92.html"/>
      <url>/2020/02-20/latex-%E5%9B%BE%E7%89%87%E5%B9%B6%E6%8E%92.html</url>
      
        <content type="html"><![CDATA[<h2 id="Latex-图文并排"><a href="#Latex-图文并排" class="headerlink" title="Latex 图文并排"></a>Latex 图文并排</h2><p>我们在论文中进行论文混排的时候, 主要有三种,</p><ul><li>单图插入</li><li>双图并列</li><li>多图混排</li></ul><p>我们主要使用的图片排版工具包是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\usepackage&#123;graphicx&#125;</span><br><span class="line">\usepackage&#123;subfigure&#125;</span><br></pre></td></tr></table></figure><h3 id="1-单图插入"><a href="#1-单图插入" class="headerlink" title="1. 单图插入"></a>1. 单图插入</h3><p>使用 <code>\begin{figure}</code> 作为环境的开始, 使用 <code>\includegraphics</code> 图片引入, 并进行尺寸设置<br>并能使用 <code>\caption</code> 做图片题注, 使用 <code>\label</code> 作为引用标识,</p><figure class="highlight tex"><figcaption><span>[latex 插入单图代码] [] [] []</span><a href="/downloads/code/latextemplate.tex">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">{figure}</span><span class="string">[!htbp]</span></span></span><br><span class="line">    <span class="tag">\<span class="name">centering</span></span></span><br><span class="line">    <span class="tag">\<span class="name">includegraphics</span><span class="string">[height=4.5cm,width=9.5cm]</span><span class="string">{dm_hb.png}</span></span></span><br><span class="line">    <span class="tag">\<span class="name">caption</span><span class="string">[图片短标题,显示在目录]</span><span class="string">{这里是显示在图片下面的长标题}</span></span></span><br><span class="line">    <span class="tag">\<span class="name">label</span><span class="string">{fig:1}</span></span>           <span class="comment">% 用于引用图片</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">{figure}</span></span></span><br></pre></td></tr></table></figure><h3 id="2-双图并列"><a href="#2-双图并列" class="headerlink" title="2. 双图并列"></a>2. 双图并列</h3><p>双图并列 一半有两种</p><ol><li>两个单独的图展示 不共享标题</li><li>一个图里面的 abc 子图 共享统一标题 可单独子标题</li></ol><figure class="highlight tex"><figcaption><span>[latex 双图并列] [] [] []</span><a href="/downloads/code/latextemplate.tex">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2. 双图并列展示, 分别使用 abc  来标识子图</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">{figure}</span><span class="string">[!htbp]</span></span></span><br><span class="line">    <span class="tag">\<span class="name">centering</span></span></span><br><span class="line">    <span class="tag">\<span class="name">subfigure</span><span class="string">[pic1.1111111111111]</span><span class="string">{</span></span></span><br><span class="line"><span class="tag"><span class="string">        \begin{minipage}</span><span class="string">[t]</span><span class="string">{0.5\linewidth}</span></span></span><br><span class="line">            <span class="tag">\<span class="name">centering</span></span></span><br><span class="line">            <span class="tag">\<span class="name">includegraphics</span><span class="string">[width=\textwidth]</span><span class="string">{dm_hb.png}</span></span></span><br><span class="line">        <span class="tag">\<span class="name">end</span><span class="string">{minipage}</span></span><span class="comment">%</span></span><br><span class="line">    }<span class="comment">%</span></span><br><span class="line">    <span class="tag">\<span class="name">subfigure</span><span class="string">[pic2. 2222222]</span><span class="string">{</span></span></span><br><span class="line"><span class="tag"><span class="string">        \begin{minipage}</span><span class="string">[t]</span><span class="string">{0.5\linewidth}</span></span></span><br><span class="line">            <span class="tag">\<span class="name">centering</span></span></span><br><span class="line">            <span class="tag">\<span class="name">includegraphics</span><span class="string">[width=\linewidth]</span><span class="string">{dm_hb.png}</span></span></span><br><span class="line">        <span class="tag">\<span class="name">end</span><span class="string">{minipage}</span></span><span class="comment">%</span></span><br><span class="line">    }<span class="comment">%</span></span><br><span class="line">    <span class="tag">\<span class="name">caption</span><span class="string">{总图的标识}</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">{figure}</span></span></span><br></pre></td></tr></table></figure><h3 id="3-4-图栅格布局"><a href="#3-4-图栅格布局" class="headerlink" title="3. 4 图栅格布局"></a>3. 4 图栅格布局</h3><p>注意 第 2 个和第 3 个图之间 加入一个换行, 保证图片 强制换行显示<br><figure class="highlight tex"><figcaption><span>[latex 双图并列] [] [] []</span><a href="/downloads/code/latextemplate.tex">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">{figure}</span><span class="string">[!htbp]</span></span></span><br><span class="line">    <span class="tag">\<span class="name">centering</span></span></span><br><span class="line">    <span class="tag">\<span class="name">subfigure</span><span class="string">[pic1.1111111111111]</span><span class="string">{</span></span></span><br><span class="line"><span class="tag"><span class="string">        \begin{minipage}</span><span class="string">[t]</span><span class="string">{0.5\linewidth}</span></span></span><br><span class="line">            <span class="tag">\<span class="name">centering</span></span></span><br><span class="line">            <span class="tag">\<span class="name">includegraphics</span><span class="string">[width=\textwidth]</span><span class="string">{dm_hb.png}</span></span></span><br><span class="line">        <span class="tag">\<span class="name">end</span><span class="string">{minipage}</span></span><span class="comment">%</span></span><br><span class="line">    }<span class="comment">%</span></span><br><span class="line">    <span class="tag">\<span class="name">subfigure</span><span class="string">[pic2. 2222222]</span><span class="string">{</span></span></span><br><span class="line"><span class="tag"><span class="string">        \begin{minipage}</span><span class="string">[t]</span><span class="string">{0.5\linewidth}</span></span></span><br><span class="line">            <span class="tag">\<span class="name">centering</span></span></span><br><span class="line">            <span class="tag">\<span class="name">includegraphics</span><span class="string">[width=\linewidth]</span><span class="string">{dm_hb.png}</span></span></span><br><span class="line">        <span class="tag">\<span class="name">end</span><span class="string">{minipage}</span></span><span class="comment">%</span></span><br><span class="line">    }<span class="comment">%</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">\<span class="name">subfigure</span><span class="string">[pic1.333333333333333]</span><span class="string">{</span></span></span><br><span class="line"><span class="tag"><span class="string">        \begin{minipage}</span><span class="string">[t]</span><span class="string">{0.5\linewidth}</span></span></span><br><span class="line">            <span class="tag">\<span class="name">centering</span></span></span><br><span class="line">            <span class="tag">\<span class="name">includegraphics</span><span class="string">[width=\textwidth]</span><span class="string">{dm_hb.png}</span></span></span><br><span class="line">        <span class="tag">\<span class="name">end</span><span class="string">{minipage}</span></span><span class="comment">%</span></span><br><span class="line">    }<span class="comment">%</span></span><br><span class="line">    <span class="tag">\<span class="name">subfigure</span><span class="string">[pic2. 44444444444]</span><span class="string">{</span></span></span><br><span class="line"><span class="tag"><span class="string">        \begin{minipage}</span><span class="string">[t]</span><span class="string">{0.5\linewidth}</span></span></span><br><span class="line">            <span class="tag">\<span class="name">centering</span></span></span><br><span class="line">            <span class="tag">\<span class="name">includegraphics</span><span class="string">[width=\linewidth]</span><span class="string">{dm_hb.png}</span></span></span><br><span class="line">        <span class="tag">\<span class="name">end</span><span class="string">{minipage}</span></span><span class="comment">%</span></span><br><span class="line">    }<span class="comment">%</span></span><br><span class="line">    <span class="tag">\<span class="name">caption</span><span class="string">{总图的标识}</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">{figure}</span></span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="代码样例"><a href="#代码样例" class="headerlink" title="代码样例"></a>代码样例</h2><p>此处给出 <a href="https://www.overleaf.com/read/qsbrgsmcdsxp" target="_blank" rel="noopener">Overleaf Latex 图文混排 MWE</a> 的最小工程, 可以在线查看运行</p><p>或者复制 下面的代码进行运行</p><figure class="highlight tex"><figcaption><span>[latex 图文混排 代码实例] []</span><a href="/downloads/code/latextemplate.tex">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">{article}</span></span></span><br><span class="line"><span class="comment">% 中文包</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">[UTF8]</span><span class="string">{ctex}</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 导言区</span></span><br><span class="line"><span class="comment">% 图片排版工具</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">{graphicx}</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">{subfigure}</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">{float}</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">{subfigure}</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">title</span><span class="string">{Latex模板}</span></span></span><br><span class="line"><span class="tag">\<span class="name">author</span><span class="string">{SChen1024 }</span></span></span><br><span class="line"><span class="tag">\<span class="name">date</span><span class="string">{March 2020}</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">{document}</span></span></span><br><span class="line"><span class="comment">% \maketitle</span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">section</span><span class="string">{latex 图片布局}</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">subsection</span><span class="string">{单图}</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">{figure}</span><span class="string">[!htbp]</span></span></span><br><span class="line">    <span class="tag">\<span class="name">centering</span></span></span><br><span class="line">    <span class="tag">\<span class="name">includegraphics</span><span class="string">[height=4.5cm,width=9.5cm]</span><span class="string">{dm_hb.png}</span></span></span><br><span class="line">    <span class="tag">\<span class="name">caption</span><span class="string">[图片短标题,显示在目录]</span><span class="string">{这里是显示在图片下面的长标题}</span></span></span><br><span class="line">    <span class="tag">\<span class="name">label</span><span class="string">{fig:1}</span></span>           <span class="comment">% 用于引用图片</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">{figure}</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">subsection</span><span class="string">{双图并排}</span></span></span><br><span class="line"></span><br><span class="line">1. 双图并列展示, 算是不同的图</span><br><span class="line"><span class="comment">% 文档中添加</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">{figure}</span><span class="string">[!htbp]</span></span></span><br><span class="line">true<span class="tag">\<span class="name">begin</span><span class="string">{minipage}</span><span class="string">[t]</span><span class="string">{0.5\linewidth}</span></span></span><br><span class="line">truetrue<span class="tag">\<span class="name">centering</span></span></span><br><span class="line">truetrue<span class="tag">\<span class="name">includegraphics</span><span class="string">[width=\textwidth]</span><span class="string">{dm_hb.png}</span></span></span><br><span class="line">truetrue<span class="tag">\<span class="name">caption</span><span class="string">{测试图1}</span></span></span><br><span class="line">truetrue<span class="tag">\<span class="name">label</span><span class="string">{fig:1}</span></span></span><br><span class="line">true<span class="tag">\<span class="name">end</span><span class="string">{minipage}</span></span></span><br><span class="line">true<span class="tag">\<span class="name">begin</span><span class="string">{minipage}</span><span class="string">[t]</span><span class="string">{0.5\linewidth}</span></span></span><br><span class="line">truetrue<span class="tag">\<span class="name">centering</span></span></span><br><span class="line">truetrue<span class="tag">\<span class="name">includegraphics</span><span class="string">[width=\textwidth]</span><span class="string">{dm_hb.png}</span></span></span><br><span class="line">truetrue<span class="tag">\<span class="name">caption</span><span class="string">{测试图2}</span></span></span><br><span class="line">truetrue<span class="tag">\<span class="name">label</span><span class="string">{fig:2}</span></span></span><br><span class="line">true<span class="tag">\<span class="name">end</span><span class="string">{minipage}</span></span> <span class="tag">\<span class="name">\</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">{figure}</span></span></span><br><span class="line"></span><br><span class="line">2. 双图并列展示, 分别使用 abc  来标识子图</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">{figure}</span><span class="string">[!htbp]</span></span></span><br><span class="line">    <span class="tag">\<span class="name">centering</span></span></span><br><span class="line">    <span class="tag">\<span class="name">subfigure</span><span class="string">[pic1.1111111111111]</span><span class="string">{</span></span></span><br><span class="line"><span class="tag"><span class="string">        \begin{minipage}</span><span class="string">[t]</span><span class="string">{0.5\linewidth}</span></span></span><br><span class="line">            <span class="tag">\<span class="name">centering</span></span></span><br><span class="line">            <span class="tag">\<span class="name">includegraphics</span><span class="string">[width=\textwidth]</span><span class="string">{dm_hb.png}</span></span></span><br><span class="line">        <span class="tag">\<span class="name">end</span><span class="string">{minipage}</span></span><span class="comment">%</span></span><br><span class="line">    }<span class="comment">%</span></span><br><span class="line">    <span class="tag">\<span class="name">subfigure</span><span class="string">[pic2. 2222222]</span><span class="string">{</span></span></span><br><span class="line"><span class="tag"><span class="string">        \begin{minipage}</span><span class="string">[t]</span><span class="string">{0.5\linewidth}</span></span></span><br><span class="line">            <span class="tag">\<span class="name">centering</span></span></span><br><span class="line">            <span class="tag">\<span class="name">includegraphics</span><span class="string">[width=\linewidth]</span><span class="string">{dm_hb.png}</span></span></span><br><span class="line">        <span class="tag">\<span class="name">end</span><span class="string">{minipage}</span></span><span class="comment">%</span></span><br><span class="line">    }<span class="comment">%</span></span><br><span class="line">    <span class="tag">\<span class="name">caption</span><span class="string">{总图的标识}</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">{figure}</span></span></span><br><span class="line"></span><br><span class="line">3. 四张图片的排列</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">{figure}</span><span class="string">[!htbp]</span></span></span><br><span class="line">    <span class="tag">\<span class="name">centering</span></span></span><br><span class="line">    <span class="tag">\<span class="name">subfigure</span><span class="string">[pic1.1111111111111]</span><span class="string">{</span></span></span><br><span class="line"><span class="tag"><span class="string">        \begin{minipage}</span><span class="string">[t]</span><span class="string">{0.5\linewidth}</span></span></span><br><span class="line">            <span class="tag">\<span class="name">centering</span></span></span><br><span class="line">            <span class="tag">\<span class="name">includegraphics</span><span class="string">[width=\textwidth]</span><span class="string">{dm_hb.png}</span></span></span><br><span class="line">        <span class="tag">\<span class="name">end</span><span class="string">{minipage}</span></span><span class="comment">%</span></span><br><span class="line">    }<span class="comment">%</span></span><br><span class="line">    <span class="tag">\<span class="name">subfigure</span><span class="string">[pic2. 2222222]</span><span class="string">{</span></span></span><br><span class="line"><span class="tag"><span class="string">        \begin{minipage}</span><span class="string">[t]</span><span class="string">{0.5\linewidth}</span></span></span><br><span class="line">            <span class="tag">\<span class="name">centering</span></span></span><br><span class="line">            <span class="tag">\<span class="name">includegraphics</span><span class="string">[width=\linewidth]</span><span class="string">{dm_hb.png}</span></span></span><br><span class="line">        <span class="tag">\<span class="name">end</span><span class="string">{minipage}</span></span><span class="comment">%</span></span><br><span class="line">    }<span class="comment">%</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">\<span class="name">subfigure</span><span class="string">[pic1.333333333333333]</span><span class="string">{</span></span></span><br><span class="line"><span class="tag"><span class="string">        \begin{minipage}</span><span class="string">[t]</span><span class="string">{0.5\linewidth}</span></span></span><br><span class="line">            <span class="tag">\<span class="name">centering</span></span></span><br><span class="line">            <span class="tag">\<span class="name">includegraphics</span><span class="string">[width=\textwidth]</span><span class="string">{dm_hb.png}</span></span></span><br><span class="line">        <span class="tag">\<span class="name">end</span><span class="string">{minipage}</span></span><span class="comment">%</span></span><br><span class="line">    }<span class="comment">%</span></span><br><span class="line">    <span class="tag">\<span class="name">subfigure</span><span class="string">[pic2. 44444444444]</span><span class="string">{</span></span></span><br><span class="line"><span class="tag"><span class="string">        \begin{minipage}</span><span class="string">[t]</span><span class="string">{0.5\linewidth}</span></span></span><br><span class="line">            <span class="tag">\<span class="name">centering</span></span></span><br><span class="line">            <span class="tag">\<span class="name">includegraphics</span><span class="string">[width=\linewidth]</span><span class="string">{dm_hb.png}</span></span></span><br><span class="line">        <span class="tag">\<span class="name">end</span><span class="string">{minipage}</span></span><span class="comment">%</span></span><br><span class="line">    }<span class="comment">%</span></span><br><span class="line">    <span class="tag">\<span class="name">caption</span><span class="string">{总图的标识}</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">{figure}</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">{document}</span></span></span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li><p><a href="https://www.latexstudio.net/archives/10174.html" target="_blank" rel="noopener">LaTeX 技巧 901：驯化 LaTeX 页面布局</a></p></li><li><p><a href="https://vvingerfly.github.io/2018/02-16-Tex-imageTypesetting/" target="_blank" rel="noopener">LaTeX 文档多图排版</a></p></li><li><p><a href="https://blog.csdn.net/chen134225/article/details/79206364" target="_blank" rel="noopener">LaTeX 如何让两张图并排显示？</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
            <tag> overleaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>罗盘校准</title>
      <link href="/2020/01-06/%E7%BD%97%E7%9B%98%E6%A0%A1%E5%87%86%E8%AE%BE%E8%AE%A1.html"/>
      <url>/2020/01-06/%E7%BD%97%E7%9B%98%E6%A0%A1%E5%87%86%E8%AE%BE%E8%AE%A1.html</url>
      
        <content type="html"><![CDATA[<h2 id="罗盘校准过程"><a href="#罗盘校准过程" class="headerlink" title="罗盘校准过程"></a>罗盘校准过程</h2><ol><li>打开串口</li><li>发送定时校准命令<blockquote><p>设定校准时间 1 分钟<br>回复 68 05 00 08 00 0D</p></blockquote></li><li>接收校准进度</li><li>输出残差</li></ol><h2 id="罗盘校准状态表示"><a href="#罗盘校准状态表示" class="headerlink" title="罗盘校准状态表示"></a>罗盘校准状态表示</h2><ol><li>串口未打开 –&gt; 打开串口 –&gt; flg -1</li><li>未开始校准 -&gt; 发送定时校准命令 0</li><li>校准中 -&gt; 校准进度中</li><li>校准完成 或者 定时时间到 –&gt; 校准结束 -&gt; 校准残差-&gt; 校准结果<br>5.</li></ol><h2 id="校准设计"><a href="#校准设计" class="headerlink" title="校准设计"></a>校准设计</h2><ol start="0"><li>点击校准进入校准界面, 初始化按钮显示,状态显示, 串口数据框内容,</li><li>选择串口参数, 点击打开串口 串口打开, 设计定时器, 循环读取串口数据</li><li>查看接收到的数据的命令位命令, 根据收到的命令一起当前状态更新串口状态,</li><li>直到收到结果表示罗盘校准完成, 结束校准</li></ol><h2 id="罗盘校准流程图"><a href="#罗盘校准流程图" class="headerlink" title="罗盘校准流程图"></a>罗盘校准流程图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant UI as 界面UI</span><br><span class="line">    participant Serial as 串口</span><br><span class="line">    participant Compass as 电子罗盘</span><br><span class="line">    participant Status as 校准状态</span><br><span class="line"></span><br><span class="line">    Note over Status: 0: 串口未开启</span><br><span class="line">    UI -&gt;&gt;+ Serial: 打开串口</span><br><span class="line">    Note over Status: 1: 连续接收模式</span><br><span class="line">    opt 连续接收到数据</span><br><span class="line">        Serial -&gt;&gt; Compass: [停止连续发送模式]</span><br><span class="line">    end</span><br><span class="line">    Note over Status: 2: 交互模式</span><br><span class="line"></span><br><span class="line">    UI -&gt;&gt; Serial: 一分钟校准</span><br><span class="line">    Serial -&gt;&gt; Compass: [定时一分钟校准]</span><br><span class="line">    Note over Status: 3: 校准模式</span><br><span class="line">    loop 读取电子罗盘数据</span><br><span class="line">        Compass -&gt;&gt; Serial: [回复指令]</span><br><span class="line"></span><br><span class="line">        opt Recv Data</span><br><span class="line">            Note over Serial: 查看关键命令字</span><br><span class="line">            alt 0x08 &amp;&amp; Status &#x3D;&#x3D; 3</span><br><span class="line">                # Serial -&gt;&gt; UI: 进入校准模式</span><br><span class="line">                Note over Serial: 进入校准模式</span><br><span class="line">            else 0xF9</span><br><span class="line">                Note over Status: 4: 校准中</span><br><span class="line">                Note over Serial: 校准中 更新接收</span><br><span class="line">                # Serial -&gt;&gt; Serial: 校准中 更新接收进度</span><br><span class="line">                Compass -&gt;&gt; Compass: 进行26点椭球拟合旋转</span><br><span class="line">            else 0xA8</span><br><span class="line">                Note over Status: 5: 校准结果</span><br><span class="line">                # Serial -&gt;&gt; UI: 显示校准残差</span><br><span class="line">                Note over Serial: 校准残差</span><br><span class="line">            else 0x08 &amp;&amp; Status &#x3D;&#x3D; 5</span><br><span class="line">                Note over Status: 6: 校准完成</span><br><span class="line">                # Serial -&gt;&gt; UI: 显示校准结果</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">                Serial -&gt;&gt; UI: 在文本框中显示回复指令</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    UI -&gt;&gt;- Serial: 校准完成</span><br><span class="line">    Note over Status: -1: 清理结果</span><br><span class="line">    Note over UI: 返回操作界面</span><br></pre></td></tr></table></figure><p><img src="/2020/01-06/%E7%BD%97%E7%9B%98%E6%A0%A1%E5%87%86%E8%AE%BE%E8%AE%A1/mermaid-diagram.svg" alt="校准流程图"></p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Serial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>留在武汉最后一次跨年</title>
      <link href="/2019/12-30/%E7%95%99%E5%9C%A8%E6%AD%A6%E6%B1%89%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E8%B7%A8%E5%B9%B4.html"/>
      <url>/2019/12-30/%E7%95%99%E5%9C%A8%E6%AD%A6%E6%B1%89%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E8%B7%A8%E5%B9%B4.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="7960cc981ad2306952eea6dddd7e837f059473ee0556f773a7be7418209fc310">1f5024e433107eb5a80a7f49b7f501c347c667e9bbafc6cf2aeb8ef8441281c0c94c9e8b5822840f2ee3cd19a8562ebdea5d4809f89c40927e7b9c1551e052a06fee57c67c9e39325a5f8d65c1a591b6fa2d5688cc41a7d94ec8506d17e86574de077f8c014dab0276e929030fd7b0ee93821e9c7a8e11d17daf1b7b3e3365ff142705adafb396a6161b804dd8058d3b257d5b9d95ec98f465be36ed537b927456490ad1cdd2a475362263ad4968e9b5fabbf9493ed98d859ef3e2f38e6965dce7225720315e36864f7d474da5e69e1f1397edd6e42e499b80386265b93609d007fb4f517370a10a5c5372ee202c1173a56fafd74d4e6947b68659107185f90bf7f566d825d95922debbf4457bc0f2ce6d7490d24d711cba1915253bd3ba5e016ee65cee2fb83b91d7cb7f99ed4f8c31c98216084022453f3c7e006b1ca5ee9c4a7753cf383bdd7d3360fafed65fdedde6b2dd1b74faf5bb386e1374cc1a5da55060b61983afa0191a29667554c0615538453027215ee8a31cffe200b5e0344a103ab941fdbc5d0bff91bd9b9c45bc65b9770d8b46f8ebc211555dc2acc60b78ee033e208d3d656dfafa9762a33cc6d3632ad3d334ae9dedcf208e79f7a93134fd1e733ec4cf55a97d4c7d2347e4edb6cfa471fce90a65bab83924359b36760d30d4209eec975cb068214cf7bee3fc4f8a298201f31d81caf62196eb157c2711158cd0b8a1dd45234de632a0811a767a77cbd24856e34813a459f4addd1e129127c9ceb9d74652ffc9cab07accf149bdea5b1ee3cb56ad4bb858020be25395f78c2f63a4ab908e9ebde76d19a980976ab3ea3ca58883138a6de11fe53b055dc39c29345155d75ece38cef8a05aef102d4d15c979d816d4f4871366b3d30e1d4db84811b03fbd6ba29c04b89516870af9db16c20b33c7c13b9cafad2294e45710ffee8b605213a692a57f43b388d53567eac302e6a85cf8c1d413e3385e024d6fad8be417aa06c2449ec8ec23aa669f6febdd3ddabec8dc08f21ebcc236f7e92a34d6f921ed66e143d8dbb4a89c59d6791b92f8ecbfac1de6f28a81ae0c518b3092fb577f433b5dc0dc53dd80a69fad5e414580f6c462ead1e8e163e6baf5cdf84429f39b3122420e796ec539f89dfc995ac209ed08b6450655601e700652d21721d6ae8b749b0b10360b481a3bb2262c39037510248f16cf17ecc1b5d43f0f2c045ee4d8e6385c1aae58903d20fe84821c9180b1be3226d609c4bdffbc724ac2fa4f52ee5c296678ad20b7afa95b630ea1ec7a0c95f7950741c616d5d89e22a9fcc34af1073803f6540457bd7b4ef98d3cce530650b0bcae7da464173fe06b40e2d0a1d01169f57b5691948e1a1fffeaa9362034f5823221a187bcc2ab2b61157518e644180d9650ed599cf5897cdb17bc742eb0ed972db0556628b759b54cfca00e25137d456669ff3538ccc31257ceb7a1f1798be2ae95345afc3f3157ee5cb6d103b73cf3e9d3feca98a177bd059d42320f0e878899da582fe6dbf16de2b9aa08149a5bfab52ee7ab2f7723e423b779aedde767871fddc5809de992cbb00fbe91b3758cffda7760f892133885db35d79de62d62613d010996a65a5cfcb243c1915dd7337435255f30b0d0e1f0590d2943b432bc6c4f0a63c14cb6c1b2c4fddade0681d13b32e9672d5410fdd39d5869420764ac7c3f7fcf40a42b1de7343902d0e4ef9b5afb6d97b6b0bd08644cc2b56b18e106369a6a6d192ed8e286e85d1e4987a8a99c026e5ba83e4f9a896a113e5707c6345486de6c4a1d6745f5f3297e294ac597b952f635cf5d4fe9d2f143108daaa9f0f776985113844070714cc205e79f6d20446b6a410c988d6f8e807c06d5b0dd850b8fe4a39e01fb438b9b3138104fedcf3f9fa6c646306d37d59582cefb533544d4dc487bcdbbc1a14c66c513653f35018854f3ba5356510e3b95b7e36f4aa3a3970a59da897a109d5e1b6cd4c5f8973717b384972de5f9a2e3f6012e70bacbd80174266e90d7cb1d26e49877571fc58c91921a24c0f9d5d750278c289f1434138310dfc25a586268295d838bda9ec8bd7a7310cdb9514a0dfb433b31c4bdd590899be48f5b865e773274b59d3136360f09215bd117d160e033ca0a9e9054336c0c86b9206ce8c83d2ca9131aa30d1bbbd81c3b53613fffee18da0435dd8f8513b8c4ef939a9f40be759680</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Person </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hide </tag>
            
            <tag> Wuhan </tag>
            
            <tag> 2019 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python读取txt批量创建文件</title>
      <link href="/2019/12-30/python%E8%AF%BB%E5%8F%96txt%E6%89%B9%E9%87%8F%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6.html"/>
      <url>/2019/12-30/python%E8%AF%BB%E5%8F%96txt%E6%89%B9%E9%87%8F%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6.html</url>
      
        <content type="html"><![CDATA[<p>前几天有个小问题,  需要批量建立很多文件夹,, 所以手动写了个小的脚本, 后续可以直接使用</p><p>读取目录文件, 然后直接创建相应的文件</p><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路:"></a>基本思路:</h2><ol><li>就是读取用户输入参数, 获取所在路径以及所要命名的后缀</li><li>获取txt所在路径, 得到同级目录</li><li>读取txt 的每一行 并计数得到数字</li><li>根据同级目录拼接路径, 创建文件(如果存在不覆盖)</li><li>输出结果</li></ol><a id="more"></a><h2 id="代码demo"><a href="#代码demo" class="headerlink" title="代码demo"></a>代码demo</h2><!-- Get UTF-8 Size (ANSI C) --><!-- Begin --><p><script src="https://gist.github.com/SChen1024/86a70fb31d2ecbb4092c6c70b1270352.js"></script><br><!-- End --></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入 指定 txt 文件路径, 创建文件的后缀 txt js</span></span><br><span class="line"><span class="comment"># 读取指定文件的txt 文档</span></span><br><span class="line"><span class="comment"># 在 txt 的同级目录下面建立相应的文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ReadArg</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">     通过sys模块来识别参数demo, http://blog.csdn.net/ouyang_peng/</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">'参数个数为:'</span>, len(sys.argv), <span class="string">'个参数。'</span>)</span><br><span class="line">    print(<span class="string">'参数列表:'</span>, str(sys.argv))</span><br><span class="line">    print(<span class="string">'脚本名为：'</span>, sys.argv[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(sys.argv)):</span><br><span class="line">        print(<span class="string">'参数 %s 为：%s'</span> % (i, sys.argv[i]))</span><br><span class="line">    <span class="keyword">return</span> sys.argv</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ReadTxtLists</span><span class="params">(file)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    读物 txt 文件中的文件列表</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    res =[]</span><br><span class="line">    <span class="keyword">with</span> open(file,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            line.strip(<span class="string">'\n'</span>)</span><br><span class="line">            line = <span class="string">''</span>.join(line.split())</span><br><span class="line">            res.append(line)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CreateFile</span><span class="params">(file)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(file, <span class="string">'a'</span>):</span><br><span class="line">        os.utime(file,<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    argv = ReadArg()</span><br><span class="line">    suffix = <span class="string">"txt"</span>     <span class="comment"># 默认后缀</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 只有两个参数表示没有 给后缀名</span></span><br><span class="line">    <span class="keyword">if</span>(len(argv) &gt;= <span class="number">3</span>):</span><br><span class="line">        suffix = argv[<span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    file_name= argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取得到所有的文件名</span></span><br><span class="line">    files = ReadTxtLists(file_name)</span><br><span class="line"></span><br><span class="line">    (filepath, filename) = os.path.split(file_name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计数 生成拼接文件 </span></span><br><span class="line">    <span class="comment"># 最终创建文件 如果存在 不更新文件</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        file_str = filepath + <span class="string">"\\"</span> + str(cnt).zfill(<span class="number">2</span>) + <span class="string">"_"</span> + file + <span class="string">"."</span> + suffix</span><br><span class="line">        CreateFile(file_str)</span><br><span class="line">        print(file_str+<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> batch </tag>
            
            <tag> file </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在圣诞之前-认识一个月有感</title>
      <link href="/2019/12-24/%E5%86%99%E5%9C%A8%E5%9C%A3%E8%AF%9E%E4%B9%8B%E5%89%8D-%E8%AE%A4%E8%AF%86%E4%B8%80%E4%B8%AA%E6%9C%88%E6%9C%89%E6%84%9F.html"/>
      <url>/2019/12-24/%E5%86%99%E5%9C%A8%E5%9C%A3%E8%AF%9E%E4%B9%8B%E5%89%8D-%E8%AE%A4%E8%AF%86%E4%B8%80%E4%B8%AA%E6%9C%88%E6%9C%89%E6%84%9F.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="bdfe3c44708a46d559cb5ba13717e7ecfacb309d3c486c68b060742afcbbb6ef">58812020a0f934cbbe22f69d846c1c44bdfc7de83ea57fcba7d59a1cc91d33ea90fd971c1c029317624c4c5a3e84e6c87c7d5df96e400a059ccc5d35840843b30c485ca467fff07dd4d6d1f2034c1889d804fa562cf657312fd6bc670e30a8983766babd39e82a0e53d969b00fd101337f5c0b4385bd8ecfa435a3826964ef73d40e915d718ef62d8f07657a0e3df6da3837190bec398d2a13acc09d3a33e0cc7680a93e99c676989dbb9d723e4733e7bf8daf63f0ce2ae1a1bf7af0dc72bfb5b5009abea483c05dbc02ed9fc9ad1b112645635dcb4111a340e9313b757c98efad19603d33574fd1e29aacfdd6a92b213c4ac145d80d362bab38fd4e242b8b68dc6b32aa43d6124dc8380c98e61b0ff37fd19fb6b5fa6fc001f3071fe575e3e2a6d68a6d41fcea57a33c382387e3496c5ac3d4edecce9c624b03d5401303738290df9802decba3dd2e1eb396d78d47c22e87338be8d41b3d21ea8c32786aa7890f750589d80d45b471747719949c5e432b17dd4daebe358668f0cbfd73e32f5985c6e5c79d2ad6786719cbd862821a3a84f5839f5acbe89971d36a0bf15376be2728bf3f5b05b12602f707f4e40bce07f8c8c561ec38061d4e91e5a1a032d69427ecb60240039648285a9ea6310f73af478dfd2834f203f545ebca482d572bc597cc60d181dccebf42be9d1aa99a8f1f777bb1a8cb30ed5693b9ab5a349847e575bf9f2af06cb9be4cf09eb1f74fc2984f91ba6490e1c1a57927f611e78d969b62394655f8af21f0f6e601559fe12022ca8b1f15d822b2636bcdb51d3d01ea5091fcd0dccd97908cf94932895fe33361008df5aab616b5151dd693c442759e2783e782c8aa6e301bde219e2edd8c931c7095a9cbda410feed1fac848b0e40e9892bfeadeeb1067dbcfd2336ae362e5e018a3ebdb979755e3d497d2546a1210f597e290f04994ebfaf743e7af6f56e06bd09246f436152b5c1528537a068a534b27071a3d613bbac3e16e8cf6e912586598ef4cacf9a2c92f87d10a13e1adebe6b7a3780db847e8db5a5f41826c4c367ba0236094a8f0357efafc864a12fb1006583ac6da3024837525ff94ae949b07afd3391093adfd537b0116cd6e3b8915e06edcfa3844d17d2d05e7f2976c2657de6f966b48827e96bfdee6c1878cf4287d6328351afb9e13290fbc687a2c999f518586490a76d70e457b443da8e4dab51c3f817ee42d1ee1101db34698fbdf74371960da5ae3265a36846f039365e13a3cf3d7929f9fb873659838655d7ae79bf6c1fc31290c66c88ecd1053ee55a0cc6401a1436b168c869244d5a97dc9dd3557ff9025c7da6f3fe2a6f2252c8d949ccc5e6c39bb2db9fbbe6de074d0400628239e674e35ee686d20f461356d3876c01204cb9160fc85ae12e2f8686ed358bd72c8aac011d2fcedb93012fbe63ac89e674151d775448b84aae65f8de251b90e1f270520a5c58a672d0a2d7efb15769daa01014c039627d75d48b3fb074ca918ea837965a7505c3dcb22270c3c52ac6de0290ce4738d68517d660a1c87449c4ea3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Person </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hide </tag>
            
            <tag> She </tag>
            
            <tag> Person </tag>
            
            <tag> Emotion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串口字符串-HEX格式</title>
      <link href="/2019/12-24/%E4%B8%B2%E5%8F%A3%E5%AD%97%E7%AC%A6%E4%B8%B2-HEX%E6%A0%BC%E5%BC%8F.html"/>
      <url>/2019/12-24/%E4%B8%B2%E5%8F%A3%E5%AD%97%E7%AC%A6%E4%B8%B2-HEX%E6%A0%BC%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>串口通信过程中 通常涉及一个数据的模拟过程以及数据发送过程, 一般来说, 我们会发送一串指令给下位机</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">68</span> <span class="number">05</span> <span class="number">00</span> <span class="number">84</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span></span><br></pre></td></tr></table></figure><p>例如这种, 我们明白 这是我们 将相应的字符转换成 hex 字符显示,用于表示 ascii 字母的使用, 但是在程序中 我们可以直接使用 字符串表示我们想写入的字符, 容纳后转换之后 串口数据相应的 ASCII 码的过程,</p><p>下面 介绍一下常用的转换函数</p><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>在我们的描述中,<br>首先给出一个 <img src="/2019/12-24/%E4%B8%B2%E5%8F%A3%E5%AD%97%E7%AC%A6%E4%B8%B2-HEX%E6%A0%BC%E5%BC%8F/ASCII.png" alt="ASCII码表"> 或者参考 <a href="https://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">Wikipedia ACII</a> 的详细介绍<br>此处我们均使用 “abc123” 作为字符串在各个里面的显示来表示</p><ol><li>字符串 string 指的是 “abc 123” 这种能用 ascii 表示的 能够打出来的字符, 由于我们部分字符不能打出来,或者说是 不可显示字符,只用于控制指令, 存在缺陷 string str = “abc123”</li><li>字符串数组 char [] uchar[] 指 cpp 中 的一种数据, 存放的 char 型或者 uchar 的字符, 我们可以使用 -128-127 或者 0-255 的数字表示, 我们暂时均认为是 uchar 的数组 便于后续处理 uchar buffer= {97,98,99,49,50,51}</li><li>字符串指针 char<em> uchar </em> 是类型指针,一般指向的是字符串数据的首地址,由于我们处理过程中 很多函数 认为 0x00 ‘\0’ 是结束,所以处理的时候尽量传入 长度 uchar *buffer = buffer</li><li>hex 字符串 将字符串数组里面的值转换成 16 进制的两位值,然后使用空格分割, 便于输入指令, 例如 string command=”61 62 63 31 32 33”</li></ol><p>这种合适各有优劣, 比如我们在常用的 Modbus 控制中 使用 这种控制命令发送到下位机, 一般直接在串口输入, 然后使用 hex 发送即可, 但是如果我们测试过程中 需要将相应的数据按照两位的段, 填入 txt 文本中, 每次读取一行数据, 然后将数据转换成 ascii 便能模拟 二进制流的输入输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">68</span> <span class="number">13</span> <span class="number">00</span> <span class="number">85</span> <span class="number">11</span> <span class="number">12</span> <span class="number">21</span> <span class="number">22</span> <span class="number">31</span> <span class="number">32</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">03</span> <span class="number">88</span> FF <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">0F</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="数据格式转换"><a href="#数据格式转换" class="headerlink" title="数据格式转换"></a>数据格式转换</h2><h3 id="1-uchar-数据和-char-字节数据的相互转换"><a href="#1-uchar-数据和-char-字节数据的相互转换" class="headerlink" title="1. uchar 数据和 char 字节数据的相互转换"></a>1. uchar 数据和 char 字节数据的相互转换</h3><p>char 类型的数据 -128-127, uchar 类型数据 0-255, 均是一个字节, char 类型的首位数据为符号位, 所以会存在从 127(0111 1111) +1 之后变成 -128(1000 0000) 的变换, 然后也会存在从-1(1111 1111) 到 0(0000 0000) 的变换, 详细可以搜索 <code>char 溢出</code> 与 <code>数据补码</code> 的相关内容,</p><p>所以 uchar -char 的相互变换可以考虑成 两个部分<br>uchar 的 [0, 127] == char [0,127]<br>ucahr 的 [128, 255] == char [-128,-1]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uchar 数据转换 char  &gt;127   c1-256</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Utils_String::UChar2Char</span><span class="params">(uchar c1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(c1 &gt; <span class="number">127</span> ? c1 - <span class="number">256</span> : c1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// char 类型转换 uchar  &lt;0 -- c1 +256</span></span><br><span class="line"><span class="function">uchar <span class="title">Utils_String::Char2UChar</span><span class="params">(<span class="keyword">char</span> c1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;uchar&gt;((c1 &lt; <span class="number">0</span> ? <span class="number">256</span> + c1 : c1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-hex-与数字的相互转换"><a href="#2-hex-与数字的相互转换" class="headerlink" title="2. hex 与数字的相互转换"></a>2. hex 与数字的相互转换</h3><p>一般的 hex 表示的 16 进制字符, 由于为了便于我们进行显示, 16 进制由 0-9 a-f 供给 16 个字符依次表示 0-15 , 此处暂时不考虑 大写字母, 大写的 A-F 等同于小写的 a-f,</p><p>由于 uchar 类型的数据在 0-256 之间, 正好可以表示成 2 个 16 进制字符来进行表示, 使用前缀字符 0x 表示 16 进制, 0o 表示 8 进制 0d 表示 10 进制 [0,255] ==[0x00,0xff]<br>我们建立一位字符 0-f 与 0-15 之间的转换, 有两种转换方式, 一种就是 if 判断进行强制转换, 另外一种 是使用 码表的排列进行一定 的优化处理</p><details><br><br><summary>1位hex 与num 的相互转换代码</summary><br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @fn  int Utils_String::Hex2Num(const char ch)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   根据 各种情况 转换字母  一位字母 大于 48 的 +9  然后取后4位的值</span></span><br><span class="line"><span class="comment"> * *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment"> * @date    2019/12/16</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   ch  The ch</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  An int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Utils_String::Hex2Num</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//int res = (ch &amp; '@' ? ch + 9 : ch) &amp; 0x0F;</span></span><br><span class="line">    <span class="comment">//LInfo("ch:&#123;&#125;,res:&#123;&#125;", ch, res);</span></span><br><span class="line">    <span class="keyword">return</span> (ch &amp; <span class="string">'@'</span> ? ch + <span class="number">9</span> : ch) &amp; <span class="number">0x0F</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @fn  char Utils_String::Num2Hex(int num, bool Up )</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   将 0-15 转换成 0-F</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment"> * @date    2019/12/18</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   num Number of</span></span><br><span class="line"><span class="comment"> * @param   Up  True to up</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  The total number of 2 hexadecimal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Utils_String::Num2Hex</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">bool</span> Up <span class="comment">/* = true */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> res;</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= <span class="number">10</span> &amp;&amp; num &lt;= <span class="number">15</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res = num - <span class="number">10</span> + (Up ? <span class="string">'A'</span> : <span class="string">'a'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        res = num + <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><summary>1位hex 与num 的相互转换代码</summary><br><br></details><details><br><br><summary>2位hex 与 uchar相互转换 </summary><br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @fn  uchar Utils_String::Hex2Uchar(const std::string &amp; str)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   Hexadecimal 2 uchar 将两个 hex 字符 转换成 0-256</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment"> * @date    2019/12/18</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   str The string 默认初始两位字符  FF == 255   00 = 0  0D = 14</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  An uchar</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">uchar <span class="title">Utils_String::Hex2Uchar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s:str)</span><br><span class="line">    &#123;</span><br><span class="line">        res = (res &lt;&lt; <span class="number">4</span>) + Hex2Num(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @fn  std::string Utils_String::Num2Hex(uchar num, bool Up)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   Number 2 hexadecimal  得到的结果只有 小写</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment"> * @date    2019/12/18</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   num Number of</span></span><br><span class="line"><span class="comment"> * @param   Up  True to up</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  The total number of 2 hexadecimal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Utils_String::Num2Hex</span><span class="params">(uchar num, <span class="keyword">bool</span> Up)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; t_base = &#123;</span><br><span class="line">    &#123; <span class="number">8</span>,<span class="string">'o'</span> &#125;,</span><br><span class="line">    &#123; <span class="number">10</span>,<span class="string">'d'</span> &#125;,</span><br><span class="line">    &#123; <span class="number">16</span>,<span class="string">'x'</span> &#125; &#125;;</span><br><span class="line">    <span class="keyword">if</span> (!t_base.count(base))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 sprintf 格式化输出, 将数字 转换成相应的进制值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> format = <span class="string">"%0"</span> + <span class="built_in">std</span>::to_string(width) + t_base.find(base)-&gt;second;</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, format.c_str(), num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> res=<span class="built_in">std</span>::<span class="built_in">string</span>(buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换大小写</span></span><br><span class="line">    <span class="keyword">return</span> Up ? StringUpper(res) : StringLowwer (res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details><h3 id="3-给定字符串转换成字符串数组"><a href="#3-给定字符串转换成字符串数组" class="headerlink" title="3. 给定字符串转换成字符串数组"></a>3. 给定字符串转换成字符串数组</h3><p>由于 原生的 string 存在字符转指针的转换<br>可以使用 原生的指针来处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @fn  const uchar * Utils_String::String2Uchar(const std::string &amp; str)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   String 2 uchar</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment"> * @date    2019/12/16</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   str The string</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  Null if it fails, else a pointer to a const uchar</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> uchar * <span class="title">Utils_String::String2Uchar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (uchar*)str.c_str();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @fn  std::string Utils_String::Uchar2String(const uchar * buffer)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   Uchar 2 string</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment"> * @date    2019/12/16</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   buffer  The buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  A std::string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Utils_String::Uchar2String</span><span class="params">(<span class="keyword">const</span> uchar * buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = (<span class="keyword">char</span>*)buffer;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-hex-字符串-转换-字符串数组"><a href="#4-hex-字符串-转换-字符串数组" class="headerlink" title="4. hex 字符串 转换 字符串数组"></a>4. hex 字符串 转换 字符串数组</h3><p>依次取两个字符, 转换成一个 ucahr 值 存入数据中即可</p><details><br><br><summary> hex 字符串 与字符串数组的相互转换  </summary><br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @fn  uchar * Utils_String::Hex2CharArr(uchar *&amp;buffer, const std::string &amp; str, bool flg_space)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   Hexadecimal 2 character array hex 字符串 转换成 数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment"> * @date    2019/12/18</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param [in,out]  buffer      [in,out] If non-null, the buffer</span></span><br><span class="line"><span class="comment"> * @param           str         The string</span></span><br><span class="line"><span class="comment"> * @param           flg_space   True to flg space hex 是否使用空格分割</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  Null if it fails, else a pointer to an uchar</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">uchar * <span class="title">Utils_String::Hex2CharArr</span><span class="params">(uchar *&amp;buffer, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; str, <span class="keyword">bool</span> flg_space)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 出错 只有两个值 默认不符合 操作</span></span><br><span class="line">    <span class="keyword">if</span> (str.size() &lt; <span class="number">3</span>)    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 默认够长 判断是否存在空格</span></span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">2</span>] == <span class="string">' '</span>)   flg_space = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> step = flg_space ? <span class="number">3</span> : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    buffer = <span class="keyword">new</span> uchar[(str.size() + <span class="number">1</span>) / step +<span class="number">1</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str2 = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(str.size());)</span><br><span class="line">    &#123;</span><br><span class="line">        uchar ch = Hex2Uchar(str.substr(<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(i), <span class="number">2</span>));</span><br><span class="line">        <span class="comment">// 根据是否有空格选择 移动</span></span><br><span class="line">        *(buffer + i/step) = ch;</span><br><span class="line">        i += step;</span><br><span class="line"></span><br><span class="line">        str2 += <span class="built_in">std</span>::to_string((<span class="keyword">int</span>)ch) + <span class="string">"-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// LInfo("charArr:&#123;&#125;", str2);</span></span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @fn  std::string Utils_String::CharArr2Hex(uchar * buffer, int length, int flg_space)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   Character array 2 hexadecimal  数组 转换成 hex 字符</span></span><br><span class="line"><span class="comment"> *          * 将UCHAR 字符串依次转换成 string 字符串</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment"> * @date    2019/12/18</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param [in,out]  buffer      If non-null, the buffer</span></span><br><span class="line"><span class="comment"> * @param           length      The length</span></span><br><span class="line"><span class="comment"> * @param           flg_space   The flg space</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  A std::string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Utils_String::CharArr2Hex</span><span class="params">(uchar * buffer, <span class="keyword">int</span> length, <span class="keyword">int</span> flg_space)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">// 读取数组中所有字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        str += Num2Hex(*buffer++);</span><br><span class="line">        <span class="comment">// 如果开启空格的话  每两个字符 之间加入一个空格 最后一个不加</span></span><br><span class="line">        <span class="keyword">if</span> (flg_space &amp;&amp; i != length - <span class="number">1</span>)</span><br><span class="line">            str += <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>大概就这么多常用的转换过程, 还存在一个 单独 数组转换 字符串的函数, 可以使用 <code>sprintf</code> 格式化输出, 或者使用 暴力循环取余得到最后的结果值</p><details><br><br><summary> 数字与字符串的转换  可多位 多进制 </summary><br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @fn  std::string Utils_String::NumToString(int num, int width, int base)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   Number to string 整型数据 前补 0 占位符显示 进制 为 8 10 16 如果超过给出的宽度 原始宽度显示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment"> * @date    2019/12/3</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   num     Number of</span></span><br><span class="line"><span class="comment"> * @param   width   The width</span></span><br><span class="line"><span class="comment"> * @param   base    The base</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  The total number of to string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Utils_String::NumToString</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> width, <span class="keyword">int</span> base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">// 保证 存在进制 只考虑 2 8 , 10 16 进制</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; t_base = &#123;</span><br><span class="line">        &#123; <span class="number">2</span>,<span class="string">'0'</span> &#125;,</span><br><span class="line">        &#123; <span class="number">8</span>,<span class="string">'o'</span> &#125;,</span><br><span class="line">        &#123; <span class="number">10</span>,<span class="string">'d'</span> &#125;,</span><br><span class="line">        &#123; <span class="number">16</span>,<span class="string">'x'</span> &#125; &#125;;</span><br><span class="line">    <span class="keyword">if</span> (!t_base.count(base))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="comment">// 二进制 特殊处理</span></span><br><span class="line">    <span class="keyword">if</span> (base == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> str_8 = NumToString(num, width, <span class="number">8</span>);</span><br><span class="line">        <span class="comment">//  设置8进制 转2进制码表, 转换之后 去除前缀0 即可</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; table = &#123; <span class="string">"000"</span>,<span class="string">"001"</span>,<span class="string">"010"</span>,<span class="string">"011"</span>,<span class="string">"100"</span>,<span class="string">"101"</span>,<span class="string">"110"</span>,<span class="string">"111"</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> str_2 = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> s : str_8)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s ==<span class="string">'0'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            str_2 += table[s - <span class="string">'0'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去掉前面所有的 0值 从1 开始</span></span><br><span class="line">        <span class="keyword">int</span> pos = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(str_2.find_first_of(<span class="string">'1'</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// #TODO(Schen00) 处理, 得到的长度小于width 的情况</span></span><br><span class="line">        <span class="keyword">return</span> pos == <span class="built_in">std</span>::<span class="built_in">string</span>::npos ?<span class="string">""</span>:str_2.substr (pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> format = <span class="string">"%0"</span> + <span class="built_in">std</span>::to_string(width) + t_base.find(base)-&gt;second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, format.c_str(), num);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(buf);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (num)</span><br><span class="line">    &#123;</span><br><span class="line">        res = base == <span class="number">16</span> ? Num2Hex(num % base) : (num % base + <span class="string">'0'</span>) + res;</span><br><span class="line">        num /= base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不足位 补0  足位 不删除</span></span><br><span class="line">    <span class="keyword">int</span> cnt = width - res.size();</span><br><span class="line">    <span class="keyword">while</span> (cnt--)</span><br><span class="line">    &#123;</span><br><span class="line">        res = <span class="string">'0'</span> + res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Serial </tag>
            
            <tag> SerialPort </tag>
            
            <tag> HEX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人情绪</title>
      <link href="/2019/12-24/%E4%B8%AA%E4%BA%BA%E6%83%85%E7%BB%AA.html"/>
      <url>/2019/12-24/%E4%B8%AA%E4%BA%BA%E6%83%85%E7%BB%AA.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="2b50e5eccb69abefb97ee3dd96bdf3e95b15a17294804b250492b6a870feb75f">a46b5b0eb22182a4f41a0d0288cebe4e4118b38158eabb80c9d7c10326f5a48a318c3a808872ae53cd3db9bc80900f24228ac320d8e5d8e5597d8aa5a4cd113470808e29d64327ee67c7dc926a67023270935204ba11af3e70b70c7e763038349b14341992fa62887d9813508a0a5bb909dee608aeff0f8e5f39e531fafbd0757315ca9a895a2c32e4c637a4bb5b8e9794591330e6879410447764dadf20427bfa847f1d1f6c3214613ac97664db3a9c0a8557a736cc23dfe24e66af4d827c8a1f69cbf53bcdd24c173074cfc44b66ea</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Person </category>
          
      </categories>
      
      
        <tags>
            
            <tag> person </tag>
            
            <tag> encrypt </tag>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV0-项目启程</title>
      <link href="/2019/12-20/OpenCV0-%E9%A1%B9%E7%9B%AE%E5%90%AF%E7%A8%8B.html"/>
      <url>/2019/12-20/OpenCV0-%E9%A1%B9%E7%9B%AE%E5%90%AF%E7%A8%8B.html</url>
      
        <content type="html"><![CDATA[<p>每当自己面临困难的时候, 自己总会给自己找很多事来做, 显得自己做的很好一样, 总是给自己一个很大的期望,认为自己能够做好, 这次的我在胡思乱想之际, 开始了两个项目,  其中一个就是现在正在规划的 opencv 大项目</p><h2 id="前因后果"><a href="#前因后果" class="headerlink" title="前因后果"></a>前因后果</h2><p>自己开始使用opencv 也有一年半的时间了, 从最开始的实现起来很简单, 到后面有过一定的深入理解, 但是在事实上, 自己做的远远不够, 甚至在很多时候, 仅仅是调用api 而已, 之前参与过 一个 <a href="https://opencv.apachecn.org/#/" target="_blank" rel="noopener" title="opencv4.0中文文档">opencv4.0中文文档</a> 的中文文档的翻译项目, 但是他们只是简单的做下去,并没有做的很深, 而且他们由于一些原因似乎出现了问题.<br>所以, 这边 之后可能考虑 不仅是翻译原本的教程, 同时发布相关的源码解析过程, 做单独的 opencv 各个模块的解析过程</p><h2 id="总体构成"><a href="#总体构成" class="headerlink" title="总体构成"></a>总体构成</h2><p>介绍</p><ol><li>opencv- blog 个人研究 opencv 的相关内容介绍, 使用简单的 hexo 搭建的blog 项目</li><li>source - opencv 的源码 根据当前时间 2019-12-20 使用较新 的版本 opencv-4.1.2 版本源码, </li><li>soft - 自己实现的基于 QT 做的界面的 opencv 的一个基础使用库, 用于实现opencv 的算法功能, 实现的过程也会发布到相应的 blog 内容中</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spdlog使用以及自定义日志设计</title>
      <link href="/2019/12-18/spdlog%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%E8%AE%BE%E8%AE%A1.html"/>
      <url>/2019/12-18/spdlog%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%E8%AE%BE%E8%AE%A1.html</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Utils </tag>
            
            <tag> Logger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT踩坑记录1-多线程信号与槽</title>
      <link href="/2019/12-15/QT%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%952-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD.html"/>
      <url>/2019/12-15/QT%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%952-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD.html</url>
      
        <content type="html"><![CDATA[<h2 id="错误输出"><a href="#错误输出" class="headerlink" title="错误输出"></a>错误输出</h2><p>无错误输出, 但是声明了信号的连接,但是无法使用 程序中就是无命令</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>QT 典型程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span><span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signals_dosomething</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slots_dosomething</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_value_ = n;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass(QObjet *parent = <span class="literal">nullptr</span>)</span><br><span class="line">        :QObject(parent),</span><br><span class="line">         m_value_(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        QObject::connect(<span class="keyword">this</span>,</span><br><span class="line">                        &amp;MyClass::signals_dosomething,</span><br><span class="line">                        <span class="keyword">this</span>,</span><br><span class="line">                        &amp;MyClass::slots_dosomething,</span><br><span class="line">                        Qt::DirectConnection);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>手动指定连接方式</p><p>connect(sender, signal, receiver, slot);<br>其实，connect 还有一个 Qt::ConnectionType 参数，只是它带有默认值，且多数情况下，默认值足够了，所以最少有机会去了解。Qt::ConnectionType 的可选值如下：</p><p>Qt::AutoConnection:<br>默认值，使用这个值则连接类型会在信号发送时决定。如果接收者和发送者在同一个线程，则自动使用 Qt::DirectConnection 类型。如果接收者和发送者不在一个线程，则自动使用 Qt::QueuedConnection。</p><p>Qt::DirectConnection: 槽函数会在信号发送的时候直接被调用，槽函数运行于信号发送者所在线程。效果看上去就像是直接在信号发送位置调用了槽函数。这个在多线程环境下比较危险，可能会造成奔溃。</p><p>Qt::QueuedConnection: 槽函数在控制回到接收者所在线程的事件循环时被调用，槽函数运行于信号接收者所在线程。发送信号之后，槽函数不会立刻被调用，等到接收者的当前函数执行完，进入事件循环之后，槽函数才会被调用。多线程环境下一般用这个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QObject::connect(<span class="keyword">this</span>,</span><br><span class="line">                &amp;MyClass::signals_dosomething,</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                &amp;MyClass::slots_dosomething,</span><br><span class="line">                Qt::DirectConnection);</span><br></pre></td></tr></table></figure><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://yehuohan.github.io/2017/10/09/%E6%9D%82%E8%AE%B0/Qt%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7-%E6%A7%BD/" target="_blank" rel="noopener" title="Qt多线程中的信号-槽">Qt 多线程中的信号-槽</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> QT </tag>
            
            <tag> Bugs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT踩坑记录1-Q_OBJECT编译问题</title>
      <link href="/2019/12-15/QT%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%951-Q-OBJECT%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98.html"/>
      <url>/2019/12-15/QT%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%951-Q-OBJECT%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h2 id="错误输出"><a href="#错误输出" class="headerlink" title="错误输出"></a>错误输出</h2><p><code>Q_OBJECT</code> 宏错误的地方会编译出现这样的错误, 无法找到….</p><p>由于自己不想再看到这个错误, 此处 复制自 <a href="https://blog.csdn.net/sunxiaoju/article/details/48316271" target="_blank" rel="noopener" title="error LNK2001: 无法解析的外部符号">参考连接 1</a>, 主要是连接错误 <code>LNK2001</code> ,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>&gt;LoginDlg.obj : error LNK2001: 无法解析的外部符号 <span class="string">"public: virtual struct QMetaObject const * __thiscall CLoginDlg::metaObject(void)const "</span> (?         metaObject@CLoginDlg@@UBEPBUQMetaObject@@XZ)</span><br><span class="line"><span class="number">1</span>&gt;LoginDlg.obj : error LNK2001: 无法解析的外部符号 <span class="string">"public: virtual void * __thiscall CLoginDlg::qt_metacast(char const *)"</span> (?qt_metacast@CLoginDlg@@UAEPAXPBD@Z)</span><br><span class="line"><span class="number">1</span>&gt;LoginDlg.obj : error LNK2001: 无法解析的外部符号 <span class="string">"public: virtual int __thiscall CLoginDlg::qt_metacall(enum QMetaObject::Call,int,void * *)"</span> (?qt_metacall@CLoginDlg@@UAEHW4Call@QMetaObject@@HPAPAX@Z)</span><br><span class="line"><span class="number">1</span>&gt;D:\VC++\QtT\MyDialog\\MyDialog.exe : fatal error LNK1120: <span class="number">3</span> 个无法解析的外部命令</span><br></pre></td></tr></table></figure><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>首先看一下一个基本的 QT 类的简单实现, 继承自 <code>QObject</code>, 然后定义了 一个信号 <code>signals_dosomething</code> 和 一个槽函数 <code>slots_dosomething</code> ,<br>信号函数不用去实现, 只需要 设定与相应的函数进行连接即可, 即 使用 <code>QObject::connect</code> 连接, 且信号函数与槽函数的参数一致, 信号这里的连接与函数参数也是一个坑, 后续会更新相应的章节, 那类中 最开始 的地方 为什么要有一个 宏 <code>Q_OBJECT</code> 这里可以参考 <a href="https://blog.csdn.net/Bruce_0712/article/details/53666174" target="_blank" rel="noopener" title="Qt之Q_OBJECT详解">QT Q_OBJECT</a>, 里面做了详细的解释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span><span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signals_dosomething</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slots_dosomething</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_value_ = n;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass(QObjet *parent = <span class="literal">nullptr</span>)</span><br><span class="line">        :QObject(parent),</span><br><span class="line">         m_value_(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        QObject::connect(<span class="keyword">this</span>,</span><br><span class="line">                        &amp;MyClass::signals_dosomething,</span><br><span class="line">                        <span class="keyword">this</span>,</span><br><span class="line">                        &amp;MyClass::slots_dosomething,</span><br><span class="line">                        Qt::DirectConnection);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>由于本人使用的是 QT 构建工程,然后使用 VS 的 <code>QT VS Tools</code> 将 QT 工程转生成的 VS 工程,<br>存在各种问题,甚至出现 QT 编译通过 VS 编译不通过的问题, 这里使用最暴力的方式, 直接使用 QT 的 <code>moc</code> 命令 将相应 类的声明 h 文件 moc 成 cpp 文件,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moc MyClass.h -o moc_MyClass.cpp</span><br></pre></td></tr></table></figure><p>然后将 cpp 文件放置到相应的生成目录下面即可, 一般在 解决方案/工程/debug 下面,里面全是 moc_* 的 cpp 文件和 obj 文件<br>注意查找自己的目录下面即可, 在手动 moc 生成之后, 之前编译不通过的 VS 工程也编译通过了,<br>这里猜想是,</p><blockquote><p>利用 Qt 编程时，写好.h、.cpp 文件并第一次编译之后，若.h 文件中定义类时没有添加 Q<em>OBJECT 宏以及信号函数、槽函数，VS 编译命令中就没有 moc 命令，就不会调用 Qt 的 moc 工具以生成 moc</em>*.cpp 文件；并且即使添加了 Q_OBJECT 宏之后，VS 也不会自动添加 moc 命令，因而不会生成 moc 文件。<br>VS 在 LINK 时，找不到 moc 文件，就出现了 error LNK2001 的错误。</p></blockquote><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/sunxiaoju/article/details/48316271" target="_blank" rel="noopener" title="error LNK2001: 无法解析的外部符号">error LNK2001: 无法解析的外部符号</a></li><li><a href="https://stackoverflow.com/questions/1368584/what-does-the-q-object-macro-do-why-do-all-qt-objects-need-this-macro" target="_blank" rel="noopener" title="What does the Q_OBJECT macro do">What does the Q_OBJECT macro do? Why do all Qt objects need this macro?</a></li><li><a href="https://blog.csdn.net/Bruce_0712/article/details/53666174" target="_blank" rel="noopener" title="Qt之Q_OBJECT详解">“Qt 之 Q_OBJECT 详解”</a></li><li>一定要看 <a href="https://blog.csdn.net/yuzhiyuxia/article/details/7844595" target="_blank" rel="noopener" title="error LNK2001: 无法解析的外部符号 Qt的moc机制">error LNK2001: 无法解析的外部符号 Qt 的 moc 机制</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> QT </tag>
            
            <tag> Bugs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT踩坑记录0-汇总</title>
      <link href="/2019/12-15/QT%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%950-%E6%B1%87%E6%80%BB.html"/>
      <url>/2019/12-15/QT%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%950-%E6%B1%87%E6%80%BB.html</url>
      
        <content type="html"><![CDATA[<p>QT 是一个跨平台的C++库, 提供了通用的解决方式,方便我们进行界面开发, 但是每个库总有各种问题,可能是自己的原因,也可能是设备环境的原因, 甚至可能是库的原因, 使用QT也有很长一段时间了, 遇到了各种问题,有的已经解决了,有的还在困扰自己. 此处记录下来自己遇到的各种关于QT库的问题, 希望对别人有 少许帮助.</p><p>此系列更多是自己遇到的问题的记录, 部分基础的问题以及常见的问题能够通过一定的搜索解决掉了,就没有去做详细解释, 但是那种坑了自己一天甚至更长时间的 问题 应该被记录下来.</p><h2 id="章节汇总"><a href="#章节汇总" class="headerlink" title="章节汇总"></a>章节汇总</h2><p>QT 踩坑记录</p><ul><li style="list-style: none"><input type="checkbox"> Q_OBJECT 宏错误</li><li style="list-style: none"><input type="checkbox"> QT 信号与槽连接</li><li style="list-style: none"><input type="checkbox"> QT 打包与依赖问题</li><li style="list-style: none"><input type="checkbox"> QT 资源问题</li></ul><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>心动的信号</title>
      <link href="/2019/12-02/%E5%BF%83%E5%8A%A8%E7%9A%84%E4%BF%A1%E5%8F%B7.html"/>
      <url>/2019/12-02/%E5%BF%83%E5%8A%A8%E7%9A%84%E4%BF%A1%E5%8F%B7.html</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="输入密码, 查看文章" /><label>输入密码, 查看文章</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="1e492d39afc430936935899f52a1b5fd84705bb777e6c229d3474045f3ed3b31">1b96604982475f960c2596f9910493c15af00763ee34064ed9cf0809fbcee377922533facf20a49df7a106fca9c199abf753f5852632c8275e3b8a67b07038b54bb9a74b3cfd23a293165d410612cbe72199f95ecab5d778840b8e2280012c4374e6b88d7e6d55289297b0159ead897cdd12b8bf126bb6ac8df7362e9481bcc1cd2ca0f24a2251e1163b36aa352ceebf4b84f3e58be13ab3edf1d7f4cb955d5da38150e617d7e4aa7c37e550f848a55c78ed1e60762200bb97e41e79130269b45164f0d2c76968b56078917023f27966c6b65b19ea9bb8cf684a6fb493edb3c56adc03d81df05f8834333f94047fe1e8415685990d78ef6e22c553ab3238e91cb80e582d93f4825a8e987b0d096d3200536af82218148777880b76501f78b6d1a2cdc73ef495a6d6a86f909ca9fb188b68593662ae2481f118435f584c7ad8fc91222fb0e9ac03cadd18815d95308c61317a5b2f9b8614058ea14d78772b1e791e280a5720845ddb03565b1faa8f778d8aaf579243f86adb01eb147d5c32979a07df0725607d196319771bc1ac9f321fa5e168cecebb8470ac9f9188af167082119861b2ac5f89a27caa273f09a7b3452f0fbaaa6b6a10a980c4d9a5ec321c3beb23c037b74f6c39637b8b23d572ac6a00425fd0101b8a5cc84b0ee12bf5ff70558907eca1bfb19a542cb72fb1b0259631ea8dca9e3b5baf04d906a1cbe78fcb38632f2c9cfefce67b75556eadca832d8ef43d072d34ee3a717fe33cae54e4f0e31197630fdd14205ec61b519c3863b6db821374155a2826186e48362d2b4debba3eb27445664d2101db42e14844528e226ccba199cbef9360c40cc05b7166c96adb5e8d0fb71c67437f58be6948bee7e158ff9161b0b863e0d0f164fc064fe31bc5a087d08d71b98e90b951f89482a53d5e2d0532edd857d8aca87a9585a496a0f2beaa4d47d32ce33730fad4522fa9baea5aafc54c68b90078b1386396efbf35567499232404017de74661542f71c3a68b9e1a195e8abd02ad947c88686f2ddbf282e1d0b95845792a052d0d034fae2a6e02044fc37fedd7a0040079a2586929f0edd33d5b680c56658e1f6961bf2334c478fffaf7869faf93ca64cf6852f81e4fbc5a9a67bf5dc0d4e2e4d89c36442e5b668086e93ec372af2ab6a95598250a50528caf029b9e4603d9b888f5729109e0264c7e163218f5f156a067a6c2d4e6dc1e9e63a7d20be4826756271dc39f96800ab21ee80acbd3fafb299e5f6cf6bb8fba01d8d80aafb082e1ff265287aabaedc3b860d147555cff00657982b02b63ee15865901ab60048af333f8be09d3dadd4b142137859cd1693eb821f6b9b159034692e6146abc8ac2fd0c61afffcb0bc3cdffea5b233849e396fdeadee26b2ec754e6179c61ac866829875a5296f5131c30625e546650bee03bd97a730c487b076e2dd2bf1ad4898a40fc3c7af855c1c768cc1c9b61fc0f198b75a3a39828224b6087211d7f6d5befba359a9568aa72adaaa87d483795e9d24a91e78b2d07c597b6f970a1b0b1a0fc5536a339e8ad9ef822384c91c0908f28b0e5efde090265cacf578d3a48512694af0c18dd76a96dfe6699e58edada1d13c3c49867206428b292c7395fb9bfe120d04c7ae3d0db954cb5d93cb944dec283498008bc8a1ee118e30f7a41aac9ea09d614f51e508ec31d35fef240db807459fda4554edf6ed9b6fddbbbe50208c6331cc826a31ef1c82ee91d6c831bfb671f4d5389cb2bd342a583ddf255570e9b6aa3be444fba38fdd3e5e079b163e41a901631221b7a2a10561939c9cbd9226e61e0bbe5ef95fe52841ce11e90b37c8beb2711052945e06b591677ccbbca329e6c4b7533d4ba3ea6974d844461d94dc3049adadf679208e42f3ac2def4e964466a6a1789ae31c846458c768ea19f46b19382a9964a92aa5bc03329a5aa78171a070e5469bc2f8b04b9c465169f98ddf8efb3f9acfd016adc7eb71d49826491ef9dbd0408c8a0f5fce9e7ebadf0d97951619b4d4dd7ee018cbc00eafa8501573def3b9f37bae58082c145e970cd0217389e3fe39798037db709b2c3b861771b17fd7fd0fa8c6c519d5de93798c8a3cfc49c577b78f019ae1fed0c5f286b3d460dc0c03a82371f2feed56a6eb9aa4aee89ae2a90323015b4a3fbc87a05021fb9c476168098272e109b199a13d8997656a74f8afdbe7ef8f24669c63711a7b5bb06d4c7859ded5ab04d26ecb36ce219f9dcf87fc2cc84b5099b977124ba2f49ca71263b9169e3574f9ebfeb0063cec72fa6810f24d091369d6535e17264d2628991bcf4176c76a25861a3f1ee52514c104da97632e294940c4e0ffd0a00b20647970bc48d02a2f0ed2fcd5432abb45e24b93c7db5922f2ac305bc8e585f645a410bfa393413f3e51d0fe670f26f75fc47fe60cf59a4f47c7148b20b0932d13b713036fe4bb763cab42670a5f6a0fac25019c49ecb4017341b574eb1146f0c133892d28746298dff8d0e381651ab025596be1b9e74cd2525ff04880cf9a5eac62f7f4c25fba5a3205f75f63c5e2b32a307cec692f484d8dff654830ad4ceb73360ed6a3ca1431fee7b73003cc0ff46f67911fd44bf0745b40968682f6bea902e354c3709e227dac79593e217cb45e2894fd62bd79c7717e9bb1847d82fb73fc2ed5681e95ae4466ce2d6b75d44052979aff60384c388f5e9e3088aa390cc2ee3f61f0964b6a875be2ca0dc35bb21ceee8bd5375ea9f3e365c33cdcc89d398f4af1c66bab1e8c0f3b56d49043d20c83e3dca00ee4975a73231c75e7693ff9e7b70701b6c5cf94b6801291a6a45ba6b992753ecbaaab83cc70e2930caaae57a562821e38d1f367e05435cd3cebc70f083dfdbffc74d46907a6f3eb1470cb37470d42e5a179e0dc94e1cc7722b5fb8b4db571da3a97c4a838d4edcc79b0e6f49db3bf2fdf3ff5e4b482e4d01cf8afd6f58b16c609ae04b2208e08980eb36ba5c1d64666edf9e3d3ac17a667a53c29184ed26b40d2757632ae3bd45be348518ed075793e558f512bfe94064da36a6da0cb0119c7a3c777f44eb0b33db9b18b485a9f0e124c97e3d29e003baa52ed245a13e55bf010aa3bf2e26c3e7db751294851d472dc41d1321b4823424f3dbfcc450ad1e8d2ad33d0e94413c1e49c34f663da8869fe1f7a2cad6114047a74e63c9e06deb9f3156806356c6d655c874fe936118e2c57725440eac14084119594321c1a7ccde51113f46f7801a6f97354539578a51552f12e33f1caf766616330b9d5d63e37370eaf33b0407d653a140e3c3e6813f9aa1db16f7c219aba229b618e655924ff98cc29f9b77f1c26320a910cd0d2c397d1a081147fd7d7da2667897a22b36eb93bbd32adae8ce72030e1bff4561aa9f11c047be7b5397d961df7bd5589a00fe7d91ca6ee5d47c43ff7d2f4c485e01329b9dc36ca7624f790de66530c0aa0a9d1c7b3445b1c853694b33d42fe83d4c6a0ab2463f1e07bf313926ca64e52ad8c2c044f94ef80be639a8eab8abb5ab58c13ac968ec961539a2db4bacff97f79e7de31edc7b6d98bd86bb1d6e22df673b1dd6de5d08d509217bcea78a9841866e71324ae646590ceb2e2018352c180132f82c3b25165babf7ea8f2dfadd3a103477049b6e19724732c5e78a3708cdeea95cc98e9bb762b35a07d507cb4a4bb43eaecdfae242685c00c6f77ed821a0406495a8dc7405b5d3b5d1ef05a237a7346c8d3b900559f433f02e7abbc2f8fe4978c2dd57f05d1b83522e9696ef1887051cc4a31d5403ac5cd55524f42eb7d22ebba1f0496293fd863eaa6b75672685fd1986bd1af72e514e50b2ae301a26d3377efdab83cc6b8f37be9e2b9d34b52d667bbe4b2f5edfe2dc6ece55ec6dfa6e8034e43fd9919af2eb344624d5c13b8d648c689c13c6a8dd3893549591e69fed2ae4411ba0dcf9dbfbc4b6a4879b8579d90483e3e5580e7b231e7360711248735f271a27676191ea41b5a7d03b8bec0f128ff9e738c940f895349b09e2e38f018db2d5bd7248c5009f2494514979d0b72f06055630499922198dc9a95b3f26632bef41807b6b2cbc596f5a0ff863507ffbe453ea07a71b06a334bf2ae3851b49f52825bc590ec55ec0c6ed31457b2a00efb6130200a45b4672c79e79207f0d4ad286e1f27fafeb8ff331fb3a7ef86435b9575704aff6f6929b5ce2d49534b3aca62d7e054e4ff086309c03f6c01ff24e62b8fc18f3755bed9a7dbbfda393abbeefb81e1d579ff03932be880a659ba6defe4757a9add3607da52bcbd40b42dea46315e69de0119ed828e3b1343c9fa38aa6cff9df71eeaf2ae90fc155d887a25c9f441e64416af35c462c019d8bda8409e527889e2f1efec3e6bb3ddbd428120ab28c0500c1ae252613fe69bc765f96e2de9215823041a8ce7bfc5c417af74eba4adaccdc9f47bdc7d69b5f7b3ca904093947cb6def7f8f55e4c9ec4055a7a07a2cbc3481291ce74ae422ab7626b24e89ef7e936919346f888773f2c54e703a2a7ab0c144d14d307a21aa3e6aa4b7bdad2df65cb31a52b17c0ffda4cef47e399d09675b4338c47a71fb5b6cdcb4dfb1904a8263eb2715481a8663ac997503eeb730e931f5384be26c0c1f76b0ec185a48a3cae42bfd692c49abc6f55f2c2cfc06a78f2daf232bb6f8eb268a353d5b6c41c903907c9bd6a05d00301e1df8c11e487556316b67fe9f503c066b344f5b66d5812e8b665641ccb306bc57efad1567de1329c7d43802612fa59f75450f188d14f5f1b4254f5cc71797b26d999a47a8d2538b683a3a8ceb067b94cb9a5d08fd4d0014ee550d9d9109153cb27d1d70e1b44fb5b6326ce166a045e071aa990c08e2ce601bada49abdc338df45093c0eb03d8cdbbb56096f2c5da66e155fd64dfcd5fa6423eee3acdb6639ad50bbda32b0674d0c0e4eb4e85e348abe80a360873eb1b54f320a780bc689ab3078cb6efc839f462072ef4345bbb4ac7ecbe04b61a95b6ea06cb17f19200a0c5dfdcca18aaee5a1ccb3548a3e237f19d26a98a3cbe42ecab51ecec5f8eecd8f94cf1d4f9dcf07ada30dbccd58be430e4d5750801c1efb5f98390707f0dc60aa708a18dc1558198e746635d75fdbb441a66c7bd05d5470f054544dbe30c52a5b9c30e2b93bca41ddc15f4d23fcf291322cd9ffc80f2a8d02e98e9c9dc370e7fe509d82c0b93efa585609ddb54ba60db721682e18658602ba8c4e54f22fdebf7741413c1f21b5851d8dde2e8359668d0c36091eacdf03fcdbefee1035cc40993ce9219f757464cda2355333cce2016288067a11878f63feaca1b237451b0c4dc3d8c13abb9cdb786914616c9cad3c6d0173ab1569115fadf0e1acd09ec073965ecb17e49b22e68c0c3686a4bb90cca6c637031a52d3261b31bccedc9fe4339094d4540f81f3ac5269fb9e06b3a48a7c32e3c817ebf959cfb42e3145b0af8176ecc1167cb8c2a79023ae57fe253d1f92b5c6b2d15268ce0227f1c187582d2eefff2c2ad993f3b8333b2de3768aced43bf55a521c74d7cc528052a57393748d655986a7238d1c2e6be4fbd18b659f3a9646a98844a8fd7360d559cc305d651ecb4207da96e5993a4fda1daf30f9be128d0aa38814f1630c74d06ffb6a5f76f5baaa931b90f457b36779f6c2a777cb658f58715a777561e05a9b0ba84797de17b18fabda9fd5129fe6ec61c0b6a9a0f4c1e97623d11b0b26fcbc1646bb096ea2393b2ecfcf0efb1460cd8f0ccd7b593aa59d647f3b9507cd1968f29a2d2a806d164508d12490f06ddcced264c3782edfa84ed23a9545e581fef277dbe4c8c3199ef87c38705be47957e36f1c615fe0a73e887a067d82127c5eb0535027c7161ae5676359fc781ba92aa5e57b47d4afd4387017414fcff54ff1099648ef60e1f707f830db82d20e4b73f7705e9fb7aff6e3ba2d481a4c99d89721119cfae9a6aa6aa445bcd1c48450250d2c998f9ab85b8cdd601e0395cc8eb3c422c4fee5dbf6ce12d1f6baf5b56cae63e8dcb0facf421865ff1f74862b373bdbffe432b10261f0a4fb89b1e241fca0bdf652f9736dbcea26a3da26e0cdf979f54d44c21fbd061c485288e1c257a063aac604496fbb4cce7e3fb4e2fa086d973395fa604d6e6699fcccc1f768dee792e657849cce837a121d7fd35e937ef08ad35a743cdd24fa75a81ea624baa15624a474c0b2dbf152535ca3921eb7efbb52871c898f576f56886ccc8dd</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Person </category>
          
      </categories>
      
      
        <tags>
            
            <tag> person </tag>
            
            <tag> encrypt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Window+Protobuf使用说明</title>
      <link href="/2019/11-27/Window-Protobuf%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html"/>
      <url>/2019/11-27/Window-Protobuf%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>由于项目中要用到二进制存储数据,之前使用的方式是按照字节数依次将数据写入字节流中, 但是这样做起来做文件的协议兼容比较难做,所以我们考虑使用 protobuf 来做格式定义, 便于不同版本的文件兼容, 这边使用用起来十分方便且后续添加参数之后, 版本之间的改动很好处理,多出来的参数或者未找到的参数可以使用默认处理即可,十分方便</p><h3 id="常用配置文件介绍"><a href="#常用配置文件介绍" class="headerlink" title="常用配置文件介绍"></a>常用配置文件介绍</h3><p>程序的配置文件是一个很常用的手段, 每次读取配置文件的信息, 容纳后根据参数决定我们的执行顺序, 是程序的一个很好的设计方式, 常用的配置文件我们会选择使用自己可读的文件格式,进行一定的程序注释之类的,然后在通过配置接口,将我们需要的参数依次读取到内存中,进行读写.</p><p>常用的配置文件格式有:</p><ul><li>xml</li><li>yaml</li><li>json</li><li>ini</li><li>properties</li><li>……</li></ul><p>具体的参数区别与优劣比较自己可以查阅 <a href="https://colobu.com/2017/08/31/configuration-file-format/" target="_blank" rel="noopener">常用配置文件格式</a></p><a id="more"></a><h3 id="protocbuf-介绍"><a href="#protocbuf-介绍" class="headerlink" title="protocbuf 介绍"></a>protocbuf 介绍</h3><p>Protocol buffers 是一种语言中立，平台无关，可扩展的序列化数据的格式，可用于通信协议，数据存储等。</p><p>Protocol buffers 在序列化数据方面，它是灵活的，高效的。相比于 XML 来说，Protocol buffers 更加小巧，更加快速，更加简单。一旦定义了要处理的数据的数据结构之后，就可以利用 Protocol buffers 的代码生成工具生成相关的代码。甚至可以在无需重新部署程序的情况下更新数据结构。只需使用 Protobuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。</p><p>Protocol buffers 很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</p><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="环境列表"><a href="#环境列表" class="headerlink" title="环境列表"></a>环境列表</h3><p>本次使用的环境列表如下</p><ul><li>protobuf 3.11.0 <a href="https://github.com/protocolbuffers/protobuf/releases/download/v3.11.0/protobuf-all-3.11.0.zip" target="_blank" rel="noopener">protobuf-all-3.11.0.zip</a></li><li>cmake 3.14.2</li><li>VS2015</li></ul><h3 id="本机配置开源库编译"><a href="#本机配置开源库编译" class="headerlink" title="本机配置开源库编译"></a>本机配置开源库编译</h3><p>由于是在 Windows 下面编译, 所以这边使用了 cmake-gui 的编译方式, 按照如下步骤配置 0. 假设已经新建了一个文件夹,后续的操作都在此文件夹下 假设操作的所有文件夹都在 D:/Soft/Protobuf 文件夹下面, 新建三个文件夹,便于后续操作, 我们使用 $() 代替在你自己设备中的路径, 不要弄错<br>_ <code>source</code> $(SOURCE) 原始文件<br>_ <code>build</code> $(BUILD) 工程文件和编译文件 * <code>install</code> $(INSTALL) 软件最后安装的路径</p><ol><li>下载原始项目,如果压缩包,将全部文件解压到 $(SOURCE) 文件夹下面</li><li>使用 cmake-gui 配置相应的原始文件夹, 一般打开到 原始文件夹下有 <code>CMakeLists.txt</code>的文件目录即可, 如: <code>$(SOURCE)/protobuf-3.11.0/cmake</code></li><li>目标目录打开到 $(BUILD)</li><li>点击左下角,Configure, 选择 自己本机的 VS 版本 可以选择架构 例如: VS2015 x64 架构</li><li>再次点击 Configure ,程序会开始读取 CMakeLists 里面的参数, 输出窗口会输出 log 信息, 如果有红色会报错,我们需要排查相应的库是否完成依赖项,如果有重要依赖, 可能无法完成编译</li><li>如果一切无措,我们可以看到 如图的 cmake 编译参数, 这是简略参数, 根据具体内容, 我们勾选相应的参数并设置相应的安装路径即可完成配置,</li><li>再次点击配置, 程序会进行配置, 选项会取消红色, 等生成完成即可,</li><li>点击 Generate 生成 VS2015 工程, 我们可以选择 open Project 快速打开,或者到 $(BUILD) 文件夹 点击对应的 sln 文件打开项目</li></ol><p><img src="/2019/11-27/Window-Protobuf%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/cmake-311.png" alt="Cmake 编译参数"></p><!--more--><h3 id="使用-VS2015-编译库"><a href="#使用-VS2015-编译库" class="headerlink" title="使用 VS2015 编译库"></a>使用 VS2015 编译库</h3><ol><li>一般 我们打开之后, 选择 Debug 或者 Release 选择 生成-生成解决方案, VS 就开始了编译过程, 开始进行了项目编译过程</li><li>可能存在编译错误, 一般不会出现, 不建议更改源项目, 可以查看是否自己错误</li><li>编译好的之后的安装文件夹可能存在如下的文件夹结构, 将 $(INSTALL)/bin 加入到 path 环境中, 里面有 dll 文件和 exe 文件便于使用</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├─bin</span><br><span class="line">├─examples</span><br><span class="line">├─include</span><br><span class="line">└─lib</span><br></pre></td></tr></table></figure><h3 id="使用编译好的库-lib"><a href="#使用编译好的库-lib" class="headerlink" title="使用编译好的库 lib"></a>使用编译好的库 lib</h3><ol start="0"><li><p>假设我们需要测试 lib 文件, 建立 VS2015 工程, 新建 <code>main.cpp</code> <code>addressbook.proto</code> 的文件</p></li><li><p>在我们使用编译好的库的时候, 需要引用 include 文件才能进行编译, <code>$(INSTALL)/include</code></p></li><li>我们使用 protobuf 的例程文件里面的 <code>addressbook.proto</code>, 配置相应的消息格式,</li></ol><details><br><summary> 自定义 message 格式 </summary><br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// See README.txt for information and build instructions.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note: START and END tags are used in comments to define sections used in</span></span><br><span class="line"><span class="comment">// tutorials.  They are not part of the syntax for Protocol Buffers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// To get an in-depth walkthrough of this file and the related examples, see:</span></span><br><span class="line"><span class="comment">// https://developers.google.com/protocol-buffers/docs/tutorials</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [START declaration]</span></span><br><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line">package tutorial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/timestamp.proto"</span>;</span><br><span class="line"><span class="comment">// [END declaration]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [START java_declaration]</span></span><br><span class="line">option java_package = <span class="string">"com.example.tutorial"</span>;</span><br><span class="line">option java_outer_classname = <span class="string">"AddressBookProtos"</span>;</span><br><span class="line"><span class="comment">// [END java_declaration]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [START csharp_declaration]</span></span><br><span class="line">option csharp_namespace = <span class="string">"Google.Protobuf.Examples.AddressBook"</span>;</span><br><span class="line"><span class="comment">// [END csharp_declaration]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [START messages]</span></span><br><span class="line">message Person &#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">  int32 id = <span class="number">2</span>;  <span class="comment">// Unique ID number for this person.</span></span><br><span class="line">  <span class="built_in">string</span> email = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">enum</span> PhoneType &#123;</span><br><span class="line">    MOBILE = <span class="number">0</span>;</span><br><span class="line">    HOME = <span class="number">1</span>;</span><br><span class="line">    WORK = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  message PhoneNumber &#123;</span><br><span class="line">    <span class="built_in">string</span> number = <span class="number">1</span>;</span><br><span class="line">    PhoneType type = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  repeated PhoneNumber phones = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  google.protobuf.Timestamp last_updated = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Our address book file is just one of these.</span></span><br><span class="line">message AddressBook &#123;</span><br><span class="line">  repeated Person people = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [END messages]</span></span><br></pre></td></tr></table></figure><br><br></details><ol start="3"><li>在工作目录下打开命令行, 使用 bash 执行命令 将 <code>.proto</code> 文件编译成 对应的 <code>.h</code> 和 <code>.cpp</code> 文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc ./addressbook.proto --cpp_out=./</span><br></pre></td></tr></table></figure><ol start="4"><li>将样例里面的 列出人员和新加人员复制到自定义文件中</li></ol><details><br><summary>根据测试样例改写的 Main.cpp </summary><br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// See README.txt for information and build instructions.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/util/time_util.h&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;google/protobuf/&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"addressbook.pb.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> google::protobuf::util::TimeUtil;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterates though all people in the AddressBook and prints info about them.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListPeople</span><span class="params">(<span class="keyword">const</span> tutorial::AddressBook&amp; address_book)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; address_book.people_size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> tutorial::Person&amp; person = address_book.people(i);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person ID: "</span> &lt;&lt; person.id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Name: "</span> &lt;&lt; person.name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (person.email() != <span class="string">""</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"  E-mail address: "</span> &lt;&lt; person.email() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; person.phones_size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> tutorial::Person::PhoneNumber&amp; phone_number = person.phones(j);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (phone_number.type())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> tutorial::Person::MOBILE:</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Mobile phone #: "</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> tutorial::Person::HOME:</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Home phone #: "</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> tutorial::Person::WORK:</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Work phone #: "</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Unknown phone #: "</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; phone_number.number() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (person.has_last_updated())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Updated: "</span> &lt;&lt; TimeUtil::ToString(person.last_updated()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function fills in a Person message based on user input.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PromptForAddress</span><span class="params">(tutorial::Person* person)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter person ID number: "</span>;</span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line">  person-&gt;set_id(id);</span><br><span class="line">  <span class="built_in">cin</span>.ignore(<span class="number">256</span>, <span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter name: "</span>;</span><br><span class="line">  getline(<span class="built_in">cin</span>, *person-&gt;mutable_name());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter email address (blank for none): "</span>;</span><br><span class="line">  <span class="built_in">string</span> email;</span><br><span class="line">  getline(<span class="built_in">cin</span>, email);</span><br><span class="line">  <span class="keyword">if</span> (!email.empty()) &#123;</span><br><span class="line">    person-&gt;set_email(email);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a phone number (or leave blank to finish): "</span>;</span><br><span class="line">    <span class="built_in">string</span> number;</span><br><span class="line">    getline(<span class="built_in">cin</span>, number);</span><br><span class="line">    <span class="keyword">if</span> (number.empty()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tutorial::Person::PhoneNumber* phone_number = person-&gt;add_phones();</span><br><span class="line">    phone_number-&gt;set_number(number);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Is this a mobile, home, or work phone? "</span>;</span><br><span class="line">    <span class="built_in">string</span> type;</span><br><span class="line">    getline(<span class="built_in">cin</span>, type);</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="string">"mobile"</span>) &#123;</span><br><span class="line">      phone_number-&gt;set_type(tutorial::Person::MOBILE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">"home"</span>) &#123;</span><br><span class="line">      phone_number-&gt;set_type(tutorial::Person::HOME);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">"work"</span>) &#123;</span><br><span class="line">      phone_number-&gt;set_type(tutorial::Person::WORK);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Unknown phone type.  Using default."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *person-&gt;mutable_last_updated() = TimeUtil::SecondsToTimestamp(time(<span class="literal">nullptr</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main function:  Reads the entire address book from a file,</span></span><br><span class="line"><span class="comment">//   adds one person based on user input, then writes it back out to the same</span></span><br><span class="line"><span class="comment">//   file.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Verify that the version of the library that we linked against is</span></span><br><span class="line">  <span class="comment">// compatible with the version of the headers we compiled against.</span></span><br><span class="line">  GOOGLE_PROTOBUF_VERIFY_VERSION;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Usage:  "</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">" ADDRESS_BOOK_FILE"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tutorial::AddressBook address_book;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Read the existing address book.</span></span><br><span class="line">    <span class="function">fstream <span class="title">input</span><span class="params">(argv[<span class="number">1</span>], ios::in | ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!input) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="string">": File not found.  Creating a new file."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!address_book.ParseFromIstream(&amp;input)) &#123;</span><br><span class="line">      <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to parse address book."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 列出文件 读取的人员</span></span><br><span class="line">  ListPeople(address_book);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重新添加一个人员</span></span><br><span class="line">  PromptForAddress(address_book.add_people());</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Write the new address book back to disk.</span></span><br><span class="line">    <span class="function">fstream <span class="title">output</span><span class="params">(argv[<span class="number">1</span>], ios::out | ios::trunc | ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!address_book.SerializeToOstream(&amp;output)) &#123;</span><br><span class="line">      <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to write address book."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Optional:  Delete all global objects allocated by libprotobuf.</span></span><br><span class="line">  google::protobuf::ShutdownProtobufLibrary();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details><ol start="5"><li><p>配置 main 函数的输入参数<br>项目–右键–属性–调试–命令参数—-加入 ./test.bin</p></li><li><p>配置 C++ 项目 include 文件夹和附加库<br>项目–右键–属性–VC++目录–包含目录–编辑—–加入 $(INSTALL)/include<br>项目–右键–属性–链接器–输入–附加依赖项– 编辑——-加入 $(INSTALL)/lib/libprotobuf.lib 和 $(INSTALL)/lib/libprotobufd.lib</p></li><li><p>如果编译了 共享 dll 文件<br>项目–右键–属性–C/C++–预处理器–预处理器定义–编辑—-加入 PROTOBUF_USE_DLLS</p></li></ol><p>最终编译成功, 可以列出来 文件中的参数, 最终生成的二进制文件 hex 文件内容</p><p><img src="/2019/11-27/Window-Protobuf%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/example.png" alt="测试成功"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F</span><br><span class="line">00000000: 0A 15 0A 01 32 10 01 1A 01 33 22 03 0A 01 34 2A    ....2....3&quot;...4*</span><br><span class="line">00000010: 06 08 B2 AD F9 EE 05 0A 15 0A 01 32 10 01 1A 01    ..2-yn.....2....</span><br><span class="line">00000020: 33 22 03 0A 01 34 2A 06 08 D2 AD F9 EE 05          3&quot;...4*..R-yn.</span><br></pre></td></tr></table></figure><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>由于我们需要才自定义文件的后续添加大量的数据文件, 所以无法使用这种方式, 可能还是要使用更多的文件版本的方式来处理文件兼容性问题吧, 后续会将自己的参数设计思路以及参数实现方法</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://linux.cn/article-7931-1.html" target="_blank" rel="noopener">C++ 程序员 Protocol Buffers 基础指南</a></li><li><a href="https://developers.google.com/protocol-buffers/docs/cpptutorial" target="_blank" rel="noopener">Protocol Buffer Basics: C++</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html" target="_blank" rel="noopener">Google Protocol Buffer 的使用和原理</a></li><li><a href="https://halfrost.com/protobuf_encode/" target="_blank" rel="noopener">高效的数据压缩编码方式 Protobuf</a></li><li><a href="https://colobu.com/2019/10/03/protobuf-ultimate-tutorial-in-go/" target="_blank" rel="noopener">Protobuf 终极教程</a></li><li><a href="https://blog.csdn.net/PROGRAM_anywhere/article/details/77365876" target="_blank" rel="noopener">protobuf【1】详细的安装和使用（windows cpp）</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Window </tag>
            
            <tag> Cmake </tag>
            
            <tag> Protocbuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人程序命名规范</title>
      <link href="/2019/11-20/%E4%B8%AA%E4%BA%BA%E7%A8%8B%E5%BA%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83.html"/>
      <url>/2019/11-20/%E4%B8%AA%E4%BA%BA%E7%A8%8B%E5%BA%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83.html</url>
      
        <content type="html"><![CDATA[<h2 id="程序命名规则"><a href="#程序命名规则" class="headerlink" title="程序命名规则"></a>程序命名规则</h2><p>函数命名参考 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/" target="_blank" rel="noopener">google 命名规范</a>, 但是由于自己的项目实际存在其他的库以及其他的程序,所以不能完全依赖,<br>以及存在一些个人的命名习惯,所以仅供参考</p><h3 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h3><p>文件名一般是类名,部分是 单词的组合,有三种格式</p><ul><li>FileName 首字母大写</li><li>fileName 除第一个单词首字母大写</li><li>filename 全小写</li><li>xxx_1107 避免冲突的文件存储</li><li>xxx_date_time_xx 根据日期时间以及 临时 避免数据重复</li></ul><p>一般来说, 同名文件存在 .cpp 和 .h 两种对应格式, 相应的 .cpp/.cc 存放在 <code>Code/src</code> 文件夹, .h 存放在 <code>Code/inc</code> 文件夹<br>具体的文件列表可以参考 项目文档里面列出的文档树以及文档里面详细介绍了每个文件的内容</p><p>按照拓展名区分文件类型</p><ul><li>C/C++ 文件<ul><li>.c 纯 c 文件</li><li>.cpp 部分 QT 的提升组件 以及主要执行文件</li><li>.cc 自定义类的实现文件</li><li>.h 类的声明文件</li><li>ui_xxx.h qt 使用 uic 编译 ui 生成的头文件</li><li>moc_xxx.h qt 使用 moc 编译 Object 类生成的 moc 文件, 处理信号与槽</li><li>test_xxx.cc 使用 doctest 的写的测试函数</li></ul></li><li>文档文件<ul><li>.md 自己写的各个模块的文档</li><li>.doc doc 格式文档, 后续生成即可</li><li>.html doxygen 通过注释生成的文件</li></ul></li><li><p>配置文件以及资源文件</p><ul><li>.yml .xml opencv 可以读取的配置文件</li><li>.pro .pri QT 工程文件,配置工程参数</li><li>.rc QT 编译资源文件</li><li>.ui QT 自己使用 ui 操作</li><li>.qml QT QML 界面文件</li><li>.ts QT 翻译家文件,用于多语言版本程序</li></ul></li><li><p>资源文件</p><ul><li>.txt log 文件存储文件 或临时文件</li><li>.idoi 自定义存储文件结构</li><li>.png 文档需要的图片或者读取文件存储的格式</li><li>.xlsx 部分 UI 表 以及多无代码表 等表格存储 临时记录,最后会转进各个 markdown 进行同一管理</li><li>.pdf 文档的部分版本留存,暂定规则之类</li></ul></li><li><p>其他文件</p><ul><li>.bat 自己写的部分脚本 来实现操作的批量操作</li><li>.properties SonarQube 配置文件</li><li>.zip 程序压缩文件备份</li></ul></li></ul><a id="more"></a><h3 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h3><p>全部首字母大写<br>例如: CamProc. CamCapture. WorkWindow</p><h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><ol><li>普通函数:<ul><li>首字母大写 多个单词每个单词首字母大写, 例如: CreateMapMat, Init</li><li>QT 这种全大写,,省事, 例如: ShowImageOnQTLabel, RenderHCM</li></ul></li><li>QT 的信号或者槽函数:<ul><li>使用 slot_ 开头命名 如: slot_render_HCM</li><li>使用 Slot_ 开头命名 例如: Slot_UpdateUIByRunPara</li><li>按照 QT 的规则, on_xxx_clicked 这种形式,表明函数信号: 例如: on_btn_work_exit_clicked</li><li>QT 的信号函数, 完全自定义, 可以使用 signal 命名, 例如: signal_close_windows</li></ul></li></ol><h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><p>变量参考匈牙利命名法, 使用 类型_变量名 来声明,</p><ol><li><p>变量作用区域类型前缀</p><ul><li>全局变量 g_ g</li><li>局部变量 (无) 争取全部小写</li><li>成员变量 m_ + 其他类型 m + class 类型名</li></ul></li><li><p>容器类型前缀 使用类型来做开头 主要是 queue 和 vector</p><ul><li>q_ 自定义队列前缀</li><li>v_ vector 类型数据</li></ul></li><li><p>变量类型前缀,基本使用类型的第一个字母小写来做</p><ul><li>b_ bool 类型 变量</li><li>k_ 常量</li><li>c_ 字符类型</li><li>f_ float 变量</li><li>d_ double 类型变量</li><li>s_ 字符串变量 std::string 类型变量</li><li>a_ 图片类型 cv::Mat 避免各种字母重复</li><li>t_ 自定义 线程变量前缀</li><li>x_ 线程处理锁</li><li>ui 标识窗口的 ui 文件</li><li>(无) 类型 Class 类 实现</li></ul></li><li>结构体元素变量前缀<ul><li>n 整型数据</li><li>r 图像区域 {x,y,width,height} 这种格式</li><li>St 结构体类型名称</li><li>(无) 使用大写字母 作为 结构体变量名称 如 Serial Image</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> NameStyle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引入OpenCV导致私有内存巨大</title>
      <link href="/2019/11-15/%E5%BC%95%E5%85%A5OpenCV%E5%AF%BC%E8%87%B4%E7%A7%81%E6%9C%89%E5%86%85%E5%AD%98%E5%B7%A8%E5%A4%A7.html"/>
      <url>/2019/11-15/%E5%BC%95%E5%85%A5OpenCV%E5%AF%BC%E8%87%B4%E7%A7%81%E6%9C%89%E5%86%85%E5%AD%98%E5%B7%A8%E5%A4%A7.html</url>
      
        <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>在调试程序的时候 发现自己的程序在 VS 的调试窗口占用很高,<br>花时间关注了一下这个问题, 手动写了小的程序复现这个问题,最终确定了占用巨大的问题.</p><p>VS 的调试工具表示的内存占用是统计的程序 <strong>私有字节</strong> 的大小, 而任务管理器统计的内存占用是程序的 <strong>工作集</strong> 大小,具体二者的内存的区别可以参考问题 <a href="https://stackoverflow.com/a/11296952" target="_blank" rel="noopener">Virtual Size causing program to run out of memory</a> 的答案,</p><blockquote><ol><li><strong>Private bytes</strong> tells you how many bytes of virtual device memory your process has mapped, excluding virtual memory shared with other processes (e.g. mapped files, global heap, etc).</li><li><strong>Working set</strong> tells you how many bytes of physical memory you are actively using. This includes physical memory, device buffers, and mapped files. It’s a pretty strange figure, since it equates to touched physical memory + mapped virtual non-system memory. In general, you should completely ignore this figure. It’s practically useless for debugging memory leaks.</li><li><strong>Virtual bytes</strong> is the total amount of virtual memory you have mapped.</li></ol></blockquote><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>通过不断的重复和二分, 最终确定了是 OpenCV 引入的头文件问题, 在我们平时写 OpenCV 的程序的时候, 总是简单的使用 <code>#include &lt;opencv.hpp&gt;</code> 引入一个头文件来解决问题, 也是官方推荐的写法, 十分方便,</p><p>但是巨大, 我们分别使用三种方式测试, 分别是</p><a id="more"></a><ol><li><p>不引入 Opencv 头文件, WorkingSet: 31,636 KB, PrivateByte: 6,224 KB ; VS: 7 MB<br><img src="/2019/11-15/%E5%BC%95%E5%85%A5OpenCV%E5%AF%BC%E8%87%B4%E7%A7%81%E6%9C%89%E5%86%85%E5%AD%98%E5%B7%A8%E5%A4%A7/opencv_bug_1.png" alt="不引入opencv文件"></p></li><li><p>引入 一个 Opencv.hpp 头文件, WorkingSet: 49,012 KB, PrivateByte: 999,068 KB VS:1 GB<br><img src="/2019/11-15/%E5%BC%95%E5%85%A5OpenCV%E5%AF%BC%E8%87%B4%E7%A7%81%E6%9C%89%E5%86%85%E5%AD%98%E5%B7%A8%E5%A4%A7/opencv_bug_2.png" alt="引入一个统一头文件"></p></li><li><p>引入 一个 Opencv.hpp 头文件, WorkingSet: 31,700 KB, PrivateByte: 6,252 KB VS:7 MB<br><img src="/2019/11-15/%E5%BC%95%E5%85%A5OpenCV%E5%AF%BC%E8%87%B4%E7%A7%81%E6%9C%89%E5%86%85%E5%AD%98%E5%B7%A8%E5%A4%A7/opencv_bug_3.png" alt="引入相应的模块文件"></p></li></ol><p>查看 <code>opencv.hpp</code> 文件里面的内容 最终通过二分排查, 确定了 只要引用 <code>opencv2/dnn.hpp</code> 之后,占用巨大, 本项目中不会用到这个头文件所以,这里可以不加入即可,问题解决!!</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include "opencv2/opencv_modules.hpp"</span></span><br><span class="line"><span class="comment">//#include "opencv2/calib3d.hpp"</span></span><br><span class="line"><span class="comment">//#include "opencv2/features2d.hpp"</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/dnn.hpp"</span>      <span class="comment">// 最终确定占用巨大</span></span></span><br><span class="line"><span class="comment">//#include "opencv2/flann.hpp"</span></span><br><span class="line"><span class="comment">//#include "opencv2/highgui.hpp"</span></span><br><span class="line"><span class="comment">//#include "opencv2/imgcodecs.hpp"</span></span><br><span class="line"><span class="comment">//#include "opencv2/imgproc.hpp"</span></span><br><span class="line"><span class="comment">//#include "opencv2/ml.hpp"</span></span><br><span class="line"><span class="comment">//#include "opencv2/objdetect.hpp"</span></span><br><span class="line"><span class="comment">//#include "opencv2/photo.hpp"</span></span><br><span class="line"><span class="comment">//#include "opencv2/shape.hpp"</span></span><br><span class="line"><span class="comment">//#include "opencv2/stitching.hpp"</span></span><br><span class="line"><span class="comment">//#include "opencv2/superres.hpp"</span></span><br><span class="line"><span class="comment">//#include "opencv2/video.hpp"</span></span><br><span class="line"><span class="comment">//#include "opencv2/videoio.hpp"</span></span><br><span class="line"><span class="comment">//#include "opencv2/videostab.hpp"</span></span><br></pre></td></tr></table></figure><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>图中程序部分是 VS2015 , 右侧进程管理查看软件是 ProcessExplorer_v16.21 可以查看进程的各种细节</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>无</p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> VS2015 </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtomineerUtils使用说明</title>
      <link href="/2019/11-14/AtomineerUtils%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html"/>
      <url>/2019/11-14/AtomineerUtils%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://www.atomineerutils.com/products.php" target="_blank" rel="noopener">AtomineerUtils</a> 是国外的一款用于生成源代码注释的一款 VS 插件工具.<br>这款插件，支持 C、C++、C++/CLI、C#、Java 语言等，由此可以看出其强大，注释的风格可以灵活配置。</p><h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p>软件是付费软件, 具体使用版本见附件 <a href="AtomineerUtils使用说明/AtomineerUtils936.zip">AtomineerUtils936</a> 也可以在参考链接给出的网页内找到 使用方法.</p><p>具体安装方法可以看压缩包内附件文档,</p><hr><ol start="0"><li>正常安装相应文件夹内的VS插件,本人使用的是 VS2015 插件</li><li>第一次请务必断网进入VS，在插件里面把本工具的自动更新关闭掉，更新到最新版本将直接无法使用破解版本(如果刚好试用到期也不就不能用了)。</li></ol><p>VS 2015之下的版本(未测试是否可用):<br>    安装路径自己选的，然后找到：你的安装路径/visual studio 20**/Addins/AtomineerUtils/<br>替换掉里面的Atomineer.Utils.dll就好了</p><p>VS 2015版本:<br>    替换位置: %LocalAppData%/Microsoft/VisualStudio/14.0/Extensions/<strong>**</strong>(随机的名称)/<br>VS 2017版本:<br>    替换位置: %LocalAppData%/Microsoft/VisualStudio/15.0_<strong><em>**</em></strong> (随机的名称) /Extensions/<strong>**</strong>(随机的名称)/</p><ol start="2"><li>在相应文件夹内找到文件, 使用附件文件夹内的 同名文件替换掉里面的AtomineerProDocumentation.dll就好了</li></ol><p>可以在VS 的拓展目录<code>C:\Users\Chen\AppData\Local\Microsoft\VisualStudio\14.0\Extensions</code> 下搜索文件名可以快速找到</p><p>例如个人最终的路径为</p><blockquote><p>C:\Users\Chen\AppData\Local\Microsoft\VisualStudio\14.0\Extensions\g2iuajz1.bzo\AtomineerProDocumentation.dll</p></blockquote><p>PS:如果使用过程中出现路径错误的情况，菜单栏-&gt;工具-&gt;Atomineer…Trial-&gt;…options 进去点下确定出来就好了。</p><p>或者进入安装路径找到AtomineerUtilsWizard.exe，通过一下配置向导</p><hr><a id="more"></a><h2 id="使用方法说明"><a href="#使用方法说明" class="headerlink" title="使用方法说明"></a>使用方法说明</h2><p>由于插件没有中文, 但是并不难理解,<br>使用的详细方法可以分为以下几步</p><h3 id="1-VS-进入设置方法"><a href="#1-VS-进入设置方法" class="headerlink" title="1. VS 进入设置方法"></a>1. VS 进入设置方法</h3><p>工具-&gt;AtomineerProDocumentation Trail -&gt; Atominee Option</p><p><img src="/2019/11-14/AtomineerUtils%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/atomineer_2.png" alt="进入方法"></p><h3 id="2-初始设定"><a href="#2-初始设定" class="headerlink" title="2. 初始设定"></a>2. 初始设定</h3><p>建议点击 quick 选择设置方案,根据自己感觉比较好看的方式设定即可, 因为后续需求, 这里选择的方案是 doxygen 的方式, 后续可以根据注释生成项目文档<br>仅供参考</p><p><img src="/2019/11-14/AtomineerUtils%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/atomineer_3.png" alt="初始设定"></p><h3 id="3-注释模板路径"><a href="#3-注释模板路径" class="headerlink" title="3. 注释模板路径"></a>3. 注释模板路径</h3><p>在通用设置界面, 选择注释模板文件的搜索路径, 会先从给出的路径进行搜索,如果存在会优先使用,如果找不到就会使用程序默认的方式生成注释, 附件<a href="AtomineerUtils使用说明/DoxygenTemplates.xml">详细配置文档</a> 给出了自己的一份配置文件, 比较满意 如果自己感觉不舒服可以自己调整</p><p><img src="/2019/11-14/AtomineerUtils%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/atomineer_4.png" alt="注释模板"></p><p>在通用设置的上半部分还可以设置右键显示的快捷菜单和菜单栏二级菜单显示的内容</p><h3 id="4-注释规则"><a href="#4-注释规则" class="headerlink" title="4. 注释规则"></a>4. 注释规则</h3><p>可以根据不同的规则生成不同的注释, 这里使用较少, 暂时不了解怎么使用的, </p><p><img src="/2019/11-14/AtomineerUtils%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/atomineer_5.png" alt="不同规则"></p><h2 id="详细配置文档"><a href="#详细配置文档" class="headerlink" title="详细配置文档"></a>详细配置文档</h2><p>详细配置文档定义了相应的行 执行相应的内容  在执行生成注释的时候会根据xml 配置文件以及在软件中的设置自动生成相关内容 <a href="AtomineerUtils使用说明/DoxygenTemplates.xml">详细配置文档</a></p><details><br><br><summary>详细配置文档  DoxygenTemplates.xml </summary><br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">DoxygenTemplates</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      Templates for Doxygen/JavaDoc/Qt Comment blocks</span></span><br><span class="line"><span class="comment">      ===============================================</span></span><br><span class="line"><span class="comment">      These control which entries are added to the doc-comment for each type of code element,</span></span><br><span class="line"><span class="comment">      and their order.</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      Full documentation can be found in the Atomineer user manual.</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Global settings for the entry types.</span></span><br><span class="line"><span class="comment">       These control the style and formatting of the individual types of entries defined in the templates below.</span></span><br><span class="line"><span class="comment">       Each element here should match one of the entries in your template blocks, and should either match the</span></span><br><span class="line"><span class="comment">       entry names Atomineer supports (e.g. "summary") or a custom entry type. If you wish to use a different </span></span><br><span class="line"><span class="comment">       name in your entries than Atomineer (e.g. you prefer "brief" to "summary", then use the &lt;summary&gt; element</span></span><br><span class="line"><span class="comment">       and set its _tagName attribute to "brief". You can also add a comma-separated list of _aliases to allow</span></span><br><span class="line"><span class="comment">       for conversions from legacy comments.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Primary settings (see the user manual for more details) are:</span></span><br><span class="line"><span class="comment">        _optionaltrue indicates this entry is not to be added by Atomineer, but shuld be preserved</span></span><br><span class="line"><span class="comment">                false indicates that this entry type is required, so Atomineer should automtaically add it</span></span><br><span class="line"><span class="comment">        _punctuatetrue/false to control automatic punctuation insertion</span></span><br><span class="line"><span class="comment">        _wordwraptrue/false to control whether word-wrapping is applied to the description</span></span><br><span class="line"><span class="comment">        _copyFromBasetrue/fase to control whether this type of entry can be copied from base-class documentation</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        _tagNameThe entry tag you want to use in your documentation, e.g. for Atomineer's "summary" you might</span></span><br><span class="line"><span class="comment">                prefer to use the tag "description"</span></span><br><span class="line"><span class="comment">        _aliasesA comma-separated list of other tags that should be considered equivalent (to convert legacy comments)</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--  条目类型的全局设置。=""</span></span><br><span class="line"><span class="comment">       它们控制下面模板中定义的各种条目类型的样式和格式。=""</span></span><br><span class="line"><span class="comment">       这里的每个元素都应该匹配模板块中的一个条目，并且应该匹配=""</span></span><br><span class="line"><span class="comment">       条目名称Atomineer支持（例如“摘要”）或自定义条目类型。如果你想使用不同的=""</span></span><br><span class="line"><span class="comment">       您的条目中的名称不是Atomineer（例如，您更喜欢“简要”到“摘要”，然后使用=""    元素</span></span><br><span class="line"><span class="comment">           并将其_tagName属性设置为“brief”。您还可以添加逗号分隔的_aliases列表以允许</span></span><br><span class="line"><span class="comment">           来自遗留评论的转换。</span></span><br><span class="line"><span class="comment">           主要设置（有关详细信息，请参阅用户手册）包括：</span></span><br><span class="line"><span class="comment">            _optional true表示Atomineer不会添加此条目，但会保留该条目</span></span><br><span class="line"><span class="comment">                    false表示此条目类型是必需的，因此Atomineer应自动添加它</span></span><br><span class="line"><span class="comment">            _punctuate true / false控制自动标点符号插入</span></span><br><span class="line"><span class="comment">            _wordwrap true / false控制是否将自动换行应用于描述</span></span><br><span class="line"><span class="comment">            _copyFromBase true / fase控制是否可以从基类文档中复制此类条目</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            _tagName您要在文档中使用的条目标记，例如对于Atomineer的“总结”你可能会</span></span><br><span class="line"><span class="comment">                    更喜欢使用标签“description”</span></span><br><span class="line"><span class="comment">            _aliases以逗号分隔的其他标记列表，应视为等效（转换旧版注释）</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- prototye is a template placeholder for the code element type (fn,method,class,interface,etc) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">EntrySettings</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> <span class="attr">_punctuate</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span> <span class="attr">_punctuate</span>=<span class="string">"false"</span> <span class="attr">_optional</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">copyright</span> <span class="attr">_punctuate</span>=<span class="string">"false"</span> <span class="attr">_optional</span>=<span class="string">"true"</span> <span class="attr">_aliases</span>=<span class="string">"copyright,Copyright,Copy,copy"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">date</span> <span class="attr">_punctuate</span>=<span class="string">"false"</span> <span class="attr">_optional</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">remarks</span> <span class="attr">_optional</span>=<span class="string">"true"</span> <span class="attr">_aliases</span>=<span class="string">"remark"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> <span class="attr">_punctuate</span>=<span class="string">"false"</span> <span class="attr">_tagName</span>=<span class="string">"brief"</span> <span class="attr">_aliases</span>=<span class="string">"summary,desc,description,details,purpose,short"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exception</span> <span class="attr">_tagName</span>=<span class="string">"exception"</span> <span class="attr">_aliases</span>=<span class="string">"throw,throws"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">_punctuate</span>=<span class="string">"false"</span> <span class="attr">_tagName</span>=<span class="string">"param"</span> <span class="attr">_aliases</span>=<span class="string">"parameter"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">typeparam</span> <span class="attr">_tagName</span>=<span class="string">"tparam"</span> <span class="attr">_aliases</span>=<span class="string">"typeparam"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">returns</span> <span class="attr">_punctuate</span>=<span class="string">"false"</span> <span class="attr">_tagName</span>=<span class="string">"returns"</span> <span class="attr">_aliases</span>=<span class="string">"return,retval,result,value"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> <span class="attr">_punctuate</span>=<span class="string">"false"</span> <span class="attr">_optional</span>=<span class="string">"true"</span> <span class="attr">_tagName</span>=<span class="string">"sa"</span> <span class="attr">_aliases</span>=<span class="string">"see,seealso"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">example</span> <span class="attr">_punctuate</span>=<span class="string">"false"</span> <span class="attr">_optional</span>=<span class="string">"true"</span> <span class="attr">_tagName</span>=<span class="string">"example"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">inheritdoc</span> <span class="attr">_punctuate</span>=<span class="string">"false"</span> <span class="attr">_optional</span>=<span class="string">"true"</span> <span class="attr">_tagName</span>=<span class="string">"inheritdoc"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">EntrySettings</span>&gt;</span>`</span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Special header and footer pair for .h and .hpp files, which will automatically add an</span></span><br><span class="line"><span class="comment">         include-once mechanism to the file.--&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- .h 文件 自动添加 #If endif--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;file _filetypes=".h .hpp" _addfooter="true" _separators="false"&gt;</span></span><br><span class="line"><span class="comment">      &lt;prototype&gt;%projectpathname%&lt;/prototype&gt;</span></span><br><span class="line"><span class="comment">      &lt;_ /&gt;</span></span><br><span class="line"><span class="comment">      &lt;summary /&gt;</span></span><br><span class="line"><span class="comment">      &lt;changelog&gt;%date%    %user%Created&lt;/changelog&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      #ifndef __%leafname%_H__</span></span><br><span class="line"><span class="comment">      #define __%leafname%_H__</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &lt;/file&gt;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    &lt;filefooter filetypes=".h.hpp" _separators="false"&gt;</span></span><br><span class="line"><span class="comment">      End of %projectpathname%</span></span><br><span class="line"><span class="comment">      #endif// __%leafname%_H__</span></span><br><span class="line"><span class="comment">    &lt;/filefooter&gt;--&gt;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 文件头  comment 格式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span>&gt;</span>%projectpathname%<span class="tag">&lt;/<span class="name">prototype</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">copyright</span>&gt;</span> Copyright (c) 2019 IRIS_Chen IRIS Lab <span class="tag">&lt;/<span class="name">copyright</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">changelog</span>&gt;</span>%date%    %user%Created<span class="tag">&lt;/<span class="name">changelog</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">file-vb</span> <span class="attr">_separators</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span>&gt;</span>%projectpathname%<span class="tag">&lt;/<span class="name">prototype</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">file-vb</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Free-form text example</span></span><br><span class="line"><span class="comment">    &lt;file&gt;</span></span><br><span class="line"><span class="comment">      // project:%project%</span></span><br><span class="line"><span class="comment">      // file:%projectpathname%</span></span><br><span class="line"><span class="comment">      //</span></span><br><span class="line"><span class="comment">      // summary:%fileDescription%</span></span><br><span class="line"><span class="comment">      //</span></span><br><span class="line"><span class="comment">      //%copyright%</span></span><br><span class="line"><span class="comment">      //</span></span><br><span class="line"><span class="comment">      //DateDeveloperChange</span></span><br><span class="line"><span class="comment">      //%date%%user%Created</span></span><br><span class="line"><span class="comment">    &lt;/file&gt;</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Default plain-text Atomineer file footer. These follow the same form as the file headers above --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filefooter</span>&gt;</span></span><br><span class="line">      End of %projectpathname%</span><br><span class="line">    <span class="tag">&lt;/<span class="name">filefooter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filefooter-vb</span> <span class="attr">_separators</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">      '---------------------------------------------------------------------------------------------------</span><br><span class="line">      ' End of %projectpathname%</span><br><span class="line">    <span class="tag">&lt;/<span class="name">filefooter-vb</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      Comment template for catch-all comments. These are added when the filetype of the document</span></span><br><span class="line"><span class="comment">      is not one of the core languages that Atomineer can parse to auto-document. The separators</span></span><br><span class="line"><span class="comment">      and line headers used for each file extension (e.g. .html, .sql) are configured in your</span></span><br><span class="line"><span class="comment">      Prefs.xml, allowing Atomineer to correctly insert simple "boilerplate" comments into any</span></span><br><span class="line"><span class="comment">      file format.</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">catchall</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>%user%<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">date</span>&gt;</span>%date%<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">catchall</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      Default namespace comment. As with file comments, you can use plain-text or XML commenting for</span></span><br><span class="line"><span class="comment">      this entry.</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">namespace</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">namespace</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">typedef</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typedef</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">enum</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">enum</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bitfield</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bitfield</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">struct</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>%user%<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">date</span>&gt;</span>%date%<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">struct</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">union</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>%user%<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">date</span>&gt;</span>%date%<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">union</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>%user%<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">date</span>&gt;</span>%date%<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>%user%<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">date</span>&gt;</span>%date%<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>%user%<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">date</span>&gt;</span>%date%<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- C/C++ #define macro --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">def</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>%user%<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">date</span>&gt;</span>%date%<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">def</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- C++ Function Method 头部声明 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">method</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>%user%<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">date</span>&gt;</span>%date%<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exception</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">returns</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">method</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exception</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">indexer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exception</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">returns</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">indexer</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delegate</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>%user%<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">date</span>&gt;</span>%date%<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exception</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">returns</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">delegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>%user%<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">date</span>&gt;</span>%date%<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exception</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">destructor</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>%user%<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">date</span>&gt;</span>%date%<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exception</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">destructor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">finaliser</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>%user%<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">date</span>&gt;</span>%date%<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exception</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">finaliser</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">operator</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>%user%<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">date</span>&gt;</span>%date%<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exception</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">returns</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">operator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">eventhandler</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>%user%<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">date</span>&gt;</span>%date%<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exception</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">returns</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">eventhandler</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">eventsender</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>%user%<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">date</span>&gt;</span>%date%<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exception</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">returns</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">eventsender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">member</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">member</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Templates for methods in abstract classes and interfaces --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interfacemethod</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">returns</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interfacemethod</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">interfaceproperty</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interfaceproperty</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">interfaceindexer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prototype</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">summary</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">returns</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">_</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">seealso</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interfaceindexer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">DoxygenTemplates</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br><br><br></details><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.windawings.com/reverse/atomineer-crack.html" target="_blank" rel="noopener">Atomineer Pro Documentation Trial 9.36 Crack</a></li><li><a href="https://www.jb51.net/softs/577153.html" target="_blank" rel="noopener">atomineer pro documentation utils(visual studio常用插件) V9.45 官方版</a></li><li><a href="https://blog.csdn.net/windawings/article/details/50607159" target="_blank" rel="noopener">Atomineer Pro Documentation Trial 9.36 Cracked</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VS2015 </tag>
            
            <tag> Plugin </tag>
            
            <tag> Crack </tag>
            
            <tag> Atomineer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT使用提升自定义组件</title>
      <link href="/2019/11-10/QT%E4%BD%BF%E7%94%A8%E6%8F%90%E5%8D%87%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6.html"/>
      <url>/2019/11-10/QT%E4%BD%BF%E7%94%A8%E6%8F%90%E5%8D%87%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6.html</url>
      
        <content type="html"><![CDATA[<p>QT 组件提升来实现自定义功能</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>我们在使用 QT 设置界面之后,往往需要自己实现一些方法,如果是单独 的还好,但是如果遇到很多同类型的都有需求,</p><p>比如 我们使用 QLineEdit 来处理数据,每次填入的数值都要更新到一个参数值中的时候, 我们需要将这个输入框的完成信号 连接到一个自定义的函数中 来更改某个值,</p><p>如果很多的时候, 我们就可以使用 继承组件然后使用提升来做了</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>如图所示的界面,我们需要对每个单行编辑框, 完成点击按钮就调整值的的方法</p><p><img src="/2019/11-10/QT%E4%BD%BF%E7%94%A8%E6%8F%90%E5%8D%87%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/QT_promotion.png" alt="QT界面"></p><p>具体的提升的方法可以参考 <a href="https://blog.csdn.net/y396397735/article/details/78451245" target="_blank" rel="noopener">Qt 自定义控件以及控件的提升</a> 的具体做法, 这里只介绍我们使用的方法</p><p>我们自定义的 类为 CLineEdit<br>我们设置了 公开的 <code>Associate</code> 函数, 将我们需要显示的 <code>QLineEdit</code> 组件 和两个 点击按钮以及内存存储相应数据的位置 关联起来, 点击相应按钮之后 会执行内存数据的加减, 然后再显示在相应的组件上, 便于查看,</p><a id="more"></a><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><details><br><summary>具体实现代码 </summary><br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file    Code\model\clineedit.h.</span></span><br><span class="line"><span class="comment"> * @copyright   Copyright (c) 2019 IRIS_Chen IRIS Lab</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   Declares the clineedit class</span></span><br><span class="line"><span class="comment"> * @changelog   2019/11/12    IRIS_Chen Created.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CLINEEDIT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLINEEDIT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMouseEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QString&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @class   CLineEdit clineedit.h Code\model\clineedit.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   继承Qt 自定义文件 提升成为自己的组件, 修改窗口的值之后 保证相应的值 直接赋值到相应的内存中 如果关联了相应的 点击按钮, 按钮点击之后可以触发 数据更改</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment"> * @date    2019/11/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLineEdit</span> :</span> <span class="keyword">public</span> QLineEdit</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *m_data_;   <span class="comment">///&lt; 指定数据关联的指针</span></span><br><span class="line">    QPushButton *btn_plus_; <span class="comment">///&lt; 定义增加按钮</span></span><br><span class="line">    QPushButton *btn_minus_;    <span class="comment">///&lt; 定义减少按钮</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CLineEdit</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span> :</span></span><br><span class="line">        QLineEdit(parent),</span><br><span class="line">        m_data_(<span class="literal">nullptr</span>),</span><br><span class="line">        btn_plus_(<span class="literal">nullptr</span>),</span><br><span class="line">        btn_minus_(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输入完成进入自定义处理函数</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  bool CLineEdit::Associate(int *data, bool over = true)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   将内存与组件关联</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/11/13</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param [in,out]  data    If non-null, the data</span></span><br><span class="line"><span class="comment">     * @param           over    (Optional) True to over</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  True if it succeeds, false if it fails</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Associate</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">bool</span> over = <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 有值且不让覆盖 返回出错</span></span><br><span class="line">        <span class="keyword">if</span> (!over &amp;&amp; m_data_ != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        m_data_ = data;</span><br><span class="line">        ShowData();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  bool CLineEdit::Associate(int *data, QPushButton *plus, QPushButton *minus, bool over = true)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   关联数据 和两个按钮</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/11/13</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param [in,out]  data    If non-null, the data</span></span><br><span class="line"><span class="comment">     * @param [in,out]  plus    If non-null, the plus</span></span><br><span class="line"><span class="comment">     * @param [in,out]  minus   If non-null, the minus</span></span><br><span class="line"><span class="comment">     * @param           over    (Optional) True to over</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  True if it succeeds, false if it fails</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Associate</span><span class="params">(<span class="keyword">int</span> *data, QPushButton *plus, QPushButton *minus, <span class="keyword">bool</span> over = <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 有值且不让覆盖 返回出错</span></span><br><span class="line">        <span class="keyword">if</span> (!over &amp;&amp; (m_data_ || btn_minus_ || btn_plus_))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        m_data_ = data;</span><br><span class="line">        btn_minus_ = minus;</span><br><span class="line">        btn_plus_ = plus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关联 按钮点击信号</span></span><br><span class="line">        QObject::connect(<span class="keyword">this</span>, &amp;QLineEdit::editingFinished, <span class="keyword">this</span>, &amp;CLineEdit::LineEditDataProc);</span><br><span class="line">        QObject::connect(btn_plus_, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;CLineEdit::LineEditDataPlus);</span><br><span class="line">        QObject::connect(btn_minus_, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;CLineEdit::LineEditDataMinus);</span><br><span class="line"></span><br><span class="line">        ShowData();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> slots:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  bool CLineEdit::LineEditDataProc(void)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   数据输入完成 将数据存储相应内存中</span></span><br><span class="line"><span class="comment">     *           暂时只考虑 数据部分, 将填入的数据内容给 获取出来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/11/13</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  True if it succeeds, false if it fails</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">LineEditDataProc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_data_)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        QString str = <span class="keyword">this</span>-&gt;text();</span><br><span class="line">        <span class="keyword">int</span> num = str.toInt();</span><br><span class="line">        <span class="comment">// 转换相应的值存储</span></span><br><span class="line">        *(<span class="keyword">this</span>-&gt;m_data_) = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(num);</span><br><span class="line">        <span class="comment">// LTrace("line data Edit:&#123;&#125;--&#123;&#125;", (int)m_data_, *m_data_);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  bool CLineEdit::LineEditDataPlus(void)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   数据 增加 并做显示</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/11/13</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  True if it succeeds, false if it fails</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">LineEditDataPlus</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_data_)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        *m_data_ = *m_data_ + <span class="number">1</span>;</span><br><span class="line">        ShowData();</span><br><span class="line">        <span class="comment">// LTrace("line data Plus:&#123;&#125;--&#123;&#125;", (int)m_data_, *m_data_);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  bool CLineEdit::LineEditDataMinus(void)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   数据减少 信号</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/11/13</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  True if it succeeds, false if it fails</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">LineEditDataMinus</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_data_)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        *m_data_ = *m_data_ - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        ShowData();</span><br><span class="line">        <span class="comment">// LTrace("line data Minus:&#123;&#125;--&#123;&#125;", (int)m_data_, *m_data_);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  void CLineEdit::ShowData(void)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Shows the data</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/11/13</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowData</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_data_)</span><br><span class="line">        &#123;</span><br><span class="line">            QString str = QString::number(*m_data_);</span><br><span class="line">            <span class="keyword">this</span>-&gt;setText(str);</span><br><span class="line">            <span class="built_in">string</span> tmp = str.toStdString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// CLINEEDIT_H</span></span></span><br></pre></td></tr></table></figure><br><br></details><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>我们可以设置相应的更为复杂的提升, 不仅关联 int 类型数据, 还能关联其他类型的数据比如字符串之类的 便于后续开发过程</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/y396397735/article/details/78451245" target="_blank" rel="noopener">Qt 自定义控件以及控件的提升</a></li><li><a href="https://blog.csdn.net/qiurisuixiang/article/details/6897914" target="_blank" rel="noopener">Qt 基础学习（3）—–滑动条之 QSlider</a></li><li><a href="https://blog.csdn.net/caoshangpa/article/details/51405179" target="_blank" rel="noopener">Qt 中控件类的提升</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> QT </tag>
            
            <tag> QT自定义 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串口数据帧同步</title>
      <link href="/2019/11-09/%E4%B8%B2%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%B8%A7%E5%90%8C%E6%AD%A5.html"/>
      <url>/2019/11-09/%E4%B8%B2%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%B8%A7%E5%90%8C%E6%AD%A5.html</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>串口是十分常用的一个资源, 每次需要进行处理串口数据, 但是 PC 上的串口存在缓冲区机制, 导致串口跟我们在单片机中的使用方式可能有所不同,<br>每次拿到缓冲区数据之后,判断是否满足帧头,进而开始新的一帧数据计数存储, 最终满足一帧数据之后 将数据发送出来.</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们使用自定义的存储结果 作为自己的存储结果, 一般来说在项目中使用就是帧数据长度是一致的, 我们的程序也是基于这个原理的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    uchar *data_;   <span class="comment">///&lt; 帧数据</span></span><br><span class="line">    uchar *head_;   <span class="comment">///&lt; 帧头数据</span></span><br><span class="line">    <span class="keyword">int</span> dat_len_;   <span class="comment">///&lt; 数据帧长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>我们需要根据自己的协议初始化数据长度和数据帧头内容 假设我们的数据为 14 个字节 包括 一般使用串口通信的数据都是按照这种格式进行的数据发送,</p><blockquote><p>[帧头] [长度] [地址] [指令] [数据] [校验]<br>00 01 02 03 04 05 06 07 08 09 10 11 12 13<br>68 0D 00 84 00 04 09 11 79 45 00 81 13 01</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">frame_len = <span class="number">14</span>;</span><br><span class="line">data_ = <span class="keyword">new</span> uchar[frame_len];               <span class="comment">///&lt; 存储数据</span></span><br><span class="line">head_ = <span class="keyword">new</span> uchar[<span class="number">4</span>]&#123; <span class="number">0x68</span>,<span class="number">0x0D</span>,<span class="number">0x00</span>,<span class="number">0x84</span> &#125;; <span class="comment">///&lt; 旧版协议头</span></span><br></pre></td></tr></table></figure><p>实际上我们确定通信协议之后,PC 不存在命令之类的解析的话,可以把前面四个字节处理帧头,<br>每次接收到帧头四个字节的时候表示数据已经重新开始了一帧,将收集到的数据存储相应的流程即可,继续处理后续数据</p><ol><li>如果数据正常, 读取到帧头数据之后,假设帧头数据一致, 数据依次往后填充数据,等到数组填满,会再次获取到帧头数据</li><li>根据上一帧的状态码, 确定当前值, 如果满足设定的四个值, 满足帧头数据, 处理后续字节</li><li>将数据与帧头数组依次比较,使用 $flg_status$ 记录上一次匹配的位置, 如果不一致, 置零, 下次重新开始,</li><li>每次判断四个字节一致之后, $flg_status$ 累加到了 4 , 这时候进行 数据校验, 根据结果,将当前数据帧的值 压入队列中,</li><li>以上方法会导致第一帧校验失败,但是后续的帧处理结果可以保证不会出现问题, 相当于将四个字符作为了帧尾处理</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> data_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> flg_status = <span class="number">0</span>;  <span class="comment">// 0 普通数据,与数据头1 比较, 1 数据头1,2 数据头2, 3 数据头3,</span></span><br><span class="line">                            <span class="comment">// 每次将缓冲区 数据全部读出来,</span></span><br><span class="line">                            <span class="comment">// 判断上一帧读取到了什么状态, 数据分为 前4个字节的帧头数据和 后面的数据</span></span><br><span class="line">                            <span class="comment">// 1.读取到了帧头 // 2. 读取到了一般数据帧</span></span><br><span class="line">                            <span class="comment">// 每次计数, 读取到帧头的时候, 判断数据是否已经满了, 已经满了进行数据校验, 满足就加入数据</span></span><br><span class="line">                            <span class="comment">// 数据未满, 则可能数据未满,</span></span><br><span class="line">QByteArray recv = serial_-&gt;readAll();   <span class="comment">// QSerial  读取的数据类型是 QByteArrray</span></span><br><span class="line"><span class="keyword">int</span> N = recv.size();</span><br><span class="line"><span class="keyword">if</span> (recv.isEmpty())</span><br><span class="line">&#123;</span><br><span class="line">    Sleep(<span class="number">5</span>);   <span class="comment">// 休眠5毫秒</span></span><br><span class="line">    LError(<span class="string">"recv data is empty"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历得到的数据数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line">    uchar tmp = char2uchar(recv[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次来了数据与上次的置位比较, 如果一致, 比较后一位,</span></span><br><span class="line">    <span class="comment">//  如果前面4位都一致,表示已经开始了新的一帧, 将数据依次复制</span></span><br><span class="line">    <span class="comment">//    如果数据已经满足帧头, 将之前的数据 校验满足之后加入队列中, 其他线程处理</span></span><br><span class="line">    <span class="keyword">if</span> (tmp == m_Frame.head_[flg_status])</span><br><span class="line">    &#123;</span><br><span class="line">        flg_status++;</span><br><span class="line">        <span class="keyword">if</span> (flg_status == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 由于存在每次存入数据的时候存在上一帧的数据 问题 所以这里校验可能失败</span></span><br><span class="line">            m_read_queue_-&gt;Push(m_Frame);</span><br><span class="line">            <span class="comment">// 更新前面4个字节的帧头数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">                m_Frame.data_[i] = m_Frame.head_[i];</span><br><span class="line">            <span class="comment">// 匹配重新置零, 同时将数据前面数据复制过去</span></span><br><span class="line">            flg_status = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        flg_status = <span class="number">0</span>; <span class="comment">// 如果前面的匹配上了, 后面匹配不上, 则重新开始进行匹配</span></span><br><span class="line">    &#125;</span><br><span class="line">    m_Frame.data_[data_cnt++] = tmp;    <span class="comment">// 移动指针, 将数据存储到数组中</span></span><br><span class="line">    <span class="comment">// 超过设定值, 减去一个长度,避免越界  // 与取与操作 % 处理一致</span></span><br><span class="line">    <span class="comment">// 重新开始的位置 从可以刷新的数据开始</span></span><br><span class="line">    <span class="keyword">if</span> (data_cnt == m_Frame.dat_len_)</span><br><span class="line">        data_cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--more--><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>这个程序是自己目前在使用的方法,简单有效, 适用于串口通信的数据处理,十分好用, 这个算是项目文档 的一部分,后续可能再拓展, 但是基本框架不变, 测试起来也很好用</p><p>自己测试过程可以使用 <a href="https://www.cr173.com/soft/21406.html" target="_blank" rel="noopener">VSPD 虚拟串口 6.9 汉化版</a> 模拟出来两个相连的串口,初始设置一下就好, 然后使用普通的串口调试软件打开两个串口即可进行通信,十分方便,</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>无</p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 串口 </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客插入图片的方法</title>
      <link href="/2019/11-09/Hexo%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E6%B3%95.html"/>
      <url>/2019/11-09/Hexo%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h2 id="hexo-blog-插入图片的方法总结"><a href="#hexo-blog-插入图片的方法总结" class="headerlink" title="hexo blog 插入图片的方法总结"></a>hexo blog 插入图片的方法总结</h2><p>hexo 的 blog 内容是根据 markdown 文件的内容生成的 html 文件, 生成的文件全部在 /public 文件夹中, 所以我们使用相对路径的引用可能导致问题, 总结了一下常用的引用图片的几种方式,记录一下,避免再次忘记</p><ol><li>绝对引用: 使用 <em>/source/images</em> 文件夹</li><li>相对引用: 使用 <strong>post_asset_folder:true</strong> 建立文章同名文件夹</li><li>CDN 或者图床引用</li></ol><h3 id="1-绝对引用"><a href="#1-绝对引用" class="headerlink" title="1. 绝对引用"></a>1. 绝对引用</h3><p>少量使用图片的时候使用, 将文件放在 <em>/source/images</em> 文件夹下, 使用 markdown 语法 <code>![Lena](/images/lena.png)</code> 可以实现图片显示, 但是这种引用在本地 markdown 编辑器中会无法预览,因为相对路径不一致,找不到文件, 不过在首页内容和文章正文中都能正常显示,十分方便</p><p><img src="/images/lena.png" alt="Lena"></p><p>个人使用的方法就是这种, 由于自己很少插入图片, 但是存在一个问题,后续可能维护起来麻烦, 不知道哪里引用了哪个图片,导致文章删除但是图片仍在, 很麻烦</p><h3 id="2-相对引用"><a href="#2-相对引用" class="headerlink" title="2. 相对引用"></a>2. 相对引用</h3><p>在站点配置文件<em>/_config.yml</em> 中配置指令 <code>post_asset_folder: true</code> 这样在每次新建文章的时候就会建立同名文件夹, 直接将相应的文章图片放在文件夹内 使用 语法 <code>![Lena](Hexo博客插入图片的方法/lena.png)</code> 可以访问同名文件夹下图片资源,十分方便</p><p><img src="/2019/11-09/Hexo%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E6%B3%95/lena.png" alt="Lena"></p><a id="more"></a><h3 id="3-在线资源"><a href="#3-在线资源" class="headerlink" title="3. 在线资源"></a>3. 在线资源</h3><h4 id="在线图片"><a href="#在线图片" class="headerlink" title="在线图片"></a>在线图片</h4><p>如果我们要的图片现在网络上已经存在了,我们找到相应的地址直接引用就好<br>可以只用标准 markdown 图片语法引用相关图片 <code>![百度图片--lena](http://images2018.cnblogs.com/blog/1003156/201806/1003156-20180604175546711-227291592.png)</code></p><p>例如</p><p><strong>百度图片</strong><br><img src="http://images2018.cnblogs.com/blog/1003156/201806/1003156-20180604175546711-227291592.png" alt="百度图片--lena"></p><p><strong>CSDN 图片</strong><br><img src="https://img-blog.csdn.net/20140702104508726" alt="CSDN--lena"></p><p><strong>博客园图片</strong><br><img src="https://images0.cnblogs.com/blog/337520/201301/27145135-f64fe16d6cc849958252c2f58d1111d1.jpg" alt="cnblogs--lena"></p><p><strong>维基百科图片</strong><br><img src="https://upload.wikimedia.org/wikipedia/zh/3/34/Lenna.jpg" alt="wikipedia--lena"></p><h4 id="自己做的图"><a href="#自己做的图" class="headerlink" title="自己做的图"></a>自己做的图</h4><p>如果我们要的图只是我们自己画出来的图,或者生成的图,可以使用在线图床上传之后得到链接使用,</p><p>个人感觉最好用的图床是 <a href="https://sm.ms/" target="_blank" rel="noopener">sm.ms</a>, 点击上传之后可以得到各种链接,十分方便, 最终给出的链接比如 <code>https://i.loli.net/2019/11/09/KDut86ljxM9TXnP.png</code> 的形式</p><p>刚刚上传了代码的一段截图 得到链接在这里测试使用</p><p><img src="https://i.loli.net/2019/11/09/KDut86ljxM9TXnP.png" alt="39-53 行内容截图"></p><h3 id="图像样式自定义"><a href="#图像样式自定义" class="headerlink" title="图像样式自定义"></a>图像样式自定义</h3><p>对于 markdown 插入的图片,可能不是很满足自己的需求,需要进行一定的图片调整,比如图片居中或者图片大小控制 相应的各家 markdown 的编辑器有自己的实现规则,但是在 hexo blog 中我们对于图片的处理一般是转为直接 做 html 处理, 比如</p><ol><li>使用 img 标记来控制图片显示大小<br>图片大小控制<br><code>&lt;img src=&quot;/images/lena.png&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt;</code></li></ol><p><img src="/images/lena.png" width="50%" height="50%"></p><ol start="2"><li>使用 div 加上 css 来控制图片的显示和大小<br><code>&lt;div style=&quot;width: 200px; margin: auto&quot;&gt;![Lena](/images/lena.png)&lt;/div&gt;</code></li></ol><div style="width: 200px; margin: auto"><img src="/images/lena.png" alt="Lena"></div><ol start="3"><li><a href="https://bobcn.github.io/2018/03/24/hexo_reset_image_size/" target="_blank" rel="noopener">Hexo 中扩展 Markdown 语法设置图片的大小</a> blog 中自己写了一个控制显示的方法,可以参考</li></ol><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>个人目前使用的方法 1<br>但是后续可能要换成方法 2 更加方便管理图片以及后续可能的迁移过程, 希望对看到的你们有一点帮助.</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://fuhailin.github.io/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener">在 Hexo 博客中插入图片的各种方式</a></li><li><a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/" target="_blank" rel="noopener">Hexo 博客搭建之在文章中插入图片</a></li><li><a href="https://www.jianshu.com/p/c2ba9533088a" target="_blank" rel="noopener">hexo 博客图片问题</a></li><li><a href="http://mcbill.cn/2018/06/21/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F/" target="_blank" rel="noopener">Hexo 插入图片和设置图片大小</a></li><li><a href="https://bobcn.github.io/2018/03/24/hexo_reset_image_size/" target="_blank" rel="noopener">Hexo 中扩展 Markdown 语法设置图片的大小</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 图片 </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++-doctest-测试框架</title>
      <link href="/2019/11-08/C-doctest-%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6.html"/>
      <url>/2019/11-08/C-doctest-%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6.html</url>
      
        <content type="html"><![CDATA[<h2 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h2><p><a href="https://github.com/onqtam/doctest" target="_blank" rel="noopener">doctest</a> 是用过的最简单好用的的单元测试框架, 只需要引用 一个头文件即可</p><h3 id="无-main-函数的测试样例"><a href="#无-main-函数的测试样例" class="headerlink" title="无 main 函数的测试样例"></a>无 main 函数的测试样例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"doctest.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123; <span class="keyword">return</span> number &lt;= <span class="number">1</span> ? number : factorial(number - <span class="number">1</span>) * number; &#125;</span><br><span class="line"></span><br><span class="line">TEST_CASE(<span class="string">"testing the factorial function"</span>) &#123;</span><br><span class="line">    CHECK(factorial(<span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">    CHECK(factorial(<span class="number">2</span>) == <span class="number">2</span>);</span><br><span class="line">    CHECK(factorial(<span class="number">3</span>) == <span class="number">6</span>);</span><br><span class="line">    CHECK(factorial(<span class="number">10</span>) == <span class="number">3628800</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="有-main-函数的测试样例"><a href="#有-main-函数的测试样例" class="headerlink" title="有 main 函数的测试样例"></a>有 main 函数的测试样例</h3><p>在函数 context 的 run 执行的时候 会将所有 TEST_CASE 的宏函数展开执行, 可以根据自己的情况安排测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOCTEST_CONFIG_IMPLEMENT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"doctest.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    doctest::Context context;</span><br><span class="line">    context.applyCommandLine(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = context.run(); <span class="comment">// run doctest</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// important - query flags (and --exit) rely on the user doing this</span></span><br><span class="line">    <span class="keyword">if</span> (context.shouldExit())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// propagate the result of the tests</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"Hello, World!"</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number &lt; <span class="number">1</span> ? <span class="number">1</span> : number &lt;= <span class="number">1</span> ? number : factorial(number - <span class="number">1</span>) * number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST_CASE(<span class="string">"testing the factorial function"</span>) &#123;</span><br><span class="line">    CHECK(factorial(<span class="number">0</span>) == <span class="number">1</span>);</span><br><span class="line">    CHECK(factorial(<span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">    CHECK(factorial(<span class="number">2</span>) == <span class="number">2</span>);</span><br><span class="line">    CHECK(factorial(<span class="number">3</span>) == <span class="number">6</span>);</span><br><span class="line">    CHECK(factorial(<span class="number">10</span>) == <span class="number">3628800</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>自己简单使用的功能能够使用了,<br>自己看到了 vczh 写的一个简单的测试框架的实现, 了解原理,然后发现了这个 C++库, 真的很好用, 目前自己需要的功能够用, 后续更过功能还要自己去啃 doctest 文档</p><p>但是感觉 GoogleTest 提供的功能更多, 后续可能切换过去,</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/liao20081228/article/details/76984975" target="_blank" rel="noopener">doctest 文档翻译</a></li><li><a href="https://github.com/onqtam/doctest" target="_blank" rel="noopener">Doctest Github 仓库</a></li><li><a href="https://github.com/onqtam/doctest/blob/master/doc/markdown/tutorial.md" target="_blank" rel="noopener">Doctest 官方例程</a></li><li><a href="http://www.cppblog.com/vczh/archive/2010/06/27/118829.html" target="_blank" rel="noopener">Vczh 自定义测试框架实现</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> UnitTest </tag>
            
            <tag> Doctest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程队列实现</title>
      <link href="/2019/11-08/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0.html"/>
      <url>/2019/11-08/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0.html</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在项目中,进行多线程队列实现是一个比较麻烦的事, 找到了一个实现比较好的多线程队列实现, 自己做了一点修改更加适应自己的项目, 记录下来, 有需要的自己进行修改使用.</p><p>代码写的并不是很好, 封装起来的实现也是并不是很好用, 个人水平的一个记录, 希望理解</p><h2 id="多线程队列实现"><a href="#多线程队列实现" class="headerlink" title="多线程队列实现"></a>多线程队列实现</h2><ol><li>初始化一定长度的空间存储数据</li><li>每次压入或者弹出操作的时候需要获取锁, 保证同时只有一个操作可以被执行,</li><li>压入或者弹出数据的时候, 如果队列已经满了或者空的, 另外一个线程可能需要<strong>等待</strong>, 或者返回 <strong>false</strong> 具体看程序注释,考虑自己情况进行程序修改</li><li>最终清理对象数据, 清空队列,退出线程</li></ol><details><br><summary>具体实现代码 </summary><br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CQUEUE_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CQUEUE_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @class   Queue CQueue.h Code\inc\CQueue.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   线程安全队列实现</span></span><br><span class="line"><span class="comment"> * *        因为有std::mutex和std::condition_variable类成员,所以此类不支持复制构造函数也不支持赋值操作符(=)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment"> * @date    2019/10/10</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @tparam  T   Generic type parameter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">/**</span></span><br><span class="line"><span class="class"> * @<span class="title">class</span>   <span class="title">CQueue</span> <span class="title">CQueue</span>.<span class="title">h</span> <span class="title">Code</span>\<span class="title">inc</span>\<span class="title">CQueue</span>.<span class="title">h</span></span></span><br><span class="line"><span class="class"> *</span></span><br><span class="line"><span class="class"> * @<span class="title">brief</span>   <span class="title">Queue</span> <span class="title">of</span> <span class="title">cs</span>.</span></span><br><span class="line"><span class="class"> *</span></span><br><span class="line"><span class="class"> * @<span class="title">author</span>  <span class="title">IRIS_Chen</span></span></span><br><span class="line"><span class="class"> * @<span class="title">date</span>    2019/10/17</span></span><br><span class="line"><span class="class"> */</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">CQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// Data</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;T&gt; _queue;   <span class="comment">///&lt; 存储数据的真实队列, 不是线程安全的</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;T&gt;::size_type _size_max;    <span class="comment">///&lt; 队列的最大长度</span></span><br><span class="line">    <span class="comment">// Thread gubbins</span></span><br><span class="line">    <span class="built_in">std</span>::mutex _mutex;  <span class="comment">///&lt;  线程操作 锁</span></span><br><span class="line">    <span class="built_in">std</span>::condition_variable _fullQue;   <span class="comment">///&lt; 队列满了的信号</span></span><br><span class="line">    <span class="built_in">std</span>::condition_variable _empty; <span class="comment">///&lt; 队列为空的信号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exit</span></span><br><span class="line">    <span class="comment">// 原子操作</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">atomic_bool</span> _quit; <span class="comment">///&lt; &#123; false &#125;;     // 退出信号</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">atomic_bool</span> _finished; <span class="comment">///&lt; &#123; false &#125;; // 完成信号 // 表示不再继续输入数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  CQueue::CQueue(const size_t size_max)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   初始化队列长度,并将退出标志和 满信号标志置空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param   size_max    队列的最长尺寸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    CQueue(<span class="keyword">const</span> <span class="keyword">size_t</span> size_max) :_size_max(size_max) &#123;</span><br><span class="line">        _quit = ATOMIC_VAR_INIT(<span class="literal">false</span>);</span><br><span class="line">        _finished = ATOMIC_VAR_INIT(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  CQueue::CQueue(CONST CQueue&amp;) = delete;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   不允许拷贝构造函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param   parameter1  The first parameter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    CQueue(CONST CQueue&amp;) = <span class="keyword">delete</span>; <span class="comment">///&lt; 不允许拷贝构造函数</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  CQueue::~CQueue()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Finalizes an instance of the CQueue class  销毁队列, 退出线程 清除数据 // 存在问题</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/11/8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    ~CQueue()</span><br><span class="line">    &#123;</span><br><span class="line">        Quit();</span><br><span class="line">        <span class="keyword">while</span> (_queue.size())</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  bool CQueue::Push(T&amp; data)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   队列中加入新的 对象  根据情况决定 满信号之后 新数据丢弃或者等待</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/10</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param [in,out]  data    The data to Push.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  True if it succeeds, false if it fails.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(T&amp; data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (!_quit &amp;&amp; !_finished)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_queue.size() &lt; _size_max)</span><br><span class="line">            &#123;</span><br><span class="line">                _queue.push(<span class="built_in">std</span>::move(data));</span><br><span class="line">                <span class="comment">//_queue.Push(data);</span></span><br><span class="line">                _empty.notify_all();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// wait的时候自动释放锁，如果wait到了会获取锁</span></span><br><span class="line">                <span class="comment">// _fullQue.wait(lock);</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">///&lt; 如果满了 这里不进行等待 避免出现问题</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  bool CQueue::Pop(T &amp;data)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   返回队列最前面的元素 并且弹出 // 如果空 如果finish 则直接返回fasle 否则 等待队列加入元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/14</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param [in,out]  data    The data to Pop.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  True if it succeeds, false if it fails.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(T &amp;data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (!_quit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!_queue.empty())                <span class="comment">// 队列非空</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//data = std::move(_queue.front());</span></span><br><span class="line">                data = _queue.front();</span><br><span class="line">                _queue.pop();</span><br><span class="line"></span><br><span class="line">                _fullQue.notify_all();       <span class="comment">// 通知所有 由于满队无法加入的线程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (_queue.empty() &amp;&amp; _finished)   <span class="comment">// 队列为空 且不再加入</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// _empty.wait(lock);          // 等待队列加入元素</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">///&lt; 不等待元素加入数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  std::shared_ptr&lt;T&gt; CQueue::Pop(void)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   弹出一个元素 直接返回  出错无法报错</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/14</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  The previous top-of-stack object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">Pop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; res = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (!_quit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!_queue.empty())                <span class="comment">// 队列非空</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//data = std::move(_queue.front());</span></span><br><span class="line">                res = <span class="built_in">std</span>::make_shared&lt;T&gt;(_queue.front());</span><br><span class="line">                _queue.pop();</span><br><span class="line"></span><br><span class="line">                _fullQue.notify_all();       <span class="comment">// 通知所有 由于满队无法加入的线程</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (_queue.empty() &amp;&amp; _finished)   <span class="comment">// 队列为空 且不再加入</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> res;     <span class="comment">// 无数据进入 智能返回一个空指针 (可能出错)</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                _empty.wait(lock);          <span class="comment">// 等待队列加入元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  void CQueue::Finished()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   The queue has Finished accepting input 标识队列完成输入 不再继续输入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/14</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Finished</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _finished = <span class="literal">true</span>;</span><br><span class="line">        _empty.notify_all();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  void CQueue::Quit()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Quits this CQueue  退出队列, 无法再加入压入或者弹出数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/14</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Quit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _quit = <span class="literal">true</span>;</span><br><span class="line">        _empty.notify_all();</span><br><span class="line">        _fullQue.notify_all();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  int CQueue::Length()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Gets the Length  返回队列目前长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/14</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  An int.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(_queue.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  int CQueue::Size()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Gets the Size 返回当前队列长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/14</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  An int.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(_queue.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  bool CQueue::empty(void)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   判断是否为空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  True if it succeeds, false if it fails</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> == _queue.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  bool CQueue::Clear(void)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   清空队列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  True if it succeeds, false if it fails</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Clear</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (!_queue.empty ())</span><br><span class="line">        &#123;</span><br><span class="line">            Pop();  <span class="comment">// 依次弹出数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><br><br></details><a id="more"></a><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>有另外的多线程实现, 来自网上找到的, 可能找不到参考链接了, 贴出来 供参考</p><h3 id="线程安全队列-1"><a href="#线程安全队列-1" class="headerlink" title="线程安全队列 1"></a>线程安全队列 1</h3><details><br><summary>具体实现代码 </summary><br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @class   ThreadSafeQueue CQueue.h Code\inc\CQueue.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   线程安全队列实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment"> * @date    2019/10/10</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @tparam  T   Generic type parameter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @class   ThreadSafeQueue CQueue.h Code\inc\CQueue.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   Queue of thread safes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment"> * @date    2019/10/17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @property    mutable std::mutex mut</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Gets the mut</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  The mut</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex mut;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;T&gt; data_queue;   <span class="comment">///&lt; Queue of data</span></span><br><span class="line">    <span class="built_in">std</span>::condition_variable data_cond;  <span class="comment">///&lt; The data condition</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  ThreadSafeQueue::ThreadSafeQueue()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Initializes a new instance of the ThreadSafeQueue class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    ThreadSafeQueue() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  ThreadSafeQueue::ThreadSafeQueue(ThreadSafeQueue const&amp; other)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   拷贝构造函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param   other   The other</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    ThreadSafeQueue(ThreadSafeQueue <span class="keyword">const</span>&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(other.mut)</span></span>;</span><br><span class="line">        data_queue = other.data_queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  void ThreadSafeQueue::Push(T&amp; new_value)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Pushes an object onto this stack</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param [in,out]  new_value   The new value to Push</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T&amp; new_value)</span><span class="comment">//入队操作</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_queue.push(new_value);</span><br><span class="line">        data_cond.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  void ThreadSafeQueue::wait_and_pop(T&amp; value)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Wait and Pop</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param [in,out]  value   The value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span><span class="comment">//直到有元素可以删除为止</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.wait(lk, [<span class="keyword">this</span>]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> !data_queue.empty();</span><br><span class="line">        &#125;);</span><br><span class="line">        value = data_queue.front();</span><br><span class="line">        data_queue.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  std::shared_ptr&lt;T&gt; ThreadSafeQueue::wait_and_pop()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Wait and pop</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  A std::shared_ptr&amp;lt;T&amp;gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.wait(lk, [<span class="keyword">this</span>]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> !data_queue.empty();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">        data_queue.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  bool ThreadSafeQueue::try_pop(T&amp; value)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Attempts to pop</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param [in,out]  value   The value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  True if it succeeds, false if it fails</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span><span class="comment">//不管有没有队首元素直接返回</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data_queue.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = data_queue.front();</span><br><span class="line">        data_queue.pop();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  std::shared_ptr&lt;T&gt; ThreadSafeQueue::try_pop()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Try pop</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  A std::shared_ptr&amp;lt;T&amp;gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data_queue.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">        data_queue.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  bool ThreadSafeQueue::empty() const</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Empties this object</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  True if it succeeds, false if it fails</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data_queue.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br></details><h3 id="线程安全队列-2"><a href="#线程安全队列-2" class="headerlink" title="线程安全队列 2"></a>线程安全队列 2</h3><p><details></details></p><summary>具体实现代码 </summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 线程安全队列</span></span><br><span class="line"><span class="comment">* T为队列元素类型</span></span><br><span class="line"><span class="comment">* 因为有std::mutex和std::condition_variable类成员,所以此类不支持复制构造函数也不支持赋值操作符(=)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @class   threadsafe_queue CQueue.h Code\inc\CQueue.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   Queue of threadsafes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment"> * @date    2019/10/17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @property    mutable std::mutex mut</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   data_queue访问信号量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  The mut</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex mut;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @property    mutable std::condition_variable data_cond</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Gets the data condition</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  The data condition</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line">    <span class="keyword">using</span> queue_type = <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;T&gt;;   <span class="comment">///&lt; Type of the queue</span></span><br><span class="line">    queue_type data_queue;  <span class="comment">///&lt; Queue of data</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">typename</span> queue_type::value_type; <span class="comment">///&lt; Type of the value</span></span><br><span class="line">    <span class="keyword">using</span> container_type = <span class="keyword">typename</span> queue_type::container_type; <span class="comment">///&lt; Type of the container</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  threadsafe_queue::threadsafe_queue() = default;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Initializes a new instance of the threadsafe_queue class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    threadsafe_queue() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  threadsafe_queue::threadsafe_queue(const threadsafe_queue&amp;) = delete;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Initializes a new instance of the threadsafe_queue class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param   parameter1  The first parameter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    threadsafe_queue(<span class="keyword">const</span> threadsafe_queue&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  threadsafe_queue&amp; threadsafe_queue::operator=(const threadsafe_queue&amp;) = delete;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Assignment operator</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param   parameter1  The first parameter</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  A shallow copy of this object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    threadsafe_queue&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_queue&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 使用迭代器为参数的构造函数,适用所有容器对象</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InputIterator&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  threadsafe_queue::threadsafe_queue(_InputIterator first, _InputIterator last)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Initializes a new instance of the threadsafe_queue class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param   first   The first</span></span><br><span class="line"><span class="comment">     * @param   last    The last</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    threadsafe_queue(_InputIterator first, _InputIterator last) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> itor = first; itor != last; ++itor)</span><br><span class="line">        &#123;</span><br><span class="line">            data_queue.push(*itor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  explicit threadsafe_queue::threadsafe_queue(const container_type &amp;c)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Initializes a new instance of the threadsafe_queue class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param   c   A container_type to process</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">threadsafe_queue</span><span class="params">(<span class="keyword">const</span> container_type &amp;c)</span> :<span class="title">data_queue</span><span class="params">(c)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 使用初始化列表为参数的构造函数</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  threadsafe_queue::threadsafe_queue(std::initializer_list&lt;value_type&gt; list)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Initializes a new instance of the threadsafe_queue class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param   list    The list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    threadsafe_queue(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;value_type&gt; <span class="built_in">list</span>) :threadsafe_queue(<span class="built_in">list</span>.begin(), <span class="built_in">list</span>.end()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 将元素加入队列</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  void threadsafe_queue::push(const value_type &amp;new_value)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Pushes an object onto this stack</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param   new_value   The new value to push</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type &amp;new_value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt;lk(mut);</span><br><span class="line">        data_queue.push(<span class="built_in">std</span>::move(new_value));</span><br><span class="line">        data_cond.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 从队列中弹出一个元素,如果队列为空就阻塞</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  value_type threadsafe_queue::wait_and_pop()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Wait and pop</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  A value_type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function">value_type <span class="title">wait_and_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt;lk(mut);</span><br><span class="line">        data_cond.wait(lk, [<span class="keyword">this</span>]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> !<span class="keyword">this</span>-&gt;data_queue.empty();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">auto</span> value = <span class="built_in">std</span>::move(data_queue.front());</span><br><span class="line">        data_queue.pop();</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 从队列中弹出一个元素,如果队列为空返回false</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  bool threadsafe_queue::try_pop(value_type&amp; value)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Attempts to pop</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param [in,out]  value   The value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  True if it succeeds, false if it fails</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(value_type&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt;lk(mut);</span><br><span class="line">        <span class="keyword">if</span> (data_queue.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = <span class="built_in">std</span>::move(data_queue.front());</span><br><span class="line">        data_queue.pop();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 返回队列是否为空</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  auto threadsafe_queue::empty() const-&gt;decltype(data_queue.empty())</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Gets the empty</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  An auto</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    auto empty() const-&gt;decltype(data_queue.empty()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt;lk(mut);</span><br><span class="line">        <span class="keyword">return</span> data_queue.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 返回队列中元素数个</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @fn  auto threadsafe_queue::Size() const-&gt;decltype(data_queue.Size())</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @brief   Gets the Size</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">     * @date    2019/10/17</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return  An auto</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    auto size() const-&gt;decltype(data_queue.size()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt;lk(mut);</span><br><span class="line">        <span class="keyword">return</span> data_queue.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; <span class="comment">/* threadsafe_queue */</span></span><br></pre></td></tr></table></figure><p></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/10km/article/details/52067929" target="_blank" rel="noopener">C++11:基于 std::queue 和 std::mutex 构建一个线程安全的队列</a></li><li><a href="https://codereview.stackexchange.com/questions/41604/thread-safe-concurrent-fifo-queue-in-c" target="_blank" rel="noopener">Thread-safe concurrent FIFO queue in C++</a></li><li><a href="https://blog.csdn.net/bieleyang/article/details/78027032" target="_blank" rel="noopener">Java 多线程总结之线程安全队列 Queue</a></li><li><a href="https://blog.csdn.net/liuxuejiang158blog/article/details/17301739" target="_blank" rel="noopener">C++并发实战 12：线程安全的 queue</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平面点集中距离最近的点对</title>
      <link href="/2019/10-22/%E5%B9%B3%E9%9D%A2%E7%82%B9%E9%9B%86%E4%B8%AD%E8%B7%9D%E7%A6%BB%E6%9C%80%E8%BF%91%E7%9A%84%E7%82%B9%E5%AF%B9.html"/>
      <url>/2019/10-22/%E5%B9%B3%E9%9D%A2%E7%82%B9%E9%9B%86%E4%B8%AD%E8%B7%9D%E7%A6%BB%E6%9C%80%E8%BF%91%E7%9A%84%E7%82%B9%E5%AF%B9.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>平面上 $N$ 个点,求点集中距离最小的一对(欧式距离)<br>如图所示, 给定 7 个点的座标, 求距离最近的两个点.</p><p><img src="/images/pointdist/sevenpoint.png" alt="平面上7点求最小距离"></p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>对于 $N$ 个点的点对距离, 可以使用不同的方法解决,</p><ol><li>暴力: 暴力枚举所有的点, 找到最近的两个点的距离, 时间复杂度: $O(N^2)$;</li><li>分治<sup>1</sup>: 按照横座标排序,分为左右两部分,分别求出两部分中的最小距离, 最后考虑最近距离点对在左右两个部分的情况, 时间复杂度: $O(NlogNlogN)$</li><li>基于哈希的随机算法<sup>3</sup>:</li></ol><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h2 id="题目实战"><a href="#题目实战" class="headerlink" title="题目实战"></a>题目实战</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/lonelycatcher/article/details/7973046" target="_blank" rel="noopener">最近点对问题</a></li><li><a href="https://blog.csdn.net/Lytning/article/details/25370169" target="_blank" rel="noopener">平面最近点对 nlogn 分治算法 求平面中距离最近的两点</a></li><li><a href="https://phoenixzhao.github.io/%E6%B1%82%E6%9C%80%E8%BF%91%E5%AF%B9%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">求最近点对的三种方法</a></li><li><a href="https://www.cnblogs.com/zle1992/p/8933421.html" target="_blank" rel="noopener">平面最近点距离问题(分治法)</a></li></ol><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无序数组中求最大值和最小值的最少比较次数</title>
      <link href="/2019/10-21/%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%91%E6%AF%94%E8%BE%83%E6%AC%A1%E6%95%B0.html"/>
      <url>/2019/10-21/%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%91%E6%AF%94%E8%BE%83%E6%AC%A1%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h2 id="无序数组中求最大值和最小值的最少比较次数"><a href="#无序数组中求最大值和最小值的最少比较次数" class="headerlink" title="无序数组中求最大值和最小值的最少比较次数"></a>无序数组中求最大值和最小值的最少比较次数</h2><h3 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h3><p>求一个无序数组中的最大值和最小值是一个很常见的情况, 一般来说, 最大值和最小值不是同一个元素, 我们可以通过下面几种方法来求:</p><ol><li>排序算法:将数组排序后, 第一个元素是最小值,最后一个元素是最大值,以快排平均复杂度为例,时间复杂度 $O(NlogN)$,空间复杂度: $O(logN)$,比较次数: $NlogN$ ;</li><li>两个元素记录最大值和最小值,判断每个值是否大于最大值或者最小值, 比较次数: $2*N$’;</li><li>使用两个值记录最大值和最小值, 每次取出两个值,先进行比较,小的与最小值比较,大的与最大值比较 , 比较次数: $1.5*N$</li><li>将相邻的数进行比较,大的放在偶数位置,小的放在奇数位置, 最后奇数位置比较和偶数位置对应比较,得到最大值和最小值,比较次数: $1.5*N$ ;</li><li>分治法, topK 问题的简化版本分成两部分,找到前半部分的 Min Max, 最后比较结果可得到最后的值</li></ol><p>方法 3 和方法 4 的 过程很接近, 方法 3 更为容易实现, 具体实现可见后续</p><a id="more"></a><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="方法-1-快排"><a href="#方法-1-快排" class="headerlink" title="方法 1 快排"></a>方法 1 快排</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到数组元素的最大值和最小值</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findMinMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(arr.begin(),arr.end());</span><br><span class="line">    <span class="keyword">return</span> &#123;arr[<span class="number">0</span>],arr.back()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2"></a>方法 2</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到数组元素的最大值和最小值</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findMinMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min_ = INT_MAX,max_ = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; max_)</span><br><span class="line">            max_ = arr[i];</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; min_)</span><br><span class="line">            min_ = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;min_,max_&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法 3"></a>方法 3</h4><p>使用两个值记录最大值和最小值, 每次取出两个值,先进行比较,小的与最小值比较,大的与最大值比较 , 比较次数: $1.5*N$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到数组元素的最大值和最小值</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findMinMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min_ = INT_MAX,max_ = INT_MIN;</span><br><span class="line">    <span class="comment">// 处理前面偶数个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.size()/<span class="number">2</span>;++i) &#123;</span><br><span class="line">        <span class="comment">// 得到两个元素的最大值和最小值</span></span><br><span class="line">        <span class="keyword">int</span> tmp_min,tmp_max;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">            tmp_min = arr[i];</span><br><span class="line">            tmp_max = arr[i+<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp_min = arr[i+<span class="number">1</span>];</span><br><span class="line">            tmp_max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比较,更新最大值和最小值</span></span><br><span class="line">        <span class="keyword">if</span>(tmp_max &gt; max_)  max_ = tmp_max;</span><br><span class="line">        <span class="keyword">if</span>(tmp_min &lt; min_)  min_ = tmp_min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理数组个数为奇数的情况 // 处理最后一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(arr.size()%<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr.back();</span><br><span class="line">        <span class="keyword">if</span>(tmp &gt; max_)  max_ = tmp;</span><br><span class="line">        <span class="keyword">if</span>(tmp &lt; min_)  min_ = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;min_,max_&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法-4"><a href="#方法-4" class="headerlink" title="方法 4"></a>方法 4</h4><p>比较前面偶数个元素,小的放在奇数位置,大的放在偶数位置, 比较次数: $1.5*N$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到数组元素的最大值和最小值</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findMinMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min_ = INT_MAX,max_ = INT_MIN;</span><br><span class="line">    <span class="comment">// 调整位置, 小的位于奇数,大的位置偶数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.size()/<span class="number">2</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>])   swap(arr[i],arr[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新最大值和最小值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.size()/<span class="number">2</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; min_)   min_ = arr[i];</span><br><span class="line">        <span class="keyword">if</span>(arr[i+<span class="number">1</span>] &gt; max_) max_ = arr[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理数组个数为奇数的情况 // 处理最后一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(arr.size()%<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr.back();</span><br><span class="line">        <span class="keyword">if</span>(tmp &gt; max_)  max_ = tmp;</span><br><span class="line">        <span class="keyword">if</span>(tmp &lt; min_)  min_ = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;min_,max_&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法-5"><a href="#方法-5" class="headerlink" title="方法 5"></a>方法 5</h4><p>在 N 个数中求最小值 Min 和 Max, 分成两个部分,依次取 Min 和 Max,<br>略</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li><a href="https://blog.csdn.net/sun_wangdong/article/details/51312502" target="_blank" rel="noopener">关于在一个无序数组中的数求最大值和最小值的最小比较次数</a></li><li><a href="https://blog.csdn.net/zbao6062/article/details/43237149" target="_blank" rel="noopener">无序数组同时查找最大和最小的元素</a></li><li><a href="https://www.jianshu.com/p/96fa355e1faf" target="_blank" rel="noopener">面试题-算法：乱序数组中找最大值和最小值</a></li><li><a href="https://blog.csdn.net/xiaoding133/article/details/8043369" target="_blank" rel="noopener">【编程之美】读书笔记：寻找数组中的最大值和最小值</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FindAJob</title>
      <link href="/2019/10-10/FindAJob.html"/>
      <url>/2019/10-10/FindAJob.html</url>
      
        <content type="html"><![CDATA[<p>此文章是找工作系列的第一篇文章, 主要展示文章的书写方式, 介绍系列文章的大纲以及后续可能进行的内容梳理.</p><p>个人并不认为自己最终拿到的 offer 非常满意, 但是由于各种原因所以还是做了妥协, 准备的面试过程中, 看到了很多, 学到了很多, 但是</p><h2 id="系列文章介绍"><a href="#系列文章介绍" class="headerlink" title="系列文章介绍"></a>系列文章介绍</h2><ul><li style="list-style: none"><input type="checkbox"> 时间安排<ul><li style="list-style: none"><input type="checkbox"> 提前批</li><li style="list-style: none"><input type="checkbox"> 实习/全职</li></ul></li><li style="list-style: none"><input type="checkbox"> 非技术要求<ul><li style="list-style: none"><input type="checkbox"> 简历</li><li style="list-style: none"><input type="checkbox"> 面试</li><li style="list-style: none"><input type="checkbox"> 手撕/白板</li><li style="list-style: none"><input type="checkbox"> BQ</li><li style="list-style: none"><input type="checkbox"> 群面</li><li style="list-style: none"><input type="checkbox"> 问面试官的话</li></ul></li><li style="list-style: none"><input type="checkbox"> 技术要求<ul><li style="list-style: none"><input type="checkbox"> 计算机基础</li><li style="list-style: none"><input type="checkbox"> 算法与数据结构</li><li style="list-style: none"><input type="checkbox"> 操作系统</li><li style="list-style: none"><input type="checkbox"> 计算机网络</li><li style="list-style: none"><input type="checkbox"> 数据库</li><li style="list-style: none"><input type="checkbox"> 设计模式</li></ul></li><li style="list-style: none"><input type="checkbox"> Offer 环节<ul><li style="list-style: none"><input type="checkbox"> 薪资待遇</li><li style="list-style: none"><input type="checkbox"> offer 比较</li><li style="list-style: none"><input type="checkbox"> 公司评价</li></ul></li><li style="list-style: none"><input type="checkbox"> 其他<ul><li style="list-style: none"><input type="checkbox"> 各家公司评价</li><li style="list-style: none"><input type="checkbox"> </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Person </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> Jobs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT bug ig9icd64.dll</title>
      <link href="/2019/08-11/bug-ig9icd64-dll.html"/>
      <url>/2019/08-11/bug-ig9icd64-dll.html</url>
      
        <content type="html"><![CDATA[<h3 id="ig9icd64-dll-处有未经处理的异常"><a href="#ig9icd64-dll-处有未经处理的异常" class="headerlink" title="ig9icd64.dll 处有未经处理的异常"></a>ig9icd64.dll 处有未经处理的异常</h3><p>遇到了一个 ==奇奇怪怪==的 bug, 一般的 QT 程序中 在==main.cpp== 中初始化一个窗口进行显示后,进行执行 QApplication 的 执行 一般是如下的结构:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QT 5.11 的例程程序 示例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QGuiApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    AnalogClockWindow clock;</span><br><span class="line">    clock.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>但是不知到为什么问题, 调试程序的时候突然出现了,如图所示的错误, 提醒 ==ig9icd64.dll== 处有未经处理的异常,调试发现是在执行最后一句,==return app.exec();==</p><p><img src="https://i.loli.net/2019/08/11/EFIGJxOVq5h4pi1.png" alt="ig9icd64.dll"></p><p>进行一定搜索之后,找到了一篇 blog 介绍<a href="https://blog.csdn.net/ARM_s/article/details/79533466" target="_blank" rel="noopener">Qt 上 OpenGL 画图不能正常使用，程序崩溃</a>, 介绍的很详细, 然后解决方法是</p><blockquote><p>更新显卡驱动或者重新安装一下显卡驱动</p></blockquote><p>查看了很多网站,以及在==Intel== 的官方社区里面都有人提出这个的问题,而且应该是一个普遍的一个问题了</p><p>给出几个参考链接 以供查询</p><p><a href="https://github.com/godotengine/godot/issues/23863" target="_blank" rel="noopener">Crash in ig9icd64.dll on intel 630 (and similar) gpu in 64bit windows 10 #23863</a><br><a href="https://github.com/godotengine/godot/issues/23069" target="_blank" rel="noopener">Editor doesn’t draw properly (one frame lag) on systems with Intel drivers (driver vendor bug)</a></p><p>最终发现了 QT 官方给出的一个 BUG 报告中<a href="https://bugreports.qt.io/browse/QTBUG-64697" target="_blank" rel="noopener">Windows/IntelHD Graphics 620: Qt Quick application crashes if it contains a visible element, with certain compilers</a><br>介绍了这个 bug 是由于硬件渲染出现了问题, 自己想办法更新驱动或者==开启软件渲染==来避免问题,开启方法可用以下语句:</p><blockquote><p>QQuickWindow::setSceneGraphBackend(QSGRendererInterface::Software);</p></blockquote><p>或者使用</p><blockquote><p>QT_OPENGL = angle</p></blockquote><p>来抑制崩溃</p><p>官方还给出了详细的介绍,以及调用的堆栈信息,可以自己查阅相关内容</p><p>2019_08_11</p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
            <tag> intel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction</title>
      <link href="/2019/08-06/intro.html"/>
      <url>/2019/08-06/intro.html</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令记录"><a href="#常用命令记录" class="headerlink" title="常用命令记录"></a>常用命令记录</h2><p>记录下来常用命令, 免得每次都要查找</p><h3 id="常用指令和发布文章"><a href="#常用指令和发布文章" class="headerlink" title="常用指令和发布文章"></a>常用指令和发布文章</h3><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><blockquote><p>hexo new “postName” //新建文章<br>hexo new page “pageName” //新建页面<br>hexo g //生成静态页面至 public 目录<br>hexo server //开启预览访问端口（默认端口 4000，’ctrl + c’关闭 server）<br>hexo deploy //将.deploy 目录部署到 GitHub</p></blockquote><h4 id="常用组合"><a href="#常用组合" class="headerlink" title="常用组合"></a>常用组合</h4><blockquote><p>hexo clean<br>hexo g<br>hexo d<br>hexo d -g #生成部署<br>hexo s -g #生成预览</p></blockquote><h4 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h4><p>终端 cd 到 blog 文件夹下，执行如下命令新建文章：</p><blockquote><p>hexo new “xxx”<br>名为 xxx.md 的文件会建在目录…/blog/source/_posts 下。</p></blockquote><p>==scaffolds== 文件夹下面存储的是模板文件,可以自定义部分模板, 使用</p><blockquote><p>hexo new temp xxx.md<br>生成新文件</p></blockquote><p>所有的文章都会以 md 形式保存在_post 文件夹中，只要在_post 文件夹中新建 md 类型的文档，就能在执行 hexo g 的时候被渲染。新建的文章头需要添加一些信息，如下所示：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxx    //在此处添加你的标题。</span><br><span class="line">date: 2016-10-07 13:38:49   //在此处输入编辑这篇文章的时间。</span><br><span class="line">tags: xxx    //在此处输入这篇文章的标签。</span><br><span class="line">categories: xxx    //在此处输入这篇文章的分类。</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>文章编辑完成后，终端 cd 到 blog 文件夹下，依次执行如下命令来发布：</p><blockquote><p>hexo g<br>hexo d</p></blockquote><p>如果没有报错 那么就已经发布成功了</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex-0-latex2word</title>
      <link href="/2019/06-20/Latex-0-latex2word.html"/>
      <url>/2019/06-20/Latex-0-latex2word.html</url>
      
        <content type="html"><![CDATA[<!-- Latex 操作总结 --><h1 id="Latex-转-Word"><a href="#Latex-转-Word" class="headerlink" title="Latex 转 Word"></a>Latex 转 Word</h1><p>虽然 latex 格式很方便，能够满足绝大部分的排版要求，但是在与人沟通的时候不可避免地需要用到其他格式文件，比如来自老板的修改意见。所以还是需要部分时候需要用到 word 文件，经过一番学习，看到了神器– <a href="https://pandoc.org/" target="_blank" rel="noopener">Pandoc</a>。</p><p>只需要一句话便能够得到对应的 word 文件，但是 tikz 似乎不能转换，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandoc -s example.tex -o example.docx</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
            <tag> XeLaTex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-912-SortAnArray</title>
      <link href="/2019/06-20/LeetCode-912-SortAnArray.html"/>
      <url>/2019/06-20/LeetCode-912-SortAnArray.html</url>
      
        <content type="html"><![CDATA[<!--## LeetCode 题目解析 --><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>题目所在链接为 <a href="https://leetcode.com/problems/" target="_blank" rel="noopener">题目名字</a></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>题目描述</p><a id="more"></a><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p><strong>Example 1:</strong></p><blockquote><p>Input: 123<br>Output: 321</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p>Input: -123<br>Output: -321</p></blockquote><p><strong>Example 3:</strong></p><blockquote><p>Input: 120<br>Output: 21</p></blockquote><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>备注或者提示</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>解题思路</p><p>==时间复杂度==: $O(log(n))$<br>==空间复杂度==: $O(1)$</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol><li><a href="https://schen1024.github.io/">blog</a></li></ol><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 输入long long 型 数据 避免溢出</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将每一位的数据 升位 加上余数</span></span><br><span class="line">            sum = sum * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输入数字 降位</span></span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断溢出</span></span><br><span class="line">            <span class="keyword">if</span> (sum &gt; INT_MAX || sum &lt; INT_MIN)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>使用 C/C++实现<br>运行结果 2019-03-27</p><blockquote><p>Runtime: 8 ms, faster than 99.38% of C++ online submissions for Reverse Integer.<br>Memory Usage: 8.2 MB, less than 99.80% of C++ online submissions for Reverse Integer.</p></blockquote><!--### 改进优化#### 改进思路 题目底下最好的优化在了空间上的节省, 不用设置 long long 类型的数据, 采用int 型数据, 但是每次判断依次结果很多数据会导致溢出 直接抛弃掉 可以节省大量的时间 整体流程如下: 1. 如果结果会溢出, 如果是正值 则 $temp = rev*10+pop $ 则 $$ rev > \frac{INTMAX}{10} || (rev == \frac{INTMAX}{10} \&\& pop>7) $$ 2. 如果结果会溢出, 如果是负值 则 $temp = rev*10+pop $ 则 $$ rev <> \frac{INTMIN}{10} || (rev == \frac{INTMIN}{10} \&\& pop<-8) $$3. 其中 $ pop = x\%10 $#### 改进的实现 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &gt; INT_MAX/<span class="number">10</span> || (rev == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN/<span class="number">10</span> || (rev == INT_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><blockquote><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Reverse Integer.<br>Memory Usage: 8.1 MB, less than 99.80% of C++ online submissions for Reverse Integer.<br> –&gt;</p></blockquote>-->]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview_ReverseList.md</title>
      <link href="/2019/06-06/Interview-ReverseList.html"/>
      <url>/2019/06-06/Interview-ReverseList.html</url>
      
        <content type="html"><![CDATA[<h3 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h3><p>==经典算法题目== : 反转单链表 reverse list</p><p>对于一个普通的单链表,可以定义成结构体形式:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode * next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请写一个函数实现单链表的翻转</p><a id="more"></a><h4 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h4><p>一般来说,单链表的反转有递归和非递归的方式来进行实现, 此处的反转实现 参考<a href="https://blog.csdn.net/FX677588/article/details/72357389" target="_blank" rel="noopener">反转链表图示</a> 其中递归方式的实现比较难以理解, 进攻参考</p><h5 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归方式</span></span><br><span class="line"><span class="function">ListNode * <span class="title">ReverseList_re</span><span class="params">(ListNode * head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果空链表或者 单节点链表</span></span><br><span class="line">    <span class="keyword">if</span>(head ==<span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次进行每个节点的执行</span></span><br><span class="line">    ListNode * new_head = ReverseList_re(head-&gt;next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于每一个节点 反转前后实现</span></span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非递归方式"><a href="#非递归方式" class="headerlink" title="非递归方式"></a>非递归方式</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ref:[链表反转图文讲解](https://blog.csdn.net/FX677588/article/details/72357389)</span></span><br><span class="line"><span class="comment">// 非递归方式</span></span><br><span class="line"><span class="function">ListNode * <span class="title">ReverseList</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果空链表或者 单节点链表</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建两个节点 P用来遍历head, new_head 为新链表的头</span></span><br><span class="line">    ListNode *p = head, *new_head = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode * tmp = p-&gt;next;   <span class="comment">// 存储当前节点的指针位置</span></span><br><span class="line">        p-&gt;next = new_head;         <span class="comment">// 将当前节点指向新节点的头</span></span><br><span class="line">        new_head = p;               <span class="comment">// 新链表 移动头</span></span><br><span class="line">        p = tmp;                    <span class="comment">// 旧链表指针移动</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回新的节点值</span></span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不返回操作  非递归 反转链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseList2</span><span class="params">(ListNode * &amp;head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果空链表或者 单节点链表</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建两个节点 P用来遍历head, new_head 为新链表的头</span></span><br><span class="line">    ListNode *p = head, *new_head = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode * tmp = p-&gt;next;   <span class="comment">// 存储当前节点的指针位置</span></span><br><span class="line">        p-&gt;next = new_head;         <span class="comment">// 将当前节点指向新节点的头</span></span><br><span class="line">        new_head = p;               <span class="comment">// 新链表 移动头</span></span><br><span class="line">        p = tmp;                    <span class="comment">// 旧链表指针移动</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复用 head  指针</span></span><br><span class="line">    head = new_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="附加内容"><a href="#附加内容" class="headerlink" title="附加内容"></a>附加内容</h4><p>测试工程 实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表操作类的 测试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表节点 值和指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表的 增 删 查 改</span></span><br><span class="line"><span class="comment">// CRUD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建链表 // 根据首指针 创建首指针节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateHead</span><span class="params">(ListNode *head, <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表尾头部添加新节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddNode</span><span class="params">(ListNode * &amp; head,<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 新节点 //申请空间</span></span><br><span class="line">    ListNode *p = (ListNode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    p-&gt;val = data;</span><br><span class="line">    p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是一个空链表 直接赋值到head 然后返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head = p;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向新节点 返回新节点</span></span><br><span class="line">    p-&gt;next = head;</span><br><span class="line">    head = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新节点值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印List 所有节点值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从某个节点开始 打印所有节点的值</span></span><br><span class="line">    ListNode *p = head; <span class="comment">// 临时节点 便于输出 避免 改变 head 值</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;(long)p%65536&lt;&lt;":";        // 输出指针的一个 数字表示</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="string">"-&gt;"</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"NULL"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转链表</span></span><br><span class="line"><span class="comment">// ref:[链表反转图文讲解](https://blog.csdn.net/FX677588/article/details/72357389)</span></span><br><span class="line"><span class="comment">// 非递归方式</span></span><br><span class="line"><span class="function">ListNode * <span class="title">ReverseList</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果空链表或者 单节点链表</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建两个节点 P用来遍历head, new_head 为新链表的头</span></span><br><span class="line">    ListNode *p = head, *new_head = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode * tmp = p-&gt;next;   <span class="comment">// 存储当前节点的指针位置</span></span><br><span class="line">        p-&gt;next = new_head;         <span class="comment">// 将当前节点指向新节点的头</span></span><br><span class="line">        new_head = p;               <span class="comment">// 新链表 移动头</span></span><br><span class="line">        p = tmp;                    <span class="comment">// 旧链表指针移动</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回新的节点值</span></span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不返回操作  非递归 反转链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseList2</span><span class="params">(ListNode * &amp;head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果空链表或者 单节点链表</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建两个节点 P用来遍历head, new_head 为新链表的头</span></span><br><span class="line">    ListNode *p = head, *new_head = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode * tmp = p-&gt;next;   <span class="comment">// 存储当前节点的指针位置</span></span><br><span class="line">        p-&gt;next = new_head;         <span class="comment">// 将当前节点指向新节点的头</span></span><br><span class="line">        new_head = p;               <span class="comment">// 新链表 移动头</span></span><br><span class="line">        p = tmp;                    <span class="comment">// 旧链表指针移动</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复用 head  指针</span></span><br><span class="line">    head = new_head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归方式</span></span><br><span class="line"><span class="function">ListNode * <span class="title">ReverseList_re</span><span class="params">(ListNode * head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果空链表或者 单节点链表</span></span><br><span class="line">    <span class="keyword">if</span>(head ==<span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次进行每个节点的执行</span></span><br><span class="line">    ListNode * new_head = ReverseList_re(head-&gt;next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于每一个节点 反转前后实现</span></span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数 测试 demo</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LENGTH 20</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *head  = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成随机链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;LENGTH;++i)</span><br><span class="line">        AddNode(head,rand()%LENGTH);</span><br><span class="line">    PrintList(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转链表 并输出</span></span><br><span class="line">    head = ReverseList(head);</span><br><span class="line">    PrintList(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转链表 并输出</span></span><br><span class="line">    ReverseList2(head);</span><br><span class="line">    PrintList(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转链表 并输出 递归实现</span></span><br><span class="line">    head = ReverseList_re(head);</span><br><span class="line">    PrintList(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> C++ </tag>
            
            <tag> Work </tag>
            
            <tag> Job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试-仿射变换</title>
      <link href="/2019/06-05/interview-zhongwang.html"/>
      <url>/2019/06-05/interview-zhongwang.html</url>
      
        <content type="html"><![CDATA[<h3 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h3><p>仿射变换,给出一个点在平面旋转$\theta$角的仿射矩阵.</p><h4 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h4><p>仿射变换(ATF,Affine Transformation) 是图像的线性变换,对于一个集合$X$ 的仿射变换可以表示为:</p><p>$$<br>f(x) = Ax+b, x \in X.<br>$$</p><p>对于我们需要处理的图像集合而言,可以表示为:</p><p>$$<br>g(x,y) = Af(x,y)+b.<br>$$</p><p>其中$A$矩阵就是仿射变换矩阵.</p><a id="more"></a><h5 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h5><p>内容介绍可以参考链接:<a href="https://blog.csdn.net/robert_chen1988/article/details/80498805" target="_blank" rel="noopener">仿射变换介绍</a></p><p>常用的仿射变换包括:<br>缩放: Scale<br>旋转: Rotate<br>平移: Transform<br>反射: Reflection<br>错切: Shear</p><p>可以参考图:</p><p><img src="https://i.loli.net/2019/08/05/caeW6pgbhHNuKUT.png" alt="仿射变换图示--wiki =400x400"></p><p>仿射变换中集合中的一些性质保持不变：<br>（1）凸性<br>（2）共线性：若几个点变换前在一条线上，则仿射变换后仍然在一条线上<br>（3）平行性：若两条线变换前平行，则变换后仍然平行<br>（4）共线比例不变性：变换前一条线上两条线段的比例，在变换后比例仍然步</p><p>注：所有的三角形都能通过仿射变化为其他三角形，所有平行四边形也能仿射变换为另一个平行四边形。</p><p>由于仿射变换是线性的,所以仿射变换的任意组合仍然是线性的.</p><h5 id="仿射变换矩阵推导"><a href="#仿射变换矩阵推导" class="headerlink" title="仿射变换矩阵推导"></a>仿射变换矩阵推导</h5><p>仿射变换矩阵推导以 矩阵旋转为例,也是面试题目的内容:<br>假设原本点为 $C$ 点,旋转 $\theta$ 角度之后到达 $B$ 点, 计算旋转矩阵 A. 以二维矩阵为例</p><p><img src="https://i.loli.net/2019/08/05/VEFsn2B7emtkhPg.png" alt="仿射变换旋转矩阵推导示意图 =400x400"></p><p>对于$C,B$两点表示成极坐标为 $C(r\cos\alpha,r\sin\alpha)$,$B(r\cos(\alpha+\theta),r\sin(\alpha+\theta))$,<br>对于</p><p>$$<br>x_B = r\cos(\alpha+\theta) = r(\cos\alpha\cos\theta-\sin\alpha\sin\theta) = (\cos\theta -\sin\theta)x_C<br>$$</p><p>$$<br>y_B = r\sin(\alpha+\theta) = r(\sin\alpha\cos\theta+\cos\alpha\sin\theta) = (\sin\theta+\cos\theta)y_C<br>$$</p><p>所以可以推导出如下矩阵</p><p>$$<br>\left[<br>    \begin{array}{l}<br>        {\mathrm{x_B}} \<br>        {y_B}<br>    \end{array}<br>\right]<br>=\left[<br>    \begin{array}{cc}<br>        {\cos \theta} &amp; {-\sin \theta} \<br>        {\sin \theta} &amp; {\cos \theta}<br>    \end{array}<br>\right]<br>\left[<br>    \begin{array}{l}<br>        {\mathrm{x_C}} \<br>        {y_C}<br>    \end{array}<br>\right]<br>$$</p><h4 id="内容延展"><a href="#内容延展" class="headerlink" title="内容延展"></a>内容延展</h4>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> Work </tag>
            
            <tag> Job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-Contest-132-DivisorGame</title>
      <link href="/2019/04-14/LeetCode-Contest-132-DivisorGame.html"/>
      <url>/2019/04-14/LeetCode-Contest-132-DivisorGame.html</url>
      
        <content type="html"><![CDATA[<!--## LeetCode 题目解析 --><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>题目所在链接为 <a href="https://leetcode.com/problems/divisor-game/" target="_blank" rel="noopener">1025. Divisor Game</a></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>A B 两个人玩游戏,A 先手<br>首先给一个数字 $N$, 每个人可以选择一个数$x$<br>满足$ 0&lt; x &lt; N$ 而且 $N % x == 0$<br>接下来 $N$ 变成 $N-x$<br>依次轮流, 直到无数字可以选择为止</p><p>如果 A 赢 返回 True 否则返回 False</p><p>Alice and Bob take turns playing a game, with Alice starting first.</p><p>Initially, there is a number $N$ on the chalkboard. On each player’s turn, that player makes a move consisting of:</p><p>Choosing any $x$ with $0 &lt; x &lt; N$ and $N % x == 0$.<br>Replacing the number $N$ on the chalkboard with $N - x$.<br>Also, if a player cannot make a move, they lose the game.</p><p>Return True if and only if Alice wins the game, assuming both players play optimally.</p><a id="more"></a><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p><strong>Example 1:</strong></p><blockquote><p>Input: 2<br>Output: true<br>Explanation: Alice chooses 1, and Bob has no more moves.</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p>Input: 3<br>Output: false<br>Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.</p></blockquote><p><strong>Example 3:</strong></p><blockquote><p>Input: 120<br>Output: 21</p></blockquote><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><ol><li>A B 足够理性</li><li>$1 &lt;= N &lt;= 1000$</li></ol><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li>记录一定赢的数组 wins 首先先加入数字 2</li><li>计算数字 N 的因子, 判断是否 N-因子 是否都在数组中</li><li>如果有一个因子不在必赢数组中,则该数字必赢, 否则必输</li></ol><p>==时间复杂度==: $O(N)$<br>==空间复杂度==: $O(log(N))$</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol><li><a href="https://github.com/lamphanviet/competitive-programming/blob/master/uva-online-judge/accepted-solutions/11960%20-%20Divisor%20Game.cpp" target="_blank" rel="noopener">11960 - Divisor Game</a></li></ol><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维持两个表, 一定赢 的数据存入数组 wins中,</span></span><br><span class="line">    <span class="comment">// 计算N 减去自己的因子, 如果在数组中 则必输, 否则一定赢 存入数组</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; wins;</span><br><span class="line">        wins.insert(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算一下每一个因子 如果存在一个因子不在数组内 则 可以必胜</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i%j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(wins.count(i-j) ==<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        wins.insert(i);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(wins.count(N))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>使用 C/C++实现<br>运行结果 2019-04-14</p><blockquote><p>40 / 40 test cases passed.<br>Status: Accepted<br>Runtime: 24 ms<br>Memory Usage: 8.5 MB</p></blockquote><h3 id="改进优化"><a href="#改进优化" class="headerlink" title="改进优化"></a>改进优化</h3><h4 id="改进思路"><a href="#改进思路" class="headerlink" title="改进思路"></a>改进思路</h4><p>所有偶数必定赢, 奇数必输<br>还不知道原理</p><h4 id="改进的实现"><a href="#改进的实现" class="headerlink" title="改进的实现"></a>改进的实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(N%<span class="number">2</span> ==<span class="number">0</span> )</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><blockquote><p>40 / 40 test cases passed.<br>Status: Accepted<br>Runtime: 4 ms<br>Memory Usage: 8.1 MB</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> easy </tag>
            
            <tag> Contest </tag>
            
            <tag> PrimeNum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-517-SuperWashingMachines</title>
      <link href="/2019/04-11/LeetCode-517-SuperWashingMachines.html"/>
      <url>/2019/04-11/LeetCode-517-SuperWashingMachines.html</url>
      
        <content type="html"><![CDATA[<!--## LeetCode 题目解析 --><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>题目所在链接为 <a href="https://leetcode.com/problems/super-washing-machines/" target="_blank" rel="noopener">517. Super Washing Machines</a></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>你拥有 n 台超级洗衣机，开始状态每台拥有或者空的衣服。<br>每次操作都只能将某些洗衣机内一件衣服移动到临近洗衣机。<br>给定一个数组标识每个洗衣机的衣服数量，问多少次操作之后才能实现衣服均等。<br>返回最少的操作次数，如果数字不可分，直接返回 <strong>-1</strong> 。</p><p>You have <strong>n</strong> super washing machines on a line. Initially, each washing machine has some dresses or is empty.</p><p>For each <strong>move</strong>, you could choose <strong>any m</strong> (1 ≤ m ≤ n) washing machines, and pass <strong>one dress</strong> of each washing machine to one of its adjacent washing machines <strong>at the same time</strong> .</p><p>Given an integer array representing the number of dresses in each washing machine from left to right on the line, you should find the <strong>minimum number of moves</strong> to make all the washing machines have the same number of dresses. If it is not possible to do it, return <strong>-1</strong>.</p><a id="more"></a><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p><strong>Example 1:</strong></p><blockquote><p>Input: [1,0,5]<br>Output: 3<br>Explanation:<br>1st move: 1 0 <-- 5> 1 1 4<br>2nd move: 1 &lt;– 1 <-- 4> 2 1 3<br>3rd move: 2 1 <-- 3> 2 2 2</--></--></--></p></blockquote><p><strong>Example 2:</strong></p><blockquote><p>Input: [0,3,0]<br>Output: 2<br>Explanation:<br>1st move: 0 <-- 0 3> 1 2 0<br>2nd move: 1 2 –&gt; 0 =&gt; 1 1 1</--></p></blockquote><p><strong>Example 3:</strong></p><blockquote><p>Input: [0,2,0]<br>Output: -1<br>Explanation:<br>It’s impossible to make all the three washing machines have the same number of dresses.</p></blockquote><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>洗衣机的数量在 [1, 10000]<br>每台洗衣机内的衣服数量为 [0, 1e5]</p><p>The range of n is [1, 10000].<br>The range of dresses number in a super washing machine is [0, 1e5].</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li>首先计算总数和，计算是否能够整除</li><li>用当前衣服数量减去均值得到需要移动到均值的状态操作</li><li>计算每一个位置左右两侧的需要衣服的数量， 记为 L，R<br>3.1 如果 L&lt;0 &amp;&amp; R <0 说明左右两侧都多衣服， 移动次数为 max(abs(l),abs(r)) 3.2 如果 l>0 &amp;&amp; R &gt; 0 说明左右两侧都缺少衣服， 移动次数为 abs(L) + abs(R)<br>3.3 如果 (L &lt; 0 &amp;&amp; R &gt; 0) || (L &gt; 0 &amp;&amp; R &lt; 0) 有多余衣服的一侧需要向缺衣服的一侧匀衣服，所以必要移动次数仍然是：max(abs(L), abs(R))。</0></li><li>计算最大移动次数既可</li></ol><p>==时间复杂度==: $O(log(n))$<br>==空间复杂度==: $O(1)$</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol><li><a href="https://leetcode.com/problems/super-washing-machines/discuss/99185/super-short-easy-java-on-solution" target="_blank" rel="noopener">Super Short &amp; Easy Java O(n) Solution</a></li><li><a href="https://blog.csdn.net/TstsUgeg/article/details/62427718" target="_blank" rel="noopener">[leetcode] 517. Super Washing Machines</a></li><li><a href="http://www.cnblogs.com/grandyang/p/6648557.html" target="_blank" rel="noopener">[LeetCode] Super Washing Machines 超级洗衣机</a></li></ol><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinMoves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; machines)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1. 首先计算总数和，计算是否能够整除</span></span><br><span class="line"><span class="comment">            2. 用当前衣服数量减去均值得到需要移动到均值的状态操作</span></span><br><span class="line"><span class="comment">            3. 计算每一个位置左右两侧的需要衣服的数量， 记为 L，R</span></span><br><span class="line"><span class="comment">            3.1 如果 L&lt;0 &amp;&amp; R &lt;0 说明左右两侧都多衣服， 移动次数为 max(abs(L),abs(R))</span></span><br><span class="line"><span class="comment">            3.2 如果 L&gt;0 &amp;&amp; R &gt; 0 说明左右两侧都缺少衣服， 移动次数为 abs(L) + abs(R)</span></span><br><span class="line"><span class="comment">            3.3 如果 (L &lt; 0 &amp;&amp; R &gt; 0) || (L &gt; 0 &amp;&amp; R &lt; 0) 有多余衣服的一侧需要向缺衣服的一侧匀衣服，所以必要移动次数仍然是：max(abs(L), abs(R))。</span></span><br><span class="line"><span class="comment">            4. 计算最大移动次数既可</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化 位置数据向量</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp_v</span><span class="params">(machines.size()+<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> total_sum= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;machines.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            total_sum += machines[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(total_sum % machines.size() != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>, avg = total_sum / machines.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m : machines) &#123;</span><br><span class="line">            cnt += m - avg;</span><br><span class="line">            res = max(res, max(<span class="built_in">abs</span>(cnt), m - avg));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>使用 C/C++实现<br>运行结果 2019-04-11</p><blockquote><p>Runtime: 12 ms, faster than 98.54% of C++ online submissions for Super Washing Machines.<br>Memory Usage: 9.5 MB, less than 100.00% of C++ online submissions for Super Washing Machines.</p></blockquote><!--### 改进优化#### 改进思路 题目底下最好的优化在了空间上的节省, 不用设置 long long 类型的数据, 采用int 型数据, 但是每次判断依次结果很多数据会导致溢出 直接抛弃掉 可以节省大量的时间 整体流程如下: 1. 如果结果会溢出, 如果是正值 则 $temp = rev*10+pop $ 则 $$ rev > \frac{INTMAX}{10} || (rev == \frac{INTMAX}{10} \&\& pop>7) $$ 2. 如果结果会溢出, 如果是负值 则 $temp = rev*10+pop $ 则 $$ rev <> \frac{INTMIN}{10} || (rev == \frac{INTMIN}{10} \&\& pop<-8) $$3. 其中 $ pop = x\%10 $#### 改进的实现 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &gt; INT_MAX/<span class="number">10</span> || (rev == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN/<span class="number">10</span> || (rev == INT_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><blockquote><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Reverse Integer.<br>Memory Usage: 8.1 MB, less than 99.80% of C++ online submissions for Reverse Integer.<br> –&gt;</p></blockquote>-->]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> hard </tag>
            
            <tag> Math </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-388-LongestAbsoluteFilePath</title>
      <link href="/2019/04-02/LeetCode-388-LongestAbsoluteFilePath.html"/>
      <url>/2019/04-02/LeetCode-388-LongestAbsoluteFilePath.html</url>
      
        <content type="html"><![CDATA[<!--## LeetCode 题目解析 --><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>题目所在链接为 <a href="https://leetcode.com/problems/longest-absolute-file-path/" target="_blank" rel="noopener">388. Longest Absolute File Path</a></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个字符串 包含两种特殊符号 \n \t<br>分别对应回车和 tab</p><p>可能包含空目录，<br>找到包含最长路径字符串的长度</p><p>Suppose we abstract our file system by a string in the following manner:</p><p>The string “dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext” represents:</p><p>dir<br>subdir1<br>subdir2<br>file.ext<br>The directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext.</p><p>The string “dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext” represents:</p><p>dir<br>subdir1<br>file1.ext<br>subsubdir1<br>subdir2<br>subsubdir2<br>file2.ext<br>The directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext.</p><p>We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is “dir/subdir2/subsubdir2/file2.ext”, and its length is 32 (not including the double quotes).</p><p>Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0.</p><a id="more"></a><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p><strong>Example 1:</strong></p><blockquote><p>Input: dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext”<br>Output: 20</p></blockquote><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><ol><li>文件包含拓展名 和 .</li><li>假设不会出现 .. 目录</li><li>最深的目录不一定是最长的目录</li></ol><p>The name of a file contains at least a . and an extension.<br>The name of a directory or sub-directory will not contain a ..<br>Time complexity required: O(n) where n is the size of the input string.</p><p>Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png.</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li>遍历字符串， 如果遇到了 \n 和 \t 停止</li><li>如果遇到了 \n 提取包含 如果文件名 . 更新长度 = 文件夹基本深度+文件名长度</li><li>否则 是文件夹， 更新深度 和下一文件夹的基本深度</li></ol><p>==时间复杂度==: $O(N)$<br>==空间复杂度==: $O(1)$</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol><li><a href="http://www.cnblogs.com/grandyang/p/5806493.html" target="_blank" rel="noopener">bl[LeetCode] Longest Absolute File Path 最长的绝对文件路径 og</a></li></ol><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. 遍历字符串， 如果遇到了 \n 和 \t  停止</span></span><br><span class="line"><span class="comment">        2. 如果遇到了 \n  提取字符串 包含 如果文件名 .   更新长度 = 文件夹基本深度+文件名长度</span></span><br><span class="line"><span class="comment">        3. 否则 是文件夹， 更新深度 和下一文件夹的基本深度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthLongestPath</span><span class="params">(<span class="built_in">string</span> input)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>,level=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;input.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> start =i;</span><br><span class="line">            <span class="comment">// 直到遇到 特殊字符停止</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;input.length() &amp;&amp; input[i] != <span class="string">'\n'</span> &amp;&amp; input[i] != <span class="string">'\t'</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= input.length() || input[i] == <span class="string">'\n'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 当当前目录层级的内容 提出出来</span></span><br><span class="line">                <span class="built_in">string</span> str = input.substr(start,i-start);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用拓展名的. 作为文件识别标志</span></span><br><span class="line">                <span class="keyword">if</span>(str.find(<span class="string">'.'</span>) != <span class="built_in">string</span>::npos)</span><br><span class="line">                    res = max(res,m[level] + (<span class="keyword">int</span>)str.size() );</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    level ++;</span><br><span class="line">                    m[level] = m[level<span class="number">-1</span>] + (<span class="keyword">int</span>)str.size() + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                level =<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                level++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>使用 C/C++实现<br>运行结果 2019-04-02</p><blockquote><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Longest Absolute File Path.<br>Memory Usage: 8.8 MB, less than 88.00% of C++ online submissions for Longest Absolute File Path.</p></blockquote><!--### 改进优化#### 改进思路 题目底下最好的优化在了空间上的节省, 不用设置 long long 类型的数据, 采用int 型数据, 但是每次判断依次结果很多数据会导致溢出 直接抛弃掉 可以节省大量的时间 整体流程如下: 1. 如果结果会溢出, 如果是正值 则 $temp = rev*10+pop $ 则 $$ rev > \frac{INTMAX}{10} || (rev == \frac{INTMAX}{10} \&\& pop>7) $$ 2. 如果结果会溢出, 如果是负值 则 $temp = rev*10+pop $ 则 $$ rev <> \frac{INTMIN}{10} || (rev == \frac{INTMIN}{10} \&\& pop<-8) $$3. 其中 $ pop = x\%10 $#### 改进的实现 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &gt; INT_MAX/<span class="number">10</span> || (rev == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN/<span class="number">10</span> || (rev == INT_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><blockquote><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Reverse Integer.<br>Memory Usage: 8.1 MB, less than 99.80% of C++ online submissions for Reverse Integer.<br> –&gt;</p></blockquote>-->]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-345-ReverseVowels</title>
      <link href="/2019/04-02/LeetCode-345-ReverseVowels.html"/>
      <url>/2019/04-02/LeetCode-345-ReverseVowels.html</url>
      
        <content type="html"><![CDATA[<!--## LeetCode 题目解析 --><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>题目所在链接为 <a href="https://leetcode.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">345. Reverse Vowels of a String</a></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>反转一个字符串中的元音字母。第一个和最后一个元音字母交换，第二个和倒数第二个交换……<br>Write a function that takes a string as input and reverse only the vowels of a string.</p><a id="more"></a><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p><strong>Example 1:</strong></p><blockquote><p>Input: “hello”<br>Output: “holle”</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p>Input: -123<br>Output: -321</p></blockquote><p><strong>Example 3:</strong></p><blockquote><p>Input: “leetcode”<br>Output: “leotcede”</p></blockquote><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>y 不算是 元音字母 只包含 aeiou AEIOU</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li>使用双指针来处理字符串的反转</li><li>左指针指向 前一个，后指针指向后一个</li><li>如果同时 则 交换， 否则依次移动</li><li>终止条件 左=右</li></ol><p>==时间复杂度==: $O(log(n))$<br>==空间复杂度==: $O(1)$</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol><li><a href="https://blog.csdn.net/crazy1235/article/details/51429823" target="_blank" rel="noopener">【LeetCode】345. Reverse Vowels of a String 解题报告</a></li></ol><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写一个 函数 判断是否存在元音字符</span></span><br><span class="line">    <span class="comment">// 此处的判断 太慢可以更改 使用hash  hash 也很慢</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containVowels</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ( <span class="string">'a'</span> == c || <span class="string">'e'</span> == c || <span class="string">'i'</span> == c || <span class="string">'o'</span> == c || <span class="string">'u'</span> == c ||</span><br><span class="line">            <span class="string">'A'</span> == c || <span class="string">'E'</span> == c || <span class="string">'I'</span> == c || <span class="string">'O'</span> == c || <span class="string">'U'</span> == c );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写一个函数 实现交换字符</span></span><br><span class="line">    <span class="comment">// 未做</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseVowels</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1. 使用双指针来处理字符串的反转</span></span><br><span class="line"><span class="comment">            2. 左指针指向 前一个，后指针指向后一个</span></span><br><span class="line"><span class="comment">            3. 如果同时 则 交换， 否则依次移动</span></span><br><span class="line"><span class="comment">            4. 终止条件 左=右</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=s.length()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果同时 则交换</span></span><br><span class="line">            <span class="keyword">if</span>(containVowels(s[l]) || containVowels(s[r]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(containVowels(s[l]) &amp;&amp; containVowels(s[r]))</span><br><span class="line">                &#123;</span><br><span class="line">                    swap(s[l],s[r]);</span><br><span class="line"></span><br><span class="line">                    l++;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(containVowels(s[l]))</span><br><span class="line">                    &#123;</span><br><span class="line">                        r--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        l++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>使用 C/C++实现<br>运行结果 2019-04-02</p><blockquote><p>Runtime: 12 ms, faster than 98.02% of C++ online submissions for Reverse Vowels of a String.<br>Memory Usage: 9.8 MB, less than 71.66% of C++ online submissions for Reverse Vowels of a String.</p></blockquote><!--### 改进优化#### 改进思路 题目底下最好的优化在了空间上的节省, 不用设置 long long 类型的数据, 采用int 型数据, 但是每次判断依次结果很多数据会导致溢出 直接抛弃掉 可以节省大量的时间 整体流程如下: 1. 如果结果会溢出, 如果是正值 则 $temp = rev*10+pop $ 则 $$ rev > \frac{INTMAX}{10} || (rev == \frac{INTMAX}{10} \&\& pop>7) $$ 2. 如果结果会溢出, 如果是负值 则 $temp = rev*10+pop $ 则 $$ rev <> \frac{INTMIN}{10} || (rev == \frac{INTMIN}{10} \&\& pop<-8) $$3. 其中 $ pop = x\%10 $#### 改进的实现 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &gt; INT_MAX/<span class="number">10</span> || (rev == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN/<span class="number">10</span> || (rev == INT_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><blockquote><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Reverse Integer.<br>Memory Usage: 8.1 MB, less than 99.80% of C++ online submissions for Reverse Integer.<br> –&gt;</p></blockquote>-->]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> easy </tag>
            
            <tag> String </tag>
            
            <tag> TwoPointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-154-FindMinimuminRotatedSortedArray</title>
      <link href="/2019/04-01/LeetCode-154-FindMinimuminRotatedSortedArrayII.html"/>
      <url>/2019/04-01/LeetCode-154-FindMinimuminRotatedSortedArrayII.html</url>
      
        <content type="html"><![CDATA[<!-- ## LeetCode 题目解析 --><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>题目所在链接为 <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. Find Minimum in Rotated Sorted Array II</a></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>事先按照升序排序的数组按照未知的某个值进行了旋转， 例如 [0,1,2,4,5,6,7] 变成了 [4,5,6,7,0,1,2]<br>找到最小的元素， 可能包含重复的值</p><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</p><p>Find the minimum element.</p><p>The array may contain duplicates.</p><a id="more"></a><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p><strong>Example 1:</strong></p><blockquote><p>Input: [1,3,5]<br>Output: 1</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p>Input: [2,2,2,0,1]<br>Output: 0</p></blockquote><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>本题目跟 上一个题目<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">Find Minimum in Rotated Sorted Array</a> 的原理有所相同，可以参考 上一篇解题内容<br>重复元素会如何影响复杂度</p><p>This is a follow up problem to Find Minimum in Rotated Sorted Array.<br>Would allow duplicates affect the run-time complexity? How and why?</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>与不重复的原理有所相同，可以参考 上一篇解题 blog 但是由于存在重复元素，导致寻找过程可能比较长</p><ol><li>使用二分查找 来定位最小元素</li><li>最小值一定位于未排序的那半段</li><li>判断中间值 A[mid]与 A[end]的大小 判断数组右半段是否排序<br>如果 A[mid]&lt;A[end] 右半段 排序 最小值一定在左半段<br>如果 A[mid]&gt;A[end] 右半段 未排序 搜索右半段<br>如果 A[mid]== A[end] 无法判断结果位于左右过程 将 end– 继续进行下一步结果判断<br>如果使用 start++ 可能会漏掉 第一个的值 end– 不会数据丢失 只需返回最小值 不考虑最小值的位置</li></ol><p>==时间复杂度==: $O(log(n))$<br>==空间复杂度==: $O(1)$</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol><li><a href="https://blog.csdn.net/qq508618087/article/details/50448909" target="_blank" rel="noopener">[leetcode] 154. Find Minimum in Rotated Sorted Array II 解题报告</a></li><li><a href="http://bangbingsyb.blogspot.com/2014/11/leecode-find-minimum-in-rotated-sorted.html" target="_blank" rel="noopener">[LeetCode]Find Minimum in Rotated Sorted Array I, II</a></li></ol><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1. 使用二分查找 来定位最小元素</span></span><br><span class="line"><span class="comment">            2. 最小值一定位于未排序的那半段</span></span><br><span class="line"><span class="comment">            3. 判断中间值A[mid]与A[end]的大小 判断数组右半段是否排序</span></span><br><span class="line"><span class="comment">                如果 A[mid]&lt;A[end] 右半段 排序 最小值一定在左半段</span></span><br><span class="line"><span class="comment">                如果 A[mid]&gt;A[end] 右半段 未排序  搜索右半段</span></span><br><span class="line"><span class="comment">                如果 A[mid]== A[end]  无法判断结果位于左右过程 将 end-- 继续进行下一步结果判断</span></span><br><span class="line"><span class="comment">                如果使用start++ 可能会漏掉 第一个的值 end-- 不会数据丢失 只需返回最小值 不考虑最小值的位置</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=nums.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一直循环直到指针重合</span></span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(start+end)/<span class="number">2</span>;  <span class="comment">// 此处可优化，避免溢出</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 由于不存在重复 此处可 只考虑两种情况</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;nums[end])</span><br><span class="line">                end = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;nums[end])</span><br><span class="line">                start = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                end--;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>使用 C/C++实现<br>运行结果 2019-04-01</p><blockquote><p>Runtime: 8 ms, faster than 99.40% of C++ online submissions for Find Minimum in Rotated Sorted Array II.<br>Memory Usage: 8.7 MB, less than 86.88% of C++ online submissions for Find Minimum in Rotated Sorted Array II.</p></blockquote><!--### 改进优化#### 改进思路 题目底下最好的优化在了空间上的节省, 不用设置 long long 类型的数据, 采用int 型数据, 但是每次判断依次结果很多数据会导致溢出 直接抛弃掉 可以节省大量的时间 整体流程如下: 1. 如果结果会溢出, 如果是正值 则 $temp = rev*10+pop $ 则 $$ rev > \frac{INTMAX}{10} || (rev == \frac{INTMAX}{10} \&\& pop>7) $$ 2. 如果结果会溢出, 如果是负值 则 $temp = rev*10+pop $ 则 $$ rev <> \frac{INTMIN}{10} || (rev == \frac{INTMIN}{10} \&\& pop<-8) $$3. 其中 $ pop = x\%10 $#### 改进的实现 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &gt; INT_MAX/<span class="number">10</span> || (rev == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN/<span class="number">10</span> || (rev == INT_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><blockquote><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Reverse Integer.<br>Memory Usage: 8.1 MB, less than 99.80% of C++ online submissions for Reverse Integer.<br> –&gt;</p></blockquote>-->]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> BinarySearch </tag>
            
            <tag> hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-153-FindMinimuminRotatedSortedArray</title>
      <link href="/2019/04-01/LeetCode-153-FindMinimuminRotatedSortedArray.html"/>
      <url>/2019/04-01/LeetCode-153-FindMinimuminRotatedSortedArray.html</url>
      
        <content type="html"><![CDATA[<!--## LeetCode 题目解析 --><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>题目所在链接为 <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. Find Minimum in Rotated Sorted Array</a></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>事先按照升序排序的数组按照未知的某个值进行了旋转， 例如 [0,1,2,4,5,6,7] 变成了 [4,5,6,7,0,1,2]<br>找到最小的元素， 数组中不包含重复的值</p><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</p><p>Find the minimum element.</p><p>You may assume no duplicate exists in the array.</p><a id="more"></a><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p><strong>Example 1:</strong></p><blockquote><p>Input: [3,4,5,1,2]<br>Output: 1</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p>Input: [4,5,6,7,0,1,2]<br>Output: 0</p></blockquote><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><ol><li>数组原本是升序的 ，旋转之后可以得到 有一个点的值与其他的完全不同</li><li>你可以将使用二分找来得到结果</li><li><p>旋转点的左侧值都大于数组最后一个值，旋转点的右侧值都小于数组第一个</p></li><li><p>Array was originally in ascending order. Now that the array is rotated, there would be a point in the array where there is a small deflection from the increasing sequence. eg. The array would be something like [4, 5, 6, 7, 0, 1, 2].</p></li><li><p>You can divide the search space into two and see which direction to go. Can you think of an algorithm which has O(logN) search complexity?</p></li><li><p>All the elements to the left of inflection point &gt; first element of the array.<br>All the elements to the right of inflection point &lt; first element of the array.</p></li></ol><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li>使用双指针加二分查找得到结果</li><li>最小值一定位于未排序的那半段</li><li>判断中间值 A[mid]与 A[end]的大小 判断数组右半段是否排序<br>如果 A[mid]&lt;A[end] 右半段 排序 最小值一定在左半段<br>如果 A[mid]&gt;A[end] 右半段 未排序 搜索右半段</li></ol><p>==时间复杂度==: $O(log(N))$ 二分查找<br>==空间复杂度==: $O(1)$</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol><li><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/solution/" target="_blank" rel="noopener">LeetCode Solution</a></li><li><a href="http://bangbingsyb.blogspot.com/2014/11/leecode-find-minimum-in-rotated-sorted.html" target="_blank" rel="noopener">[LeetCode]Find Minimum in Rotated Sorted Array I, II</a></li></ol><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. 使用双指针加二分查找得到结果</span></span><br><span class="line"><span class="comment">        2. 最小值一定位于未排序的那半段</span></span><br><span class="line"><span class="comment">        3. 判断中间值A[mid]与A[end]的大小 判断数组右半段是否排序</span></span><br><span class="line"><span class="comment">            如果 A[mid]&lt;A[end] 排序 最小值一定在左半段</span></span><br><span class="line"><span class="comment">            如果 A[mid]&gt;A[end] 未排序  搜索右半段</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=nums.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一直循环直到指针重合</span></span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(start+end)/<span class="number">2</span>;  <span class="comment">// 此处可优化，避免溢出</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 由于不存在重复 此处可 只考虑两种情况</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;nums[end])</span><br><span class="line">                end = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                start = mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>使用 C/C++实现<br>运行结果 2019-04-01</p><blockquote><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Find Minimum in Rotated Sorted Array.<br>Memory Usage: 8.5 MB, less than 96.46% of C++ online submissions for Find Minimum in Rotated Sorted Array.</p></blockquote><!--### 改进优化#### 改进思路 题目底下最好的优化在了空间上的节省, 不用设置 long long 类型的数据, 采用int 型数据, 但是每次判断依次结果很多数据会导致溢出 直接抛弃掉 可以节省大量的时间 整体流程如下: 1. 如果结果会溢出, 如果是正值 则 $temp = rev*10+pop $ 则 $$ rev > \frac{INTMAX}{10} || (rev == \frac{INTMAX}{10} \&\& pop>7) $$ 2. 如果结果会溢出, 如果是负值 则 $temp = rev*10+pop $ 则 $$ rev <> \frac{INTMIN}{10} || (rev == \frac{INTMIN}{10} \&\& pop<-8) $$3. 其中 $ pop = x\%10 $#### 改进的实现 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &gt; INT_MAX/<span class="number">10</span> || (rev == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN/<span class="number">10</span> || (rev == INT_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><blockquote><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Reverse Integer.<br>Memory Usage: 8.1 MB, less than 99.80% of C++ online submissions for Reverse Integer.<br> –&gt;</p></blockquote>-->]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
            <tag> Array </tag>
            
            <tag> BinarySearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-14-LongestCommonPrefix</title>
      <link href="/2019/03-29/LeetCode-14-LongestCommonPrefix.html"/>
      <url>/2019/03-29/LeetCode-14-LongestCommonPrefix.html</url>
      
        <content type="html"><![CDATA[<!--## LeetCode 题目解析 --><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>题目所在链接为 <a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener">LeetCode-14:Longest Common Prefix</a></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>写一个函数,找到一组字符串的最长前缀</p><p>如果没有公共前缀 返回空字符串</p><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string “”.</p><a id="more"></a><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p><strong>Example 1:</strong></p><blockquote><p>Input: [“flower”,”flow”,”flight”]<br>Output: “fl”</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p>Input: [“dog”,”racecar”,”car”]<br>Output: “”</p></blockquote><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>如果没有公共前缀就返回空字符串 “”</p><p>所有的字符都是 小写字符 a-z</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><ol><li>同时遍历每个字符串的同位置字符, 如果出现不一致的情况就直接报错,返回之前的结果</li></ol><p>==时间复杂度==: $ O(n*m) $<br>==空间复杂度==: $ O(m) $<br>m 指最长字符串长度</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><ol><li>比较两个字符串得到公共的之后 跟后面的依次比较.得到公共字符串</li></ol><p>==时间复杂度==: $ O(n*m) $<br>==空间复杂度==: $ O(m) $<br>m 指最长字符串长度</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 解法一</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> prefix = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 依次比较所有字符的 同位置字符</span></span><br><span class="line">            <span class="keyword">if</span>(strs.size() ==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> prefix;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 公共字符长度一定小于每一个字符串的长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs[<span class="number">0</span>].length();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;strs.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(strs[<span class="number">0</span>][i] != strs[j][i])</span><br><span class="line">                        <span class="keyword">return</span> prefix;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                prefix = prefix+strs[<span class="number">0</span>][i];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> prefix;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>使用 C/C++实现<br>运行结果 2019-03-27</p><blockquote><p>Runtime: 8 ms, faster than 98.87% of C++ online submissions for Longest Common Prefix.<br>Memory Usage: 9 MB, less than 98.54% of C++ online submissions for Longest Common Prefix.</p></blockquote><!--### 改进优化#### 改进思路 题目底下最好的优化在了空间上的节省, 不用设置 long long 类型的数据, 采用int 型数据, 但是每次判断依次结果很多数据会导致溢出 直接抛弃掉 可以节省大量的时间 整体流程如下: 1. 如果结果会溢出, 如果是正值 则 $temp = rev*10+pop $ 则 $$ rev > \frac{INTMAX}{10} || (rev == \frac{INTMAX}{10} \&\& pop>7) $$ 2. 如果结果会溢出, 如果是负值 则 $temp = rev*10+pop $ 则 $$ rev <> \frac{INTMIN}{10} || (rev == \frac{INTMIN}{10} \&\& pop<-8) $$3. 其中 $ pop = x\%10 $#### 改进的实现 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &gt; INT_MAX/<span class="number">10</span> || (rev == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN/<span class="number">10</span> || (rev == INT_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><blockquote><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Reverse Integer.<br>Memory Usage: 8.1 MB, less than 99.80% of C++ online submissions for Reverse Integer.<br> –&gt;</p></blockquote>-->]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-13-Roman2Integer</title>
      <link href="/2019/03-28/LeetCode-13-Roman2Integer.html"/>
      <url>/2019/03-28/LeetCode-13-Roman2Integer.html</url>
      
        <content type="html"><![CDATA[<!--## LeetCode 题目解析 --><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>题目所在链接为 <a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="noopener">LeetCode-13:Roman to Integer</a></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>罗马数字一般有七个等级 包括: I, V, X, L, C, D and M.</p><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p><p>符号表示的值</p><table><thead><tr><th style="text-align:center">Symbol</th><th style="text-align:center">Value</th></tr></thead><tbody><tr><td style="text-align:center">I</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">V</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">50</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">500</td></tr><tr><td style="text-align:center">M</td><td style="text-align:center">1000</td></tr></tbody></table><p>例如，2 用罗马数字写成 II，两个 1 相加。12 写成，XII，就是 X + II。27 被写成 XXVII，也就是 XX + V + II。罗马数字通常从左到右由大到小书写。然而，4 的数字不是 IIII。4 写成了 4，因为 1 在 5 之前，所以减 4。同样的原理也适用于数字 9，也就是 9。使用减法有六种情况:I 可以放在 V(5)和 X(10)前面，得到 4 和 9。X 可以放在 L(50)和 C(100)之前，得到 40 和 90。C 可以放在 D(500)和 M(1000)之前，得到 400 和 900。给定一个罗马数字，把它转换成整数。输入保证在 1 到 3999 之间。</p><p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p><p>I can be placed before V (5) and X (10) to make 4 and 9.<br>X can be placed before L (50) and C (100) to make 40 and 90.<br>C can be placed before D (500) and M (1000) to make 400 and 900.<br>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p><a id="more"></a><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p><strong>Example 1:</strong></p><blockquote><p>Input: “III”<br>Output: 3</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p>Input: “IV”<br>Output: 4</p></blockquote><p><strong>Example 3:</strong></p><blockquote><p>Input: “IX”<br>Output: 9</p></blockquote><p><strong>Example 4:</strong></p><blockquote><p>Input: “LVIII”<br>Output: 58</p></blockquote><p><strong>Example 5:</strong></p><blockquote><p>Input: “MCMXCIV”<br>Output: 1994</p></blockquote><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>特殊规则:</p><ol><li>如果 I 在 V 或者 X 之前 则表示 V-I,例 IV=4</li><li>如果 X 在 L 或 C 之前 则表示 L-X 例 XL = 40</li><li>如果 C 在 D 或 M 之前 则表示 D-X 例 CD = 400</li></ol><p>Rules:</p><ul><li>If I comes before V or X, subtract 1 eg: IV = 4 and IX = 9</li><li>If X comes before L or C, subtract 10 eg: XL = 40 and XC = 90</li><li>If C comes before D or M, subtract 100 eg: CD = 400 and CM = 900</li></ul><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li>将对应的 字符赋予相应的值,使用 map 存储键值对</li><li>从前往后的顺序 将结果加起来, 如果遇到倒装(特殊规则 2) 则减去两倍的值</li></ol><p>==时间复杂度==: $O(n)$<br>==空间复杂度==: $O(1)$</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将结果存储在键值对中便于读取</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; m&#123;</span><br><span class="line">            &#123;<span class="string">'I'</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'V'</span>,<span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'X'</span>,<span class="number">10</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'L'</span>,<span class="number">50</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'C'</span>,<span class="number">100</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'D'</span>,<span class="number">500</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'M'</span>,<span class="number">1000</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照顺序累加, 如果出现倒装 则减去双倍</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += m[s[i]];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 首位不需要计算</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果倒装 则需要减去 并减去之前循环加上的  所以减去双倍</span></span><br><span class="line">                 <span class="keyword">if</span>(m[s[i]] &gt; m[s[i<span class="number">-1</span>]])</span><br><span class="line">                     sum -= <span class="number">2</span>*m[s[i<span class="number">-1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>使用 C/C++实现<br>运行结果 2019-03-28</p><blockquote><p>Runtime: 28 ms, faster than 98.23% of C++ online submissions for Roman to Integer.<br>Memory Usage: 10.7 MB, less than 97.97% of C++ online submissions for Roman to Integer.</p></blockquote><!--### 改进优化#### 改进思路 题目底下最好的优化在了空间上的节省, 不用设置 long long 类型的数据, 采用int 型数据, 但是每次判断依次结果很多数据会导致溢出 直接抛弃掉 可以节省大量的时间 整体流程如下: 1. 如果结果会溢出, 如果是正值 则 $temp = rev*10+pop $ 则 $$ rev > \frac{INTMAX}{10} || (rev == \frac{INTMAX}{10} \&\& pop>7) $$ 2. 如果结果会溢出, 如果是负值 则 $temp = rev*10+pop $ 则 $$ rev <> \frac{INTMIN}{10} || (rev == \frac{INTMIN}{10} \&\& pop<-8) $$3. 其中 $ pop = x\%10 $#### 改进的实现 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &gt; INT_MAX/<span class="number">10</span> || (rev == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN/<span class="number">10</span> || (rev == INT_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><blockquote><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Reverse Integer.<br>Memory Usage: 8.1 MB, less than 99.80% of C++ online submissions for Reverse Integer.</p></blockquote><p> –&gt;</p>-->]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_9_PalindromeNumber</title>
      <link href="/2019/03-27/LeetCode-9-PalindromeNumber.html"/>
      <url>/2019/03-27/LeetCode-9-PalindromeNumber.html</url>
      
        <content type="html"><![CDATA[<!--## LeetCode 题目解析 --><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>题目所在链接为 <a href="https://leetcode.com/problems/palindrome-number/" target="_blank" rel="noopener">LeetCode-9:PalindromeNumber</a></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>确定整数是否是回文。当一个整数从前往后读和从后往前读是一致的则认为是回文数</p><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><a id="more"></a><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p><strong>Example 1:</strong></p><blockquote><p>Input: 121<br>Output: true</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p>Input: -121<br>Output: false<br>Explanation: 所以可以判定所有的负数均不是回文数</p></blockquote><p><strong>Example 3:</strong></p><blockquote><p>Input: 10<br>Output: false</p></blockquote><h4 id="跟进"><a href="#跟进" class="headerlink" title="跟进"></a>跟进</h4><p>能不能不通过把数字转化为字符串实现?</p><p>Coud you solve it without converting the integer to a string?</p><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>验证一个整数是否为回文，不能把整数变成字符，题目要求不能使用额外空间，也不能反转整数，因为可能会溢出。</p><p>可直接对整数进行取整和取余来获得想要的首尾数字，比如: 1221，取整 1221 / 1000，可得首位 1， 取余 1221 % 10， 可得到末尾 1，进行比较，如果相等取中间的 22 继续用此方法比较。</p><p>Could negative integers be palindromes? (ie, -1)</p><p>If you are thinking of converting the integer to string, note the restriction of using extra space.</p><p>You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case?</p><p>There is a more generic way of solving this problem.</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li>通过余数得到最后一位, 计算出来最高的位数 得到首位,</li><li>首尾判断得到结果</li></ol><p>==时间复杂度==: $O(log(x))$<br>==空间复杂度==: $O(1)$</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对于负值 均不回文</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 个位数 回文</span></span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算 整10次幂的值</span></span><br><span class="line">        <span class="keyword">int</span> dec = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((x / dec) &gt;= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dec *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> head = x / dec;</span><br><span class="line">            <span class="keyword">int</span> end  = x % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不对应 直接结束</span></span><br><span class="line">            <span class="keyword">if</span>(head != end)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将原始数字 两头</span></span><br><span class="line">            x = (x % dec) / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 除数减去两位</span></span><br><span class="line">            dec /= <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>使用 C/C++实现<br>运行结果 2019-03-27</p><blockquote><p>Runtime: 32 ms, faster than 99.96% of C++ online submissions for Palindrome Number.<br>Memory Usage: 8.1 MB, less than 99.67% of C++ online submissions for Palindrome Number.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>996-ICU</title>
      <link href="/2019/03-27/996-ICU.html"/>
      <url>/2019/03-27/996-ICU.html</url>
      
        <content type="html"><![CDATA[<p>日常闲着没事的时候打开<a href="https://github.com" target="_blank" rel="noopener">Github</a>,想看看有什么好玩的没有, 突然看到一个以前关注的一个非常漂亮的小姐姐<a href="https://github.com/Ovilia" target="_blank" rel="noopener">Ovilia</a>点赞了一个项目<a href="https://github.com/996icu/996.ICU" target="_blank" rel="noopener">Github/996.ICU</a>, 这个项目是 2019/03/26 创建的.</p><p>03/27 看到的时候才 1000 star 截至 03/29 的时候 项目已经 100k start 了.</p><p><img src="./images/1553868365404.png" alt="Github 截图"></p><p>然后搜了一下看到了一片文章 是 虎嗅的文章<a href="https://www.huxiu.com/article/291579.html" target="_blank" rel="noopener">谈谈 996.ICU</a> 以一个过来人的身份简述了自己 现在看待 996 的事情.感觉文章不错</p><p>其实前天跟室友谈过一句,我问他, 给你多少钱你愿意 996,他说 给多少都不干,然后我说,你现在是 9 点上班 10 点半下班,一周 7 天,比 996 还要累啊. 沉默….</p><a id="more"></a><p>读研期间,看到太多加班的事情了,但是更多的是给自己的安慰</p><ol><li>反正回去也是玩手机,玩电脑,实验室网还比较好,在这边多好</li><li>同实验室的师兄师姐都没走,我回去没啥事</li><li>我要多学习一会,这样比他们多学一点,积累着总是好的</li></ol><p>老板也从没有说过要我们 997 的干活, 但是对应的有相应的工作,做不玩自然不能休息,你自然就会加班了,而且看到别人都在努力的时候,如果自己有半天时间浪费了都感觉自己太堕落了,自己还不够努力.</p><p>现在都在努力向前,哪怕停止不前就是已经落后了.</p><p>其实哪有那么多的事情,你只是不愿把时间花在其他地方上罢了</p><p>如果你很享受 996 的工作，那应当恭喜你，人生活得有意义。如果你觉得 996 让你痛苦不堪，耽误了你追求更有意思的生活，那么及时止损吧.</p>]]></content>
      
      
      <categories>
          
          <category> Emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> ICU </tag>
            
            <tag> 996 </tag>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode7-ReverseInteger</title>
      <link href="/2019/03-27/LeetCode-7-ReverseInteger.html"/>
      <url>/2019/03-27/LeetCode-7-ReverseInteger.html</url>
      
        <content type="html"><![CDATA[<!--## LeetCode 题目解析 --><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>题目所在链接为 <a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">LeetCode-7:ReverseInteger</a></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给出一个 32 位的有符号整数, 反向输出一个整型数字</p><p>Given a 32-bit signed integer, reverse digits of an integer.</p><a id="more"></a><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p><strong>Example 1:</strong></p><blockquote><p>Input: 123<br>Output: 321</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p>Input: -123<br>Output: -321</p></blockquote><p><strong>Example 3:</strong></p><blockquote><p>Input: 120<br>Output: 21</p></blockquote><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>假设我们正在处理一个只能在 32 位有符号整数范围内存储整数的环境：[−2<sup>31</sup>, 2<sup>31</sup> − 1]。出于此问题的目的，假设当反向整数溢出时，函数返回 0.</p><p>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2<sup>31</sup>, 2<sup>31</sup> − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><p>例如 $2^{31} -1 = 2,147,483,647$ 如果 设计的返回的值应该是$ 7,463,847,412 $ 溢出 返回 0 .</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li>通过余数和除法获取 从尾部 获取数据的每一位,依次成将数据乘 10 得到新的数据</li><li>判断符号, 判断是否溢出</li></ol><p>==时间复杂度==: $ O(log(x)) $<br>==空间复杂度==: $ O(1) $</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 输入long long 型 数据 避免溢出</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将每一位的数据 升位 加上余数</span></span><br><span class="line">            sum = sum * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输入数字 降位</span></span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断溢出</span></span><br><span class="line">            <span class="keyword">if</span> (sum &gt; INT_MAX || sum &lt; INT_MIN)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>使用 C/C++实现<br>运行结果 2019-03-27</p><blockquote><p>Runtime: 8 ms, faster than 99.38% of C++ online submissions for Reverse Integer.<br>Memory Usage: 8.2 MB, less than 99.80% of C++ online submissions for Reverse Integer.</p></blockquote><h3 id="改进优化"><a href="#改进优化" class="headerlink" title="改进优化"></a>改进优化</h3><h4 id="改进思路"><a href="#改进思路" class="headerlink" title="改进思路"></a>改进思路</h4><p>题目底下最好的优化在了空间上的节省, 不用设置 long long 类型的数据, 采用 int 型数据, 但是每次判断依次结果<br>很多数据会导致溢出 直接抛弃掉 可以节省大量的时间</p><p>整体流程如下:</p><ol><li><p>如果结果会溢出, 如果是正值 则 $temp = rev*10+pop $ 则<br>$$ rev &gt; \frac{INTMAX}{10} || (rev == \frac{INTMAX}{10} \&amp;\&amp; pop&gt;7) $$</p></li><li><p>如果结果会溢出, 如果是负值 则 $temp = rev*10+pop $ 则<br>$$ rev &lt;&gt; \frac{INTMIN}{10} || (rev == \frac{INTMIN}{10} \&amp;\&amp; pop&lt;-8) $$</p></li><li><p>其中 $ pop = x\%10 $</p></li></ol><h4 id="改进的实现"><a href="#改进的实现" class="headerlink" title="改进的实现"></a>改进的实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">           x /= <span class="number">10</span>;</span><br><span class="line">           <span class="keyword">if</span> (rev &gt; INT_MAX/<span class="number">10</span> || (rev == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">if</span> (rev &lt; INT_MIN/<span class="number">10</span> || (rev == INT_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> rev;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><blockquote><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Reverse Integer.<br>Memory Usage: 8.1 MB, less than 99.80% of C++ online submissions for Reverse Integer.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode,easy,Overflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-0</title>
      <link href="/2019/03-27/LeetCode-0.html"/>
      <url>/2019/03-27/LeetCode-0.html</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p>目前 LeetCode 的上面的题目还有很多不会, 之前做过的部分结果也不完善,准备从头开始将 LeetCode 的题目刷遍, 按照一定顺序来刷,可能会先写容易的,后面会把难得给写出来,可能不会是比较好的解答,但是是目前自己能做的一个解答过程,以此记录一下,</p><p>20190327-Schen</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学堂在线课程字幕下载</title>
      <link href="/2019/02-13/%E5%AD%A6%E5%A0%82%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B%E5%AD%97%E5%B9%95%E4%B8%8B%E8%BD%BD.html"/>
      <url>/2019/02-13/%E5%AD%A6%E5%A0%82%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B%E5%AD%97%E5%B9%95%E4%B8%8B%E8%BD%BD.html</url>
      
        <content type="html"><![CDATA[<h3 id="事情起因"><a href="#事情起因" class="headerlink" title="事情起因"></a>事情起因</h3><p>学堂在线<br>工程伦理课程<br>在线学习,没有课件, 考试的时候可能会不方便,做一解决此类问题<br>字幕下载 合成为 Txt 文件或者 word 文件以供学习使用</p><h3 id="事情经过"><a href="#事情经过" class="headerlink" title="事情经过"></a>事情经过</h3><ol><li>首先想到的是自己写一个爬虫 怕区相应的字幕, 发现是文本形式存储和, 很好做, 但是涉及到登录的 cookie 信息, 暂时不会,没有做 同时找到了 github 上一个爬取学堂在线字幕的项目^[<a href="https://github.com/maxujie/xuetang-down]" target="_blank" rel="noopener">https://github.com/maxujie/xuetang-down]</a> 需要简单配置 cookie 即可, 没有测试, 之后测试一下</li><li>找到一个 blog 提供的一个简单的 js 版本的字幕下载^[<a href="http://corie.cn/2016/09/29/mooc-js/]" target="_blank" rel="noopener">http://corie.cn/2016/09/29/mooc-js/]</a> 下载得到的是 srt 字幕格式, 不过下载得到的文件是按照后台的文件名存储的, 跟课程顺序 有所不同, 切部分无法获取到完整用户名</li></ol><p><img src="/2019/02-13/%E5%AD%A6%E5%A0%82%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B%E5%AD%97%E5%B9%95%E4%B8%8B%E8%BD%BD/1545214189668.png" alt="工程伦理字幕文件列表"></p><ol start="3"><li><p>手工将文件 重命名 之后 使用程序将 可以找到相应的 srt 转成相应的纯 txt 文本文件 此处有一个 C++ 版本的 srt 转 txt^[<a href="https://blog.csdn.net/TimoTolkki1966/article/details/80783801]" target="_blank" rel="noopener">https://blog.csdn.net/TimoTolkki1966/article/details/80783801]</a></p></li><li><p>此处提供其他的视频或者字幕下载工具,可以之后尝试下载^[<a href="https://blog.csdn.net/jiandanjinxin/article/details/23679869]" target="_blank" rel="noopener">https://blog.csdn.net/jiandanjinxin/article/details/23679869]</a><br>5.</p></li></ol><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Changelog</title>
      <link href="/2019/01-24/Changelog.html"/>
      <url>/2019/01-24/Changelog.html</url>
      
        <content type="html"><![CDATA[<h4 id="About-Page"><a href="#About-Page" class="headerlink" title="About Page"></a>About Page</h4><p>网站结构更新log文件, 记录更新中的部分变更, 每次变动过程尽量记录下来, 之后完善之后记录自己的站点历史</p><p>按照 时间 顺序  正序时间记录 blog</p><h4 id="Changelog"><a href="#Changelog" class="headerlink" title="Changelog"></a>Changelog</h4><p>2019-01-24 22:09    初始化站点</p><blockquote><p>按照官方仓库给出的<a href="https://github.com/HarleyWang93/blog/issues/1" target="_blank" rel="noopener">方法</a> 正常的完成了blog 的搭建, 之前尝试过, 感觉有点麻烦就放弃了, 现在可能要慢慢坚持下来, 作出持续 的成果了</p></blockquote><p>2019-02-12 22:14:23  增加分类与标签</p><blockquote><p>找到一个<a href="http://orzcss.com/posts/5a207d64/" target="_blank" rel="noopener">orzcss</a>的站点, 讲述了,创建分类的方法, 暂时没有将文章分类, 之后一一完成</p></blockquote><p>2019-03-27 19:40 更换主题</p><blockquote><p>按照<a href="https://xaoxuu.com/wiki/material-x/index.html" target="_blank" rel="noopener">MaterialX</a>的给出的结果 更换了主题 找到一个站点<a href="https://itrhx.com/2018/08/27/Hexo-blog-topic-personalization/" target="_blank" rel="noopener">Hexo 主题设置</a> 的方法 对网页加了相应的特效</p></blockquote><p>2019-11-08  完善程序框架</p><blockquote><p>已经对目前的网站有了比较喜欢的样子了, 后续会继续添加文章, 希望还能继续坚持</p></blockquote><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> xxx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
            <tag> changelog </tag>
            
            <tag> history </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello_Github_blog</title>
      <link href="/2019/01-24/hello-world.html"/>
      <url>/2019/01-24/hello-world.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>根据 <a href="https://github.com/HarleyWang93/blog/issues/1" target="_blank" rel="noopener">hexo+github 部署 blog 方法</a> 完成了 blog 搭建工作, 之后会主要将自己做的研究内容以及部分工程文档放在 blog 上展示,</p><p>目前使用方式</p><p>在 blog/source 下新建 md 文档, 然后使用 <strong><a href="http://soft.xiaoshujiang.com/" target="_blank" rel="noopener">小书匠</a></strong> 书写预览, 然后使用 <strong><a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">SourceTree</a></strong> 将得到的结果 push 到 github 中</p><p>使用==蓝色 #03A9F4== 高亮的部分是软件, 之后可能会出介绍一下这些软件, 真的十分好用,<br>之后学习得到 的结果 一一 post 到 blog 中, 现在还比较少, 之后慢慢完善吧</p><p>之前废弃过很多 blog 使用了各种部署 都感觉太麻烦了 自己坚持不下来, 所以之后会慢慢坚持 争取周更</p><p>2019.1.24<br>陈</p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
