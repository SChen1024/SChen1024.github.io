<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>東木 - 随笔</title>
  
  <subtitle>相信自己的每一分努力终将有所收获</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://schen1024.github.io/"/>
  <updated>2023-01-01T13:25:24.265Z</updated>
  <id>https://schen1024.github.io/</id>
  
  <author>
    <name>SChen1024</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2022年终总结</title>
    <link href="https://schen1024.github.io/2023/01-01/attachments/2021+2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93_2.html"/>
    <id>https://schen1024.github.io/2023/01-01/attachments/2021+2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93_2.html</id>
    <published>2023-01-01T13:51:31.000Z</published>
    <updated>2023-01-01T13:25:24.265Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="1e0edeef78809b41c4a3e73df5bd01a1c77f6b92fb9a5f30a74ad82d3b495741">681847c39b6521bb3e6b7f34c9f4fff7dfe378ab4bd615a8b32a0271d97b3b404922deaa691fe03149a74fe34b3a151dbb771aad6e32d6e9ea90d249ed052d678fc8cf170b6276d60c12af5d9821fee98e99ea34c7beeb8953dc17415713676475e178cf6083259e924ce703b1f17fdbc7cfb462da59098298d036a615a89a65ec32caf74acc2f9a69f613aa42c77d692559753681df06312b7795bb99278900978e0192434aa8494f29c47feb97cc6b0c135ec9eadcbbfd1a0461c6c1f6be6ff40165c1d6dcaf1a2c888326d537ba75d2a21f88397fc4e89e1f75ac19c2af036a22eff96b561b3d1512be489230c92c118283debb12c22f52537e08d34f91a4d6b5931ffe19585aa99437061a150b8bfaedb33b6dbcf0aa0438ad4fb21b1aceae595f2b7b14224f1cb9bf48735b04317a38bfbdb46e07dd71da2cce4e5f2d9005029be5905a5d8e85fabeae4d3644ee49dd57d1aeb63eb31f2c58d65e4d3d3b42ba39fe2e344d371087b9b3854c4041c98b95a3934f8977d813e22b97d065341c78d55e7fb9bc7a3a433a45c498467d3b4cb619d247d171d2a6d0261d3fade67debe9c0e17247b5a878c56268abcb48f7011d4f1211f0b9d7eb375e1d02505a775897ec0ec37b4d2e20ec0d1f38a4b7ebdda90c2f914799c557e2388033b8f7b6c937ab7704e52b5714faa9ccc48962b91c49aeeb1798cc6dead6571887239107eae0ba7a206555b09278a0ecd509a17ebed646452a641005187b1f946cd553a5edd1b937a7608dc25abd1c18ea591c780636c448760432280083da304560a40f2e19ffeceae00236349fd898fc4b101fc69b095f1bd4f081faec806f018567c29161cf30b158bddd22018737ffde41268c4bdf94960825c06ed190ccf42487854625ce88c4ad38967b8aa4eb211985d383efaf10be6044c696e69dea77b177383e9e1d483ba6a7b233ac511ee5fd3fcf0e827cbcf2731d7e6511a5684f04a7ebb3581b8812482356e3b7e1abb6bf1cb4f024c0b9477ecd80bab4dd8c1083aaeea415734fc54b982581d19ce409ac6940b751e1c7a384eb32e70c71ca94635f5afe40ddb1045f7d18be00b0ac4af977945d458c1dc214df06ac9e1672b1d9debf3565a772a202c35c69a49d0b6b3c43c6972d2018fd9725ee27520f8c412e99a501d790fdff1237be25a2481a6f1f2ad693c07dee504b66e5a5d4148b72344d4cfc581bad7562e2d3b3de15c4232b47acb589388cf8efa68f492259850c5f434af13d7d1d2ad8d330525f163a79b30134c2f66255634ed091ad8d029d3c0f1c88540b948c7c81014a666ef8f2aa4f41e71fce0be2a73919298491d28418dde1cd50120ee9babd68ee4030e8498dd11e943f2ad3d14301ac5a3edc340c3b484ec088aa6dc6aab2839552c3639a51754e42a78a0df50be379a422545786ab60053ad2c03e6b29d8993bb34ccc2859a8a7ab728f1060a1f3af2842904e87cde764c09277485d4c2253cc9da3ea181932cb06b365d29956a3e1a0464ad14118130de9cf3295c356b33cd6ebd4b328d972ad4a1981751c284d35582b00e5a755c3f4fe762b6c4f72d1b45cb0509e56c0cb40b8574fa524ff5263eee4c145b8831e4c9413164af4b74139a38c517c2be64dab0b7918cc2414c4761c7e02c75b059a97355e98fe2f54ff151714f650204d0d5db434a18a61f2e9bdc555bdb8ff53f635dcc45d3d38c3f8e2049ac2f88e0ff86e2964c496bf099559bb376f4c07a731d0b9f3ecacfa7e72b8bcaaf0f5431ae324a4d4b60e17ceee2a9a2315fe13a6259ff8aabbe4b2b94685f315d2c028fee3c74662c3bc50927bf5c3e01a48f66096a41f069f34169234735854c8416ca8588787c80800b57ad41e62362788917b3652bb2e7570992237dfdff39356355034a7ac9bb0c738718910db281506c6487643f761e848901482fd5337e22c86d1f09b4c37288b29fdc3f1ffef06b622a8864048d5e2c0f8a89b88d1b71d4d9bb4694fc4917552fe8b8a621001d787414b21476a3e820381872ff69807637e0e4da5fcb79dce371f98cac6ce930e856ac45f2dd6578781b191afa5c678dc0264e0cf6cc530c2aee1d87d3fb2a7bb47a34720e771da173f4d4103861dd20d80b85c753cab51eeedced353d09e356c35936cab44a0f4d3efc4b7daed333d07adea822eb39dcac360c2be786e3e2989ded349597c0179feebced60c875d16cffb8d6664db0057cb81f21c06e8710efdeb11af8672bed840f36f5e4211ed38e3b28862f40111ad5ae66c1bddbaedeb31e084d760c822c31365155915a362585f920ab68cf4bca442ea05f6724c03c47e4fe4aa5ec0a85a2bae04311fbee7917156f17b7f622a070a28509d2b04a62789a5b2e163aa86dd24b8b528539b74e11727b0aafe216d8f34b820ff0ac8e670529aa33fa5378c3296727c444f9c25becfb108814c94f4667fc75831eece7a7ca9322bcdf0d7deeea977e9c92fdfe8e8baf6c069e6b516ae0d909de6f296505f73259826837b383dfb393d8d2dd4501419e525ed94c6eeb97cd34912932ef4820a76f1aaa3a93b4cb40e604d57cfd8066e6f5e6c466935214113837c1f957617eed68a2b3eb7eab6bc20e5fc63563faa51e610875754888a4fe0bdc85928e4278972ca03dda76087db0dffae08bd8e945c02a52552bf1100878e0fe0247aff4d4c72e937b97292c42eac972544e249b38f40020f11a15d492522ef956566c17caf822e6b4a808ea2b2e16b1a326253ded7749bf6fc7e26b43611541b3f240d08e7a916dcb05102e06f9bcac1ba4a4bd446d9f68d77b4de5bc8dd0a9a2c993342b38acf2c26e651f5bf08323e533cc9c6291b563fbdff19009d91f5eebb04bec5de3911bf4c4d23481e5bf25907ae04221ce113ad1468c9b6dc1e08fd62d82eb273f8d697951a6e220c4881e403be62cd6eb4097b8bacb299e9dd114608b4ddf55aefd71cd5e94daf2d930a6616b13ea8f866c1de797af021a680ea1c4e1d3895d1bbad6690dc18f80be529d075df26f465c537526b0762b01aad9a69d607d1de2f9532c33c2c09d5f0f804c137247bb49a16c57f6ce5da6cffaca5b907929bae93823a4c5acdfbf78df62d3a48ba556dc9555941b377a59fbb38a9e04255d8ddd2fbd34d22d1612c8d3fe866b47417333c9a302fcc3d161388bc6850e5613b6321a87157898e96e491f9780ea3053fdd2892bbb0b9a6a755ce7d609043a1ea0ab911a128a6af185c332c9d509befe7fae75c26cb725d7ad2728dc81d761bfc6f54d3deb6bfc34b40a2d3ec97f33f5b3b03c6442c9aef8356d019fd7cc78f8f3a6c895b350fb038c4f7248faf42d87d978ae369fe139e1b60aaac139d4922e46b0c771557049ec08e7d794093bbdc3f33d585933287bd4f939b48b04a18433a54f541ae44abdab6fcadbc1d4ee05910d010da694df6df7b7c6c1279d7e8b5fc8a1b4f4f9abdad2c1897f53b7f5b381ced5329228290871a3b14facf49c300b6f0a9c626f21ab82767204c59d8bc360f8785567c63f90d2144959d2de224bb1a89e1a6f2545c916e11f83e5a13c4f0fcc95c55ce824d627cec37418d229a799ad234262a204ab016823bdf4a301d7af970163fd3e2e56585a0b272aada5aa0a5e62a095689f02cac9de63293f36de0923b66454674558eb1bb5b9fb7529ea06a7f46a48aad24409dd42fb147ff317c1203ff1b8b63f71d1d5eec7ca7d226f0e519e5377b6fc49acf7ca9754077747359a6332d744a29ba27f0feaaca0d66eda60a978003ea41501a626ed1ee8ba62eaf7cfd1406574a09e250c164c4a60ab52e0e33bb3657bc3ed09f0945ed5cabf96baebedf81db7436a74ed0fb4220a88e0aaf9eae0f09463e43b2ede22e5ac43a9b08ac4c1500f779ebd24f07dfb8ff3809b80dbbb55b821d6840bdfa9d55f2808a12043c98f5f41f7f1c0833dd45859bfb35ba79c5180e6822877ea4484f1112f5e69f7afeeb10cc200b80d7c44d8499b5f016fb2d4526430e21b0291ded543022dfe3a94dae200946ff2e71b431c42835be5e8031a4632e674ec6074ae173c0166bd0f85d3c5336bb724ae01d21a5d46525fe172429918a1ecc7e9c212abd461e4f31e94dee0785fa33b9cbecb58b65ec5faeee1ca465efb5b732839ed8a7847eb7f7d9ded8cf0cd5b789b271b3a8908643bacd7f489d216435dbcba2826da27192157edceb6a39c850adc2941fccd40894a7127ce68d020ab3a04d9c1d52f2b16ac6da8a794ff2844924ab9844a705b18f74637c5cdefe189cb81253ada3ceddee6c2a96e3db7a2c8a2864e9f5fe737c33420ee088013dfe3c5c54d15bedd9e263467c298293fd9478dd9a4742aaaf109c74ac059c648d2c3925ad8db72e16ea39dde8047e03fd0cd4e44dfcc69afc3379ceb76b86ded74c3205381c71d00c92ddc2b6d0075456796c4faa287507806e0946cf641391b58a1ad6665a88c19fdcff2ea42972c72aaad3ae5cf14965499d3a9f349d93d17c7cc5ff2317552687b764a80d2ebfd34907c222d6d3e98f4fb2548d803acde2a9241a19f880971d7cc6ae8594aec2ccca08e656af9ae919f4a2770fb1bb72c8a3d621f58e842fa9b6440d43fe650891649a61eeb134b3f475abcd66a544598d340304b7f734ab19b8ae29b164f79e399ea21cf87581128c493ba5014184c921a1dd058b287030841ed9f6feccc0d6b35071ed9cbffb7446d2bc19140d10467772024ce0eb1368e5ee243439871deaf1dec2b2af70e13185f47d3b2794548846eb1dac99b7e5d8803e692e158d33933e75aa03bb55602d2e758f7ad595ee71a6f9a332d2f701aecb11b51e97703e40c247a833d4806ba3e572c075add57c6e50e516e49f002e99b9e58add87cd88d49e379e1c334f6dfc6ccbc64a62f304329bb5373ad0da42747850cc2f9b9613ee6d24a44c6d8703cf7050046fc695762bc55cc51f0fde30cefa5861aebf38b17a7b647510d372c57c28b346292b90565fb55e472c651a91ab0ac39bbe2671bf7d03ce2f456ae97ebebf5b0e8def45a5aaa1c2683323118ecb05a4588102a0b2b6a8f198dd5c8d5fff66ac8e6f4e1ed449ac52066ceb8da35afa9f0dc8c3ff36a76dd4de7ce0aecb36de7af670779b7c25c898b34f2be83b487f35296ea416b7b5ccf6f3402f4b214a3f71b08cc132569d7d62e5537695dc01735df6ffb2fb9a7d9b8b217000cde6046f6da3f59abaf05a47d5fd7a16a53a5d072d1941e3e32b2d8c7e5bd0b60ac979ea5b80a1ef3fecee0b8136efd07633affd57e22aaf8f2b8190ac503316467eb2e14d2cc3aa08e5a764ab276986d677c8e2d54ef61afe846152609651ffcf0c83066c420281ec321eba697f90203dc41f6ceebac5d820e1b5e91c9fc4b2994607aa7aca1553bd634189986331f1b5d963a15922266835176fea2b010dee24575830ebe189055486906415869152e78fedb9e29811bf361128159f2832144333242386da8d8ccdb4641a85c2a0040495c6e23e6beaefbbfae2ed22893d261dd40bad671dd6df9b7992de169691a362b18f83a0d5e1ef6623ec4be81d09cf93d560945d2c1c920d1a6fd51554565e58e95c6ee09a6fcaa0fbf4e50429dedcd53c363ad0d974dc6756094a67962e0eba2f2f3c324f27be4a770134f0e1e0c2214771c9ac843c8e622a3c42ef63044e9958c74b369bfff200790b869ef0c3867e86da65bf4d9544b921604dfbb714ba9fd3fb738e76dcb56d72e69edc336c0ba3a80c6436405d59c3e2aa8e5edca24405929569ec47e0fcb429ef6b84703437b5473cbabbd748250104f979ed6c75c00db05d3f1ed22fab7f3e2624046b5e7aacb3f31fcaa058823bbb9f332dd3f17dc6a421db70fcf170c26a1c1c0fbd98a9b5e2bc9ac30528a25620acdc01912f517d9020929ff5cdfc190a61aadad54ebea79f2899c53196c45c54ecb15ae99110b61809cc2a792075fb8361b8b3e481e7a90bd0ebf7c5026c361d71944f2106b62dcd2b5fc3b034e56f35030bbdc7b7cdbadb999f116772fb65594dc823f1c537ab65ff0825013f601d0c1773f868203bdd13be9b14322df92ff173c3b722cabc96390e68de6b5907f324c604e8a5bf4f8d631ce0b6fce1f087c754ec16ec5017af28e880a53504a52925d02818dd508459c835e5db102488b81e54fedac75cf42dd0061b0a154aa24cb516e78e3530af8dec6430bb9f52898e97865a01ae7e64096e7d8e3c28836909db7ff1067b2f613bc048d790bf3facea6253bf6fbf3ed32802428e35bd75568ba5959e65</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      这是一篇加密文章，内容可能是个人情感宣泄或者收费技术。暂时不对外进行开放,之后给想看的人看,十分抱歉,如果你确实想看，请与我联系。
    
    </summary>
    
    
      <category term="Person" scheme="https://schen1024.github.io/categories/Person/"/>
    
    
      <category term="encrypt" scheme="https://schen1024.github.io/tags/encrypt/"/>
    
      <category term="hide" scheme="https://schen1024.github.io/tags/hide/"/>
    
      <category term="years" scheme="https://schen1024.github.io/tags/years/"/>
    
      <category term="2022" scheme="https://schen1024.github.io/tags/2022/"/>
    
  </entry>
  
  <entry>
    <title>2022年终总结</title>
    <link href="https://schen1024.github.io/2023/01-01/2021+2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html"/>
    <id>https://schen1024.github.io/2023/01-01/2021+2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html</id>
    <published>2023-01-01T13:51:31.000Z</published>
    <updated>2023-01-01T13:25:24.183Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="1e0edeef78809b41c4a3e73df5bd01a1c77f6b92fb9a5f30a74ad82d3b495741">681847c39b6521bb3e6b7f34c9f4fff7dfe378ab4bd615a8b32a0271d97b3b404922deaa691fe03149a74fe34b3a151dbb771aad6e32d6e9ea90d249ed052d678fc8cf170b6276d60c12af5d9821fee98e99ea34c7beeb8953dc17415713676475e178cf6083259e924ce703b1f17fdbc7cfb462da59098298d036a615a89a65ec32caf74acc2f9a69f613aa42c77d692559753681df06312b7795bb99278900978e0192434aa8494f29c47feb97cc6b0c135ec9eadcbbfd1a0461c6c1f6be6ff40165c1d6dcaf1a2c888326d537ba75d2a21f88397fc4e89e1f75ac19c2af036a22eff96b561b3d1512be489230c92c118283debb12c22f52537e08d34f91a4d6b5931ffe19585aa99437061a150b8bfaedb33b6dbcf0aa0438ad4fb21b1aceae595f2b7b14224f1cb9bf48735b04317a38bfbdb46e07dd71da2cce4e5f2d9005029be5905a5d8e85fabeae4d3644ee49dd57d1aeb63eb31f2c58d65e4d3d3b42ba39fe2e344d371087b9b3854c4041c98b95a3934f8977d813e22b97d065341c78d55e7fb9bc7a3a433a45c498467d3b4cb619d247d171d2a6d0261d3fade67debe9c0e17247b5a878c56268abcb48f7011d4f1211f0b9d7eb375e1d02505a775897ec0ec37b4d2e20ec0d1f38a4b7ebdda90c2f914799c557e2388033b8f7b6c937ab7704e52b5714faa9ccc48962b91c49aeeb1798cc6dead6571887239107eae0ba7a206555b09278a0ecd509a17ebed646452a641005187b1f946cd553a5edd1b937a7608dc25abd1c18ea591c780636c448760432280083da304560a40f2e19ffeceae00236349fd898fc4b101fc69b095f1bd4f081faec806f018567c29161cf30b158bddd22018737ffde41268c4bdf94960825c06ed190ccf42487854625ce88c4ad38967b8aa4eb211985d383efaf10be6044c696e69dea77b177383e9e1d483ba6a7b233ac511ee5fd3fcf0e827cbcf2731d7e6511a5684f04a7ebb3581b8812482356e3b7e1abb6bf1cb4f024c0b9477ecd80bab4dd8c1083aaeea415734fc54b982581d19ce409ac6940b751e1c7a384eb32e70c71ca94635f5afe40ddb1045f7d18be00b0ac4af977945d458c1dc214df06ac9e1672b1d9debf3565a772a202c35c69a49d0b6b3c43c6972d2018fd9725ee27520f8c412e99a501d790fdff1237be25a2481a6f1f2ad693c07dee504b66e5a5d4148b72344d4cfc581bad7562e2d3b3de15c4232b47acb589388cf8efa68f492259850c5f434af13d7d1d2ad8d330525f163a79b30134c2f66255634ed091ad8d029d3c0f1c88540b948c7c81014a666ef8f2aa4f41e71fce0be2a73919298491d28418dde1cd50120ee9babd68ee4030e8498dd11e943f2ad3d14301ac5a3edc340c3b484ec088aa6dc6aab2839552c3639a51754e42a78a0df50be379a422545786ab60053ad2c03e6b29d8993bb34ccc2859a8a7ab728f1060a1f3af2842904e87cde764c09277485d4c2253cc9da3ea181932cb06b365d29956a3e1a0464ad14118130de9cf3295c356b33cd6ebd4b328d972ad4a1981751c284d35582b00e5a755c3f4fe762b6c4f72d1b45cb0509e56c0cb40b8574fa524ff5263eee4c145b8831e4c9413164af4b74139a38c517c2be64dab0b7918cc2414c4761c7e02c75b059a97355e98fe2f54ff151714f650204d0d5db434a18a61f2e9bdc555bdb8ff53f635dcc45d3d38c3f8e2049ac2f88e0ff86e2964c496bf099559bb376f4c07a731d0b9f3ecacfa7e72b8bcaaf0f5431ae324a4d4b60e17ceee2a9a2315fe13a6259ff8aabbe4b2b94685f315d2c028fee3c74662c3bc50927bf5c3e01a48f66096a41f069f34169234735854c8416ca8588787c80800b57ad41e62362788917b3652bb2e7570992237dfdff39356355034a7ac9bb0c738718910db281506c6487643f761e848901482fd5337e22c86d1f09b4c37288b29fdc3f1ffef06b622a8864048d5e2c0f8a89b88d1b71d4d9bb4694fc4917552fe8b8a621001d787414b21476a3e820381872ff69807637e0e4da5fcb79dce371f98cac6ce930e856ac45f2dd6578781b191afa5c678dc0264e0cf6cc530c2aee1d87d3fb2a7bb47a34720e771da173f4d4103861dd20d80b85c753cab51eeedced353d09e356c35936cab44a0f4d3efc4b7daed333d07adea822eb39dcac360c2be786e3e2989ded349597c0179feebced60c875d16cffb8d6664db0057cb81f21c06e8710efdeb11af8672bed840f36f5e4211ed38e3b28862f40111ad5ae66c1bddbaedeb31e084d760c822c31365155915a362585f920ab68cf4bca442ea05f6724c03c47e4fe4aa5ec0a85a2bae04311fbee7917156f17b7f622a070a28509d2b04a62789a5b2e163aa86dd24b8b528539b74e11727b0aafe216d8f34b820ff0ac8e670529aa33fa5378c3296727c444f9c25becfb108814c94f4667fc75831eece7a7ca9322bcdf0d7deeea977e9c92fdfe8e8baf6c069e6b516ae0d909de6f296505f73259826837b383dfb393d8d2dd4501419e525ed94c6eeb97cd34912932ef4820a76f1aaa3a93b4cb40e604d57cfd8066e6f5e6c466935214113837c1f957617eed68a2b3eb7eab6bc20e5fc63563faa51e610875754888a4fe0bdc85928e4278972ca03dda76087db0dffae08bd8e945c02a52552bf1100878e0fe0247aff4d4c72e937b97292c42eac972544e249b38f40020f11a15d492522ef956566c17caf822e6b4a808ea2b2e16b1a326253ded7749bf6fc7e26b43611541b3f240d08e7a916dcb05102e06f9bcac1ba4a4bd446d9f68d77b4de5bc8dd0a9a2c993342b38acf2c26e651f5bf08323e533cc9c6291b563fbdff19009d91f5eebb04bec5de3911bf4c4d23481e5bf25907ae04221ce113ad1468c9b6dc1e08fd62d82eb273f8d697951a6e220c4881e403be62cd6eb4097b8bacb299e9dd114608b4ddf55aefd71cd5e94daf2d930a6616b13ea8f866c1de797af021a680ea1c4e1d3895d1bbad6690dc18f80be529d075df26f465c537526b0762b01aad9a69d607d1de2f9532c33c2c09d5f0f804c137247bb49a16c57f6ce5da6cffaca5b907929bae93823a4c5acdfbf78df62d3a48ba556dc9555941b377a59fbb38a9e04255d8ddd2fbd34d22d1612c8d3fe866b47417333c9a302fcc3d161388bc6850e5613b6321a87157898e96e491f9780ea3053fdd2892bbb0b9a6a755ce7d609043a1ea0ab911a128a6af185c332c9d509befe7fae75c26cb725d7ad2728dc81d761bfc6f54d3deb6bfc34b40a2d3ec97f33f5b3b03c6442c9aef8356d019fd7cc78f8f3a6c895b350fb038c4f7248faf42d87d978ae369fe139e1b60aaac139d4922e46b0c771557049ec08e7d794093bbdc3f33d585933287bd4f939b48b04a18433a54f541ae44abdab6fcadbc1d4ee05910d010da694df6df7b7c6c1279d7e8b5fc8a1b4f4f9abdad2c1897f53b7f5b381ced5329228290871a3b14facf49c300b6f0a9c626f21ab82767204c59d8bc360f8785567c63f90d2144959d2de224bb1a89e1a6f2545c916e11f83e5a13c4f0fcc95c55ce824d627cec37418d229a799ad234262a204ab016823bdf4a301d7af970163fd3e2e56585a0b272aada5aa0a5e62a095689f02cac9de63293f36de0923b66454674558eb1bb5b9fb7529ea06a7f46a48aad24409dd42fb147ff317c1203ff1b8b63f71d1d5eec7ca7d226f0e519e5377b6fc49acf7ca9754077747359a6332d744a29ba27f0feaaca0d66eda60a978003ea41501a626ed1ee8ba62eaf7cfd1406574a09e250c164c4a60ab52e0e33bb3657bc3ed09f0945ed5cabf96baebedf81db7436a74ed0fb4220a88e0aaf9eae0f09463e43b2ede22e5ac43a9b08ac4c1500f779ebd24f07dfb8ff3809b80dbbb55b821d6840bdfa9d55f2808a12043c98f5f41f7f1c0833dd45859bfb35ba79c5180e6822877ea4484f1112f5e69f7afeeb10cc200b80d7c44d8499b5f016fb2d4526430e21b0291ded543022dfe3a94dae200946ff2e71b431c42835be5e8031a4632e674ec6074ae173c0166bd0f85d3c5336bb724ae01d21a5d46525fe172429918a1ecc7e9c212abd461e4f31e94dee0785fa33b9cbecb58b65ec5faeee1ca465efb5b732839ed8a7847eb7f7d9ded8cf0cd5b789b271b3a8908643bacd7f489d216435dbcba2826da27192157edceb6a39c850adc2941fccd40894a7127ce68d020ab3a04d9c1d52f2b16ac6da8a794ff2844924ab9844a705b18f74637c5cdefe189cb81253ada3ceddee6c2a96e3db7a2c8a2864e9f5fe737c33420ee088013dfe3c5c54d15bedd9e263467c298293fd9478dd9a4742aaaf109c74ac059c648d2c3925ad8db72e16ea39dde8047e03fd0cd4e44dfcc69afc3379ceb76b86ded74c3205381c71d00c92ddc2b6d0075456796c4faa287507806e0946cf641391b58a1ad6665a88c19fdcff2ea42972c72aaad3ae5cf14965499d3a9f349d93d17c7cc5ff2317552687b764a80d2ebfd34907c222d6d3e98f4fb2548d803acde2a9241a19f880971d7cc6ae8594aec2ccca08e656af9ae919f4a2770fb1bb72c8a3d621f58e842fa9b6440d43fe650891649a61eeb134b3f475abcd66a544598d340304b7f734ab19b8ae29b164f79e399ea21cf87581128c493ba5014184c921a1dd058b287030841ed9f6feccc0d6b35071ed9cbffb7446d2bc19140d10467772024ce0eb1368e5ee243439871deaf1dec2b2af70e13185f47d3b2794548846eb1dac99b7e5d8803e692e158d33933e75aa03bb55602d2e758f7ad595ee71a6f9a332d2f701aecb11b51e97703e40c247a833d4806ba3e572c075add57c6e50e516e49f002e99b9e58add87cd88d49e379e1c334f6dfc6ccbc64a62f304329bb5373ad0da42747850cc2f9b9613ee6d24a44c6d8703cf7050046fc695762bc55cc51f0fde30cefa5861aebf38b17a7b647510d372c57c28b346292b90565fb55e472c651a91ab0ac39bbe2671bf7d03ce2f456ae97ebebf5b0e8def45a5aaa1c2683323118ecb05a4588102a0b2b6a8f198dd5c8d5fff66ac8e6f4e1ed449ac52066ceb8da35afa9f0dc8c3ff36a76dd4de7ce0aecb36de7af670779b7c25c898b34f2be83b487f35296ea416b7b5ccf6f3402f4b214a3f71b08cc132569d7d62e5537695dc01735df6ffb2fb9a7d9b8b217000cde6046f6da3f59abaf05a47d5fd7a16a53a5d072d1941e3e32b2d8c7e5bd0b60ac979ea5b80a1ef3fecee0b8136efd07633affd57e22aaf8f2b8190ac503316467eb2e14d2cc3aa08e5a764ab276986d677c8e2d54ef61afe846152609651ffcf0c83066c420281ec321eba697f90203dc41f6ceebac5d820e1b5e91c9fc4b2994607aa7aca1553bd634189986331f1b5d963a15922266835176fea2b010dee24575830ebe189055486906415869152e78fedb9e29811bf361128159f2832144333242386da8d8ccdb4641a85c2a0040495c6e23e6beaefbbfae2ed22893d261dd40bad671dd6df9b7992de169691a362b18f83a0d5e1ef6623ec4be81d09cf93d560945d2c1c920d1a6fd51554565e58e95c6ee09a6fcaa0fbf4e50429dedcd53c363ad0d974dc6756094a67962e0eba2f2f3c324f27be4a770134f0e1e0c2214771c9ac843c8e622a3c42ef63044e9958c74b369bfff200790b869ef0c3867e86da65bf4d9544b921604dfbb714ba9fd3fb738e76dcb56d72e69edc336c0ba3a80c6436405d59c3e2aa8e5edca24405929569ec47e0fcb429ef6b84703437b5473cbabbd748250104f979ed6c75c00db05d3f1ed22fab7f3e2624046b5e7aacb3f31fcaa058823bbb9f332dd3f17dc6a421db70fcf170c26a1c1c0fbd98a9b5e2bc9ac30528a25620acdc01912f517d9020929ff5cdfc190a61aadad54ebea79f2899c53196c45c54ecb15ae99110b61809cc2a792075fb8361b8b3e481e7a90bd0ebf7c5026c361d71944f2106b62dcd2b5fc3b034e56f35030bbdc7b7cdbadb999f116772fb65594dc823f1c537ab65ff0825013f601d0c1773f868203bdd13be9b14322df92ff173c3b722cabc96390e68de6b5907f324c604e8a5bf4f8d631ce0b6fce1f087c754ec16ec5017af28e880a53504a52925d02818dd508459c835e5db102488b81e54fedac75cf42dd0061b0a154aa24cb516e78e3530af8dec6430bb9f52898e97865a01ae7e64096e7d8e3c28836909db7ff1067b2f613bc048d790bf3facea6253bf6fbf3ed32802428e35bd75568ba5959e65</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      这是一篇加密文章，内容可能是个人情感宣泄或者收费技术。暂时不对外进行开放,之后给想看的人看,十分抱歉,如果你确实想看，请与我联系。
    
    </summary>
    
    
      <category term="Person" scheme="https://schen1024.github.io/categories/Person/"/>
    
    
      <category term="encrypt" scheme="https://schen1024.github.io/tags/encrypt/"/>
    
      <category term="hide" scheme="https://schen1024.github.io/tags/hide/"/>
    
      <category term="years" scheme="https://schen1024.github.io/tags/years/"/>
    
      <category term="2022" scheme="https://schen1024.github.io/tags/2022/"/>
    
  </entry>
  
  <entry>
    <title>2022年终总结</title>
    <link href="https://schen1024.github.io/2023/01-01/attachments/2021+2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html"/>
    <id>https://schen1024.github.io/2023/01-01/attachments/2021+2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html</id>
    <published>2023-01-01T13:51:31.000Z</published>
    <updated>2023-01-01T13:25:24.265Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="1e0edeef78809b41c4a3e73df5bd01a1c77f6b92fb9a5f30a74ad82d3b495741">681847c39b6521bb3e6b7f34c9f4fff7dfe378ab4bd615a8b32a0271d97b3b404922deaa691fe03149a74fe34b3a151dbb771aad6e32d6e9ea90d249ed052d678fc8cf170b6276d60c12af5d9821fee98e99ea34c7beeb8953dc17415713676475e178cf6083259e924ce703b1f17fdbc7cfb462da59098298d036a615a89a65ec32caf74acc2f9a69f613aa42c77d692559753681df06312b7795bb99278900978e0192434aa8494f29c47feb97cc6b0c135ec9eadcbbfd1a0461c6c1f6be6ff40165c1d6dcaf1a2c888326d537ba75d2a21f88397fc4e89e1f75ac19c2af036a22eff96b561b3d1512be489230c92c118283debb12c22f52537e08d34f91a4d6b5931ffe19585aa99437061a150b8bfaedb33b6dbcf0aa0438ad4fb21b1aceae595f2b7b14224f1cb9bf48735b04317a38bfbdb46e07dd71da2cce4e5f2d9005029be5905a5d8e85fabeae4d3644ee49dd57d1aeb63eb31f2c58d65e4d3d3b42ba39fe2e344d371087b9b3854c4041c98b95a3934f8977d813e22b97d065341c78d55e7fb9bc7a3a433a45c498467d3b4cb619d247d171d2a6d0261d3fade67debe9c0e17247b5a878c56268abcb48f7011d4f1211f0b9d7eb375e1d02505a775897ec0ec37b4d2e20ec0d1f38a4b7ebdda90c2f914799c557e2388033b8f7b6c937ab7704e52b5714faa9ccc48962b91c49aeeb1798cc6dead6571887239107eae0ba7a206555b09278a0ecd509a17ebed646452a641005187b1f946cd553a5edd1b937a7608dc25abd1c18ea591c780636c448760432280083da304560a40f2e19ffeceae00236349fd898fc4b101fc69b095f1bd4f081faec806f018567c29161cf30b158bddd22018737ffde41268c4bdf94960825c06ed190ccf42487854625ce88c4ad38967b8aa4eb211985d383efaf10be6044c696e69dea77b177383e9e1d483ba6a7b233ac511ee5fd3fcf0e827cbcf2731d7e6511a5684f04a7ebb3581b8812482356e3b7e1abb6bf1cb4f024c0b9477ecd80bab4dd8c1083aaeea415734fc54b982581d19ce409ac6940b751e1c7a384eb32e70c71ca94635f5afe40ddb1045f7d18be00b0ac4af977945d458c1dc214df06ac9e1672b1d9debf3565a772a202c35c69a49d0b6b3c43c6972d2018fd9725ee27520f8c412e99a501d790fdff1237be25a2481a6f1f2ad693c07dee504b66e5a5d4148b72344d4cfc581bad7562e2d3b3de15c4232b47acb589388cf8efa68f492259850c5f434af13d7d1d2ad8d330525f163a79b30134c2f66255634ed091ad8d029d3c0f1c88540b948c7c81014a666ef8f2aa4f41e71fce0be2a73919298491d28418dde1cd50120ee9babd68ee4030e8498dd11e943f2ad3d14301ac5a3edc340c3b484ec088aa6dc6aab2839552c3639a51754e42a78a0df50be379a422545786ab60053ad2c03e6b29d8993bb34ccc2859a8a7ab728f1060a1f3af2842904e87cde764c09277485d4c2253cc9da3ea181932cb06b365d29956a3e1a0464ad14118130de9cf3295c356b33cd6ebd4b328d972ad4a1981751c284d35582b00e5a755c3f4fe762b6c4f72d1b45cb0509e56c0cb40b8574fa524ff5263eee4c145b8831e4c9413164af4b74139a38c517c2be64dab0b7918cc2414c4761c7e02c75b059a97355e98fe2f54ff151714f650204d0d5db434a18a61f2e9bdc555bdb8ff53f635dcc45d3d38c3f8e2049ac2f88e0ff86e2964c496bf099559bb376f4c07a731d0b9f3ecacfa7e72b8bcaaf0f5431ae324a4d4b60e17ceee2a9a2315fe13a6259ff8aabbe4b2b94685f315d2c028fee3c74662c3bc50927bf5c3e01a48f66096a41f069f34169234735854c8416ca8588787c80800b57ad41e62362788917b3652bb2e7570992237dfdff39356355034a7ac9bb0c738718910db281506c6487643f761e848901482fd5337e22c86d1f09b4c37288b29fdc3f1ffef06b622a8864048d5e2c0f8a89b88d1b71d4d9bb4694fc4917552fe8b8a621001d787414b21476a3e820381872ff69807637e0e4da5fcb79dce371f98cac6ce930e856ac45f2dd6578781b191afa5c678dc0264e0cf6cc530c2aee1d87d3fb2a7bb47a34720e771da173f4d4103861dd20d80b85c753cab51eeedced353d09e356c35936cab44a0f4d3efc4b7daed333d07adea822eb39dcac360c2be786e3e2989ded349597c0179feebced60c875d16cffb8d6664db0057cb81f21c06e8710efdeb11af8672bed840f36f5e4211ed38e3b28862f40111ad5ae66c1bddbaedeb31e084d760c822c31365155915a362585f920ab68cf4bca442ea05f6724c03c47e4fe4aa5ec0a85a2bae04311fbee7917156f17b7f622a070a28509d2b04a62789a5b2e163aa86dd24b8b528539b74e11727b0aafe216d8f34b820ff0ac8e670529aa33fa5378c3296727c444f9c25becfb108814c94f4667fc75831eece7a7ca9322bcdf0d7deeea977e9c92fdfe8e8baf6c069e6b516ae0d909de6f296505f73259826837b383dfb393d8d2dd4501419e525ed94c6eeb97cd34912932ef4820a76f1aaa3a93b4cb40e604d57cfd8066e6f5e6c466935214113837c1f957617eed68a2b3eb7eab6bc20e5fc63563faa51e610875754888a4fe0bdc85928e4278972ca03dda76087db0dffae08bd8e945c02a52552bf1100878e0fe0247aff4d4c72e937b97292c42eac972544e249b38f40020f11a15d492522ef956566c17caf822e6b4a808ea2b2e16b1a326253ded7749bf6fc7e26b43611541b3f240d08e7a916dcb05102e06f9bcac1ba4a4bd446d9f68d77b4de5bc8dd0a9a2c993342b38acf2c26e651f5bf08323e533cc9c6291b563fbdff19009d91f5eebb04bec5de3911bf4c4d23481e5bf25907ae04221ce113ad1468c9b6dc1e08fd62d82eb273f8d697951a6e220c4881e403be62cd6eb4097b8bacb299e9dd114608b4ddf55aefd71cd5e94daf2d930a6616b13ea8f866c1de797af021a680ea1c4e1d3895d1bbad6690dc18f80be529d075df26f465c537526b0762b01aad9a69d607d1de2f9532c33c2c09d5f0f804c137247bb49a16c57f6ce5da6cffaca5b907929bae93823a4c5acdfbf78df62d3a48ba556dc9555941b377a59fbb38a9e04255d8ddd2fbd34d22d1612c8d3fe866b47417333c9a302fcc3d161388bc6850e5613b6321a87157898e96e491f9780ea3053fdd2892bbb0b9a6a755ce7d609043a1ea0ab911a128a6af185c332c9d509befe7fae75c26cb725d7ad2728dc81d761bfc6f54d3deb6bfc34b40a2d3ec97f33f5b3b03c6442c9aef8356d019fd7cc78f8f3a6c895b350fb038c4f7248faf42d87d978ae369fe139e1b60aaac139d4922e46b0c771557049ec08e7d794093bbdc3f33d585933287bd4f939b48b04a18433a54f541ae44abdab6fcadbc1d4ee05910d010da694df6df7b7c6c1279d7e8b5fc8a1b4f4f9abdad2c1897f53b7f5b381ced5329228290871a3b14facf49c300b6f0a9c626f21ab82767204c59d8bc360f8785567c63f90d2144959d2de224bb1a89e1a6f2545c916e11f83e5a13c4f0fcc95c55ce824d627cec37418d229a799ad234262a204ab016823bdf4a301d7af970163fd3e2e56585a0b272aada5aa0a5e62a095689f02cac9de63293f36de0923b66454674558eb1bb5b9fb7529ea06a7f46a48aad24409dd42fb147ff317c1203ff1b8b63f71d1d5eec7ca7d226f0e519e5377b6fc49acf7ca9754077747359a6332d744a29ba27f0feaaca0d66eda60a978003ea41501a626ed1ee8ba62eaf7cfd1406574a09e250c164c4a60ab52e0e33bb3657bc3ed09f0945ed5cabf96baebedf81db7436a74ed0fb4220a88e0aaf9eae0f09463e43b2ede22e5ac43a9b08ac4c1500f779ebd24f07dfb8ff3809b80dbbb55b821d6840bdfa9d55f2808a12043c98f5f41f7f1c0833dd45859bfb35ba79c5180e6822877ea4484f1112f5e69f7afeeb10cc200b80d7c44d8499b5f016fb2d4526430e21b0291ded543022dfe3a94dae200946ff2e71b431c42835be5e8031a4632e674ec6074ae173c0166bd0f85d3c5336bb724ae01d21a5d46525fe172429918a1ecc7e9c212abd461e4f31e94dee0785fa33b9cbecb58b65ec5faeee1ca465efb5b732839ed8a7847eb7f7d9ded8cf0cd5b789b271b3a8908643bacd7f489d216435dbcba2826da27192157edceb6a39c850adc2941fccd40894a7127ce68d020ab3a04d9c1d52f2b16ac6da8a794ff2844924ab9844a705b18f74637c5cdefe189cb81253ada3ceddee6c2a96e3db7a2c8a2864e9f5fe737c33420ee088013dfe3c5c54d15bedd9e263467c298293fd9478dd9a4742aaaf109c74ac059c648d2c3925ad8db72e16ea39dde8047e03fd0cd4e44dfcc69afc3379ceb76b86ded74c3205381c71d00c92ddc2b6d0075456796c4faa287507806e0946cf641391b58a1ad6665a88c19fdcff2ea42972c72aaad3ae5cf14965499d3a9f349d93d17c7cc5ff2317552687b764a80d2ebfd34907c222d6d3e98f4fb2548d803acde2a9241a19f880971d7cc6ae8594aec2ccca08e656af9ae919f4a2770fb1bb72c8a3d621f58e842fa9b6440d43fe650891649a61eeb134b3f475abcd66a544598d340304b7f734ab19b8ae29b164f79e399ea21cf87581128c493ba5014184c921a1dd058b287030841ed9f6feccc0d6b35071ed9cbffb7446d2bc19140d10467772024ce0eb1368e5ee243439871deaf1dec2b2af70e13185f47d3b2794548846eb1dac99b7e5d8803e692e158d33933e75aa03bb55602d2e758f7ad595ee71a6f9a332d2f701aecb11b51e97703e40c247a833d4806ba3e572c075add57c6e50e516e49f002e99b9e58add87cd88d49e379e1c334f6dfc6ccbc64a62f304329bb5373ad0da42747850cc2f9b9613ee6d24a44c6d8703cf7050046fc695762bc55cc51f0fde30cefa5861aebf38b17a7b647510d372c57c28b346292b90565fb55e472c651a91ab0ac39bbe2671bf7d03ce2f456ae97ebebf5b0e8def45a5aaa1c2683323118ecb05a4588102a0b2b6a8f198dd5c8d5fff66ac8e6f4e1ed449ac52066ceb8da35afa9f0dc8c3ff36a76dd4de7ce0aecb36de7af670779b7c25c898b34f2be83b487f35296ea416b7b5ccf6f3402f4b214a3f71b08cc132569d7d62e5537695dc01735df6ffb2fb9a7d9b8b217000cde6046f6da3f59abaf05a47d5fd7a16a53a5d072d1941e3e32b2d8c7e5bd0b60ac979ea5b80a1ef3fecee0b8136efd07633affd57e22aaf8f2b8190ac503316467eb2e14d2cc3aa08e5a764ab276986d677c8e2d54ef61afe846152609651ffcf0c83066c420281ec321eba697f90203dc41f6ceebac5d820e1b5e91c9fc4b2994607aa7aca1553bd634189986331f1b5d963a15922266835176fea2b010dee24575830ebe189055486906415869152e78fedb9e29811bf361128159f2832144333242386da8d8ccdb4641a85c2a0040495c6e23e6beaefbbfae2ed22893d261dd40bad671dd6df9b7992de169691a362b18f83a0d5e1ef6623ec4be81d09cf93d560945d2c1c920d1a6fd51554565e58e95c6ee09a6fcaa0fbf4e50429dedcd53c363ad0d974dc6756094a67962e0eba2f2f3c324f27be4a770134f0e1e0c2214771c9ac843c8e622a3c42ef63044e9958c74b369bfff200790b869ef0c3867e86da65bf4d9544b921604dfbb714ba9fd3fb738e76dcb56d72e69edc336c0ba3a80c6436405d59c3e2aa8e5edca24405929569ec47e0fcb429ef6b84703437b5473cbabbd748250104f979ed6c75c00db05d3f1ed22fab7f3e2624046b5e7aacb3f31fcaa058823bbb9f332dd3f17dc6a421db70fcf170c26a1c1c0fbd98a9b5e2bc9ac30528a25620acdc01912f517d9020929ff5cdfc190a61aadad54ebea79f2899c53196c45c54ecb15ae99110b61809cc2a792075fb8361b8b3e481e7a90bd0ebf7c5026c361d71944f2106b62dcd2b5fc3b034e56f35030bbdc7b7cdbadb999f116772fb65594dc823f1c537ab65ff0825013f601d0c1773f868203bdd13be9b14322df92ff173c3b722cabc96390e68de6b5907f324c604e8a5bf4f8d631ce0b6fce1f087c754ec16ec5017af28e880a53504a52925d02818dd508459c835e5db102488b81e54fedac75cf42dd0061b0a154aa24cb516e78e3530af8dec6430bb9f52898e97865a01ae7e64096e7d8e3c28836909db7ff1067b2f613bc048d790bf3facea6253bf6fbf3ed32802428e35bd75568ba5959e65</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      这是一篇加密文章，内容可能是个人情感宣泄或者收费技术。暂时不对外进行开放,之后给想看的人看,十分抱歉,如果你确实想看，请与我联系。
    
    </summary>
    
    
      <category term="Person" scheme="https://schen1024.github.io/categories/Person/"/>
    
    
      <category term="encrypt" scheme="https://schen1024.github.io/tags/encrypt/"/>
    
      <category term="hide" scheme="https://schen1024.github.io/tags/hide/"/>
    
      <category term="years" scheme="https://schen1024.github.io/tags/years/"/>
    
      <category term="2022" scheme="https://schen1024.github.io/tags/2022/"/>
    
  </entry>
  
  <entry>
    <title>2020年终总结</title>
    <link href="https://schen1024.github.io/2021/01-09/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html"/>
    <id>https://schen1024.github.io/2021/01-09/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html</id>
    <published>2021-01-09T13:51:31.000Z</published>
    <updated>2023-01-01T13:25:24.182Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="d42b0535662c6286e7d178b79b01dee65f244a7ae0bfeb1d992fba35e3174ccf">3374c411198d947a9f9e69b4d65d81e9e15225e11b6b103253c3f24f499bba8ff65c9f1c7aa54c256744235c618c9f659b951cb17d3b0d08bb6ae30a6b0a069e4a684f67fcefc40e8b7f98c3dc012760694d425de92339cac2de2f50a11988bccfe393b3443de7dde5141a38b9d585c3453b48e5b3ccfbaa555fce282eeadd0b2d2720d87a80fc3212a24c8148da998fb097618966c42f42acd81c538886470aafc23ca9e9f6fddf2714a5d343d2f653258ec9a60e49f5cfd292b6d71c8b003671940ab4afc8030ed46dad1666bc56ee0a3fc2650030dda0665fb3bb3efeb3a731ea86913dfe4bc66d5032e294abcc18490b6ace691432842b28ae58168eb612b108cfee8d164285def1a0a3cf8a40230eff5909bec415d067867a7cff8817bb873ece27af7bd75ee843a467af3877dbf4fa6c6f46aa29390bdbf198b7a63e0b480576b8c3b4314b84fe84a8c1f0a0fb56473e12c37f84585d5d6de4ada2eb54afb9b1c37a2e93cface6091bf156063d8af4bb946a497df3f3c25bdab820191233f9cab023e3a755518238ce3d2db55a889ae6f78fcfd29bf32857b71f78bf5ea638b9b7f1fb072c1409ce3257b902fe9269f15ab8194d464b79dd1bd6631618d9a36979a77c2a601a107a534d7751bf352fb92c8ad97fc6064918059d45eb16564ea0ea60d1ddd046221321e0f9fd436c3b2db4c6a0b2940bce56e37d06674829d8032f2f477b2b6c14bd4dfa0f07a5faa9b70c5ce24803d44e07cf9b8cd95addeb5006e08bf430e6b6b5424fea6eec8b5b4059919177944b027bc1ba5d665d7209341b860bf966091c261a4e92cb7a1d0569012ffcb326b4b3491a1f355fa6d1608ff065395b75e4de179cd773666e8de18c4ec4f14e7206848654e6774f96b52020e95b5b55240d5c76ed9ac03a406dd69f4cdac38dc8b98a718ec5ecc578032d634133b8a88ce2984036b343f8cab400dd1724b6b303fa20c91dd0c8a16dd17c2b78ed073523345baeb3222c7bffad7ba46bb14fbc19079e949a3663aac8c6c8aa606d6b285870682ca4a5e61fb4384a5be4290320c7be33e2455df8c0334a2a3fb107fab3a9f9ae156d55ff1151a23c5ed4a8bf379069ef5f7e40ee79204d39f0b6c29f9ecf0e7342b3f753a22c92d751bb4645dc797d5d352d7156ff7f1e8ef3c711d6598550fed2dcf6e4748178d4769ba42542ffa7ca9ba71ce4515194f6fd79cffec168e64b8b8ad3f132f3ad60513287b18f21d23c265e2ba479cd71897b30eda85dc9078dd90799dd1eff6256fab085e547fb9d09a3b4f5ab5f7a23b478c1455846b7c00a5accd9458c5b3da9ca8ad90ee79d0b4e03d2562301f23c386abf72d98f0d1fd0b80919633d71bb3a0e5c02a31a2aa6199e68322b60f97b07f9932c139a14c246f807ae0c70a54ec769b53c3b7ef502e8a13774f70df07a30d205239a4610f72cb2a45679c85eea90a4913c2d11f91905c0c13507bc98329b0f4ba331a37d4e7b1087b99cee1c15d8df514ecd46bd45d72d6509c6297253fe481268bca914740bd8b50870e501e5c26e6c714f8102e1c522b9ca84b27b5b5534d298ce8969d26d265768c02f041d44df14674602586d4c08df4f6504dc8003a50cf82a9491de17844779abbd7178406b080375de21e7c1d1734275ebf70bcde10efdebe210de317cd7dc805a4b8686ba0e3d1b339b8e7ebdb47041bc6b2e849cdaf8083f1926d1caa02691f11ac8befe5738768588b4cf302fe375a70aa327df4b5cd9bbc250b942aca001e08e8ef49f62fee253d3670f2601f4f3687a11e8c23ae850e207856f16726ef1fc69252ea6f0d489aae915407f0c23bca2a2fc96b3669daa88dee352f7bcf991a2b09127fd3982a459e38fa85f9b97f06c63d0aecbfe2042449bce3402f7961a6b7133cba6df4f48ca414dd8e4fc82c3140fcd3d9093996fa517ebba0fd88af3da8db9b8c6c424d20edd5d7c986f1e661b4999580d71d9ca94f25b4e8d837b3e132191a212e5a93f2eecf0e051c269148b82e53738f8723264072958b8bd22b8b40e8fde77891ad4931ca302a445460ea1c20b5e84cdc7f6b993cef2a33027590ab53b0bdaaa53df1df261db9ea430c99768a3fe37111d9d2ac1e2bcf05bc04592f44eb52797c6f75608db80069211e7ec942a3420305847dbb9849483cfdff201633d4246a670e9f091a7c65d09a5741074218ce077b20228686ea2da3cd5128bd5998dac6adbaac4011db8475a2e13b44f4409064064d46f2670561955b6753743740fc58c51a54ed339be65c2562bce77b70623ae85f3ed2451c66e97f634773c0afe809c9dbb96f5c6dc1c9b6df25f8075165a813453508ba2c9acba1f9eebc5ee9e5bb39426abb599d5b0ae11bfb2e92bd53cb02e6b7dd028f8486810c3fbc8d9c21f188bbc30829a5b2988a7b962ed5c33c88bf2da9aff991a6efe4e8964d227159124b3f09b784a76cae1920dc2f9bd2e78b52b942534403b9a43a5f845957ba339e2e12bb91e463f195e40766856deb6b1c77c6494ee0f4995b9ec727b6f7cb2d9140fa832148b9ae9958df51ee88ea8d307c5fd53c4c53302fc2f74faf51885fa378efc3dabddbfea10e150dfcf0adecc87da76465a306242a48b20b39e14819a263f997f1712d4d257947d270c205f16929954b43d578669a49302509fef476841328702de2ab613686e315aebf544bd0fca08fb86790bd2164a4404d397a7ac755cc320b6ff13174526070819fe85f5e038d717e5f7c4ecef4c668fa2d4b904cb13b1da12237423d8b3f6de2018b76ca7599dddff6bcb2fc8b55310d6187515c2f88298d3d695818db175f769a3d9b9878798a13a2d88c4802e1997d8bbe3a3843b2a8c655b01a6c844d9f277c74c4cc8ecf0beacd50383b7e712f19b07d5d92f5dafd0d872ba65c7e0f03647cd6a61a06b030daf7464be2772278792d256cb7a63a67add17ce1a7e1de505dff3c81301f2cff8855b0e5f2b5f59d407c55a0ce077fbef82a24cf40eee3e80fcb97b10ab37b36622c9d484653bbbb4ac9039ab45b4742769b1eb64e37da7e52e1531cce8cf0ac6f69c3deba033e78688584a81170d0a1a512015f049ff86c5d57aa550bd3b9145b491d86715de04b41f8e54fed8fb0d6e4a67559342a10417c535acc1efe508743b10466701bd8a2a41e329fd7334744b186c703ca4b57a68930b538c236008afcc94bfe32d68a8d8b9b897067f813a0ca8d10e5cf7d7c40103f8d3622b828dffe36d67d494d029ee3f3544997d525c9f12dd8a82d3efb13773ba27c5317b065aa00153a8f2a37a8b1e2f9621ef0d0188c8ecc92191b0e52bf7674885da57a8975028cd847285926da4e52d71455d6086ef0299ea92a3e7a5de1afcb4b93e2ccf5130bac3d8dfa4768edd48d4153f315bd8d5dca3df5780ab8b69da08f65ec09ad93fa23b8ce484465b39291e433faf69cfa104c4ce924e59f0af1d1b3330d0993403e7d28aa94490e4dd6a194510f1b6d5b7125063ccd61018a3eb5b6f4cd428e7c4880111da8afb7d7cc3442ae1c238f0001cf19ba017933756c5396c195e95fb57190f6e1ca35944d1b1d56446a9d1df2f25db22455e0c28d9e3abb0bcc5c27229d5d6a6f3b8c568be2e49c806a06261ac6a359a735829b9c9fc4fb1b2d5abe639c624044ed4fe8fc761861b3f16d093012bb130f3b1045b81f362a3c28da8551a8152872db9b8ad841528af5d1b7755b04055ae94fd904338d0581ada8a0e3489eec5068fd71e2dc1e48b616fcbe83441a5b8a2bdcb92b495462be9260d78fec4cc357c0971c1a41ec68bf531e48c0030220104716837527618fc2b1d433e1ca47c00668b958a7317dff3c3b2030f9026942588dde60704fa0a2f9e3d9944c1654888db0a300072c4f1e719542bb3c9f1e3997bb879980daa068d0034c9655c0aba56a06332c3f6febe1f36de8b38f9991fa24a20882dd047c61a234d97f3ce0bdcd03497ca18442f872c711ce96ac0363b3275c5bf8d81f0b0ca347bedb92d6635d2feec63bb1e6840d537d34b621a7a79b5c51e8c63348b2de6bcfe838f11872eb4ab2ef664d5a99fd837ab2074fc24e828ee55eaf7a2823438f728765fa659b2a766f08dec7e7ac33ec5a1991c16460e04d876c49e3fcf80196eb83ea51c74482bd1895b878bc6f76bec8aae3cf73eb07493fca813df37aa1568c07d8218b8ee6655b1ca90ad590f57fcce6c128c4baecfaf9d4db0cdbbf3e94f5eb9264d3a2ac041ba4092c14b2973ce6847f3e0a58225c99bf8c71e6e637e4c9c11c72efcd373af5e4847865634eebb8f56ceff29a7f7ef478e5acb99545655030d1d1e9a5fec9074d05e59c204403f2971597a871a56b9e69803be239d270f6f0ebd9ccab88c7112dd213619dd4448d6b8d3851488c73818f7837395c90bfd4d498e74f5bafe3b689376e36431e76d878f54c21ff696532c756bdb56b5afa552496794c34b4a1104e26fe8c9dcf38844af526b003a9737ee68a52dc11b32999dbb39f93c7cdf6327e5157704c329d49d1a54d865f72cdcf9eb3be168391065c4141c21b6950c0c87bee7e0f4e342497d8b59f9dd6f41532ad2c865388ed267ca0a69207297417a88003fe6a76445fb21979a097c3c967d947c46762badbfcbb2bd14bfd94e25c4d0807fe96696d1ab2a31aa975e3b76b4ba39fba112d27e450b03b113485ebc6239927991e0fb59967e4f149ba93bcfb0de7c50d702ce35a7a7040038e579e57c6c338176f4a969c2d6d45df316336d0cd9c68ae9bf59c5bcb22445fea991b22beb4a9a61d70e4d0ed2eadb1b321c63dd10f330794fb6dfbd9dd2d9960db153871a39942e889213048c8548d48477688a37d7cf53eb9baa399414090576b8f6c2b6f559f7e8587eccfbb391e09967a4f2eb9ebda27c6ac8292733347222a3df705d7f6039c9c37f2f542519f825eeed8430bef880d06db16dea5935298ac37f38cdb599fb57a76bede47e900ebf2591d9c48495435e5025a27ca131f19283c172db505d7c06ac5675b24b1eeeff6d885d64c6fa7a61ed86e73cc11d59400b475835221a67f42b43897164853b800b708bcd99575a3b2b50907eafff4ca70d145899cc07673fd92230147d3093af216e5c1b8b376d7a8a5e74c69a2cd21ff0a58ddca2d049dd8740eb53c4abc16ec4a00a3c6d42435bc232ecee49cad31cabce475db72fa9bbd4ece7dc3ea08efdd65a63475188ddcaa24bb8773d929c471cf2a9a4dad034954727e7264286439766c0aaf1f8bb588daf45a3a671392db0907688a2749cb03f394fd12fbff6fbc597ee2d8336ae7212a5c2caa4132c546c6c690d27a89c9c1df63972ab4de86373537be45b8e40853bb1625ac7834e7f413d6e7aeeaababca4f77ee29a7c54578acee5947f788edac20a7bec40ffffc0196e26864019e6f224b6c877d7031ded2b59e91454460dbd9e1cb97f2260dfd510e0aef774efad7b67d961ea8561f4cc8c430b10b564f00713cb0394df0a6150f2c6faacfce3a329a57cedea4f6db9a702d7bff14767b168e0511cfe3db399815c820ab5382858f620799d80a8c23acc16f3e605bfea5e17f510d94b79a12883681b4b99c0c4d253b0f9e8561b7def1b69b140fa447dae129d32b270a2995140d6e3c584502c307a163a51eb3a2a0d564502b3f7878ad595f4e9aedbb71fed38f5240927bf4cb8814ff3e5dd0283bfd07b842230c4c4028e4191e4b0053e590c0ee1a0cb6ff8dfee4e3c4450bf967f4808d432d969bdf729f7ac7e440006cd1b42c9946b2f27def074fc322809b68c051fe34f70f576373bf6aa7de6d8f0215bb6fa4c94cf84b8c92236367f314add023a0fd0bb21757c6772509aae14ff1f762d14a53b49f1351554775123669b4f06ae5805f6501028ac087dadd322544fa3bb11f5b305514b2b192331880e5d8a38a478f6fb77ae11de335360d3c3e6d47045bdd642d7de51634d8a2ce155f60fbe62385a220f5087c587b17b0bf55ff735cc6b02c638fe9942b9304363c2c96cbc9e50ab927e14f41fd1e9b2167cdde5ccee936d12333965156f2cf959ad0c1c18c3b3e22b568d658ea7966542c83a30fd731c6c302cf46a170c29c6ad621c169ceee722035405f8d34bd337127bf6acbdd555093fa12357dfcebc3c8db87726c8f98774be9eccfc42edbca6588e64a56f6fba320bb1abf475514e0bda6893b1c6b5c8608a34c4b71b30069b93ddfc1290c3beb858fea2bf0120884c07eee02efab60f07eefed0b6eb79978d5651edab389326cfe1bbca3c764b0b62f5c9e5351247fa7347ca7787ba4afca4d8f99ddc9919a46e6b7569aeb5</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      这是一篇加密文章，内容可能是个人情感宣泄或者收费技术。暂时不对外进行开放,之后给想看的人看,十分抱歉,如果你确实想看，请与我联系。
    
    </summary>
    
    
      <category term="Person" scheme="https://schen1024.github.io/categories/Person/"/>
    
    
      <category term="encrypt" scheme="https://schen1024.github.io/tags/encrypt/"/>
    
      <category term="hide" scheme="https://schen1024.github.io/tags/hide/"/>
    
      <category term="years" scheme="https://schen1024.github.io/tags/years/"/>
    
      <category term="2020" scheme="https://schen1024.github.io/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>去紫边算法</title>
    <link href="https://schen1024.github.io/2020/08-12/%E5%8E%BB%E7%B4%AB%E8%BE%B9%E7%AE%97%E6%B3%95.html"/>
    <id>https://schen1024.github.io/2020/08-12/%E5%8E%BB%E7%B4%AB%E8%BE%B9%E7%AE%97%E6%B3%95.html</id>
    <published>2020-08-12T09:56:45.000Z</published>
    <updated>2023-01-01T13:25:24.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="紫边成因"><a href="#紫边成因" class="headerlink" title="紫边成因"></a>紫边成因</h2><h3 id="相机原因"><a href="#相机原因" class="headerlink" title="相机原因"></a>相机原因</h3><p>color fringing 彩色边缘<br>Chromatic Aberration 色差</p><p>相机的镜头和相机的传感器导致了紫边的出现，使得光产生衍射，出现绿、紫等色差，尤其在大光圈的情况下很容易出现。</p><p><img src="https://i.loli.net/2021/01/01/lobHPShc5X6BDk8.png" alt="光学色差"></p><p><a href="https://zhuanlan.zhihu.com/p/55029984" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/55029984</a></p><p><img src="https://i.loli.net/2021/01/01/2kIsGpAxEVSDyPz.png" alt="纵向色差"></p><p><img src="https://i.loli.net/2021/01/01/dLeClziF8qGTrRP.png" alt="横向色差"></p><a id="more"></a><h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><p>高反差， 大背光图像时候容易出现，</p><p>焦前紫边，焦后绿边</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="LightRoom-去除"><a href="#LightRoom-去除" class="headerlink" title="LightRoom 去除"></a>LightRoom 去除</h3><p>修改照片 -&gt; 镜头校正 -&gt; 手动 -&gt; 去边</p><p>效果图展示</p><p><img src="https://i.loli.net/2021/01/01/eVPyEWhGlI7xYHp.png" alt="左为紫边图像， 右为处理后图像"></p><h2 id="算法处理原理"><a href="#算法处理原理" class="headerlink" title="算法处理原理"></a>算法处理原理</h2><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p><a href="https://github.com/mjambon/purple-fringe" target="_blank" rel="noopener">https://github.com/mjambon/purple-fringe</a><br>从原始图像中的蓝色分量产生模糊的蒙版。<br>使用以下约束，根据模糊蒙版中发现的强度从原始图像中减去一些蓝色和红色：<br>蓝色电平可能不会低于绿色电平。<br>红色电平可能不会低于绿色电平。<br>红色：蓝色比率可能不会降至某个常数以下。</p><p>仅在比原始紫色成分亮的地方减去紫色蒙版。<br>仅从有些紫色的区域中减去紫色，最多直到它们看起来为灰色为止。例如，从像（红色= 0.3，绿色= 0.1，蓝色= 0.3）这样的暗紫色像素中，我们可以考虑使用（0.25、0、0.25）的紫色条纹蒙版。如果直接减去此蒙版，我们将得到（0.05，0.1，0.05），现在像素会变绿！我们通过确保在最坏的情况下将像素变成灰色来避免这种情况。在这种情况下，我们得到的像素将是（0.1，0.1，0.1），这是深灰色而不是不希望的深绿色。</p><h3 id="算法效果"><a href="#算法效果" class="headerlink" title="算法效果"></a>算法效果</h3><p><a href="https://mjambon.github.io/mjambon2016/purple-fringe/examples.html" target="_blank" rel="noopener">https://mjambon.github.io/mjambon2016/purple-fringe/examples.html</a></p><p><img src="https://i.loli.net/2021/01/01/vNVRfoYm59sygQa.png" alt="算法效果展示"></p><p><img src="https://i.loli.net/2021/01/01/fiBjuKsRQXand7M.png" alt="enter description here"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;紫边成因&quot;&gt;&lt;a href=&quot;#紫边成因&quot; class=&quot;headerlink&quot; title=&quot;紫边成因&quot;&gt;&lt;/a&gt;紫边成因&lt;/h2&gt;&lt;h3 id=&quot;相机原因&quot;&gt;&lt;a href=&quot;#相机原因&quot; class=&quot;headerlink&quot; title=&quot;相机原因&quot;&gt;&lt;/a&gt;相机原因&lt;/h3&gt;&lt;p&gt;color fringing 彩色边缘&lt;br&gt;Chromatic Aberration 色差&lt;/p&gt;
&lt;p&gt;相机的镜头和相机的传感器导致了紫边的出现，使得光产生衍射，出现绿、紫等色差，尤其在大光圈的情况下很容易出现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/01/lobHPShc5X6BDk8.png&quot; alt=&quot;光学色差&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/55029984&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/55029984&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/01/2kIsGpAxEVSDyPz.png&quot; alt=&quot;纵向色差&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/01/dLeClziF8qGTrRP.png&quot; alt=&quot;横向色差&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Technology" scheme="https://schen1024.github.io/categories/Technology/"/>
    
    
      <category term="depurple" scheme="https://schen1024.github.io/tags/depurple/"/>
    
  </entry>
  
  <entry>
    <title>新硬盘入手</title>
    <link href="https://schen1024.github.io/2020/07-19/%E6%96%B0%E7%A1%AC%E7%9B%98%E5%85%A5%E6%89%8B.html"/>
    <id>https://schen1024.github.io/2020/07-19/%E6%96%B0%E7%A1%AC%E7%9B%98%E5%85%A5%E6%89%8B.html</id>
    <published>2020-07-19T15:37:35.000Z</published>
    <updated>2023-01-01T13:25:24.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ol><li>在张大妈上看到的这款硬盘有优惠, <a href="https://www.smzdm.com/p/23057560/" target="_blank" rel="noopener">https://www.smzdm.com/p/23057560/</a></li><li>在小米有品上 <a href="https://www.xiaomiyoupin.com/detail?gid=121497&amp;source=smzdm_514_0_184__35d5f288db49ca2a_3.smzdm.514_0_184__35d5f288db49ca2a.1595749103578" target="_blank" rel="noopener">https://www.xiaomiyoupin.com/detail?gid=121497&amp;source=smzdm_514_0_184__35d5f288db49ca2a_3.smzdm.514_0_184__35d5f288db49ca2a.1595749103578</a> 购买的商品</li><li>顺丰到家, 拆机</li></ol><a id="more"></a><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1595912523918.png" alt="硬件拆机"></p><ol start="4"><li>根据 <a href="https://www.iplaysoft.com/disk-benchmark-tools.html" target="_blank" rel="noopener">https://www.iplaysoft.com/disk-benchmark-tools.html</a> 给出的软件进行硬件测试</li><li>这里有一个相关参数的内容信息, 够用就好 <a href="https://post.smzdm.com/p/626598/" target="_blank" rel="noopener">https://post.smzdm.com/p/626598/</a></li></ol><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1595912519001.png" alt="CDM测试"></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1595912519074.png" alt="CDI"></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1595912518999.png" alt="AS SSD"></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1595912519068.png" alt="ATTO"></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1595912519075.png" alt="Anvil"></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1595912519076.png" alt="19-____-2020_21-21"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>硬盘总体上比较垃圾, 但是够用就好.</p><!--more-->]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在张大妈上看到的这款硬盘有优惠, &lt;a href=&quot;https://www.smzdm.com/p/23057560/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.smzdm.com/p/23057560/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在小米有品上 &lt;a href=&quot;https://www.xiaomiyoupin.com/detail?gid=121497&amp;amp;source=smzdm_514_0_184__35d5f288db49ca2a_3.smzdm.514_0_184__35d5f288db49ca2a.1595749103578&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.xiaomiyoupin.com/detail?gid=121497&amp;amp;source=smzdm_514_0_184__35d5f288db49ca2a_3.smzdm.514_0_184__35d5f288db49ca2a.1595749103578&lt;/a&gt; 购买的商品&lt;/li&gt;
&lt;li&gt;顺丰到家, 拆机&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Person" scheme="https://schen1024.github.io/categories/Person/"/>
    
    
      <category term="hexo" scheme="https://schen1024.github.io/tags/hexo/"/>
    
      <category term="blog" scheme="https://schen1024.github.io/tags/blog/"/>
    
      <category term="cnblogs" scheme="https://schen1024.github.io/tags/cnblogs/"/>
    
      <category term="csdn" scheme="https://schen1024.github.io/tags/csdn/"/>
    
  </entry>
  
  <entry>
    <title>神秘海域系列</title>
    <link href="https://schen1024.github.io/2020/06-26/%E7%A5%9E%E7%A7%98%E6%B5%B7%E5%9F%9F%E7%B3%BB%E5%88%97.html"/>
    <id>https://schen1024.github.io/2020/06-26/%E7%A5%9E%E7%A7%98%E6%B5%B7%E5%9F%9F%E7%B3%BB%E5%88%97.html</id>
    <published>2020-06-26T18:20:09.000Z</published>
    <updated>2023-01-01T13:25:24.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="游戏前准备"><a href="#游戏前准备" class="headerlink" title="游戏前准备"></a>游戏前准备</h2><ul><li>百度会员购买 <a href="https://detail.tmall.com/item.htm?id=586287059156&amp;ali_trackid=2:mm_121879788_43102803_282058237:1593166791_151_1837085262&amp;spm=a2e2e.10720394/brand2.90100100.002&amp;pvid=25089348&amp;ak=25089348" target="_blank" rel="noopener">https://detail.tmall.com/item.htm?id=586287059156&amp;ali_trackid=2:mm_121879788_43102803_282058237:1593166791_151_1837085262&amp;spm=a2e2e.10720394/brand2.90100100.002&amp;pvid=25089348&amp;ak=25089348</a></li></ul><p>【福禄网络】您购买的百度网盘超级会员月卡活动激活码为:pyxp6sf2g9d42v9d，激活地址:<a href="https://url.cn/5wxMFXi，请在2020.6.28晚24点前激活使用，激活前请核对登录账号是否正确！" target="_blank" rel="noopener">https://url.cn/5wxMFXi，请在2020.6.28晚24点前激活使用，激活前请核对登录账号是否正确！</a></p><p><img src="./images/1593167547240.png" alt="enter description here"></p><ul><li>游戏网盘链接： <a href="https://pan.baidu.com/share/link?shareid=1102752313&amp;uk=839856656#list/path=%2F" target="_blank" rel="noopener">https://pan.baidu.com/share/link?shareid=1102752313&amp;uk=839856656#list/path=%2F</a></li></ul><h2 id="游戏内容"><a href="#游戏内容" class="headerlink" title="游戏内容"></a>游戏内容</h2><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;游戏前准备&quot;&gt;&lt;a href=&quot;#游戏前准备&quot; class=&quot;headerlink&quot; title=&quot;游戏前准备&quot;&gt;&lt;/a&gt;游戏前准备&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;百度会员购买 &lt;a href=&quot;https://detail.tmall.com/item.htm?id=586287059156&amp;amp;ali_trackid=2:mm_121879788_43102803_282058237:1593166791_151_1837085262&amp;amp;spm=a2e2e.10720394/brand2.90100100.002&amp;amp;pvid=25089348&amp;amp;ak=25089348&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://detail.tmall.com/item.htm?id=586287059156&amp;amp;ali_trackid=2:mm_121879788_43102803_282058237:1593166791_151_1837085262&amp;amp;spm=a2e2e.10720394/brand2.90100100.002&amp;amp;pvid=25089348&amp;amp;ak=25089348&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;【福禄网络】您购买的百度网盘超级会员月卡活动激活码为:pyxp6sf2g9d42v9d，激活地址:&lt;a href=&quot;https://url.cn/5wxMFXi，请在2020.6.28晚24点前激活使用，激活前请核对登录账号是否正确！&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://url.cn/5wxMFXi，请在2020.6.28晚24点前激活使用，激活前请核对登录账号是否正确！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./images/1593167547240.png&quot; alt=&quot;enter description here&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;游戏网盘链接： &lt;a href=&quot;https://pan.baidu.com/share/link?shareid=1102752313&amp;amp;uk=839856656#list/path=%2F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pan.baidu.com/share/link?shareid=1102752313&amp;amp;uk=839856656#list/path=%2F&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;游戏内容&quot;&gt;&lt;a href=&quot;#游戏内容&quot; class=&quot;headerlink&quot; title=&quot;游戏内容&quot;&gt;&lt;/a&gt;游戏内容&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Person" scheme="https://schen1024.github.io/categories/Person/"/>
    
    
      <category term="blog" scheme="https://schen1024.github.io/tags/blog/"/>
    
      <category term="game" scheme="https://schen1024.github.io/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>ToDoList-game</title>
    <link href="https://schen1024.github.io/2020/06-26/ToDoList.html"/>
    <id>https://schen1024.github.io/2020/06-26/ToDoList.html</id>
    <published>2020-06-26T17:48:26.000Z</published>
    <updated>2023-01-01T13:25:24.240Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="e879f8ef116fbb6eb07b71f7cac5f7534931b6e7db2c06dc2fdacca25083d86e">51ed69c21307b22a06c456d9947ce8dd289cdf1a7cce29a89ed094891a74e326612ec3937b45c639e70c50fd667583b829aad5982800194f2a7c756b2982c764b43f99c8fe0d5bb668c88a2d5ecb47bdb1e4fccdf0efbf5b5f1431548698449a5e131fb785ec0ee71acc32d130b672762d638a4949ecd7dc1c4ffded49fb3d2d242f5c2fc2378812b5e6774574e00fa360ab7c6e17b79f6466ff57e73cde7c0e49ba203b0e82f8c2f3a6b5cf627730439e7513228cbf9ef2f48ba482121dac686259633074ed226ec85ba20cf386bffa0230450e948074a3644c8e86b3f805af48d39e876e136fe683a2e3e18273ed6173e86e08d4b70af13e123569acea34b0e25514da92621c29e2b0cea452bf10d9d5bfda7e513746211dcdea6a87a70a402c8eaa45b2d004b2669c080c337d5d5e85ef36d90257033f13a78e2cb99ad5a40aff6ea5234db7cc008920c3dab990558e9f04318788f8ec48a69e93c07bf6e900c8034e950df460dd660ea949ca6fb36a9e1513663b7adbfad2e87d063440f59d21dc89dba2e1a4217a16008b78251664c793b9a9e8a72e5efbfab2e89bda4ceb48ae73bac466c25a7beed5a29545ad754a395eced329ccd7a7d9ef77f0f82343a09e48f3a3d9a494513fbcddf149f114efea5f0fe532fdab44bf5ccd99345d0fed4ac24ace81263c778ee111dd61d3090283bef563dcff38a6877fafb6eee0ae88c6fa48ca7fd4aa9b83ca32116625120bd770723d46a272d76ce5516282e8992731122ba57eaba21713104cd4125eadea216daa21386cf2690fb9539e45c9a375da8710dcd086dd21d0a30800cc4d1106eb074737bdaad709db66458ab2da4cf913b22219ae3c083b8e1cb7195820c41820659cf71d0dd2c5502b2a0f60a1e54bd1dff301d80d6a43e71648c40ec8a7f79bd6d9ed06ab6d7db8a30cd486fa6a68db20238a364cc342d8ca3b4661ca96dbdb03429f9533ee54c9d430f19a6f1ac8bea1e2b0b994b9f04589a92f361875f09b153aa73f9ee4ceffaf922b42d17db2a1456ada84e76014f17a7d82d3605c1e773a2c37ded18369af430ef04afe703479084ff2d66d6f0ac7916f255d0271c14ea98505a1897d1dee9a73719a62e32ddd2bd0b376288ff939d13aaba96eb1924ad917fbb6b93c5039476caf3ae11be4d64b8dec211219ab6fff9fb8b910d626c627c11b187cf0549225ff612ef85172ec6a60ad32822d6a891c71bd3ec9d98c96c2e2756de3fa2bbaa9e9e15cf0d2b010022001243e1e9f90d13392d8ee9c48a23007d982fb455e92b21898506b907be40b192493b860435f57cb6ebeeab1a23bf8b2fa8710702930075686508da5c6947a77b3adc1c146a5909830574be8b6bc27db1ceb1208069ef0652677d6056eaeed23713097182b55c3892daee9dec01d4edfe1f3e360f7460ac44f3096e70b127d138866764cb9e0301a9b3d73249265e42c28fb8087ca0de84652152c1ab76c1d11e20077d7698e2d020bd28b26dda029835133003efc07164d90048b9f48aae39fbf22b7c62f9ec85d2947d694b2605c31e5d404fddb07204718c004a9afcf8977c1e8060f5caabb20f098a257e84f2914ee47435c4b603c5ba4bef945c11a18327ee4001725e3b6830830b03b77b2389fb5587456b2118de51294d10f0b98ea2bcd7ad7f41864d51cfb88c45754b14e704e82159b7288f71b815b3e564a0b8337a129b684b5e3ad883fe5d9ea12fa8a1e8da015d4ca15c368279def94e76398c656df7546d439d93de2b04af97e71ac6df4582c617fae5dd445efe2b2ba1015f12df7f2f08851b42449ff450bdd5d4c97123fa9c2d875445f1cd1d619c25660ae773945de82869469b1a18428cfb3c18815ef382fcffd6b833c31f5cc4952d7e9badd5a4be79b4aaf3e494ead9c48cc015b7c12c625ee105116887f92bd5e6d7b3931204a5e08443923dfe1d63e27be104106eb950d95ff912c005a7b31d185d0568d1148cbf83305feb518c4f26dc2f4b2618298e2e2acec6c014ec79e34847979dee8803ee1a35c4092209f32edb1c78ef132bb5fae513d590f3c05fbe86d8774516307f45a04ae5bd04726fd36321595b09367b9dd2ce83f11a5127766a3522ab833d67c90415b52ef36b1144a8ec07a1f011030caa6e0e511cc2fe997b6ea5a66351892cc1884eee35bfa41afcb8cf013764c0cad28dfd1325bd8dc5d5d342bb6bb07fe13553faa2b5c0d4df3c0ecf03d1af4386c74617037dbfc71dcdee33f09f67c89337affea00fc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      这是一篇加密文章，内容可能是个人情感宣泄或者收费技术。暂时不对外进行开放,之后给想看的人看,十分抱歉,如果你确实想看，请与我联系。
    
    </summary>
    
    
      <category term="TODO" scheme="https://schen1024.github.io/categories/TODO/"/>
    
    
      <category term="person" scheme="https://schen1024.github.io/tags/person/"/>
    
      <category term="encrypt" scheme="https://schen1024.github.io/tags/encrypt/"/>
    
      <category term="todo" scheme="https://schen1024.github.io/tags/todo/"/>
    
      <category term="game" scheme="https://schen1024.github.io/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>休假归来-重新启程</title>
    <link href="https://schen1024.github.io/2020/06-10/%E4%BC%91%E5%81%87%E5%BD%92%E6%9D%A5-%E9%87%8D%E6%96%B0%E5%90%AF%E7%A8%8B.html"/>
    <id>https://schen1024.github.io/2020/06-10/%E4%BC%91%E5%81%87%E5%BD%92%E6%9D%A5-%E9%87%8D%E6%96%B0%E5%90%AF%E7%A8%8B.html</id>
    <published>2020-06-10T15:11:32.000Z</published>
    <updated>2023-01-01T13:25:24.782Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="85efb3d43322466309d289339ebdef9982cdd8378d6d9b2f936c46f71a5c2ed0">c69d458b5be806e1275b581ae7b46a5b4b1cdbf18bb8d8faf805c851b25c609010ca069a2b1764a60d39c53be031376fa62e88129a5f5b8f63131c39a64ae076912e51b3e7ddb0d28217b41a9e65c2f4fc8a49a1eca2cdb264532b6fb43ff7a91a93c6ca3e62366cdbbbfd3346675baf3370a27a59b2010c6837dfd8115190aa18d3d9b4096df3853f85f4c8313f270e64f343bbe5f3420b35e5ddd2da49701f6cedaa4033284a4b1f3eb71703fe8b84ab534908f6070974bf9caab917798d377e77296f0de862f619851adce440e6c90e7321f612b64cf1df8250b4c23d46a90971737267ecbcf4f91a2f81a73dba026b134db785691bc07768c030f40f8b18fc29a83f89574a507b0fb4f56fc92b4cdcce6ff4d301791da1a4637c4603b68c0f290b344eea669b52e11a23bef44364f8ce5a3cc14d1434ce02eaa0c0628b6a074caae178ebbc7c8762b9a8a181a3102ade4c714395ec5a158b0c5bbe641d26b4091e8abb751d56d64439fda6de423ba6c296c6c89a2fc20c06bc91207a772c052b42f2600482d52e2bfce88bf04f6a00daa91a5b3063577ab247a792b95d6dd4c02e7bf1e9f1a3f0c12c7d01c6eb554c57395566cc76d1deb91aa1b6bb29bc8d33a9cf71d1d4271b5cd804fc5afb8b71069264f0eca06f01652ce6cd6efa369a4ce2723f3c5e6cdce26c13b28048da1c90a5ff2b92905f51d8b823d91d3c73c028a62a3062f1692d484384d15e26df729657daf998fa511473625b98f3c96f4c544394ec56f3d6a89573430b24ac083bb6a1f6a0a9595bf5872af58fff9ffde8fc288ecdb0527d0b2020ba9ce97ec08312802576b97082764ee99ec7e33814ec60041a5f3b16f41075afda70a61af0e15d33400cb60cfab35400ae2b86785789ee02b8733d74c7a82e376536578edbbf12a4a5994893acb3433ae77c84d132385d59bb917269f4dff891450aa385ebfb3484bba2623b205721af6ad5f5e7c7c540ffa794aa53ce1bd2c0f99e491345ef949f0a230d8ed13f326125895890ed3d35ce7fd5db0e2b7c983c142364e8f785e2b37124f9a326ae8e579ee4ae1cd2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      这是一篇加密文章，内容可能是个人情感宣泄或者收费技术。暂时不对外进行开放,之后给想看的人看,十分抱歉,如果你确实想看，请与我联系。
    
    </summary>
    
    
      <category term="Person" scheme="https://schen1024.github.io/categories/Person/"/>
    
    
      <category term="encrypt" scheme="https://schen1024.github.io/tags/encrypt/"/>
    
      <category term="hexo" scheme="https://schen1024.github.io/tags/hexo/"/>
    
      <category term="blog" scheme="https://schen1024.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>opencv-13-直方图计算</title>
    <link href="https://schen1024.github.io/2020/05-21/opencv-13-%E7%9B%B4%E6%96%B9%E5%9B%BE%E8%AE%A1%E7%AE%97.html"/>
    <id>https://schen1024.github.io/2020/05-21/opencv-13-%E7%9B%B4%E6%96%B9%E5%9B%BE%E8%AE%A1%E7%AE%97.html</id>
    <published>2020-05-21T00:36:37.000Z</published>
    <updated>2023-01-01T13:25:24.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>在进行更多的算法操作之前， 有一个很有意思的数据或者工具需要我们提前学习，那就是 直方图</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[toc]</p><h2 id="本文目标"><a href="#本文目标" class="headerlink" title="本文目标"></a>本文目标</h2><ol><li>介绍直方图及其原理</li><li>算法实现直方图统计</li><li>将统计结果进行展示应用</li><li>实现基于直方图的图像均衡化</li></ol><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="直方图原理与实现"><a href="#直方图原理与实现" class="headerlink" title="直方图原理与实现"></a>直方图原理与实现</h3><p>这是一个统计数据， 由基础可知，灰度一共分为256个层级， 给出一副灰度图，我们能够统计不同灰度等级的像素一共有多少个， 或者进一步的我们能够得到</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; title=&quot;开始之前&quot;&gt;&lt;/a&gt;开始之前&lt;/h2&gt;&lt;p&gt;在进行更多的算法操作之前， 有一个很有意思的数据或者工具需要我们提前学习，那就是 直方图&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;本文目标&quot;&gt;&lt;a href=&quot;#本文目标&quot; class=&quot;headerlink&quot; title=&quot;本文目标&quot;&gt;&lt;/a&gt;本文目标&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;介绍直方图及其原理&lt;/li&gt;
&lt;li&gt;算法实现直方图统计&lt;/li&gt;
&lt;li&gt;将统计结果进行展示应用&lt;/li&gt;
&lt;li&gt;实现基于直方图的图像均衡化&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;h3 id=&quot;直方图原理与实现&quot;&gt;&lt;a href=&quot;#直方图原理与实现&quot; class=&quot;headerlink&quot; title=&quot;直方图原理与实现&quot;&gt;&lt;/a&gt;直方图原理与实现&lt;/h3&gt;&lt;p&gt;这是一个统计数据， 由基础可知，灰度一共分为256个层级， 给出一副灰度图，我们能够统计不同灰度等级的像素一共有多少个， 或者进一步的我们能够得到&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;h2 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h2&gt;
    
    </summary>
    
    
      <category term="opencv" scheme="https://schen1024.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://schen1024.github.io/tags/opencv/"/>
    
      <category term="c++" scheme="https://schen1024.github.io/tags/c/"/>
    
      <category term="histograms" scheme="https://schen1024.github.io/tags/histograms/"/>
    
  </entry>
  
  <entry>
    <title>武汉大学硕士毕业论文格式</title>
    <link href="https://schen1024.github.io/2020/05-15/whumaster.html"/>
    <id>https://schen1024.github.io/2020/05-15/whumaster.html</id>
    <published>2020-05-15T15:51:46.000Z</published>
    <updated>2023-01-01T13:25:24.780Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="391750bbd226d1baa414b2f570ea292b27d27410fbaedbfc8f9832c5b5848c4c">8461f7898b2290b1304edc4c8480707fcb837656eb2c250add0df8697fd7c97bf26cbcb2846c0cc75ec9ba94e12288d3ddeefca371fa5415ce0c6ef5c86436753934e9cf5494b17306f7e0616f943b36449b1ea38738f7c394b7b919c5d4c2c7ecb9a29df4b1381348e382b9c1a8bbdfbe39178a3360fac62d4d662c4ea2e763446d31bce28ba29afff7f6385b031f9e59006509576a03df24bb284bb42db4ab22c58935c9392adb1442270ffea6974675a26e65e93efa6698da37c45ec97987074cc30ebb2a5b9ffb47fd914ffa7968c6b6bd5fe727df448c083ad51456887730fb8307609b4d4e9dde3addf62010c08f5672ecf9af5d57483edc7c0a284c27555ff151e53e9795bbe476b1ec3543ae397bbb027657183e95e3f484c7b0ebd56f65a05e1191715c32dfa717fb47bb670d878b179b4b1cb48319ab50494eca10eb2195f213bd43aed51f0ba35573635bbc6bf860c2e71d0b3b9fc9ccc77d754dfee740c2a02b492df152a357fd045b789f843e53cb838c0dd0ad1ed5513ba6b7b03a595d4cf83c4578fe61f4152e14178242c73d9de1678c102b7cf92ef3c28b423d28773f487aea30cb933d4040a7a52b063ad1bebd5e636d7ce058ce49b16ead107b3ba92ff74063569f4ae12c0fd7a60e0c5d197e980d230f197a22fbd261039879bd86ef39849c8d2ded8729e492d8236f27f57696be9ce9c99360e547a4ba71b5d4395c35b5e77dd9a27be1562308715bf5e3c235a6d446836b9db09a499bbb35905685f6e9af47518c6930b74a0e48646f44c54754a81e5edaa4c2bad976e9eaa04d2ee8ee095af2a6ff8645e0ca02c3f374af4eec2db2dfde4474b99522dba514ffa1533d85a5b6278fc09809720742bb72cea090ca551d8f875fe42bb46cede7d108e3bb389c45bc8fb7c5e417314851f20a250a09a180ddbf717548e8b4dc5b6fe282a5e04bb23e9b898ebff7c97e55b2adc8ed77d51bd13a68a6d46f257fc8f2b4081d104401908df46b6310a75fe9a0eda9bf516059fdf1487382ddd763585674150b4292dc5cfcbc9d7ee4815df7cd232e14403b61696d37b3fa0cf66ce8b600352ac57748a9188a1972d1194f81adaef57f5cbc61bac5558170e6366ec3c41d140ef7e92dc3f7c2bdff00bebdb37a9c4a000e62c9ee48aedcc5ee923c2eb6663370f2d16f6f420d97109bff89ddb80be22ecf03b1001cd51c393df456441fd2f7285f5072d2f31d809b853fd03c150cd018a523398a77ac8c3f6c0bd2e8442a023f2fb53af3f024449f8253c02d1afae446a6c8413155fffbca7cb04a26029adf804ee6763f5d29b97067921d181ca99e09b83c5b75bc960a43342c87d0544d453beab34442082b35e867d5bf0ff4242775abf771995e84685da230ba04c4be57a0b3671e55cc811c8336f44e7ea0a5738e6a6cfef22cbd5d7b13d2fcfc7d02803d07684d012f93d3979b9c00f75dba80b87d653baa5bb2a1741f674961912b307e537d424da0820eb090eadca4a319fdd782a5d2fd5603f871f4342741d80ea1b95acbd3be31f18be45f04e9bfb310a99acae3b2b72bdc5ecade627b95c05c38d19ddfce119470ef3410a5a781f417eaf6c557f9f635e134e6a61622b0d7572b640d706cb06338203294d0f71be81c55c57931ab3daa5b5def1f265f93bc7d57862a6b926e3437123172b3d1d3b47c2f659255f61bde4778420359dbdba566d034b3c0b741f444d68170c9f1eff3f4d593aa718bbb5c693b28f434ce7852c683aaa2920ae1a0a6a082921bb41cd74aafc37a0c56d146b5900961b0a7abcf955d303711711787e771fa4b150ced70ceb1885c8f4b01bc3ec0f8d33185ab2d4b21b4baba0a569fb0894bc1fd0c5065476137a296c321bfd175ce21b85043768a72ef03879f1fec72c63ea1efafb95c5f46d8fe898cdd0831fe0b641c44a2bc01fc734950fa2070f8a13892d093ab82491a74d3040fa52eb88996cbde9546cdcf356bc9c8a8ee2a931cbf3e5ef025f7a92ce312feb21178f78350e6703ae7a74b643110e0ddf2ed0d52f2dcf11c8744b2ee90ef50cd55259fe5dce7a61145d860679601e0355cd5cbd88aa469d4900e194624351ce9315334fe83f7591fef3de05911a9c736c1853fab8e55e8c120ba52934363cecc0f18901f3fd2a8933451ccc6a4faa5796a886184de79322c9027d5a667513615365b24611ffc14e0b519588632ea18b3cf151c7e9c9402c5592766ac7c3fad4409b2bcdf45c479ef87d96de6e56a5a745b2109f19b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      这是一篇加密文章，内容可能是个人情感宣泄或者收费技术。暂时不对外进行开放,之后给想看的人看,十分抱歉,如果你确实想看，请与我联系。
    
    </summary>
    
    
      <category term="Person" scheme="https://schen1024.github.io/categories/Person/"/>
    
    
      <category term="encrypt" scheme="https://schen1024.github.io/tags/encrypt/"/>
    
      <category term="hide" scheme="https://schen1024.github.io/tags/hide/"/>
    
      <category term="hexo" scheme="https://schen1024.github.io/tags/hexo/"/>
    
      <category term="blog" scheme="https://schen1024.github.io/tags/blog/"/>
    
      <category term="whu" scheme="https://schen1024.github.io/tags/whu/"/>
    
      <category term="master" scheme="https://schen1024.github.io/tags/master/"/>
    
  </entry>
  
  <entry>
    <title>记一次电信诈骗经历</title>
    <link href="https://schen1024.github.io/2020/05-13/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%B5%E4%BF%A1%E8%AF%88%E9%AA%97%E7%BB%8F%E5%8E%86.html"/>
    <id>https://schen1024.github.io/2020/05-13/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%B5%E4%BF%A1%E8%AF%88%E9%AA%97%E7%BB%8F%E5%8E%86.html</id>
    <published>2020-05-13T18:40:07.000Z</published>
    <updated>2023-01-01T13:25:24.790Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="c68688e80ae420871de24f72850865e821e0e7d8f5e2f79eea63b7542760086b">34191281404cd31e685e77dcf28deaf6e17d5ae3f95704bff710d1e5df9da1d395107afc438c926f2f85b1a0ac4ec759a37554abb52944f7ed0a69ee9ec7d8997e6e45956c838189d1138af108970521678a567019c48b3f1c5e0da4814c156da285d87fc2ab8c7bf103204a435f298f5ffa06805c9d15b045eddbb74e921bc6f26e4b68702e870ecbc969070e752e71fe489ef0dfb2829650f4d58e72beee5adee2e9b6922ee80beed62c1aebc725310a840c618d05db64a7c890246fdcdc7f1875fa7570dcc5fdea550ae62d292b2107e27a59b194e2b409c032d0251011c745dc22150e5e48b9dda30daf60600231ae5dbb797dce27c9d1e344dbaeba550e9d5491d9a2c856bd4a3070844ecfa15be359f76fe78ac8bd6a7bbd11e4263c278845e28f26203573055c38add1186c27f5104d00784853430ac4c3839e2a339732f67768cb1d35d380b678a1dc3120fc220b4fa1cd1ce17487f38a77910207095f1ec57237f1cdb516ca03cc2001bc0765a2afa9d9ce3fa5eca88ea77bc5d855de7d8fe51ac32069777d27eaca92ede62fa2495813ebede3cdbb32f078c50a6340657f0dbea0424369369403b2921230c97b01837ea6b5a16ff1e3b9abe16114165162134a1861c7ad6c516288f98196621745c7fd26599a98f27648d4eaa32c72adf0a6d3cc83a6818c234226f980ea227795dc0b7c3243d6dbf1866e88701ccde06487bba91fe4745bff0620b9e564e87fa7ec96c4694d6cb70c70c0e3e5cfd5135433e880b1c809a38e1d8cf0edc3163155c6d507dd9f656b60cf662c192f85924aaea3d3f6ab584408855ecf3f1e94bae427d4e535608a76cdd7e02ee00fa85e063d90b448b7c924cff7611128acbec59442144732d9ba6d279d10c1a24f3f79216a3b5c93a57886f8497c44359b2ff7d971bb3d9d33c49b6d1e1128662d83cecc6eebfa73108cab651c3d07a4d00c85a85f9a4cd0e390a4edf1c41fb3c11c6d1c0805a4a41d4b06cb0cebd6ecb912583db04cc5f30e7cc929073a5bd2d3da77c449c45a799d91198c71ac86d3c60a929ce8ea2d23f1706bddcee5be1453ee53bee9325d179ff92d69ad426d37f5b076d5f54e1e5b51ec77acccba539c26f4d9158cfb3529f55e37b2cc62a3c3f7da73771121025944c9caee40b4a52a131aa17d694ed747ad7c5194e382c2d2e1495c9315611a9a737a49a69391962ca46583d80850cc3d076e020f84757138a404a3c7962a85180ef265a25029b5747483e3226311a6c3b5d1ea626eae79d42175413b06354d06fdc1d9e029281e0a7c6e039bd34e79ee64a0f4a2f68b52fd16a588a20705a3f75020ad83f9173dbc565393e18a98d47bfa3901771c5e06f89f19853986fabdb1206c443b4c96ddc27a8a395a1ddfdf537a9399f09b4aa8ce8ed809f568ce46fbbfdcbb9d0aac722d2ecf5c6ec77b4fad9e83ab02fd58d29030d4a8c00d99e2b95da79f2dfd991bec502a870e15c094ca25b09691342e1206bf685a645cfc255aa563196012b66fee7d10d5360b683ad631aa1d8c19ee0820785e5eced75c3b79535720fac6bea49c56515089e86ab2e161af980794e126ac4b38bba17e47af0abd71809a9b34d0b8766c64ca2f22663c7578d63174f4e7ba19b0b87d69c3b67c0029ab261fb25b750b98f391eb14a4b27385d4dce065fdf5e8c06f05ba4d0c718148cafa9120bb64c10f45064d494ba86c8adf1860503b46761b0f902a68e2b90194dec480795f6f5eb26074ec3f12b116ba66f122195f52a173eebcfb375f33578e20c2cbb26c2fde65cf82886399e97a85413a389e7e1af266b34e1f41449f401f69612b75cc263f94630f7b55165b173df3f9dfeb4a3e88c5c7776c4c105165cac9f705aa94ef1445d581feaa6a231433b73f0e24c71806eddaf6bbd0f71d398e33af440f60eb44cb6cc3cd14cf416d0330facd4c5bac149286ea62d586b2bf6518b748fa9a7953f41b5f2ae4b83f6a0478a6f99cc9343a9d720cefd7fb0fc113db978ce077c66ab9763814b04cd24c70a8555d0b88737df6388ef4f8561ecc280d0dfa49c016b96b2a2f5d58926df7a8766d12ccc00cbdb35be92c68778471b526536400dfef72f328025175e936399e5c6779b4eea3c94d3e98db49433a679bea94f692870291ff42aed4968aaba407d0d4ed453bc2a87107d63d8e3728bbc2ad875a859d3e69c35ac66b6ba9011ab375176e7ce35275d2537f371bf6da38d2e526415195ae6413f6b9651b5342472bcd906b1e370a884e338fbd177ee529fc99cdc535a82d34a23c8bf0d7cc17a0275247b857ac40ccf82eb486a0d77343629452659bbe6d2396dafe1fa5c8fcee7e038355cc86fdaa81ae4cf842a5bb769158a21092a2fb5acbd337fd7fc20362260fd4831365935f18496aed30d7461b58b951f20e14d4ba854caf6e9eff8f67fbe478939c75348546564f6eeacdbf99716855a9e8af146d56b189729da2e5f58ebb1da0dc536c99c464604e127621e56754027ef2393daed594236b4ba7cafc1d242848cc478f464c1318cffd02644a01d61477392f8e85bd2fa236d053a27cbdb9fbb05f5f4e57624ab36cf95d5dd069bb6864fc54db6875af9c4cfc8cdca7e9b2acc70237088be3bb06326f186eed69fbea494cb55bef23ae6ea2b7ea3d94cc6c4fc505ee39405173c03400ad96938316790a33e7f065bc2f1285e5ec5533c1ecdf2cd73f89bc55b1fe32c6b84728fd9d0a9ef75251d4d89a1497b4c0967f1b7f445450d9c4bcfa6f874756f496f91a59143a2d3f345bf605a2023bdd9c1060aadd2a227c2da07d8d3551882f2fbf11921bccc44a5b7450e0e559a520a498704328054fafc373e7f16cbd751d08d69517d69b8026bb20faafbc7ea8410116e4de9fc8eb6d496359ad71cbee879457d343a7833d99239c743704afd78e9565233e42bca5a858c78e36b1ac7a1f33c043a74825ee6fbf5dc6a45fce7bce37521177077671e1749bb3fb941967ca003e70c281c05417a5973ad91c3fab883a0e2f6b2eed7d9acceeef84eebe267a6bfe672d619a1dd77596569f7c3b93a3566b7d2c89b1475073535847076d949701929924749a37e9530d1d39e9838371634e337a69a59c22fbcffbdd524ed00f3f5c66f8fb7476724406f33b70c8275ce99d39c527831bdd941526c96de5945dafc0eb53e70faee6aebceace60d4f63c070e0926e5f0eaf9980822188efdd273fd22be806fce347c837886c82cba7f9cbc77f14c81223e51e018ecf48762ad407b6b975dfa87c1450accb77f52c6c8a730306db614aea11784355af3fa39a4c304b0b9a72c59456f87ab00ba5494d7714ec7c02320f2e560e6d20a3ecdb7ab59646c3fb3ac421fa68906bdae8eea73de489011d447f17408e9f6d2e11a0df22b70a43be1aab19ffac6e9f5a11cc53cb8282b48f0fa09b6b6dfb23f57e650392ef48c584fb543f8594d4d07fbe66271bdcb7acc5e4103bf530206c412abecc20b476c57fd3e561c0517932f6b12eed395cbf480f01f2d84ed66612c5c6cd9aa7dd40e1d22152d05449d40d8198a3a245d19325f759e6e6aefb584aa7ff882c9c08aa3ff00d48894d15652e4a32f26f66bb86c964e35cb5bdd31aaaec2cabfaef0df2ea49ab4becd41753a17b22eab4aada0fd852753b9e3b153759457f6a3152ba08c9c017fcf23a509ccb6bb2bfb71a62b982d14e97052df249fe632d451b71796506a4467b0cfe5a0dc61a169b98a7b0a155ce8be8985905d311cd4b75b65557ddf5e7edcc5b150c4569e29c642660ba2a53c0dcc0c65ded5fbe8070801ebdcc6c33f293ec5d77f5ca6c0064c12510f0f5504393712932ed5ff34d66a4c191fa2f49a11e787ef6ca6dfb324ad9edaa0ae86a894e8ff3f125171ed8a75ade11164be56c55a8d70e99f645269511049a317ee81d64d0e13e3ec710495e3ba3eaa2f13cabf98842c072f339deecef8ece1713768fa7628d8f916e50617f5282dd280ef8b5b65a566edcb3d9e8683b063d6aec9f981f5bef1db4e1cf73d0e12f955be2c019e9dfa0fecd604882673b7cd522f54259358d4fe977beffef4a5c00e2dc9fe5c743c5a9b8113dc8e0985aca6952eb619c9187cf6ece06253c41aa8b693321f3759b170b7e8065b4347d99c8de367f5ccccc08b054ab353459ed54194aa076615ebd5b928ca4859b78832d1746d8c26216e815275dd89607c448d93a6fbac4bfa412a3f8b5210b7b2c947876e14c8005fe4bf187c1df70a54dd801f1037d79b34d62116b3e5123f00e317c969315ee261cd012e171e5168a27dc6ab917b4976787d3c55d23dcb16eee030fd0713f3d9f322bd43993fd693d80e619e18852c6bff80efd782db6b69</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      这是一篇加密文章，内容可能是个人情感宣泄或者收费技术。暂时不对外进行开放,之后给想看的人看,十分抱歉,如果你确实想看，请与我联系。
    
    </summary>
    
    
      <category term="Person" scheme="https://schen1024.github.io/categories/Person/"/>
    
    
      <category term="person" scheme="https://schen1024.github.io/tags/person/"/>
    
      <category term="encrypt" scheme="https://schen1024.github.io/tags/encrypt/"/>
    
      <category term="hide" scheme="https://schen1024.github.io/tags/hide/"/>
    
      <category term="fraud" scheme="https://schen1024.github.io/tags/fraud/"/>
    
  </entry>
  
  <entry>
    <title>opencv-12-高斯滤波-双边滤波(附C++代码实现)</title>
    <link href="https://schen1024.github.io/2020/05-10/opencv-12-filter.html"/>
    <id>https://schen1024.github.io/2020/05-10/opencv-12-filter.html</id>
    <published>2020-05-10T10:08:27.000Z</published>
    <updated>2023-01-01T13:25:24.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>这几天由于自己的原因没有写, 一个是因为自己懒了, 一个是感觉这里遇到点问题不想往下写了, 我们先努力结束这个章节吧, 之前介绍了比较常用而且比较好理解的均值和中值滤波,  但是呢,在例程<a href="https://docs.opencv.org/4.3.0/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html" target="_blank" rel="noopener">Smoothing Images</a>, 还有给出的其他的滤波方式, 主要是高斯滤波和双边滤波,</p><p>我们这一次完结掉滤波与平滑的这个部分, 写的有点多了,反而不想再写了, 加油</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[toc]</p><h2 id="本文目标"><a href="#本文目标" class="headerlink" title="本文目标"></a>本文目标</h2><p>本文主要是介绍</p><ul><li>高斯滤波</li><li>双边滤波</li></ul><p>和之前介绍的一样, 我们仍然还是 介绍一下原理, 给出一下具体的形式, 然后使用 opencv 进行一下实现的过程, 最后使用我们之前的图像进行测试 进行算法的分析与总结.</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="高斯滤波-Gaussian-Filter"><a href="#高斯滤波-Gaussian-Filter" class="headerlink" title="高斯滤波(Gaussian Filter)"></a>高斯滤波(Gaussian Filter)</h3><p>我们在之前介绍了中值滤波是统计排序的结果, 属于非线性的结果, 均值滤波是使用模板核进行的操作, 我们在的文章中也提到了均值滤波在计算的过程中必须要考虑权重的问题, 进而提出了加权的均值滤波的操作, 比如最常见的加权均值滤波的操作核.<br>$$<br>M = \frac{1}{16} \left [<br>        \begin{array}{c}<br>            1 &amp; 2 &amp; 1 \ 2&amp; 4 &amp; 2 \ 1 &amp; 2 &amp; 1<br>        \end{array}<br>\right ]<br>$$</p><p>其实呢,这个核也就是高斯滤波器在 <code>3*3</code>窗口的离散取整的结果值, 最明显的特点就是模板的系数随着距离模板中心的距离而变换, 能够有效的抑制噪声,平滑图像, 相比均值滤波能够更好的平滑图像, 保留图像边缘. </p><h4 id="高斯滤波原理"><a href="#高斯滤波原理" class="headerlink" title="高斯滤波原理"></a>高斯滤波原理</h4><p>由于我们的图像是二维的, 但是高斯分布是一维的, 那我们先考虑一维的高斯分布, 就是我们常用的正太分布曲线,<br>$$<br>G(x) = \frac{1}{\sqrt{2\pi \sigma}} e^{-\frac{x^2}{2\sigma^2}}<br>$$</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1589099908842.png" alt="一维高斯分布"></p><p>对于二维的高斯分布其实可以考虑成两个方向的运算相叠加的得到的结果<br>$$<br>G(x,y) = \frac{1}{2\pi \sigma^2} e^{-\frac{x^2+y^2}{2\sigma^2}} = G(x)*G(y)<br>$$</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1589099908844.png" alt="二维高斯分布"></p><p>考虑到图像的计算实际上是离散的座标, 对于窗口大小为 $(2k + 1) \times (2k + 1)$ 模板, 我们可以表示成<br>$$<br>G{i,j} = \frac{1}{2\pi \sigma ^ 2}e ^{-\frac{(i - k - 1)^2 + (j - k - 1)^2}{2 \sigma ^ 2}}<br>$$</p><p>可以参考<a href="https://www.cnblogs.com/wangguchangqing/p/6407717.html" target="_blank" rel="noopener">图像处理基础(4)：高斯滤波器详解</a><br>里面给出的方法, 使用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateGaussianTemplate</span><span class="params">(<span class="keyword">double</span> window[][<span class="number">11</span>], <span class="keyword">int</span> ksize, <span class="keyword">double</span> sigma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="keyword">int</span> center = ksize / <span class="number">2</span>; <span class="comment">// 模板的中心位置，也就是坐标的原点</span></span><br><span class="line">    <span class="keyword">double</span> x2, y2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ksize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x2 = <span class="built_in">pow</span>(i - center, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ksize; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            y2 = <span class="built_in">pow</span>(j - center, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">double</span> g = <span class="built_in">exp</span>(-(x2 + y2) / (<span class="number">2</span> * sigma * sigma));</span><br><span class="line">            g /= <span class="number">2</span> * pi * sigma*sigma;<span class="comment">// </span></span><br><span class="line">            window[i][j] = g;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> k = <span class="number">1</span> / window[<span class="number">0</span>][<span class="number">0</span>]; <span class="comment">// 将左上角的系数归一化为1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ksize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ksize; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            window[i][j] *= k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">生成了$<span class="number">3</span> \times <span class="number">3</span>, \sigma = <span class="number">0.8</span>$ 的高斯模板, 对应的将其取整就得到了</span><br><span class="line">$$</span><br><span class="line">M = \frac&#123;<span class="number">1</span>&#125;&#123;<span class="number">16</span>&#125; \left [ </span><br><span class="line">        \begin&#123;<span class="built_in">array</span>&#125;&#123;c&#125;</span><br><span class="line">            <span class="number">1</span> &amp; <span class="number">2</span> &amp; <span class="number">1</span> \\ <span class="number">2</span>&amp; <span class="number">4</span> &amp; <span class="number">2</span> \\ <span class="number">1</span> &amp; <span class="number">2</span> &amp; <span class="number">1</span></span><br><span class="line">        \end&#123;<span class="built_in">array</span>&#125;</span><br><span class="line">\right ]</span><br><span class="line">$$</span><br><span class="line">上面给出的文章同样的详细介绍了 $\sigma$ 在统计学中的意义, 可以去参考学习</span><br><span class="line">不过根据高中的知识, 我们可以看到 正态分布的曲线</span><br><span class="line"></span><br><span class="line">![正态分布曲线](https:<span class="comment">//gitee.com/schen00/BlogImage/raw/master/image/1589099908845.png)</span></span><br><span class="line"></span><br><span class="line">#### C++ 实现</span><br><span class="line">在我们之前提到的[图像处理基础(<span class="number">4</span>)：高斯滤波器详解](https:<span class="comment">//www.cnblogs.com/wangguchangqing/p/6407717.html) 这里给出了基于 opencv 的代码实现, 这里是$O(m*n*k^2)$ 的算法实现</span></span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">// 来源链接: https://www.cnblogs.com/wangguchangqing/p/6407717.html</span></span><br><span class="line"><span class="keyword">void</span> GaussianFilter(<span class="keyword">const</span> Mat &amp;src, Mat &amp;dst, <span class="keyword">int</span> ksize, <span class="keyword">double</span> sigma)</span><br><span class="line">&#123;</span><br><span class="line">    CV_Assert(src.channels() || src.channels() == <span class="number">3</span>); <span class="comment">// 只处理单通道或者三通道图像</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">double</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="comment">// 根据窗口大小和sigma生成高斯滤波器模板</span></span><br><span class="line">    <span class="comment">// 申请一个二维数组，存放生成的高斯模板矩阵</span></span><br><span class="line">    <span class="keyword">double</span> **templateMatrix = <span class="keyword">new</span> <span class="keyword">double</span>*[ksize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ksize; i++)</span><br><span class="line">        templateMatrix[i] = <span class="keyword">new</span> <span class="keyword">double</span>[ksize];</span><br><span class="line">    <span class="keyword">int</span> origin = ksize / <span class="number">2</span>; <span class="comment">// 以模板的中心为原点</span></span><br><span class="line">    <span class="keyword">double</span> x2, y2;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ksize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x2 = <span class="built_in">pow</span>(i - origin, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ksize; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            y2 = <span class="built_in">pow</span>(j - origin, <span class="number">2</span>);</span><br><span class="line">            <span class="comment">// 高斯函数前的常数可以不用计算，会在归一化的过程中给消去</span></span><br><span class="line">            <span class="keyword">double</span> g = <span class="built_in">exp</span>(-(x2 + y2) / (<span class="number">2</span> * sigma * sigma));</span><br><span class="line">            sum += g;</span><br><span class="line">            templateMatrix[i][j] = g;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ksize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ksize; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            templateMatrix[i][j] /= sum;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; templateMatrix[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将模板应用到图像中</span></span><br><span class="line">    <span class="keyword">int</span> border = ksize / <span class="number">2</span>;</span><br><span class="line">    copyMakeBorder(src, dst, border, border, border, border, BorderTypes::BORDER_REFLECT);</span><br><span class="line">    <span class="keyword">int</span> channels = dst.channels();</span><br><span class="line">    <span class="keyword">int</span> rows = dst.rows - border;</span><br><span class="line">    <span class="keyword">int</span> cols = dst.cols - border;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = border; i &lt; rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = border; j &lt; cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> sum[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a = -border; a &lt;= border; a++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> b = -border; b &lt;= border; b++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (channels == <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        sum[<span class="number">0</span>] += templateMatrix[border + a][border + b] * dst.at&lt;uchar&gt;(i + a, j + b);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (channels == <span class="number">3</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Vec3b rgb = dst.at&lt;Vec3b&gt;(i + a, j + b);</span><br><span class="line">                        <span class="keyword">auto</span> k = templateMatrix[border + a][border + b];</span><br><span class="line">                        sum[<span class="number">0</span>] += k * rgb[<span class="number">0</span>];</span><br><span class="line">                        sum[<span class="number">1</span>] += k * rgb[<span class="number">1</span>];</span><br><span class="line">                        sum[<span class="number">2</span>] += k * rgb[<span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channels; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum[k] &lt; <span class="number">0</span>)</span><br><span class="line">                    sum[k] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum[k] &gt; <span class="number">255</span>)</span><br><span class="line">                    sum[k] = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (channels == <span class="number">1</span>)</span><br><span class="line">                dst.at&lt;uchar&gt;(i, j) = <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (channels == <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Vec3b rgb = &#123; <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">0</span>]), <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">1</span>]), <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">2</span>]) &#125;;</span><br><span class="line">                dst.at&lt;Vec3b&gt;(i, j) = rgb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放模板数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ksize; i++)</span><br><span class="line">        <span class="keyword">delete</span>[] templateMatrix[i];</span><br><span class="line">    <span class="keyword">delete</span>[] templateMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后同样的给出了分离的实现, 将图像进行水平运算之后再进行竖直运算, 计算的时间上会有一定的速度提升<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来源链接: https://www.cnblogs.com/wangguchangqing/p/6407717.html</span></span><br><span class="line"><span class="comment">// 分离的计算</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">separateGaussianFilter</span><span class="params">(<span class="keyword">const</span> Mat &amp;src, Mat &amp;dst, <span class="keyword">int</span> ksize, <span class="keyword">double</span> sigma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CV_Assert(src.channels()==<span class="number">1</span> || src.channels() == <span class="number">3</span>); <span class="comment">// 只处理单通道或者三通道图像</span></span><br><span class="line">    <span class="comment">// 生成一维的高斯滤波模板</span></span><br><span class="line">    <span class="keyword">double</span> *matrix = <span class="keyword">new</span> <span class="keyword">double</span>[ksize];</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> origin = ksize / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ksize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 高斯函数前的常数可以不用计算，会在归一化的过程中给消去</span></span><br><span class="line">        <span class="keyword">double</span> g = <span class="built_in">exp</span>(-(i - origin) * (i - origin) / (<span class="number">2</span> * sigma * sigma));</span><br><span class="line">        sum += g;</span><br><span class="line">        matrix[i] = g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 归一化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ksize; i++)</span><br><span class="line">        matrix[i] /= sum;</span><br><span class="line">    <span class="comment">// 将模板应用到图像中</span></span><br><span class="line">    <span class="keyword">int</span> border = ksize / <span class="number">2</span>;</span><br><span class="line">    copyMakeBorder(src, dst, border, border, border, border, BorderTypes::BORDER_REFLECT);</span><br><span class="line">    <span class="keyword">int</span> channels = dst.channels();</span><br><span class="line">    <span class="keyword">int</span> rows = dst.rows - border;</span><br><span class="line">    <span class="keyword">int</span> cols = dst.cols - border;</span><br><span class="line">    <span class="comment">// 水平方向</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = border; i &lt; rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = border; j &lt; cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> sum[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = -border; k &lt;= border; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (channels == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum[<span class="number">0</span>] += matrix[border + k] * dst.at&lt;uchar&gt;(i, j + k); <span class="comment">// 行不变，列变化；先做水平方向的卷积</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (channels == <span class="number">3</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Vec3b rgb = dst.at&lt;Vec3b&gt;(i, j + k);</span><br><span class="line">                    sum[<span class="number">0</span>] += matrix[border + k] * rgb[<span class="number">0</span>];</span><br><span class="line">                    sum[<span class="number">1</span>] += matrix[border + k] * rgb[<span class="number">1</span>];</span><br><span class="line">                    sum[<span class="number">2</span>] += matrix[border + k] * rgb[<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channels; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum[k] &lt; <span class="number">0</span>)</span><br><span class="line">                    sum[k] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum[k] &gt; <span class="number">255</span>)</span><br><span class="line">                    sum[k] = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (channels == <span class="number">1</span>)</span><br><span class="line">                dst.at&lt;uchar&gt;(i, j) = <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (channels == <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Vec3b rgb = &#123; <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">0</span>]), <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">1</span>]), <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">2</span>]) &#125;;</span><br><span class="line">                dst.at&lt;Vec3b&gt;(i, j) = rgb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 竖直方向</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = border; i &lt; rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = border; j &lt; cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> sum[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = -border; k &lt;= border; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (channels == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum[<span class="number">0</span>] += matrix[border + k] * dst.at&lt;uchar&gt;(i + k, j); <span class="comment">// 列不变，行变化；竖直方向的卷积</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (channels == <span class="number">3</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Vec3b rgb = dst.at&lt;Vec3b&gt;(i + k, j);</span><br><span class="line">                    sum[<span class="number">0</span>] += matrix[border + k] * rgb[<span class="number">0</span>];</span><br><span class="line">                    sum[<span class="number">1</span>] += matrix[border + k] * rgb[<span class="number">1</span>];</span><br><span class="line">                    sum[<span class="number">2</span>] += matrix[border + k] * rgb[<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channels; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum[k] &lt; <span class="number">0</span>)</span><br><span class="line">                    sum[k] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum[k] &gt; <span class="number">255</span>)</span><br><span class="line">                    sum[k] = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (channels == <span class="number">1</span>)</span><br><span class="line">                dst.at&lt;uchar&gt;(i, j) = <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (channels == <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Vec3b rgb = &#123; <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">0</span>]), <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">1</span>]), <span class="keyword">static_cast</span>&lt;uchar&gt;(sum[<span class="number">2</span>]) &#125;;</span><br><span class="line">                dst.at&lt;Vec3b&gt;(i, j) = rgb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的算法都是 上面提到的<a href="https://www.cnblogs.com/wangguchangqing/p/6407717.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangguchangqing/p/6407717.html</a>  这篇文章, 具体可以去看内容</p><h4 id="opencv-高斯滤波"><a href="#opencv-高斯滤波" class="headerlink" title="opencv 高斯滤波"></a>opencv 高斯滤波</h4><p>其实这篇文章<a href="https://blog.csdn.net/L_inYi/article/details/8915116" target="_blank" rel="noopener">图像处理–高斯滤波</a>写的很好<br>其实主要的结构也就是他给出的过程</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1589099909152.png" alt="高斯函数调用图"></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1589099908858.png" alt="高斯滤波函数调用简图"></p><p>其实整个高斯滤波的过程就是创建高斯核, 然后使用 filter2D 的方法进行的滤波操作, 具体要深入的话可以看函数的调用图, 实现起来也是一样的思路, 很简单的操作, 我们之后测试一下效果..<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /modules\imgproc\src\smooth.dispatch.cpp:600</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GaussianBlur</span><span class="params">(InputArray _src, OutputArray _dst, Size ksize,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">double</span> sigma1, <span class="keyword">double</span> sigma2,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> borderType)</span></span></span><br></pre></td></tr></table></figure></p><ul><li>src    ‪输入图像</li><li>dst    输出图像</li><li>ksize    核的尺寸 奇数</li><li>sigmaX    x 方向 的 sigma 值</li><li>sigmaY    ‪y 方向 的 sigma 值</li><li>borderType    边界处理的方式</li></ul><h4 id="高斯滤波效果对比"><a href="#高斯滤波效果对比" class="headerlink" title="高斯滤波效果对比"></a>高斯滤波效果对比</h4><p>我们还是使用之前的高椒盐噪声图像, 然后直接进行算法滤波, 计算结果就好, 跟之前的测试图像很相似, 这里</p><p><img src="./images/1589100238500.png" alt="测试结果图"></p><p>这里的四张图分别对应 高噪声图像, 直接高斯滤波的结果, 分离xy方向进行滤波结果,以及opencv 自带的高斯滤波效果图, 这里是预览图像, 实际的检测结果就是上面给出的参数值, 实际上效果只能说一般, 我们之后再进行算法层面的对比.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353</span><br><span class="line">image-noise: psnr:26.3155, mssim: B:0.584585 G:0.617172 R:0.812303</span><br><span class="line">image-noise: psnr:26.1721, mssim: B:0.574719 G:0.607494 R:0.809844</span><br><span class="line">image-noise: psnr:26.4206, mssim: B:0.598176 G:0.630657 R:0.819658</span><br></pre></td></tr></table></figure><h3 id="双边滤波-Bilateral-Filter"><a href="#双边滤波-Bilateral-Filter" class="headerlink" title="双边滤波(Bilateral Filter)"></a>双边滤波(Bilateral Filter)</h3><h4 id="双边滤波原理"><a href="#双边滤波原理" class="headerlink" title="双边滤波原理"></a>双边滤波原理</h4><p>我们在上面提出了高斯滤波的原理是对于距离模板中心 距离不同给予不同的权重, 而双边滤波则不仅考虑图像的空间距离, 还要考虑其灰度距离, 对于越接近中间灰度值的点权重越高, 灰度值相差大的则权重更小.</p><p>双边滤波的原理可以参考<a href="https://blog.csdn.net/Jfuck/article/details/8932978" target="_blank" rel="noopener">双边滤波（Bilateral Filter）详解</a>,<br>可以参考<a href="http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html" target="_blank" rel="noopener">Bilateral Filtering for Gray and Color Images</a></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1589099908862.png" alt="双边滤波原理"></p><p>在文章<a href="https://www.cnblogs.com/wangguchangqing/p/6416401.html" target="_blank" rel="noopener">图像处理基础(5)：双边滤波器</a>详细介绍了双边滤波<br>其实跟上面给出的滤波演示一致, 都是在保证图像边缘信息的情况下进行噪声的滤波..</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1589099909153.png" alt="双边滤波原理"></p><p>可以参考<a href="https://blog.csdn.net/guyuealian/article/details/82660826" target="_blank" rel="noopener">bilateral filter双边滤波器的通俗理解</a> 给出的双边滤波的数学表达<br>$$<br>g(x,y) = \frac{\sum_{kl}f(k,l)w(i,j,k,l)}{\sum_{kl}w(i,j,k,l)}<br>$$</p><p>对于不同的模板系数又有两个部分, 主要是 空间域模板权值 $w_d$ 和 灰度域 模板权值 $w_r$,<br>$$<br>\begin{array}{rl}<br>w_d(i,j,k,l) &amp;= e^{-\frac{(i-k)^2 +(j-l)^2}{2\sigma_d^2}} \<br>w_r(i,j,k,l) &amp;= e^{-\frac{\left | f(i,j) - f(k,l) \right |} {2\sigma_r^2}}  \<br>w &amp;= w_d * w_r<br>\end{array}<br>$$<br> 其中，$q(i,j)$ 为模板窗口的其他系数的坐标，$f(i,j)$ 表示图像在点$q(i,j)$ 处的像素值；$p(k,l)$ 为模板窗口的中心坐标点，对应的像素值为$f(k,l)$ ；$\sigma_r$ 为高斯函数的标准差。</p><h4 id="C-实现-双边滤波"><a href="#C-实现-双边滤波" class="headerlink" title="C++ 实现 双边滤波"></a>C++ 实现 双边滤波</h4><p>感觉这里写的挺好的 <a href="https://www.cnblogs.com/wangguchangqing/p/6416401.html" target="_blank" rel="noopener">图像处理基础(5)：双边滤波器</a>, 手动实现了双边滤波, 我们可以详细的参考, 这里</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考来源: https://www.cnblogs.com/wangguchangqing/p/6416401.html</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myBilateralFilter</span><span class="params">(<span class="keyword">const</span> Mat &amp;src, Mat &amp;dst, <span class="keyword">int</span> ksize, <span class="keyword">double</span> space_sigma, <span class="keyword">double</span> color_sigma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> channels = src.channels();</span><br><span class="line">    CV_Assert(channels == <span class="number">1</span> || channels == <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">double</span> space_coeff = <span class="number">-0.5</span> / (space_sigma * space_sigma);</span><br><span class="line">    <span class="keyword">double</span> color_coeff = <span class="number">-0.5</span> / (color_sigma * color_sigma);</span><br><span class="line">    <span class="keyword">int</span> radius = ksize / <span class="number">2</span>;</span><br><span class="line">    Mat temp;</span><br><span class="line">    copyMakeBorder(src, temp, radius, radius, radius, radius, BorderTypes::BORDER_REFLECT);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; _color_weight(channels * <span class="number">256</span>); <span class="comment">// 存放差值的平方</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; _space_weight(ksize * ksize); <span class="comment">// 空间模板系数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _space_ofs(ksize * ksize); <span class="comment">// 模板窗口的坐标</span></span><br><span class="line">    <span class="keyword">double</span> *color_weight = &amp;_color_weight[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">double</span> *space_weight = &amp;_space_weight[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span>    *space_ofs = &amp;_space_ofs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; channels * <span class="number">256</span>; i++)</span><br><span class="line">        color_weight[i] = <span class="built_in">exp</span>(i * i * color_coeff);</span><br><span class="line">    <span class="comment">// 生成空间模板</span></span><br><span class="line">    <span class="keyword">int</span> maxk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = -radius; i &lt;= radius; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = -radius; j &lt;= radius; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> r = <span class="built_in">sqrt</span>(i*i + j * j);</span><br><span class="line">            <span class="keyword">if</span> (r &gt; radius)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            space_weight[maxk] = <span class="built_in">exp</span>(r * r * space_coeff); <span class="comment">// 存放模板系数</span></span><br><span class="line">            space_ofs[maxk++] = i * temp.step + j * channels; <span class="comment">// 存放模板的位置，和模板系数相对应</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 滤波过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; src.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> uchar *sptr = temp.data + (i + radius) * temp.step + radius * channels;</span><br><span class="line">        uchar *dptr = dst.data + i * dst.step;</span><br><span class="line">        <span class="keyword">if</span> (channels == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.cols; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> sum = <span class="number">0</span>, wsum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> val0 = sptr[j]; <span class="comment">// 模板中心位置的像素</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; maxk; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> val = sptr[j + space_ofs[k]];</span><br><span class="line">                    <span class="keyword">double</span> w = space_weight[k] * color_weight[<span class="built_in">abs</span>(val - val0)]; <span class="comment">// 模板系数 = 空间系数 * 灰度值系数</span></span><br><span class="line">                    sum += val * w;</span><br><span class="line">                    wsum += w;</span><br><span class="line">                &#125;</span><br><span class="line">                dptr[j] = (uchar)cvRound(sum / wsum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (channels == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.cols * <span class="number">3</span>; j+=<span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> sum_b = <span class="number">0</span>, sum_g = <span class="number">0</span>, sum_r = <span class="number">0</span>, wsum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> b0 = sptr[j];</span><br><span class="line">                <span class="keyword">int</span> g0 = sptr[j + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> r0 = sptr[j + <span class="number">2</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; maxk; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">const</span> uchar *sptr_k = sptr + j + space_ofs[k];</span><br><span class="line">                    <span class="keyword">int</span> b = sptr_k[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> g = sptr_k[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">int</span> r = sptr_k[<span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">double</span> w = space_weight[k] * color_weight[<span class="built_in">abs</span>(b - b0) + <span class="built_in">abs</span>(g - g0) + <span class="built_in">abs</span>(r - r0)];</span><br><span class="line">                    sum_b += b * w;</span><br><span class="line">                    sum_g += g * w;</span><br><span class="line">                    sum_r += r * w;</span><br><span class="line">                    wsum += w;</span><br><span class="line">                &#125;</span><br><span class="line">                wsum = <span class="number">1.0f</span> / wsum;</span><br><span class="line">                b0 = cvRound(sum_b * wsum);</span><br><span class="line">                g0 = cvRound(sum_g * wsum);</span><br><span class="line">                r0 = cvRound(sum_r * wsum);</span><br><span class="line">                dptr[j] = (uchar)b0;</span><br><span class="line">                dptr[j + <span class="number">1</span>] = (uchar)g0;</span><br><span class="line">                dptr[j + <span class="number">2</span>] = (uchar)r0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="opencv-实现-双边滤波"><a href="#opencv-实现-双边滤波" class="headerlink" title="opencv 实现 双边滤波"></a>opencv 实现 双边滤波</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bilateralFilter</span><span class="params">( InputArray _src, OutputArray _dst, <span class="keyword">int</span> d,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">double</span> sigmaColor, <span class="keyword">double</span> sigmaSpace,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> borderType )</span></span></span><br></pre></td></tr></table></figure><blockquote><ul><li>InputArray src: 输入图像，可以是Mat类型，图像必须是8位或浮点型单通道、三通道的图像。 </li><li>OutputArray dst: 输出图像，和原图像有相同的尺寸和类型。 </li><li>int d: 表示在过滤过程中每个像素邻域的直径范围。如果这个值是非正数，则函数会从第五个参数sigmaSpace计算该值。 </li><li>double sigmaColor: 颜色空间过滤器的sigma值，这个参数的值月大，表明该像素邻域内有越宽广的颜色会被混合到一起，产生较大的半相等颜色区域。 （这个参数可以理解为值域核的）</li><li>double sigmaSpace: 坐标空间中滤波器的sigma值，如果该值较大，则意味着越远的像素将相互影响，从而使更大的区域中足够相似的颜色获取相同的颜色。当d&gt;0时，d指定了邻域大小且与sigmaSpace无关，否则d正比于sigmaSpace. （这个参数可以理解为空间域核的）</li><li>int borderType=BORDER_DEFAULT: 用于推断图像外部像素的某种边界模式，有默认值BORDER_DEFAULT.</li></ul></blockquote><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1589099909156.png" alt="双边滤波函数调用图"></p><h4 id="双边滤波算法对比"><a href="#双边滤波算法对比" class="headerlink" title="双边滤波算法对比"></a>双边滤波算法对比</h4><p>一开始的时候看双边滤波真的搞不懂,  也不知道这么做有什么目的, 最终的结果又代表什么, 我们按照之前的方法去测试我们的图像, 结果真的是几种算法中最差的了, 但是这只是说不适用于我们的图像结果, 在实际使用过程中还是要进行测试之后才能得出结论</p><p>测试结果如下: 对应原始图和 手动实现的结果以及 opencv 的结果 都使用的 是3 的窗口, sigma 的值 为 255<br>, 这篇文章<a href="https://blog.csdn.net/Jfuck/article/details/8932978" target="_blank" rel="noopener">https://blog.csdn.net/Jfuck/article/details/8932978</a>  讲的很好, 介绍了参数对滤波的影响, 可以学习一下..<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353</span><br><span class="line">image-noise: psnr:24.4502, mssim: B:0.538774 G:0.570666 R:0.776195</span><br><span class="line">image-noise: psnr:24.4691, mssim: B:0.539177 G:0.571087 R:0.776461</span><br></pre></td></tr></table></figure></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1589099909397.png" alt="双边滤波算法"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实个人使用双边滤波真的不算很多,  在之前研究导向滤波的时候才了解过很多, 这里写的比较差吧, 只能说勉强能看, 强烈推荐 <a href="https://www.cnblogs.com/wangguchangqing/category/740760.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangguchangqing/category/740760.html</a>  这个系列, 将的很详细, 很多都是博文里面的内容, 可以参考学习,  高斯滤波就比较简单了, 其实复杂的滤波过程主要是理解算法, 然后根据算法的思路进行代码的实现过程, 最后做一定的程序上的优化就好, 理解第一, 实现其次.. 希望带给读者一点点启发..</p><p>我这里一开始不准备写这么多的, 结果越写越多, 导致自己收不住了, 很多自己说不上很了解的地方, 这一次也是深入的了解了一下,  但是还是很僵硬, 只能说能用而已, 这里还是推荐看我给出的链接或者自己去查阅相关的内容, 我这里只是给出一个大略的介绍, 如果有错误还请指名, 十分感谢</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li>《快速高斯滤波、高斯模糊、高斯平滑(二维卷积分步为一维卷积)<em>人工智能</em>青城山小和尚-CSDN博客》. 见于 2020年5月10日. <a href="https://blog.csdn.net/qq_36359022/article/details/80188873" target="_blank" rel="noopener">https://blog.csdn.net/qq_36359022/article/details/80188873</a>.</li><li>《双边滤波 - 旗亭涉的博客 | Qitingshe Blog》. 见于 2020年5月10日. <a href="https://qitingshe.github.io/2018/06/14/%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2/" target="_blank" rel="noopener">https://qitingshe.github.io/2018/06/14/%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2/</a>.</li><li>《双边滤波（Bilateral Filter）详解_人工智能_Jfuck的专栏-CSDN博客》. 见于 2020年5月10日. <a href="https://blog.csdn.net/Jfuck/article/details/8932978" target="_blank" rel="noopener">https://blog.csdn.net/Jfuck/article/details/8932978</a>.</li><li>《雙邊濾波器》. 收入 维基百科，自由的百科全书, 2019年11月16日. <a href="https://zh.wikipedia.org/w/index.php?title=%E9%9B%99%E9%82%8A%E6%BF%BE%E6%B3%A2%E5%99%A8&amp;oldid=56898678" target="_blank" rel="noopener">https://zh.wikipedia.org/w/index.php?title=%E9%9B%99%E9%82%8A%E6%BF%BE%E6%B3%A2%E5%99%A8&amp;oldid=56898678</a>.</li><li>《图像处理–高斯滤波_网络_L-inYi的专栏-CSDN博客》. 见于 2020年5月10日. <a href="https://blog.csdn.net/L_inYi/article/details/8915116" target="_blank" rel="noopener">https://blog.csdn.net/L_inYi/article/details/8915116</a>.</li><li>《图像处理基础(4)：高斯滤波器详解 - Brook_icv - 博客园》. 见于 2020年5月10日. <a href="https://www.cnblogs.com/wangguchangqing/p/6407717.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangguchangqing/p/6407717.html</a>.</li><li>《图像处理基础(5)：双边滤波器 - Brook_icv - 博客园》. 见于 2020年5月10日. <a href="https://www.cnblogs.com/wangguchangqing/p/6416401.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangguchangqing/p/6416401.html</a>.</li><li>《图像处理－线性滤波－3 高斯滤波器 - Tony Ma - 博客园》. 见于 2020年5月10日. <a href="https://www.cnblogs.com/pegasus/archive/2011/05/20/2052031.html" target="_blank" rel="noopener">https://www.cnblogs.com/pegasus/archive/2011/05/20/2052031.html</a>.</li><li>《【转】高斯图像滤波原理及其编程离散化实现方法_Smile_Gogo_新浪博客》. 见于 2020年5月10日. <a href="http://blog.sina.com.cn/s/blog_640577ed0100yz8v.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_640577ed0100yz8v.html</a>.</li><li>《bilateral filter双边滤波器的通俗理解_网络_pan_jinquan的博客-CSDN博客》. 见于 2020年5月10日. <a href="https://blog.csdn.net/guyuealian/article/details/82660826" target="_blank" rel="noopener">https://blog.csdn.net/guyuealian/article/details/82660826</a>.</li><li>《Bilateral Filtering》. 见于 2020年5月10日. <a href="http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html" target="_blank" rel="noopener">http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html</a>.</li><li>《Cv图像处理 - OpenCV China ：图像处理,计算机视觉库,Image Processing, Computer Vision》. 见于 2020年5月10日. <a href="http://wiki.opencv.org.cn/index.php/Cv%e5%9b%be%e5%83%8f%e5%a4%84%e7%90%86" target="_blank" rel="noopener">http://wiki.opencv.org.cn/index.php/Cv%e5%9b%be%e5%83%8f%e5%a4%84%e7%90%86</a>.</li><li>《o(1)复杂度之双边滤波算法的原理、流程、实现及效果。 - 云+社区 - 腾讯云》. 见于 2020年5月10日. <a href="https://cloud.tencent.com/developer/article/1011738" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1011738</a>.</li></ol><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; title=&quot;开始之前&quot;&gt;&lt;/a&gt;开始之前&lt;/h2&gt;&lt;p&gt;这几天由于自己的原因没有写, 一个是因为自己懒了, 一个是感觉这里遇到点问题不想往下写了, 我们先努力结束这个章节吧, 之前介绍了比较常用而且比较好理解的均值和中值滤波,  但是呢,在例程&lt;a href=&quot;https://docs.opencv.org/4.3.0/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Smoothing Images&lt;/a&gt;, 还有给出的其他的滤波方式, 主要是高斯滤波和双边滤波,&lt;/p&gt;
&lt;p&gt;我们这一次完结掉滤波与平滑的这个部分, 写的有点多了,反而不想再写了, 加油&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;本文目标&quot;&gt;&lt;a href=&quot;#本文目标&quot; class=&quot;headerlink&quot; title=&quot;本文目标&quot;&gt;&lt;/a&gt;本文目标&lt;/h2&gt;&lt;p&gt;本文主要是介绍&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高斯滤波&lt;/li&gt;
&lt;li&gt;双边滤波&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;和之前介绍的一样, 我们仍然还是 介绍一下原理, 给出一下具体的形式, 然后使用 opencv 进行一下实现的过程, 最后使用我们之前的图像进行测试 进行算法的分析与总结.&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;h3 id=&quot;高斯滤波-Gaussian-Filter&quot;&gt;&lt;a href=&quot;#高斯滤波-Gaussian-Filter&quot; class=&quot;headerlink&quot; title=&quot;高斯滤波(Gaussian Filter)&quot;&gt;&lt;/a&gt;高斯滤波(Gaussian Filter)&lt;/h3&gt;&lt;p&gt;我们在之前介绍了中值滤波是统计排序的结果, 属于非线性的结果, 均值滤波是使用模板核进行的操作, 我们在的文章中也提到了均值滤波在计算的过程中必须要考虑权重的问题, 进而提出了加权的均值滤波的操作, 比如最常见的加权均值滤波的操作核.&lt;br&gt;$$&lt;br&gt;M = \frac{1}{16} \left [&lt;br&gt;        \begin{array}{c}&lt;br&gt;            1 &amp;amp; 2 &amp;amp; 1 \ 2&amp;amp; 4 &amp;amp; 2 \ 1 &amp;amp; 2 &amp;amp; 1&lt;br&gt;        \end{array}&lt;br&gt;\right ]&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;其实呢,这个核也就是高斯滤波器在 &lt;code&gt;3*3&lt;/code&gt;窗口的离散取整的结果值, 最明显的特点就是模板的系数随着距离模板中心的距离而变换, 能够有效的抑制噪声,平滑图像, 相比均值滤波能够更好的平滑图像, 保留图像边缘. &lt;/p&gt;
&lt;h4 id=&quot;高斯滤波原理&quot;&gt;&lt;a href=&quot;#高斯滤波原理&quot; class=&quot;headerlink&quot; title=&quot;高斯滤波原理&quot;&gt;&lt;/a&gt;高斯滤波原理&lt;/h4&gt;&lt;p&gt;由于我们的图像是二维的, 但是高斯分布是一维的, 那我们先考虑一维的高斯分布, 就是我们常用的正太分布曲线,&lt;br&gt;$$&lt;br&gt;G(x) = \frac{1}{\sqrt{2\pi \sigma}} e^{-\frac{x^2}{2\sigma^2}}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1589099908842.png&quot; alt=&quot;一维高斯分布&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于二维的高斯分布其实可以考虑成两个方向的运算相叠加的得到的结果&lt;br&gt;$$&lt;br&gt;G(x,y) = \frac{1}{2\pi \sigma^2} e^{-\frac{x^2+y^2}{2\sigma^2}} = G(x)*G(y)&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1589099908844.png&quot; alt=&quot;二维高斯分布&quot;&gt;&lt;/p&gt;
&lt;p&gt;考虑到图像的计算实际上是离散的座标, 对于窗口大小为 $(2k + 1) \times (2k + 1)$ 模板, 我们可以表示成&lt;br&gt;$$&lt;br&gt;G{i,j} = \frac{1}{2\pi \sigma ^ 2}e ^{-\frac{(i - k - 1)^2 + (j - k - 1)^2}{2 \sigma ^ 2}}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;可以参考&lt;a href=&quot;https://www.cnblogs.com/wangguchangqing/p/6407717.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图像处理基础(4)：高斯滤波器详解&lt;/a&gt;&lt;br&gt;里面给出的方法, 使用&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;108&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;109&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;112&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;113&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;114&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;115&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;116&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;117&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;118&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;119&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;120&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;122&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;124&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;125&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;126&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;127&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;generateGaussianTemplate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; window[][&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;], &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ksize, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sigma)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; pi = &lt;span class=&quot;number&quot;&gt;3.1415926&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; center = ksize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 模板的中心位置，也就是坐标的原点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; x2, y2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; ksize; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        x2 = &lt;span class=&quot;built_in&quot;&gt;pow&lt;/span&gt;(i - center, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; ksize; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            y2 = &lt;span class=&quot;built_in&quot;&gt;pow&lt;/span&gt;(j - center, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; g = &lt;span class=&quot;built_in&quot;&gt;exp&lt;/span&gt;(-(x2 + y2) / (&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * sigma * sigma));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            g /= &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * pi * sigma*sigma;	&lt;span class=&quot;comment&quot;&gt;// &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            window[i][j] = g;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; / window[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]; &lt;span class=&quot;comment&quot;&gt;// 将左上角的系数归一化为1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; ksize; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; ksize; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            window[i][j] *= k;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;``` &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;生成了$&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; \times &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, \sigma = &lt;span class=&quot;number&quot;&gt;0.8&lt;/span&gt;$ 的高斯模板, 对应的将其取整就得到了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$$&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M = \frac&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;&amp;#123;&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;&amp;#125; \left [ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        \begin&amp;#123;&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;&amp;#125;&amp;#123;c&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;amp; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &amp;amp; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; \\ &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;amp; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &amp;amp; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; \\ &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;amp; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &amp;amp; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        \end&amp;#123;&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\right ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$$&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;上面给出的文章同样的详细介绍了 $\sigma$ 在统计学中的意义, 可以去参考学习&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;不过根据高中的知识, 我们可以看到 正态分布的曲线&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;![正态分布曲线](https:&lt;span class=&quot;comment&quot;&gt;//gitee.com/schen00/BlogImage/raw/master/image/1589099908845.png)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### C++ 实现&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在我们之前提到的[图像处理基础(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)：高斯滤波器详解](https:&lt;span class=&quot;comment&quot;&gt;//www.cnblogs.com/wangguchangqing/p/6407717.html) 这里给出了基于 opencv 的代码实现, 这里是$O(m*n*k^2)$ 的算法实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;```cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 来源链接: https://www.cnblogs.com/wangguchangqing/p/6407717.html&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; GaussianFilter(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Mat &amp;amp;src, Mat &amp;amp;dst, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ksize, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sigma)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CV_Assert(src.channels() || src.channels() == &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 只处理单通道或者三通道图像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; pi = &lt;span class=&quot;number&quot;&gt;3.1415926&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 根据窗口大小和sigma生成高斯滤波器模板&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 申请一个二维数组，存放生成的高斯模板矩阵&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; **templateMatrix = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;*[ksize];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; ksize; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        templateMatrix[i] = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;[ksize];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; origin = ksize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 以模板的中心为原点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; x2, y2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; ksize; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        x2 = &lt;span class=&quot;built_in&quot;&gt;pow&lt;/span&gt;(i - origin, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; ksize; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            y2 = &lt;span class=&quot;built_in&quot;&gt;pow&lt;/span&gt;(j - origin, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 高斯函数前的常数可以不用计算，会在归一化的过程中给消去&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; g = &lt;span class=&quot;built_in&quot;&gt;exp&lt;/span&gt;(-(x2 + y2) / (&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * sigma * sigma));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            sum += g;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            templateMatrix[i][j] = g;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; ksize; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; ksize; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            templateMatrix[i][j] /= sum;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; templateMatrix[i][j] &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot; &quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将模板应用到图像中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; border = ksize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    copyMakeBorder(src, dst, border, border, border, border, BorderTypes::BORDER_REFLECT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; channels = dst.channels();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; rows = dst.rows - border;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; cols = dst.cols - border;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = border; i &amp;lt; rows; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = border; j &amp;lt; cols; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sum[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] = &amp;#123; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = -border; a &amp;lt;= border; a++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b = -border; b &amp;lt;= border; b++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (channels == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        sum[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] += templateMatrix[border + a][border + b] * dst.at&amp;lt;uchar&amp;gt;(i + a, j + b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (channels == &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        Vec3b rgb = dst.at&amp;lt;Vec3b&amp;gt;(i + a, j + b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; k = templateMatrix[border + a][border + b];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        sum[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] += k * rgb[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        sum[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] += k * rgb[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        sum[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] += k * rgb[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; k &amp;lt; channels; k++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sum[k] &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    sum[k] = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sum[k] &amp;gt; &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    sum[k] = &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (channels == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                dst.at&amp;lt;uchar&amp;gt;(i, j) = &lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;uchar&amp;gt;(sum[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (channels == &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Vec3b rgb = &amp;#123; &lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;uchar&amp;gt;(sum[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]), &lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;uchar&amp;gt;(sum[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]), &lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;uchar&amp;gt;(sum[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]) &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                dst.at&amp;lt;Vec3b&amp;gt;(i, j) = rgb;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 释放模板数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; ksize; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;delete&lt;/span&gt;[] templateMatrix[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;delete&lt;/span&gt;[] templateMatrix;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;然后同样的给出了分离的实现, 将图像进行水平运算之后再进行竖直运算, 计算的时间上会有一定的速度提升&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 来源链接: https://www.cnblogs.com/wangguchangqing/p/6407717.html&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 分离的计算&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;separateGaussianFilter&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Mat &amp;amp;src, Mat &amp;amp;dst, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ksize, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sigma)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CV_Assert(src.channels()==&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; || src.channels() == &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 只处理单通道或者三通道图像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 生成一维的高斯滤波模板&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; *matrix = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;[ksize];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; origin = ksize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; ksize; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 高斯函数前的常数可以不用计算，会在归一化的过程中给消去&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; g = &lt;span class=&quot;built_in&quot;&gt;exp&lt;/span&gt;(-(i - origin) * (i - origin) / (&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * sigma * sigma));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sum += g;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        matrix[i] = g;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 归一化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; ksize; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        matrix[i] /= sum;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将模板应用到图像中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; border = ksize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    copyMakeBorder(src, dst, border, border, border, border, BorderTypes::BORDER_REFLECT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; channels = dst.channels();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; rows = dst.rows - border;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; cols = dst.cols - border;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 水平方向&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = border; i &amp;lt; rows; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = border; j &amp;lt; cols; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sum[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] = &amp;#123; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k = -border; k &amp;lt;= border; k++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (channels == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    sum[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] += matrix[border + k] * dst.at&amp;lt;uchar&amp;gt;(i, j + k); &lt;span class=&quot;comment&quot;&gt;// 行不变，列变化；先做水平方向的卷积&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (channels == &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    Vec3b rgb = dst.at&amp;lt;Vec3b&amp;gt;(i, j + k);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    sum[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] += matrix[border + k] * rgb[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    sum[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] += matrix[border + k] * rgb[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    sum[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] += matrix[border + k] * rgb[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; k &amp;lt; channels; k++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sum[k] &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    sum[k] = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sum[k] &amp;gt; &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    sum[k] = &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (channels == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                dst.at&amp;lt;uchar&amp;gt;(i, j) = &lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;uchar&amp;gt;(sum[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (channels == &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Vec3b rgb = &amp;#123; &lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;uchar&amp;gt;(sum[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]), &lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;uchar&amp;gt;(sum[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]), &lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;uchar&amp;gt;(sum[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]) &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                dst.at&amp;lt;Vec3b&amp;gt;(i, j) = rgb;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 竖直方向&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = border; i &amp;lt; rows; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = border; j &amp;lt; cols; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sum[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] = &amp;#123; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k = -border; k &amp;lt;= border; k++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (channels == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    sum[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] += matrix[border + k] * dst.at&amp;lt;uchar&amp;gt;(i + k, j); &lt;span class=&quot;comment&quot;&gt;// 列不变，行变化；竖直方向的卷积&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (channels == &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    Vec3b rgb = dst.at&amp;lt;Vec3b&amp;gt;(i + k, j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    sum[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] += matrix[border + k] * rgb[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    sum[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] += matrix[border + k] * rgb[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    sum[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] += matrix[border + k] * rgb[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; k &amp;lt; channels; k++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sum[k] &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    sum[k] = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sum[k] &amp;gt; &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    sum[k] = &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (channels == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                dst.at&amp;lt;uchar&amp;gt;(i, j) = &lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;uchar&amp;gt;(sum[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (channels == &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Vec3b rgb = &amp;#123; &lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;uchar&amp;gt;(sum[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]), &lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;uchar&amp;gt;(sum[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]), &lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;uchar&amp;gt;(sum[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]) &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                dst.at&amp;lt;Vec3b&amp;gt;(i, j) = rgb;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;delete&lt;/span&gt;[] matrix;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里的算法都是 上面提到的&lt;a href=&quot;https://www.cnblogs.com/wangguchangqing/p/6407717.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/wangguchangqing/p/6407717.html&lt;/a&gt;  这篇文章, 具体可以去看内容&lt;/p&gt;
&lt;h4 id=&quot;opencv-高斯滤波&quot;&gt;&lt;a href=&quot;#opencv-高斯滤波&quot; class=&quot;headerlink&quot; title=&quot;opencv 高斯滤波&quot;&gt;&lt;/a&gt;opencv 高斯滤波&lt;/h4&gt;&lt;p&gt;其实这篇文章&lt;a href=&quot;https://blog.csdn.net/L_inYi/article/details/8915116&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图像处理–高斯滤波&lt;/a&gt;写的很好&lt;br&gt;其实主要的结构也就是他给出的过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1589099909152.png&quot; alt=&quot;高斯函数调用图&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1589099908858.png&quot; alt=&quot;高斯滤波函数调用简图&quot;&gt;&lt;/p&gt;
&lt;p&gt;其实整个高斯滤波的过程就是创建高斯核, 然后使用 filter2D 的方法进行的滤波操作, 具体要深入的话可以看函数的调用图, 实现起来也是一样的思路, 很简单的操作, 我们之后测试一下效果..&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// /modules\imgproc\src\smooth.dispatch.cpp:600&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GaussianBlur&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(InputArray _src, OutputArray _dst, Size ksize,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                  &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sigma1, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sigma2,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; borderType)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;src    ‪输入图像&lt;/li&gt;
&lt;li&gt;dst    输出图像&lt;/li&gt;
&lt;li&gt;ksize    核的尺寸 奇数&lt;/li&gt;
&lt;li&gt;sigmaX    x 方向 的 sigma 值&lt;/li&gt;
&lt;li&gt;sigmaY    ‪y 方向 的 sigma 值&lt;/li&gt;
&lt;li&gt;borderType    边界处理的方式&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;高斯滤波效果对比&quot;&gt;&lt;a href=&quot;#高斯滤波效果对比&quot; class=&quot;headerlink&quot; title=&quot;高斯滤波效果对比&quot;&gt;&lt;/a&gt;高斯滤波效果对比&lt;/h4&gt;&lt;p&gt;我们还是使用之前的高椒盐噪声图像, 然后直接进行算法滤波, 计算结果就好, 跟之前的测试图像很相似, 这里&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./images/1589100238500.png&quot; alt=&quot;测试结果图&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里的四张图分别对应 高噪声图像, 直接高斯滤波的结果, 分离xy方向进行滤波结果,以及opencv 自带的高斯滤波效果图, 这里是预览图像, 实际的检测结果就是上面给出的参数值, 实际上效果只能说一般, 我们之后再进行算法层面的对比.&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image-noise: psnr:26.3155, mssim: B:0.584585 G:0.617172 R:0.812303&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image-noise: psnr:26.1721, mssim: B:0.574719 G:0.607494 R:0.809844&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image-noise: psnr:26.4206, mssim: B:0.598176 G:0.630657 R:0.819658&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;双边滤波-Bilateral-Filter&quot;&gt;&lt;a href=&quot;#双边滤波-Bilateral-Filter&quot; class=&quot;headerlink&quot; title=&quot;双边滤波(Bilateral Filter)&quot;&gt;&lt;/a&gt;双边滤波(Bilateral Filter)&lt;/h3&gt;&lt;h4 id=&quot;双边滤波原理&quot;&gt;&lt;a href=&quot;#双边滤波原理&quot; class=&quot;headerlink&quot; title=&quot;双边滤波原理&quot;&gt;&lt;/a&gt;双边滤波原理&lt;/h4&gt;&lt;p&gt;我们在上面提出了高斯滤波的原理是对于距离模板中心 距离不同给予不同的权重, 而双边滤波则不仅考虑图像的空间距离, 还要考虑其灰度距离, 对于越接近中间灰度值的点权重越高, 灰度值相差大的则权重更小.&lt;/p&gt;
&lt;p&gt;双边滤波的原理可以参考&lt;a href=&quot;https://blog.csdn.net/Jfuck/article/details/8932978&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;双边滤波（Bilateral Filter）详解&lt;/a&gt;,&lt;br&gt;可以参考&lt;a href=&quot;http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bilateral Filtering for Gray and Color Images&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1589099908862.png&quot; alt=&quot;双边滤波原理&quot;&gt;&lt;/p&gt;
&lt;p&gt;在文章&lt;a href=&quot;https://www.cnblogs.com/wangguchangqing/p/6416401.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图像处理基础(5)：双边滤波器&lt;/a&gt;详细介绍了双边滤波&lt;br&gt;其实跟上面给出的滤波演示一致, 都是在保证图像边缘信息的情况下进行噪声的滤波..&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1589099909153.png&quot; alt=&quot;双边滤波原理&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以参考&lt;a href=&quot;https://blog.csdn.net/guyuealian/article/details/82660826&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;bilateral filter双边滤波器的通俗理解&lt;/a&gt; 给出的双边滤波的数学表达&lt;br&gt;$$&lt;br&gt;g(x,y) = \frac{\sum_{kl}f(k,l)w(i,j,k,l)}{\sum_{kl}w(i,j,k,l)}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;对于不同的模板系数又有两个部分, 主要是 空间域模板权值 $w_d$ 和 灰度域 模板权值 $w_r$,&lt;br&gt;$$&lt;br&gt;\begin{array}{rl}&lt;br&gt;w_d(i,j,k,l) &amp;amp;= e^{-\frac{(i-k)^2 +(j-l)^2}{2\sigma_d^2}} \&lt;br&gt;w_r(i,j,k,l) &amp;amp;= e^{-\frac{\left | f(i,j) - f(k,l) \right |} {2\sigma_r^2}}  \&lt;br&gt;w &amp;amp;= w_d * w_r&lt;br&gt;\end{array}&lt;br&gt;$$&lt;br&gt; 其中，$q(i,j)$ 为模板窗口的其他系数的坐标，$f(i,j)$ 表示图像在点$q(i,j)$ 处的像素值；$p(k,l)$ 为模板窗口的中心坐标点，对应的像素值为$f(k,l)$ ；$\sigma_r$ 为高斯函数的标准差。&lt;/p&gt;
&lt;h4 id=&quot;C-实现-双边滤波&quot;&gt;&lt;a href=&quot;#C-实现-双边滤波&quot; class=&quot;headerlink&quot; title=&quot;C++ 实现 双边滤波&quot;&gt;&lt;/a&gt;C++ 实现 双边滤波&lt;/h4&gt;&lt;p&gt;感觉这里写的挺好的 &lt;a href=&quot;https://www.cnblogs.com/wangguchangqing/p/6416401.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图像处理基础(5)：双边滤波器&lt;/a&gt;, 手动实现了双边滤波, 我们可以详细的参考, 这里&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 参考来源: https://www.cnblogs.com/wangguchangqing/p/6416401.html&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;myBilateralFilter&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Mat &amp;amp;src, Mat &amp;amp;dst, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ksize, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; space_sigma, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; color_sigma)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; channels = src.channels();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CV_Assert(channels == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; || channels == &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; space_coeff = &lt;span class=&quot;number&quot;&gt;-0.5&lt;/span&gt; / (space_sigma * space_sigma);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; color_coeff = &lt;span class=&quot;number&quot;&gt;-0.5&lt;/span&gt; / (color_sigma * color_sigma);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; radius = ksize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Mat temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    copyMakeBorder(src, temp, radius, radius, radius, radius, BorderTypes::BORDER_REFLECT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;&amp;gt; _color_weight(channels * &lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 存放差值的平方&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;&amp;gt; _space_weight(ksize * ksize); &lt;span class=&quot;comment&quot;&gt;// 空间模板系数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; _space_ofs(ksize * ksize); &lt;span class=&quot;comment&quot;&gt;// 模板窗口的坐标&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; *color_weight = &amp;amp;_color_weight[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; *space_weight = &amp;amp;_space_weight[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;    *space_ofs = &amp;amp;_space_ofs[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; channels * &lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        color_weight[i] = &lt;span class=&quot;built_in&quot;&gt;exp&lt;/span&gt;(i * i * color_coeff);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 生成空间模板&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxk = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = -radius; i &amp;lt;= radius; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = -radius; j &amp;lt;= radius; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; r = &lt;span class=&quot;built_in&quot;&gt;sqrt&lt;/span&gt;(i*i + j * j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (r &amp;gt; radius)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            space_weight[maxk] = &lt;span class=&quot;built_in&quot;&gt;exp&lt;/span&gt;(r * r * space_coeff); &lt;span class=&quot;comment&quot;&gt;// 存放模板系数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            space_ofs[maxk++] = i * temp.step + j * channels; &lt;span class=&quot;comment&quot;&gt;// 存放模板的位置，和模板系数相对应&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 滤波过程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; src.rows; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; uchar *sptr = temp.data + (i + radius) * temp.step + radius * channels;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        uchar *dptr = dst.data + i * dst.step;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (channels == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; src.cols; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, wsum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; val0 = sptr[j]; &lt;span class=&quot;comment&quot;&gt;// 模板中心位置的像素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; k &amp;lt; maxk; k++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; val = sptr[j + space_ofs[k]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; w = space_weight[k] * color_weight[&lt;span class=&quot;built_in&quot;&gt;abs&lt;/span&gt;(val - val0)]; &lt;span class=&quot;comment&quot;&gt;// 模板系数 = 空间系数 * 灰度值系数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    sum += val * w;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    wsum += w;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                dptr[j] = (uchar)cvRound(sum / wsum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (channels == &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; src.cols * &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;; j+=&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sum_b = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, sum_g = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, sum_r = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, wsum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b0 = sptr[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; g0 = sptr[j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; r0 = sptr[j + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; k &amp;lt; maxk; k++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; uchar *sptr_k = sptr + j + space_ofs[k];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b = sptr_k[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; g = sptr_k[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; r = sptr_k[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; w = space_weight[k] * color_weight[&lt;span class=&quot;built_in&quot;&gt;abs&lt;/span&gt;(b - b0) + &lt;span class=&quot;built_in&quot;&gt;abs&lt;/span&gt;(g - g0) + &lt;span class=&quot;built_in&quot;&gt;abs&lt;/span&gt;(r - r0)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    sum_b += b * w;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    sum_g += g * w;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    sum_r += r * w;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    wsum += w;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                wsum = &lt;span class=&quot;number&quot;&gt;1.0f&lt;/span&gt; / wsum;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                b0 = cvRound(sum_b * wsum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                g0 = cvRound(sum_g * wsum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                r0 = cvRound(sum_r * wsum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                dptr[j] = (uchar)b0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                dptr[j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = (uchar)g0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                dptr[j + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] = (uchar)r0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;opencv-实现-双边滤波&quot;&gt;&lt;a href=&quot;#opencv-实现-双边滤波&quot; class=&quot;headerlink&quot; title=&quot;opencv 实现 双边滤波&quot;&gt;&lt;/a&gt;opencv 实现 双边滤波&lt;/h4&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bilateralFilter&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( InputArray _src, OutputArray _dst, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; d,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                      &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sigmaColor, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sigmaSpace,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                      &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; borderType )&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;InputArray src: 输入图像，可以是Mat类型，图像必须是8位或浮点型单通道、三通道的图像。 &lt;/li&gt;
&lt;li&gt;OutputArray dst: 输出图像，和原图像有相同的尺寸和类型。 &lt;/li&gt;
&lt;li&gt;int d: 表示在过滤过程中每个像素邻域的直径范围。如果这个值是非正数，则函数会从第五个参数sigmaSpace计算该值。 &lt;/li&gt;
&lt;li&gt;double sigmaColor: 颜色空间过滤器的sigma值，这个参数的值月大，表明该像素邻域内有越宽广的颜色会被混合到一起，产生较大的半相等颜色区域。 （这个参数可以理解为值域核的）&lt;/li&gt;
&lt;li&gt;double sigmaSpace: 坐标空间中滤波器的sigma值，如果该值较大，则意味着越远的像素将相互影响，从而使更大的区域中足够相似的颜色获取相同的颜色。当d&amp;gt;0时，d指定了邻域大小且与sigmaSpace无关，否则d正比于sigmaSpace. （这个参数可以理解为空间域核的）&lt;/li&gt;
&lt;li&gt;int borderType=BORDER_DEFAULT: 用于推断图像外部像素的某种边界模式，有默认值BORDER_DEFAULT.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1589099909156.png&quot; alt=&quot;双边滤波函数调用图&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;双边滤波算法对比&quot;&gt;&lt;a href=&quot;#双边滤波算法对比&quot; class=&quot;headerlink&quot; title=&quot;双边滤波算法对比&quot;&gt;&lt;/a&gt;双边滤波算法对比&lt;/h4&gt;&lt;p&gt;一开始的时候看双边滤波真的搞不懂,  也不知道这么做有什么目的, 最终的结果又代表什么, 我们按照之前的方法去测试我们的图像, 结果真的是几种算法中最差的了, 但是这只是说不适用于我们的图像结果, 在实际使用过程中还是要进行测试之后才能得出结论&lt;/p&gt;
&lt;p&gt;测试结果如下: 对应原始图和 手动实现的结果以及 opencv 的结果 都使用的 是3 的窗口, sigma 的值 为 255&lt;br&gt;, 这篇文章&lt;a href=&quot;https://blog.csdn.net/Jfuck/article/details/8932978&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/Jfuck/article/details/8932978&lt;/a&gt;  讲的很好, 介绍了参数对滤波的影响, 可以学习一下..&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image-noise: psnr:24.4502, mssim: B:0.538774 G:0.570666 R:0.776195&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image-noise: psnr:24.4691, mssim: B:0.539177 G:0.571087 R:0.776461&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1589099909397.png&quot; alt=&quot;双边滤波算法&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;其实个人使用双边滤波真的不算很多,  在之前研究导向滤波的时候才了解过很多, 这里写的比较差吧, 只能说勉强能看, 强烈推荐 &lt;a href=&quot;https://www.cnblogs.com/wangguchangqing/category/740760.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/wangguchangqing/category/740760.html&lt;/a&gt;  这个系列, 将的很详细, 很多都是博文里面的内容, 可以参考学习,  高斯滤波就比较简单了, 其实复杂的滤波过程主要是理解算法, 然后根据算法的思路进行代码的实现过程, 最后做一定的程序上的优化就好, 理解第一, 实现其次.. 希望带给读者一点点启发..&lt;/p&gt;
&lt;p&gt;我这里一开始不准备写这么多的, 结果越写越多, 导致自己收不住了, 很多自己说不上很了解的地方, 这一次也是深入的了解了一下,  但是还是很僵硬, 只能说能用而已, 这里还是推荐看我给出的链接或者自己去查阅相关的内容, 我这里只是给出一个大略的介绍, 如果有错误还请指名, 十分感谢&lt;/p&gt;
&lt;h2 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;headerlink&quot; title=&quot;参考链接&quot;&gt;&lt;/a&gt;参考链接&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;《快速高斯滤波、高斯模糊、高斯平滑(二维卷积分步为一维卷积)&lt;em&gt;人工智能&lt;/em&gt;青城山小和尚-CSDN博客》. 见于 2020年5月10日. &lt;a href=&quot;https://blog.csdn.net/qq_36359022/article/details/80188873&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_36359022/article/details/80188873&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《双边滤波 - 旗亭涉的博客 | Qitingshe Blog》. 见于 2020年5月10日. &lt;a href=&quot;https://qitingshe.github.io/2018/06/14/%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://qitingshe.github.io/2018/06/14/%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2/&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《双边滤波（Bilateral Filter）详解_人工智能_Jfuck的专栏-CSDN博客》. 见于 2020年5月10日. &lt;a href=&quot;https://blog.csdn.net/Jfuck/article/details/8932978&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/Jfuck/article/details/8932978&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《雙邊濾波器》. 收入 维基百科，自由的百科全书, 2019年11月16日. &lt;a href=&quot;https://zh.wikipedia.org/w/index.php?title=%E9%9B%99%E9%82%8A%E6%BF%BE%E6%B3%A2%E5%99%A8&amp;amp;oldid=56898678&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.wikipedia.org/w/index.php?title=%E9%9B%99%E9%82%8A%E6%BF%BE%E6%B3%A2%E5%99%A8&amp;amp;oldid=56898678&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《图像处理–高斯滤波_网络_L-inYi的专栏-CSDN博客》. 见于 2020年5月10日. &lt;a href=&quot;https://blog.csdn.net/L_inYi/article/details/8915116&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/L_inYi/article/details/8915116&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《图像处理基础(4)：高斯滤波器详解 - Brook_icv - 博客园》. 见于 2020年5月10日. &lt;a href=&quot;https://www.cnblogs.com/wangguchangqing/p/6407717.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/wangguchangqing/p/6407717.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《图像处理基础(5)：双边滤波器 - Brook_icv - 博客园》. 见于 2020年5月10日. &lt;a href=&quot;https://www.cnblogs.com/wangguchangqing/p/6416401.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/wangguchangqing/p/6416401.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《图像处理－线性滤波－3 高斯滤波器 - Tony Ma - 博客园》. 见于 2020年5月10日. &lt;a href=&quot;https://www.cnblogs.com/pegasus/archive/2011/05/20/2052031.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/pegasus/archive/2011/05/20/2052031.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《【转】高斯图像滤波原理及其编程离散化实现方法_Smile_Gogo_新浪博客》. 见于 2020年5月10日. &lt;a href=&quot;http://blog.sina.com.cn/s/blog_640577ed0100yz8v.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.sina.com.cn/s/blog_640577ed0100yz8v.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《bilateral filter双边滤波器的通俗理解_网络_pan_jinquan的博客-CSDN博客》. 见于 2020年5月10日. &lt;a href=&quot;https://blog.csdn.net/guyuealian/article/details/82660826&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/guyuealian/article/details/82660826&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《Bilateral Filtering》. 见于 2020年5月10日. &lt;a href=&quot;http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《Cv图像处理 - OpenCV China ：图像处理,计算机视觉库,Image Processing, Computer Vision》. 见于 2020年5月10日. &lt;a href=&quot;http://wiki.opencv.org.cn/index.php/Cv%e5%9b%be%e5%83%8f%e5%a4%84%e7%90%86&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://wiki.opencv.org.cn/index.php/Cv%e5%9b%be%e5%83%8f%e5%a4%84%e7%90%86&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《o(1)复杂度之双边滤波算法的原理、流程、实现及效果。 - 云+社区 - 腾讯云》. 见于 2020年5月10日. &lt;a href=&quot;https://cloud.tencent.com/developer/article/1011738&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cloud.tencent.com/developer/article/1011738&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="opencv" scheme="https://schen1024.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://schen1024.github.io/tags/opencv/"/>
    
      <category term="c++" scheme="https://schen1024.github.io/tags/c/"/>
    
      <category term="qt" scheme="https://schen1024.github.io/tags/qt/"/>
    
  </entry>
  
  <entry>
    <title>opencv-11-中值滤波及自适应中值滤波</title>
    <link href="https://schen1024.github.io/2020/05-02/opencv-11-%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2.html"/>
    <id>https://schen1024.github.io/2020/05-02/opencv-11-%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2.html</id>
    <published>2020-05-02T14:37:12.000Z</published>
    <updated>2023-01-01T13:25:24.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>在上一篇我们实现了读取噪声图像, 然后 进行三种形式的均值滤波得到结果, 由于我们自己写的均值滤波未作边缘处理, 所以效果有一定的下降, 但是总体来说, 我们得到的结果能够说明我们的算法执行之后得到的图像噪声更低, 图像更清晰. 但是也会造成图像的模糊, 导致部分细节丢失. 在这一章中,我们介绍一下中值滤波及其实现</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>首先介绍了中值滤波的原理, 给出其实现思路,并根据思路实现了 C++ 的代码, 然后 同样测试 opencv 自带的中值滤波, 同样的测试图像, 得到对比结果, 分析代码的实现过程, .</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="中值滤波原理"><a href="#中值滤波原理" class="headerlink" title="中值滤波原理"></a>中值滤波原理</h3><p>中值滤波(Media Filter)就是对于图像的每一个点计算其邻域窗口的像素序列中值, 可以表示为:<br>$$<br>g(x,y) = meida_{(i,j) \in S}f(i,j)<br>$$<br>核心就是将相应窗口内的像素值进行排列, 我们之前也说过, 我们选择的窗口为奇数尺寸, 所以我们能够保证窗口内的像素个数也是奇数个, 这样我们可以保证取得唯一的中值, 相应的设置为该点的目标值就行了.</p><h3 id="C-实现中值滤波"><a href="#C-实现中值滤波" class="headerlink" title="C++ 实现中值滤波"></a>C++ 实现中值滤波</h3><p>我们来实现一下, 这方面还是能够找到不少结果的, 感觉这个博主写的还是很不错的,有兴趣的可以看下<a href="https://www.cnblogs.com/ranjiewen/p/5699395.html" target="_blank" rel="noopener">数字图像处理——中值滤波</a>,还有<a href="https://www.cnblogs.com/qiqibaby/p/5281743.html" target="_blank" rel="noopener">图像处理之中值滤波介绍及C实现</a>, 或者 <a href="https://blog.csdn.net/liyuanbhu/article/details/48502005" target="_blank" rel="noopener">中值滤波器（Median filter）特性及其实现</a>, 这里我就不再造轮子了, 我们来看下 C++的实现<br>, 主要参考 第一篇文章, 可以看下效果</p><p>这里有一点点需要讨论的, 对于彩色图像的三个通道怎么处理, 自己的思路就是分成三个通道进行处理, 然后分别得到三个图之后进行合并三个通道, 得到结果图像.   查了下 目测大家都是这么做的, 可以看<a href="https://blog.csdn.net/cyf15238622067/article/details/88718615" target="_blank" rel="noopener">OpenCV 彩色图像的自适应中值滤波 C++</a> 和 <a href="https://blog.csdn.net/liyuqian199695/article/details/70050852" target="_blank" rel="noopener">彩色图像空间滤波（MATLAB）</a> 这两篇文章, 思路都是一样的, 我们来实现一下.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中值滤波：C++ 代码实现 // 处理单通道图像 // 参考 https://www.cnblogs.com/ranjiewen/p/5699395.html</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">medianFilterGray</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;src, <span class="keyword">int</span> ksize = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat dst = src.clone();</span><br><span class="line">    <span class="comment">//0. 准备：获取图片的宽，高和像素信息，</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>  num = ksize * ksize;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;uchar&gt; <span class="title">pixel</span><span class="params">(num)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相对于中心点，3*3领域中的点需要偏移的位置</span></span><br><span class="line">    <span class="keyword">int</span> delta[<span class="number">3</span> * <span class="number">3</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123; <span class="number">-1</span>, <span class="number">-1</span> &#125;, &#123; <span class="number">-1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">-1</span>, <span class="number">1</span> &#125;, &#123; <span class="number">0</span>, <span class="number">-1</span> &#125;, &#123; <span class="number">0</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">-1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span> &#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//1. 中值滤波，没有考虑边缘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; src.rows - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; src.cols - <span class="number">1</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//1.1 提取领域值 // 使用数组 这样处理 8邻域值 不适合更大窗口</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; num; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                pixel[k] = src.at&lt;uchar&gt;(i+delta[k][<span class="number">0</span>], j+ delta[k][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//1.2 排序  // 使用自带的库及排序即可</span></span><br><span class="line">            <span class="built_in">std</span>::sort(pixel.begin(), pixel.end());</span><br><span class="line">            <span class="comment">//1.3 获取该中心点的值</span></span><br><span class="line">            dst.at&lt;uchar&gt;(i, j) = pixel[num / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路还是那个思路, 不过在写的过程中, 我在想, 能不能直接处理彩色的图像呢, 对于彩色图像最麻烦的地方就是排序了, 我们没办法考虑颜色的高低值, 所以 那我们自定义一个比较函数应该就行了吧.  我们使用三个颜色的和值 做比较<br>这里使用了C++ 的sort 自定义函数的方法, 这边采用的比较函数的方式, 还有别的方式实现两个元素的比较, 可以参考<a href="https://blog.csdn.net/aastoneaa/article/details/8471722" target="_blank" rel="noopener">c++中vector自定义排序的问题</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义两个像素的比较函数,  // 使用和值 排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> cv::Vec3b &amp;p1, <span class="keyword">const</span> cv::Vec3b &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p1[<span class="number">0</span>] + p1[<span class="number">1</span>] + p1[<span class="number">2</span>]) &lt; (p2[<span class="number">0</span>] + p2[<span class="number">1</span>] + p2[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试彩色图像, 中值排序使用三个通道的和排序</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">medianFilterColor</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;src, <span class="keyword">int</span> ksize = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat dst = src.clone();</span><br><span class="line">    <span class="comment">//0. 准备：获取图片的宽，高和像素信息，</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>  num = ksize * ksize;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Vec3b&gt; <span class="title">pixel</span><span class="params">(num)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相对于中心点，3*3领域中的点需要偏移的位置</span></span><br><span class="line">    <span class="keyword">int</span> delta[<span class="number">3</span> * <span class="number">3</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123; <span class="number">-1</span>, <span class="number">-1</span> &#125;, &#123; <span class="number">-1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">-1</span>, <span class="number">1</span> &#125;, &#123; <span class="number">0</span>, <span class="number">-1</span> &#125;, &#123; <span class="number">0</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">-1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span> &#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//1. 中值滤波，没有考虑边缘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; src.rows - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; src.cols - <span class="number">1</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//1.1 提取领域值 // 使用数组 这样处理 8邻域值 不适合更大窗口</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; num; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                pixel[k] = src.at&lt;cv::Vec3b&gt;(i + delta[k][<span class="number">0</span>], j + delta[k][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//1.2 排序  // 使用自定义的排序函数排序彩色图像</span></span><br><span class="line">            <span class="built_in">std</span>::sort(pixel.begin(),pixel.end(),comp);</span><br><span class="line">            <span class="comment">//1.3 获取该中心点的值</span></span><br><span class="line">            dst.at&lt;cv::Vec3b&gt;(i, j) = pixel[num / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="opencv-中值滤波"><a href="#opencv-中值滤波" class="headerlink" title="opencv 中值滤波"></a>opencv 中值滤波</h3><p>这里还是之前的方法, 一样的接口, 实现起来很简单, opencv 提供的 函数还是很丰富的, 很厉害<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// opencv 中值滤波</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">mediaFilterDefault</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;src, <span class="keyword">int</span> ksize = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat dst;</span><br><span class="line">    cv::medianBlur(src, dst, ksize);</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="中值滤波算法对比"><a href="#中值滤波算法对比" class="headerlink" title="中值滤波算法对比"></a>中值滤波算法对比</h3><p>我们这里就跟之前均值算法的计算很相似了, 我们已经写了三种算法的实现, 然后测试就好了, 趁着功夫, 将上一章一直重复的两个图比较并输出参数的部分写成了一个函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对比两个图像 然后输出 参数信息</span></span><br><span class="line"><span class="function">QString <span class="title">compareImages</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;I1,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> cv::Mat &amp;I2,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QString str = <span class="string">"noise"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QString str_temp = <span class="string">"image-%1: psnr:%2, mssim: B:%3 G:%4 R:%5"</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> psnr_ = getPSNR(I1, I2);</span><br><span class="line">    cv::Scalar mssim_ = getMSSIM(I1, I2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 输出模板 生成参数信息</span></span><br><span class="line">    QString res_str = str_temp.arg(str)</span><br><span class="line">        .arg(psnr_)</span><br><span class="line">        .arg(mssim_.val[<span class="number">0</span>])</span><br><span class="line">        .arg(mssim_.val[<span class="number">1</span>])</span><br><span class="line">        .arg(mssim_.val[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res_str;</span><br><span class="line">    <span class="comment">// cv::imwrite(IMAGE_DIR + "dst_" + std::to_string(i + 1) + ".png", dst[i]);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>没什么难度, 就是用来拼接一个字符串, 用来显示在界面上, 或者 输出输出来, </p><p>这样的我们就能很容易的去写测试的函数了, 三种方法依次去实现, 比较麻烦的是第一种, 需要将彩色图像分成三个通道的灰度图像, 然后分别进行中值滤波, 最后合并结果,得到结果图像.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 测试 中值 滤波 三种方式的不同</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> TEST = <span class="number">1</span>; <span class="comment">// 使用统一的图进行测试 暂时使用 高 椒盐噪声图像</span></span><br><span class="line">    QString res_str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 噪声图像的参数值</span></span><br><span class="line">    res_str = compareImages(gSrcImg, gNoiseImg[TEST]);</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line"></span><br><span class="line">    cv::Mat test_img = gNoiseImg[TEST];</span><br><span class="line"></span><br><span class="line">    cv::Mat dst[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 中值滤波 拆分三个通道进行中值滤波然后合并图像</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Mat&gt; <span class="title">bgr</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    cv::split(test_img, bgr);</span><br><span class="line">    bgr[<span class="number">0</span>] = medianFilterGray(bgr[<span class="number">0</span>]);</span><br><span class="line">    bgr[<span class="number">1</span>] = medianFilterGray(bgr[<span class="number">1</span>]);</span><br><span class="line">    bgr[<span class="number">2</span>] = medianFilterGray(bgr[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    cv::merge(bgr, dst[<span class="number">0</span>]);     <span class="comment">// 第一种方式</span></span><br><span class="line">    dst[<span class="number">1</span>] = medianFilterColor(test_img);   <span class="comment">// 第二种 彩色直接 计算中值滤波</span></span><br><span class="line">    dst[<span class="number">2</span>] = mediaFilterDefault(test_img);  <span class="comment">// opencv 实现 中值滤波</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别计算三种方式得到的滤波的效果 (结果图与 原始图比较)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res_str = compareImages(gSrcImg, dst[i]);</span><br><span class="line">        <span class="comment">// 噪声的参数值</span></span><br><span class="line">        ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line"></span><br><span class="line">        cv::imwrite(IMAGE_DIR + <span class="string">"dst_media_"</span> + <span class="built_in">std</span>::to_string(i+<span class="number">1</span>)+<span class="string">".png"</span>,dst[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们仍然选择高椒盐噪声图像用于测试,  先看下结果, 分别对应噪声图的参数, 以及三种方法进行的参数结果.<br>第三行的结果就是我们进行自定义排序的图像处理, </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353</span><br><span class="line">image-noise: psnr:33.3725, mssim: B:0.896859 G:0.915976 R:0.912563</span><br><span class="line">image-noise: psnr:31.2668, mssim: B:0.866162 G:0.901717 R:0.879337</span><br><span class="line">image-noise: psnr:34.3125, mssim: B:0.902338 G:0.921419 R:0.91531</span><br></pre></td></tr></table></figure><p>我们看一下结果图像, 原始图像可以看 <a href="https://gitee.com/schen00/BlogImage/raw/master/image/1588468343599.png" target="_blank" rel="noopener">https://gitee.com/schen00/BlogImage/raw/master/image/1588468343599.png</a> 这里, </p><blockquote><p>gitee 限制了 1M 以上的图的显示, 所以有需要的去看这个就好. </p><blockquote><p>最近一直用的图拼接使用的 <a href="http://www.zuohaotu.com/image-merge.aspx" target="_blank" rel="noopener">做好图 在线拼接图片</a>  主要是懒得自己写了, <a href="http://www.zuohaotu.com/image-merge.aspx" target="_blank" rel="noopener">http://www.zuohaotu.com/image-merge.aspx</a> 链接在这里了 有需要自取</p></blockquote></blockquote><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1588468342493.png" alt="中值滤波处理结果图像预览图"></p><p>这里的第一副图是噪声图像, 第二副是我们拆分通道处理后拼接起来了的, 没有处理边缘的细节问题, 第三章图就是我们进行自定义中值排序得到的图, 部分点处理不掉 甚至还复制了出来, 不过整体效果还是不错的, 第四章图就是opencv 自带的中值滤波的处理. </p><h3 id="中值滤波算法优化"><a href="#中值滤波算法优化" class="headerlink" title="中值滤波算法优化"></a>中值滤波算法优化</h3><p>类似均值滤波, 处理的时候考虑变化了的边界就好了, 那中值滤波怎么优化呢, 感觉这一块做的人还挺多, 中值滤波的优化主要是使用自适应中值滤波, 和在中值滤波的方法上进行加速运算, </p><h4 id="自适应中值滤波"><a href="#自适应中值滤波" class="headerlink" title="自适应中值滤波"></a>自适应中值滤波</h4><p>可以参考<a href="https://blog.csdn.net/hongbin_xu/article/details/79780967" target="_blank" rel="noopener">自适应中值滤波及实现</a>, 我感觉介绍的还是比较详细的, 主要的思路就是如果噪声比较严重时, 窗口获取到的中值可能是噪声值, 这时候增大窗口, 然后重新进行中值滤波,直到找到比较符合的中值.<br>引用他给出的部分叙述</p><blockquote><p>在自适应中值滤波算法中，A步骤里面会先判断是否满足 $Zmin&lt;Zmed&lt;ZmaxZmin&lt;Zmed&lt;Zmax$。这一步骤实质是判断当前区域的中值点是否是噪声点，通常来说是满足 $Zmin&lt;Zmed&lt;ZmaxZmin&lt;Zmed&lt;Zmax$ 这个条件的，此时中值点不是噪声点，跳转到B；考虑一些特殊情况，如果 $Zmed=ZminZmed=Zmin或者Zmed=ZmaxZmed=Zmax$ ，则认为是噪声点，应该扩大窗口尺寸，在一个更大的范围内寻找一个合适的非噪声点，随后再跳转到B，否则输出的中值点是噪声点；<br>接下来考虑跳转到B之后的情况：判断中心点的像素值是否是噪声点，判断条件为 $Zmin&lt;Zxy&lt;ZmaxZmin&lt;Zxy&lt;Zmax$，原理同上，因为如果$Zxy=ZminZxy=Zmin$或者$Zxy=ZmaxZxy=Zmax$，则认为是噪声点。如果不是噪声点，我们可以保留当前像素点的灰度值；如果是噪声点，则使用中值替代原始灰度值，滤去噪声。</p></blockquote><p>同样的, <a href="https://www.cnblogs.com/wangguchangqing/p/6379646.html" target="_blank" rel="noopener">图像处理基础(2)：自适应中值滤波器(基于OpenCV实现)</a>, 这篇文章写的更好一点, 并给出了 opencv 的实现代码, 我们来看一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自适应中值滤波窗口实现  // 图像 计算座标, 窗口尺寸和 最大尺寸</span></span><br><span class="line"><span class="function">uchar <span class="title">adaptiveProcess</span><span class="params">(<span class="keyword">const</span> Mat &amp;im, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> kernelSize, <span class="keyword">int</span> maxSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;uchar&gt; pixels;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = -kernelSize / <span class="number">2</span>; a &lt;= kernelSize / <span class="number">2</span>; a++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = -kernelSize / <span class="number">2</span>; b &lt;= kernelSize / <span class="number">2</span>; b++)</span><br><span class="line">        &#123;</span><br><span class="line">            pixels.push_back(im.at&lt;uchar&gt;(row + a, col + b));</span><br><span class="line">        &#125;</span><br><span class="line">    sort(pixels.begin(), pixels.end());</span><br><span class="line">    <span class="keyword">auto</span> min = pixels[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">auto</span> max = pixels[kernelSize * kernelSize - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">auto</span> med = pixels[kernelSize * kernelSize / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">auto</span> zxy = im.at&lt;uchar&gt;(row, col);</span><br><span class="line">    <span class="keyword">if</span> (med &gt; min &amp;&amp; med &lt; max)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// to B</span></span><br><span class="line">        <span class="keyword">if</span> (zxy &gt; min &amp;&amp; zxy &lt; max)</span><br><span class="line">            <span class="keyword">return</span> zxy;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> med;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        kernelSize += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (kernelSize &lt;= maxSize)</span><br><span class="line">            <span class="keyword">return</span> adaptiveProcess(im, row, col, kernelSize, maxSize); <span class="comment">// 增大窗口尺寸，继续A过程。</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> med;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自适应均值滤波</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">adaptiveMediaFilter</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;src, <span class="keyword">int</span> ksize = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minSize = <span class="number">3</span>; <span class="comment">// 滤波器窗口的起始尺寸</span></span><br><span class="line">    <span class="keyword">int</span> maxSize = <span class="number">7</span>; <span class="comment">// 滤波器窗口的最大尺寸</span></span><br><span class="line">    cv::Mat dst;</span><br><span class="line">    <span class="comment">// 扩展图像的边界</span></span><br><span class="line">    cv::copyMakeBorder(src, dst, maxSize / <span class="number">2</span>, maxSize / <span class="number">2</span>, maxSize / <span class="number">2</span>, maxSize / <span class="number">2</span>, cv::BorderTypes::BORDER_REFLECT);</span><br><span class="line">    <span class="comment">// 图像循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = maxSize / <span class="number">2</span>; j &lt; dst.rows - maxSize / <span class="number">2</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = maxSize / <span class="number">2</span>; i &lt; dst.cols * dst.channels() - maxSize / <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dst.at&lt;uchar&gt;(j, i) = adaptiveProcess(dst, j, i, minSize, maxSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cv::Rect r = cv::Rect(cv::Point(maxSize / <span class="number">2</span>, maxSize / <span class="number">2</span>), cv::Point(dst.rows-maxSize / <span class="number">2</span>, dst.rows-maxSize / <span class="number">2</span>));</span><br><span class="line">    cv::Mat res = dst(r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里还是使用的分离三个通道然后进行自适应均值滤波, 参数就使用默认的3, 最大窗口设为7, 我们测试还是跑的之前的高椒盐噪声图像, 下面给出的最后一行就是我们使用自适应中值滤波得到的结果, 至少从 psnr 的参数上我们能看到图像质量的提升, 我们给出图像结果, 肉眼上能看出稍微一点的区别, 对比之前的已经完全不存在白点了, 图像已经比较接近真实图像了..<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拆分三个通道 计算自适应中值滤波</span></span><br><span class="line">cv::split(test_img, bgr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">truebgr[i] = adaptiveMediaFilter(bgr[i]);</span><br><span class="line">cv::merge(bgr, dst[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353</span><br><span class="line">image-noise: psnr:33.3725, mssim: B:0.896859 G:0.915976 R:0.912563</span><br><span class="line">image-noise: psnr:31.2655, mssim: B:0.86636 G:0.901517 R:0.879384</span><br><span class="line">image-noise: psnr:34.3125, mssim: B:0.902338 G:0.921419 R:0.91531</span><br><span class="line">image-noise: psnr:37.4024, mssim: B:0.946158 G:0.958146 R:0.953884</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1588477728759.png" alt="自适应中值滤波图像结果"></p><h4 id="中值滤波计算加速"><a href="#中值滤波计算加速" class="headerlink" title="中值滤波计算加速"></a>中值滤波计算加速</h4><p>由于中值滤波无论多大的窗口都是用来将窗口内的像素进行排序, 这里的优化有两个方向 一个是窗口的优化, 一个计算的加速, </p><p>我真的 imageshop 的这篇文章 <a href="https://www.cnblogs.com/Imageshop/archive/2013/04/26/3045672.html" target="_blank" rel="noopener">任意半径中值滤波（扩展至百分比滤波器）O(1)时间复杂度算法的原理、实现及效果。</a><br>已经写的比较完全了, 我都不想在写了, </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1588477728325.png" alt="图像窗口滑动"></p><p>再从<a href="https://blog.csdn.net/linj_m/article/details/35780163" target="_blank" rel="noopener">中值滤波的快速算法</a> 偷一张图, </p><p><img src="./images/1588478054028.png" alt="中值滤波算法流程"></p><p>感兴趣的可以看一下的链接<br><a href="https://www.jianshu.com/p/eb0b856286f2" target="_blank" rel="noopener">OpenCV源码分析（四）：中值滤波</a> 这里详细介绍了 opencv 中怎么实现的 中值滤波<br><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1588477728321.png" alt="中值滤波函数调用图"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>算是从中值滤波的基础上做了一个开始, 介绍了一下中值滤波的原理, 然后根据原理使用C++ 进行了实现, 之后再进行 opencv 的实现, 然后我们根据之前的程序上加入了中值滤波的实现效果, 最后在中值滤波的基础上进行优化, 做了自适应中值滤波的实现,测试发现结果还要更好, 最后我稍微提了一下中值滤波的优化加速, 这一块做的很多, 可以去参考里面去找,  算是完成了中值滤波的章节, 如果这里搞懂了我再来完善这一章节..</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《绘制函数调用图（call graph）（4）：doxygen + graphviz_运维_许振坪的专栏-CSDN博客》. 见于 2020年5月2日. <a href="https://blog.csdn.net/benkaoya/article/details/79763668" target="_blank" rel="noopener">https://blog.csdn.net/benkaoya/article/details/79763668</a>.</li><li>《任意半径中值滤波（扩展至百分比滤波器）O(1)时间复杂度算法的原理、实现及效果。 - Imageshop - 博客园》. 见于 2020年5月3日. <a href="https://www.cnblogs.com/Imageshop/archive/2013/04/26/3045672.html" target="_blank" rel="noopener">https://www.cnblogs.com/Imageshop/archive/2013/04/26/3045672.html</a>.</li><li>《数字图像处理——中值滤波 - ranjiewen - 博客园》. 见于 2020年5月2日. <a href="https://www.cnblogs.com/ranjiewen/p/5699395.html" target="_blank" rel="noopener">https://www.cnblogs.com/ranjiewen/p/5699395.html</a>.</li><li>《【算法随记三】小半径中值模糊的急速实现（16MB图7.5ms实现） + Photoshop中蒙尘和划痕算法解读。 - Imageshop - 博客园》. 见于 2020年5月3日. <a href="https://www.cnblogs.com/Imageshop/p/11087804.html" target="_blank" rel="noopener">https://www.cnblogs.com/Imageshop/p/11087804.html</a>.</li><li>《图像处理基础(2)：自适应中值滤波器(基于OpenCV实现) - Brook_icv - 博客园》. 见于 2020年5月3日. <a href="https://www.cnblogs.com/wangguchangqing/p/6379646.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangguchangqing/p/6379646.html</a>.</li><li>《图像处理之原理 - 中值滤波 - tanfy - 博客园》. 见于 2020年5月2日. <a href="https://www.cnblogs.com/tanfy/p/median_filter.html" target="_blank" rel="noopener">https://www.cnblogs.com/tanfy/p/median_filter.html</a>.</li><li>《图像处理之中值滤波介绍及C实现 - 淇淇宝贝 - 博客园》. 见于 2020年5月2日. <a href="https://www.cnblogs.com/qiqibaby/p/5281743.html" target="_blank" rel="noopener">https://www.cnblogs.com/qiqibaby/p/5281743.html</a>.</li><li>《中值滤波的快速算法_网络_LinJM-机器视觉-CSDN博客》. 见于 2020年5月3日. <a href="https://blog.csdn.net/linj_m/article/details/35780163" target="_blank" rel="noopener">https://blog.csdn.net/linj_m/article/details/35780163</a>.</li><li>《中值滤波器》. 收入 维基百科，自由的百科全书, 2017年9月8日. <a href="https://zh.wikipedia.org/w/index.php?title=%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%99%A8&amp;oldid=46098815" target="_blank" rel="noopener">https://zh.wikipedia.org/w/index.php?title=%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%99%A8&amp;oldid=46098815</a>.</li><li>《中值滤波器（Median filter）特性及其实现_人工智能_Ivan 的专栏-CSDN博客》. 见于 2020年5月2日. <a href="https://blog.csdn.net/liyuanbhu/article/details/48502005" target="_blank" rel="noopener">https://blog.csdn.net/liyuanbhu/article/details/48502005</a>.</li><li>《自适应中值滤波及实现_人工智能_hongbin_xu的博客-CSDN博客》. 见于 2020年5月3日. <a href="https://blog.csdn.net/hongbin_xu/article/details/79780967" target="_blank" rel="noopener">https://blog.csdn.net/hongbin_xu/article/details/79780967</a>.</li><li>GitHub. 《ARM-Software/ComputeLibrary》. 见于 2020年5月3日. <a href="https://github.com/ARM-software/ComputeLibrary" target="_blank" rel="noopener">https://github.com/ARM-software/ComputeLibrary</a>.</li><li>《c++中vector自定义排序的问题_C/C++_Stone_Sky-CSDN博客》. 见于 2020年5月2日. <a href="https://blog.csdn.net/aastoneaa/article/details/8471722" target="_blank" rel="noopener">https://blog.csdn.net/aastoneaa/article/details/8471722</a>.</li><li>《OpenCV 彩色图像的自适应中值滤波 C++_人工智能_cyf15238622067的博客-CSDN博客》. 见于 2020年5月3日. <a href="https://blog.csdn.net/cyf15238622067/article/details/88718615" target="_blank" rel="noopener">https://blog.csdn.net/cyf15238622067/article/details/88718615</a>.</li><li>《‪opencv: ‪Image Filtering》. 见于 2020年5月3日. <a href="http://schen.xyz:89/opencv/d4/d86/group__imgproc__filter.html#gad7c87bbc46b97e7eafa71357916ab568" target="_blank" rel="noopener">http://schen.xyz:89/opencv/d4/d86/group__imgproc__filter.html#gad7c87bbc46b97e7eafa71357916ab568</a>.</li><li>知乎专栏. 《OpenCV图像处理专栏九 | 基于直方图的快速中值滤波算法》. 见于 2020年5月3日. <a href="https://zhuanlan.zhihu.com/p/98092747" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/98092747</a>.</li><li>简书. 《OpenCV源码分析（四）：中值滤波》. 见于 2020年5月2日. <a href="https://www.jianshu.com/p/eb0b856286f2" target="_blank" rel="noopener">https://www.jianshu.com/p/eb0b856286f2</a>.</li></ol><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; title=&quot;开始之前&quot;&gt;&lt;/a&gt;开始之前&lt;/h2&gt;&lt;p&gt;在上一篇我们实现了读取噪声图像, 然后 进行三种形式的均值滤波得到结果, 由于我们自己写的均值滤波未作边缘处理, 所以效果有一定的下降, 但是总体来说, 我们得到的结果能够说明我们的算法执行之后得到的图像噪声更低, 图像更清晰. 但是也会造成图像的模糊, 导致部分细节丢失. 在这一章中,我们介绍一下中值滤波及其实现&lt;/p&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;首先介绍了中值滤波的原理, 给出其实现思路,并根据思路实现了 C++ 的代码, 然后 同样测试 opencv 自带的中值滤波, 同样的测试图像, 得到对比结果, 分析代码的实现过程, .&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;h3 id=&quot;中值滤波原理&quot;&gt;&lt;a href=&quot;#中值滤波原理&quot; class=&quot;headerlink&quot; title=&quot;中值滤波原理&quot;&gt;&lt;/a&gt;中值滤波原理&lt;/h3&gt;&lt;p&gt;中值滤波(Media Filter)就是对于图像的每一个点计算其邻域窗口的像素序列中值, 可以表示为:&lt;br&gt;$$&lt;br&gt;g(x,y) = meida_{(i,j) \in S}f(i,j)&lt;br&gt;$$&lt;br&gt;核心就是将相应窗口内的像素值进行排列, 我们之前也说过, 我们选择的窗口为奇数尺寸, 所以我们能够保证窗口内的像素个数也是奇数个, 这样我们可以保证取得唯一的中值, 相应的设置为该点的目标值就行了.&lt;/p&gt;
&lt;h3 id=&quot;C-实现中值滤波&quot;&gt;&lt;a href=&quot;#C-实现中值滤波&quot; class=&quot;headerlink&quot; title=&quot;C++ 实现中值滤波&quot;&gt;&lt;/a&gt;C++ 实现中值滤波&lt;/h3&gt;&lt;p&gt;我们来实现一下, 这方面还是能够找到不少结果的, 感觉这个博主写的还是很不错的,有兴趣的可以看下&lt;a href=&quot;https://www.cnblogs.com/ranjiewen/p/5699395.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数字图像处理——中值滤波&lt;/a&gt;,还有&lt;a href=&quot;https://www.cnblogs.com/qiqibaby/p/5281743.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图像处理之中值滤波介绍及C实现&lt;/a&gt;, 或者 &lt;a href=&quot;https://blog.csdn.net/liyuanbhu/article/details/48502005&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中值滤波器（Median filter）特性及其实现&lt;/a&gt;, 这里我就不再造轮子了, 我们来看下 C++的实现&lt;br&gt;, 主要参考 第一篇文章, 可以看下效果&lt;/p&gt;
&lt;p&gt;这里有一点点需要讨论的, 对于彩色图像的三个通道怎么处理, 自己的思路就是分成三个通道进行处理, 然后分别得到三个图之后进行合并三个通道, 得到结果图像.   查了下 目测大家都是这么做的, 可以看&lt;a href=&quot;https://blog.csdn.net/cyf15238622067/article/details/88718615&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenCV 彩色图像的自适应中值滤波 C++&lt;/a&gt; 和 &lt;a href=&quot;https://blog.csdn.net/liyuqian199695/article/details/70050852&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;彩色图像空间滤波（MATLAB）&lt;/a&gt; 这两篇文章, 思路都是一样的, 我们来实现一下.&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//中值滤波：C++ 代码实现 // 处理单通道图像 // 参考 https://www.cnblogs.com/ranjiewen/p/5699395.html&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;cv::Mat &lt;span class=&quot;title&quot;&gt;medianFilterGray&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; cv::Mat &amp;amp;src, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ksize = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat dst = src.clone();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//0. 准备：获取图片的宽，高和像素信息，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;  num = ksize * ksize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;uchar&amp;gt; &lt;span class=&quot;title&quot;&gt;pixel&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//相对于中心点，3*3领域中的点需要偏移的位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; delta[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123; &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt; &amp;#125;, &amp;#123; &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#125;, &amp;#123; &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;#125;, &amp;#123; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt; &amp;#125;, &amp;#123; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#125;, &amp;#123; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;#125;, &amp;#123; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt; &amp;#125;, &amp;#123; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#125;, &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//1. 中值滤波，没有考虑边缘&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt; src.rows - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; ++i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j &amp;lt; src.cols - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; ++j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//1.1 提取领域值 // 使用数组 这样处理 8邻域值 不适合更大窗口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; k &amp;lt; num; ++k)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                pixel[k] = src.at&amp;lt;uchar&amp;gt;(i+delta[k][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], j+ delta[k][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//1.2 排序  // 使用自带的库及排序即可&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::sort(pixel.begin(), pixel.end());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//1.3 获取该中心点的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dst.at&amp;lt;uchar&amp;gt;(i, j) = pixel[num / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dst;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;思路还是那个思路, 不过在写的过程中, 我在想, 能不能直接处理彩色的图像呢, 对于彩色图像最麻烦的地方就是排序了, 我们没办法考虑颜色的高低值, 所以 那我们自定义一个比较函数应该就行了吧.  我们使用三个颜色的和值 做比较&lt;br&gt;这里使用了C++ 的sort 自定义函数的方法, 这边采用的比较函数的方式, 还有别的方式实现两个元素的比较, 可以参考&lt;a href=&quot;https://blog.csdn.net/aastoneaa/article/details/8471722&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;c++中vector自定义排序的问题&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 自定义两个像素的比较函数,  // 使用和值 排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;comp&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; cv::Vec3b &amp;amp;p1, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; cv::Vec3b &amp;amp;p2)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (p1[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] + p1[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] + p1[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]) &amp;lt; (p2[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] + p2[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] + p2[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 尝试彩色图像, 中值排序使用三个通道的和排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;cv::Mat &lt;span class=&quot;title&quot;&gt;medianFilterColor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; cv::Mat &amp;amp;src, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ksize = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat dst = src.clone();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//0. 准备：获取图片的宽，高和像素信息，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;  num = ksize * ksize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;cv::Vec3b&amp;gt; &lt;span class=&quot;title&quot;&gt;pixel&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//相对于中心点，3*3领域中的点需要偏移的位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; delta[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123; &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt; &amp;#125;, &amp;#123; &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#125;, &amp;#123; &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;#125;, &amp;#123; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt; &amp;#125;, &amp;#123; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#125;, &amp;#123; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;#125;, &amp;#123; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt; &amp;#125;, &amp;#123; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#125;, &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//1. 中值滤波，没有考虑边缘&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt; src.rows - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; ++i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j &amp;lt; src.cols - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; ++j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//1.1 提取领域值 // 使用数组 这样处理 8邻域值 不适合更大窗口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; k &amp;lt; num; ++k)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                pixel[k] = src.at&amp;lt;cv::Vec3b&amp;gt;(i + delta[k][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], j + delta[k][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//1.2 排序  // 使用自定义的排序函数排序彩色图像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::sort(pixel.begin(),pixel.end(),comp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//1.3 获取该中心点的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dst.at&amp;lt;cv::Vec3b&amp;gt;(i, j) = pixel[num / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dst;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;opencv-中值滤波&quot;&gt;&lt;a href=&quot;#opencv-中值滤波&quot; class=&quot;headerlink&quot; title=&quot;opencv 中值滤波&quot;&gt;&lt;/a&gt;opencv 中值滤波&lt;/h3&gt;&lt;p&gt;这里还是之前的方法, 一样的接口, 实现起来很简单, opencv 提供的 函数还是很丰富的, 很厉害&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// opencv 中值滤波&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;cv::Mat &lt;span class=&quot;title&quot;&gt;mediaFilterDefault&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; cv::Mat &amp;amp;src, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ksize = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat dst;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::medianBlur(src, dst, ksize);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dst;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;中值滤波算法对比&quot;&gt;&lt;a href=&quot;#中值滤波算法对比&quot; class=&quot;headerlink&quot; title=&quot;中值滤波算法对比&quot;&gt;&lt;/a&gt;中值滤波算法对比&lt;/h3&gt;&lt;p&gt;我们这里就跟之前均值算法的计算很相似了, 我们已经写了三种算法的实现, 然后测试就好了, 趁着功夫, 将上一章一直重复的两个图比较并输出参数的部分写成了一个函数&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 对比两个图像 然后输出 参数信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;QString &lt;span class=&quot;title&quot;&gt;compareImages&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; cv::Mat &amp;amp;I1,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; cv::Mat &amp;amp;I2,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; QString str = &lt;span class=&quot;string&quot;&gt;&quot;noise&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; QString str_temp = &lt;span class=&quot;string&quot;&gt;&quot;image-%1: psnr:%2, mssim: B:%3 G:%4 R:%5&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; psnr_ = getPSNR(I1, I2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Scalar mssim_ = getMSSIM(I1, I2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 根据 输出模板 生成参数信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QString res_str = str_temp.arg(str)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .arg(psnr_)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .arg(mssim_.val[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .arg(mssim_.val[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .arg(mssim_.val[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res_str;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// cv::imwrite(IMAGE_DIR + &quot;dst_&quot; + std::to_string(i + 1) + &quot;.png&quot;, dst[i]);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;没什么难度, 就是用来拼接一个字符串, 用来显示在界面上, 或者 输出输出来, &lt;/p&gt;
&lt;p&gt;这样的我们就能很容易的去写测试的函数了, 三种方法依次去实现, 比较麻烦的是第一种, 需要将彩色图像分成三个通道的灰度图像, 然后分别进行中值滤波, 最后合并结果,得到结果图像.&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainWindow::testFunc2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 测试 中值 滤波 三种方式的不同&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; TEST = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 使用统一的图进行测试 暂时使用 高 椒盐噪声图像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QString res_str;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 噪声图像的参数值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res_str = compareImages(gSrcImg, gNoiseImg[TEST]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui-&amp;gt;pt_log-&amp;gt;appendPlainText(res_str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat test_img = gNoiseImg[TEST];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat dst[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 测试 中值滤波 拆分三个通道进行中值滤波然后合并图像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;cv::Mat&amp;gt; &lt;span class=&quot;title&quot;&gt;bgr&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::split(test_img, bgr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bgr[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = medianFilterGray(bgr[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bgr[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = medianFilterGray(bgr[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bgr[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] = medianFilterGray(bgr[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::merge(bgr, dst[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);     &lt;span class=&quot;comment&quot;&gt;// 第一种方式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dst[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = medianFilterColor(test_img);   &lt;span class=&quot;comment&quot;&gt;// 第二种 彩色直接 计算中值滤波&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dst[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] = mediaFilterDefault(test_img);  &lt;span class=&quot;comment&quot;&gt;// opencv 实现 中值滤波&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 分别计算三种方式得到的滤波的效果 (结果图与 原始图比较)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        res_str = compareImages(gSrcImg, dst[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 噪声的参数值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ui-&amp;gt;pt_log-&amp;gt;appendPlainText(res_str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cv::imwrite(IMAGE_DIR + &lt;span class=&quot;string&quot;&gt;&quot;dst_media_&quot;&lt;/span&gt; + &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::to_string(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)+&lt;span class=&quot;string&quot;&gt;&quot;.png&quot;&lt;/span&gt;,dst[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们仍然选择高椒盐噪声图像用于测试,  先看下结果, 分别对应噪声图的参数, 以及三种方法进行的参数结果.&lt;br&gt;第三行的结果就是我们进行自定义排序的图像处理, &lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image-noise: psnr:33.3725, mssim: B:0.896859 G:0.915976 R:0.912563&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image-noise: psnr:31.2668, mssim: B:0.866162 G:0.901717 R:0.879337&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image-noise: psnr:34.3125, mssim: B:0.902338 G:0.921419 R:0.91531&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们看一下结果图像, 原始图像可以看 &lt;a href=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1588468343599.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://gitee.com/schen00/BlogImage/raw/master/image/1588468343599.png&lt;/a&gt; 这里, &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;gitee 限制了 1M 以上的图的显示, 所以有需要的去看这个就好. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最近一直用的图拼接使用的 &lt;a href=&quot;http://www.zuohaotu.com/image-merge.aspx&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;做好图 在线拼接图片&lt;/a&gt;  主要是懒得自己写了, &lt;a href=&quot;http://www.zuohaotu.com/image-merge.aspx&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.zuohaotu.com/image-merge.aspx&lt;/a&gt; 链接在这里了 有需要自取&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1588468342493.png&quot; alt=&quot;中值滤波处理结果图像预览图&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里的第一副图是噪声图像, 第二副是我们拆分通道处理后拼接起来了的, 没有处理边缘的细节问题, 第三章图就是我们进行自定义中值排序得到的图, 部分点处理不掉 甚至还复制了出来, 不过整体效果还是不错的, 第四章图就是opencv 自带的中值滤波的处理. &lt;/p&gt;
&lt;h3 id=&quot;中值滤波算法优化&quot;&gt;&lt;a href=&quot;#中值滤波算法优化&quot; class=&quot;headerlink&quot; title=&quot;中值滤波算法优化&quot;&gt;&lt;/a&gt;中值滤波算法优化&lt;/h3&gt;&lt;p&gt;类似均值滤波, 处理的时候考虑变化了的边界就好了, 那中值滤波怎么优化呢, 感觉这一块做的人还挺多, 中值滤波的优化主要是使用自适应中值滤波, 和在中值滤波的方法上进行加速运算, &lt;/p&gt;
&lt;h4 id=&quot;自适应中值滤波&quot;&gt;&lt;a href=&quot;#自适应中值滤波&quot; class=&quot;headerlink&quot; title=&quot;自适应中值滤波&quot;&gt;&lt;/a&gt;自适应中值滤波&lt;/h4&gt;&lt;p&gt;可以参考&lt;a href=&quot;https://blog.csdn.net/hongbin_xu/article/details/79780967&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;自适应中值滤波及实现&lt;/a&gt;, 我感觉介绍的还是比较详细的, 主要的思路就是如果噪声比较严重时, 窗口获取到的中值可能是噪声值, 这时候增大窗口, 然后重新进行中值滤波,直到找到比较符合的中值.&lt;br&gt;引用他给出的部分叙述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在自适应中值滤波算法中，A步骤里面会先判断是否满足 $Zmin&amp;lt;Zmed&amp;lt;ZmaxZmin&amp;lt;Zmed&amp;lt;Zmax$。这一步骤实质是判断当前区域的中值点是否是噪声点，通常来说是满足 $Zmin&amp;lt;Zmed&amp;lt;ZmaxZmin&amp;lt;Zmed&amp;lt;Zmax$ 这个条件的，此时中值点不是噪声点，跳转到B；考虑一些特殊情况，如果 $Zmed=ZminZmed=Zmin或者Zmed=ZmaxZmed=Zmax$ ，则认为是噪声点，应该扩大窗口尺寸，在一个更大的范围内寻找一个合适的非噪声点，随后再跳转到B，否则输出的中值点是噪声点；&lt;br&gt;接下来考虑跳转到B之后的情况：判断中心点的像素值是否是噪声点，判断条件为 $Zmin&amp;lt;Zxy&amp;lt;ZmaxZmin&amp;lt;Zxy&amp;lt;Zmax$，原理同上，因为如果$Zxy=ZminZxy=Zmin$或者$Zxy=ZmaxZxy=Zmax$，则认为是噪声点。如果不是噪声点，我们可以保留当前像素点的灰度值；如果是噪声点，则使用中值替代原始灰度值，滤去噪声。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同样的, &lt;a href=&quot;https://www.cnblogs.com/wangguchangqing/p/6379646.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图像处理基础(2)：自适应中值滤波器(基于OpenCV实现)&lt;/a&gt;, 这篇文章写的更好一点, 并给出了 opencv 的实现代码, 我们来看一下&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 自适应中值滤波窗口实现  // 图像 计算座标, 窗口尺寸和 最大尺寸&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;uchar &lt;span class=&quot;title&quot;&gt;adaptiveProcess&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Mat &amp;amp;im, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; row, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; col, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; kernelSize, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxSize)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;uchar&amp;gt; pixels;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = -kernelSize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; a &amp;lt;= kernelSize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; a++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b = -kernelSize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; b &amp;lt;= kernelSize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; b++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            pixels.push_back(im.at&amp;lt;uchar&amp;gt;(row + a, col + b));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sort(pixels.begin(), pixels.end());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; min = pixels[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; max = pixels[kernelSize * kernelSize - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; med = pixels[kernelSize * kernelSize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; zxy = im.at&amp;lt;uchar&amp;gt;(row, col);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (med &amp;gt; min &amp;amp;&amp;amp; med &amp;lt; max)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// to B&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (zxy &amp;gt; min &amp;amp;&amp;amp; zxy &amp;lt; max)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; zxy;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; med;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        kernelSize += &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (kernelSize &amp;lt;= maxSize)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; adaptiveProcess(im, row, col, kernelSize, maxSize); &lt;span class=&quot;comment&quot;&gt;// 增大窗口尺寸，继续A过程。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; med;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 自适应均值滤波&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;cv::Mat &lt;span class=&quot;title&quot;&gt;adaptiveMediaFilter&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; cv::Mat &amp;amp;src, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ksize = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; minSize = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 滤波器窗口的起始尺寸&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxSize = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 滤波器窗口的最大尺寸&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat dst;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 扩展图像的边界&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::copyMakeBorder(src, dst, maxSize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, maxSize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, maxSize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, maxSize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, cv::BorderTypes::BORDER_REFLECT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 图像循环&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = maxSize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; j &amp;lt; dst.rows - maxSize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = maxSize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; i &amp;lt; dst.cols * dst.channels() - maxSize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dst.at&amp;lt;uchar&amp;gt;(j, i) = adaptiveProcess(dst, j, i, minSize, maxSize);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Rect r = cv::Rect(cv::Point(maxSize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, maxSize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;), cv::Point(dst.rows-maxSize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, dst.rows-maxSize / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat res = dst(r);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们这里还是使用的分离三个通道然后进行自适应均值滤波, 参数就使用默认的3, 最大窗口设为7, 我们测试还是跑的之前的高椒盐噪声图像, 下面给出的最后一行就是我们使用自适应中值滤波得到的结果, 至少从 psnr 的参数上我们能看到图像质量的提升, 我们给出图像结果, 肉眼上能看出稍微一点的区别, 对比之前的已经完全不存在白点了, 图像已经比较接近真实图像了..&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 拆分三个通道 计算自适应中值滤波&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cv::split(test_img, bgr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;truebgr[i] = adaptiveMediaFilter(bgr[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cv::merge(bgr, dst[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image-noise: psnr:33.3725, mssim: B:0.896859 G:0.915976 R:0.912563&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image-noise: psnr:31.2655, mssim: B:0.86636 G:0.901517 R:0.879384&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image-noise: psnr:34.3125, mssim: B:0.902338 G:0.921419 R:0.91531&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image-noise: psnr:37.4024, mssim: B:0.946158 G:0.958146 R:0.953884&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1588477728759.png&quot; alt=&quot;自适应中值滤波图像结果&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;中值滤波计算加速&quot;&gt;&lt;a href=&quot;#中值滤波计算加速&quot; class=&quot;headerlink&quot; title=&quot;中值滤波计算加速&quot;&gt;&lt;/a&gt;中值滤波计算加速&lt;/h4&gt;&lt;p&gt;由于中值滤波无论多大的窗口都是用来将窗口内的像素进行排序, 这里的优化有两个方向 一个是窗口的优化, 一个计算的加速, &lt;/p&gt;
&lt;p&gt;我真的 imageshop 的这篇文章 &lt;a href=&quot;https://www.cnblogs.com/Imageshop/archive/2013/04/26/3045672.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;任意半径中值滤波（扩展至百分比滤波器）O(1)时间复杂度算法的原理、实现及效果。&lt;/a&gt;&lt;br&gt;已经写的比较完全了, 我都不想在写了, &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1588477728325.png&quot; alt=&quot;图像窗口滑动&quot;&gt;&lt;/p&gt;
&lt;p&gt;再从&lt;a href=&quot;https://blog.csdn.net/linj_m/article/details/35780163&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中值滤波的快速算法&lt;/a&gt; 偷一张图, &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./images/1588478054028.png&quot; alt=&quot;中值滤波算法流程&quot;&gt;&lt;/p&gt;
&lt;p&gt;感兴趣的可以看一下的链接&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/eb0b856286f2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenCV源码分析（四）：中值滤波&lt;/a&gt; 这里详细介绍了 opencv 中怎么实现的 中值滤波&lt;br&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1588477728321.png&quot; alt=&quot;中值滤波函数调用图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;算是从中值滤波的基础上做了一个开始, 介绍了一下中值滤波的原理, 然后根据原理使用C++ 进行了实现, 之后再进行 opencv 的实现, 然后我们根据之前的程序上加入了中值滤波的实现效果, 最后在中值滤波的基础上进行优化, 做了自适应中值滤波的实现,测试发现结果还要更好, 最后我稍微提了一下中值滤波的优化加速, 这一块做的很多, 可以去参考里面去找,  算是完成了中值滤波的章节, 如果这里搞懂了我再来完善这一章节..&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;《绘制函数调用图（call graph）（4）：doxygen + graphviz_运维_许振坪的专栏-CSDN博客》. 见于 2020年5月2日. &lt;a href=&quot;https://blog.csdn.net/benkaoya/article/details/79763668&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/benkaoya/article/details/79763668&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《任意半径中值滤波（扩展至百分比滤波器）O(1)时间复杂度算法的原理、实现及效果。 - Imageshop - 博客园》. 见于 2020年5月3日. &lt;a href=&quot;https://www.cnblogs.com/Imageshop/archive/2013/04/26/3045672.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/Imageshop/archive/2013/04/26/3045672.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《数字图像处理——中值滤波 - ranjiewen - 博客园》. 见于 2020年5月2日. &lt;a href=&quot;https://www.cnblogs.com/ranjiewen/p/5699395.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/ranjiewen/p/5699395.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《【算法随记三】小半径中值模糊的急速实现（16MB图7.5ms实现） + Photoshop中蒙尘和划痕算法解读。 - Imageshop - 博客园》. 见于 2020年5月3日. &lt;a href=&quot;https://www.cnblogs.com/Imageshop/p/11087804.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/Imageshop/p/11087804.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《图像处理基础(2)：自适应中值滤波器(基于OpenCV实现) - Brook_icv - 博客园》. 见于 2020年5月3日. &lt;a href=&quot;https://www.cnblogs.com/wangguchangqing/p/6379646.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/wangguchangqing/p/6379646.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《图像处理之原理 - 中值滤波 - tanfy - 博客园》. 见于 2020年5月2日. &lt;a href=&quot;https://www.cnblogs.com/tanfy/p/median_filter.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/tanfy/p/median_filter.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《图像处理之中值滤波介绍及C实现 - 淇淇宝贝 - 博客园》. 见于 2020年5月2日. &lt;a href=&quot;https://www.cnblogs.com/qiqibaby/p/5281743.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/qiqibaby/p/5281743.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《中值滤波的快速算法_网络_LinJM-机器视觉-CSDN博客》. 见于 2020年5月3日. &lt;a href=&quot;https://blog.csdn.net/linj_m/article/details/35780163&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/linj_m/article/details/35780163&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《中值滤波器》. 收入 维基百科，自由的百科全书, 2017年9月8日. &lt;a href=&quot;https://zh.wikipedia.org/w/index.php?title=%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%99%A8&amp;amp;oldid=46098815&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.wikipedia.org/w/index.php?title=%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%99%A8&amp;amp;oldid=46098815&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《中值滤波器（Median filter）特性及其实现_人工智能_Ivan 的专栏-CSDN博客》. 见于 2020年5月2日. &lt;a href=&quot;https://blog.csdn.net/liyuanbhu/article/details/48502005&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/liyuanbhu/article/details/48502005&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《自适应中值滤波及实现_人工智能_hongbin_xu的博客-CSDN博客》. 见于 2020年5月3日. &lt;a href=&quot;https://blog.csdn.net/hongbin_xu/article/details/79780967&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/hongbin_xu/article/details/79780967&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;GitHub. 《ARM-Software/ComputeLibrary》. 见于 2020年5月3日. &lt;a href=&quot;https://github.com/ARM-software/ComputeLibrary&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ARM-software/ComputeLibrary&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《c++中vector自定义排序的问题_C/C++_Stone_Sky-CSDN博客》. 见于 2020年5月2日. &lt;a href=&quot;https://blog.csdn.net/aastoneaa/article/details/8471722&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/aastoneaa/article/details/8471722&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《OpenCV 彩色图像的自适应中值滤波 C++_人工智能_cyf15238622067的博客-CSDN博客》. 见于 2020年5月3日. &lt;a href=&quot;https://blog.csdn.net/cyf15238622067/article/details/88718615&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/cyf15238622067/article/details/88718615&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《‪opencv: ‪Image Filtering》. 见于 2020年5月3日. &lt;a href=&quot;http://schen.xyz:89/opencv/d4/d86/group__imgproc__filter.html#gad7c87bbc46b97e7eafa71357916ab568&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://schen.xyz:89/opencv/d4/d86/group__imgproc__filter.html#gad7c87bbc46b97e7eafa71357916ab568&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;知乎专栏. 《OpenCV图像处理专栏九 | 基于直方图的快速中值滤波算法》. 见于 2020年5月3日. &lt;a href=&quot;https://zhuanlan.zhihu.com/p/98092747&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/98092747&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;简书. 《OpenCV源码分析（四）：中值滤波》. 见于 2020年5月2日. &lt;a href=&quot;https://www.jianshu.com/p/eb0b856286f2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/eb0b856286f2&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="opencv" scheme="https://schen1024.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://schen1024.github.io/tags/opencv/"/>
    
      <category term="c++" scheme="https://schen1024.github.io/tags/c/"/>
    
      <category term="qt" scheme="https://schen1024.github.io/tags/qt/"/>
    
  </entry>
  
  <entry>
    <title>opencv-10-图像滤波-噪声添加与均值滤波-含opencv C++ 代码实现</title>
    <link href="https://schen1024.github.io/2020/04-29/opencv-10-%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2.html"/>
    <id>https://schen1024.github.io/2020/04-29/opencv-10-%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2.html</id>
    <published>2020-04-29T17:02:57.000Z</published>
    <updated>2023-01-01T13:25:24.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>再说上一篇文章中, 我们想按照噪声产生, 然后将降噪的, 但是限于篇幅, 我就放在这一篇里面了,<br>说起图像的噪声问题就又回到了我们上一章的内容, 把噪声当作信号处理, 实际上数字图像处理实际上也是在进行数字信号的处理过程, 我们这一章就是将滤除信号的过程,</p><p>根据上一章的方式, 我们对图像添加噪声, 然后计算 PSNR 与 SSIM 参数, 然后通过降噪, 再从新计算参数值, 比较我们算法的效果 对比我们的算法效果, 看正文吧</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[toc]</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我们在上一章给出了两种噪声的添加方式, 可以根据我们的需求添加椒盐噪声和高斯噪声, 但是由于我们的噪声添加使用了随机数 , 导致我们在每次进行的结果可能不一致, 所以我们提前设计好噪声情况, 将图片存储起来, 后面我们进行滤波的时候, 都使用一样的照片, 这样我们能够保证每次的结果是一致的, 这样就能进行算法的对比了,  </p><h3 id="生成噪声图像"><a href="#生成噪声图像" class="headerlink" title="生成噪声图像"></a>生成噪声图像</h3><p>我们在上一章给出了不同噪声情况下图像结果, 也给出了一个链接, 对比了更多情况下的图像噪声情况, 可以参考, 所以我们考虑五种情况吧 分别是低椒盐噪声, 高椒盐噪声,低高斯噪声, 高高斯噪声,低椒盐混合低高斯噪声, 高椒盐混合高高斯噪声. 我们分别将图片进行存储便能够得到结果</p><p>说明一下: 之前的算法使用的 lena 图像 忘记从那搞来的了, 今天对比了一下, 发现图像不太对, 我现在找到opencv的一个标准图像<a href="https://raw.githubusercontent.com/opencv/opencv/master/samples/data/lena.jpg" target="_blank" rel="noopener">Lena.jpg</a>, 我下载下来了, 转换成了 lena.png 的图像, 可以见<a href="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588298950276.png" target="_blank" rel="noopener">lena.png</a> 这幅图, 可以直接访问链接 <a href="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588298950276.png" target="_blank" rel="noopener">https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588298950276.png</a> 直接下载即可.. </p><p>这里的处理算法比较简单, 我们来看代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 用于生成 测试图像 一共6幅图像</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Mat&gt; <span class="title">noise_img</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 初始化为原始图像</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;m: noise_img)</span><br><span class="line">        m = gSrcImg.clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别添加 低, 高, 低混合, 高混合 共6幅图像</span></span><br><span class="line">    addSaltNoise(noise_img[<span class="number">0</span>],<span class="number">1000</span>);</span><br><span class="line">    addSaltNoise(noise_img[<span class="number">1</span>],<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    addGaussianNoise(noise_img[<span class="number">2</span>],<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    addGaussianNoise(noise_img[<span class="number">3</span>],<span class="number">100</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    addSaltNoise(noise_img[<span class="number">4</span>],<span class="number">1000</span>);</span><br><span class="line">    addGaussianNoise(noise_img[<span class="number">4</span>],<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    addSaltNoise(noise_img[<span class="number">5</span>],<span class="number">10000</span>);</span><br><span class="line">    addGaussianNoise(noise_img[<span class="number">5</span>],<span class="number">100</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 6幅图像的  psnr 和 ssim 然后存储结果值</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">psnr</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Scalar&gt; <span class="title">mssim</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    QString res_temp = <span class="string">"image-%1: psnr:%2, mssim: B:%3 G:%4 R:%5 "</span>;</span><br><span class="line">    QString res_str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个图像的 参数值, 然后存储起来</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        psnr[i] = getPSNR(gSrcImg, noise_img[i]);</span><br><span class="line">        mssim[i] = getMSSIM(gSrcImg, noise_img[i]);</span><br><span class="line">        res_str = res_temp.arg(i+<span class="number">1</span>)</span><br><span class="line">                            .arg(psnr[i])</span><br><span class="line">                            .arg(mssim[i].val[<span class="number">0</span>])</span><br><span class="line">                            .arg(mssim[i].val[<span class="number">1</span>])</span><br><span class="line">                            .arg(mssim[i].val[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line">        cv::imwrite(<span class="string">"../testimages/noise/lena-"</span> + <span class="built_in">std</span>::to_string(i+<span class="number">1</span>) + <span class="string">".png"</span>, noise_img[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们将图片输出, 然后输出了每幅图的参数, 同时将结果图存储下来, 由于我们在实际进行图像处理的时候会有很多<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">image-1: psnr:29.4922, mssim: B:0.880587 G:0.888243 R:0.944992 </span><br><span class="line">image-2: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353 </span><br><span class="line">image-3: psnr:46.8705, mssim: B:0.991138 G:0.991732 R:0.991185 </span><br><span class="line">image-4: psnr:9.15966, mssim: B:0.492354 G:0.482311 R:0.680167 </span><br><span class="line">image-5: psnr:29.2807, mssim: B:0.874794 G:0.881488 R:0.935624 </span><br><span class="line">image-6: psnr:8.92587, mssim: B:0.392531 G:0.393254 R:0.655795</span><br></pre></td></tr></table></figure><br>我这里使用之前提到的 图像”拼接” 的方式将图像拼接起来, 这样我们可以更为直观的比较, 图像尺寸都是 $512*512$, 如果需要可以裁剪出来,</p><blockquote><p>CSDN 上传会自己转存图片, 上传资源比较麻烦, 懒得搞, 我这边的图片都存在了 gitee 的图床上, 原图存储的 , 有需要的可以自己取用</p></blockquote><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1588391819059.png" alt="噪声图像&quot;拼接&quot;图"></p><h3 id="传统图像降噪算法及其对比"><a href="#传统图像降噪算法及其对比" class="headerlink" title="传统图像降噪算法及其对比"></a>传统图像降噪算法及其对比</h3><p>之前提到过的<a href="https://zhuanlan.zhihu.com/p/51403693" target="_blank" rel="noopener">【技术综述】一文道尽传统图像降噪方法</a><br> 这篇文章讲的还比较详细, 大概的给我们讲了一下传统的降噪的方法,<br> 这里我想将各种滤波分开进行实现, 但是比较麻烦, 我就直接在一篇文章中写了吧.. </p><p> 目前常用的降噪的方法主要可以分为空域降噪与频域降噪, 空域滤波也是我们常用的使用空间处理的方式,计算量小, 简单易用. 频域比较难理解,计算量也比较大, 但是在很多情况结果比较有效.. </p><p> 所以我们主要的部分也是空间域处理的方式, 也比较直观. opencv 的例程中<a href="https://docs.opencv.org/4.3.0/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html" target="_blank" rel="noopener">Smoothing Images</a> 章节大概讲了一下目前使用的模糊方式, 其实模糊是相对的, 也是进行降噪的一个有利手段, 在处理掉噪声的同时, 会导致原始图像的细节模糊, 进而丢失一部分图像信息,我们之后看下图像测试结果. 同时在例程中还提到了一本书<a href="http://szeliski.org/Book" target="_blank" rel="noopener">Computer Vision: Algorithms and Applications, 1st ed.</a> 有中译版本, 内容还不错, 可以学习</p><h3 id="opencv-核表示的算法操作"><a href="#opencv-核表示的算法操作" class="headerlink" title="opencv 核表示的算法操作"></a>opencv 核表示的算法操作</h3><p>在之前的内容中, 我们介绍了 opencv 核操作的方式, 对于图像的每个像素点的领域操作都可以使用 opencv 提供的 <code>filter2D</code> 方式进行指定核的运算, 我们能够很容易核的操作, 也就是说我们将图像的算法操作都可以转换成图像的矩阵相乘的运算, 可以表示成<br>$$<br>g(x,y) = M \cdot f(x,y)<br>$$<br>$g(x,y)$ 用来表示结果图像, $f(x,y)$ 表示原始图像,  (x,y) 表示 列行座标, M 就是我们的图像运算矩阵,<br>我们后续都不再重复这些默认的操作, 希望能够明白</p><p>一般来说, 我们进行矩阵运算的时候都会选择方阵, 这样不会由于矩阵的方向性导致的处理结果不同, 所以我们在一般情况下都会选择<br>方阵, 比如上面进行的滤波 采用的就是 $3x3$ 尺寸的图像, 而且由于我们的图像都是离散的, 所以 实际山采用的滤波的窗口边长也是奇数值, 类似于 $3,5,7,9…(2k+1)$ 的形式</p><h3 id="均值滤波及C-代码实现"><a href="#均值滤波及C-代码实现" class="headerlink" title="均值滤波及C++ 代码实现"></a>均值滤波及C++ 代码实现</h3><h4 id="算术均值滤波"><a href="#算术均值滤波" class="headerlink" title="算术均值滤波"></a>算术均值滤波</h4><p>均值滤波(Mean Filter)的算法就是对于每一个像素点, 将其设定为取其邻域窗口内的所有像素的平均值<br>我们考虑一般形式的均值滤波器<br>$$<br>g(x,y) = \frac{1}{mn} \sum_{(i,j) \in S_{xy}} f(i,j)<br>$$</p><p>那我们开始转换一下, 则可以得到下相应的 均值滤波的矩阵<br>$$<br>M = \frac{1}{9} \left [<br>        \begin{array}{c}<br>            1 &amp; 1 &amp; 1 \ 1&amp; 1 &amp; 1 \ 1 &amp; 1 &amp; 1<br>        \end{array}<br>\right ]<br>$$</p><h4 id="加权均值滤波"><a href="#加权均值滤波" class="headerlink" title="加权均值滤波"></a>加权均值滤波</h4><p>上面给出的均值滤波让人容易的就会想一个问题, 对于不同的像素位置, 应该要赋予不同的权重值, 靠近中间的位置我们必须要考虑权重的问题, 这就是我们使用加权的均值滤波了, 一般来说我们最常用的矩阵为<br>$$<br>M = \frac{1}{16} \left [<br>        \begin{array}{c}<br>            1 &amp; 2 &amp; 1 \ 2&amp; 4 &amp; 2 \ 1 &amp; 2 &amp; 1<br>        \end{array}<br>\right ]<br>$$<br> 这种矩阵对于中心元素的权重更高, 边缘的较弱, 符合人的感觉, 具体的参数值可以自己调整, 前面的系数为矩阵内各个元素的总和, 是为了保证系数的归一.</p><p>其实均值滤波器还有很多, 有兴趣的推荐看<a href="https://www.cnblogs.com/wangguchangqing/p/6399293.html" target="_blank" rel="noopener">图像处理基础(3)：均值滤波器及其变种</a> 这篇文章, 写的很好,介绍的很详细, </p><h5 id="C-手动实现均值滤波"><a href="#C-手动实现均值滤波" class="headerlink" title="C++手动实现均值滤波"></a>C++手动实现均值滤波</h5><p>我们这里还是使用基础的 算术均值滤波, 实现起来简单一点, 边界问题也不考虑, 这样的话,我们处理的图像区域就稍微内缩小一个像素(1,1)- (m-2,n-2), 至于边界问题, 处理起来还是要看<br>看起来还是比较简单的, 我们按照给出的方法写一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认 尺寸为3的  均值滤波 // 自定义实现 暂时不考虑参数异常等 处理</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">meanFilter</span><span class="params">(<span class="keyword">const</span> cv::Mat src, <span class="keyword">int</span> ksize = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 边界不处理, 直接忽略掉 使用原始图, 拷贝, 避免直接修改</span></span><br><span class="line">    cv::Mat dst = src.clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接出, 强制向下取整, // 暴力计算每一个 邻域区间的值</span></span><br><span class="line">    <span class="keyword">int</span> k0 = ksize/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> sum[<span class="number">3</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k0;i&lt;dst.rows-k0<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=k0;j&lt;dst.cols-k0<span class="number">-1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 清空 和数组</span></span><br><span class="line">            <span class="built_in">memset</span>(sum,<span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算三个通道的结果 和值 并计算 均值写入目标图像</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>;c&lt;<span class="number">3</span>;c++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>;m&lt;ksize;m++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;ksize;n++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        sum[c] += src.at&lt;cv::Vec3b&gt;(i-k0+m,j-k0+n)[c];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 计算均值写入</span></span><br><span class="line">                dst.at&lt;cv::Vec3b&gt;(i,j)[c] = cv::saturate_cast&lt;uchar&gt;((<span class="keyword">float</span>)sum[c] /(ksize*ksize));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中间部分写的比较暴力,直接计算的窗口的和值, 然后进行均值得到的结果, 其实这里如果要考虑窗口的和值, 我们没必要重复计算一次, 每次计我们移动窗口后变化的两个边界差值即可, 这样计算上的一点点速度优化, 我们这里实现的只是一个 小小的demo , 有一定的效果即可</p><h4 id="opencv-实现均值滤波"><a href="#opencv-实现均值滤波" class="headerlink" title="opencv 实现均值滤波"></a>opencv 实现均值滤波</h4><p>我们在之前的章节提到了 使用 <code>filter2D</code> 代替普通操作的方法,在这里自然而然的想到怎么去实现, 我们还是一样的构造一个核, 然后计算结果即可, 这里使用的核还是 上面提到的 算术均值滤波的核</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filter2D 实现 meanfilter</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">meanFilterByFilter2D</span><span class="params">(<span class="keyword">const</span> cv::Mat src, <span class="keyword">int</span> ksize = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat kernel = (cv::Mat_&lt;<span class="keyword">float</span>&gt;(ksize,ksize) &lt;&lt; <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    kernel = kernel / <span class="number">9.0f</span>;</span><br><span class="line">    cv::Mat dst;</span><br><span class="line">    cv::filter2D(src,dst,src.depth(),kernel);</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里实现起来真的很简单, 这里的 <code>Mat</code> 可以直接进行矩阵的操作, 每个元素都除以了9,这样就简单很多了,  </p><p>接下来呢, opencv 对于这种基础且常见的算法肯定自己去在做了实现呀, 在我们上面也提到了opencv 的例程<a href="https://docs.opencv.org/4.3.0/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html" target="_blank" rel="noopener">Smoothing Images</a>, 提到了 一个模糊的函数, <code>cv::blur</code>, 这个函数可以调用盒式滤波器, 其实也就是均值滤波的通用形式, 前面的系数不一定而已, 我们先实现一下看下效果,  这里跟上面写成一样的形式, 看起来好看一点, 其实只需要一句话便可以实现了 没什么难度,  至于效果, 我们马上来对比<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 blur 均值滤波</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">meanFilterByBlur</span><span class="params">(<span class="keyword">const</span> cv::Mat src, <span class="keyword">int</span> ksize = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat dst;</span><br><span class="line">    cv::blur(src,dst,cv::Size(ksize,ksize));</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="均值滤波算法对比"><a href="#均值滤波算法对比" class="headerlink" title="均值滤波算法对比"></a>均值滤波算法对比</h4><p>我们上面提到了构造噪声图像, 然后我们存储了起来, 这里我们选择了一副图像进行直接给结果,  这里我们选择 高椒盐噪声的图像进行测试, 然后先看结果, 第一行表示噪声图像与原始图像的参数值, 后面的三行依次是我们进行上面提到的三种实现出来的滤波方式得到的图像与原始图像进行的对比分析, 这里还是能看到比较明显的结果的, </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353 </span><br><span class="line">image-1: psnr:26.505, mssim: B:0.603292 G:0.63888 R:0.806963 </span><br><span class="line">image-2: psnr:26.7208, mssim: B:0.605704 G:0.641344 R:0.809115 </span><br><span class="line">image-3: psnr:26.7208, mssim: B:0.605704 G:0.641344 R:0.809115</span><br></pre></td></tr></table></figure><p>我们看一下测试的代码, 还是之前的界面里面的第二个按钮执行的函数,  这里我们第一个按钮是去读取我们之前存储的噪声图像, 按名称读取,<br>然后结果的时候, 我们是按照每幅图像进行的, 这里暂时 高椒盐噪声的图像, 可以在上面给出的图中看到<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局 噪声图像数组, psnr 数组 mssim 数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> IMAGE_DIR =<span class="string">"../testimages/noise/"</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Mat&gt; <span class="title">gNoiseImg</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> psnr[<span class="number">6</span>];</span><br><span class="line">cv::Scalar mssim[<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 用于读取 测试图片</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        gNoiseImg[i] = cv::imread(IMAGE_DIR + <span class="string">"lena-"</span> + <span class="built_in">std</span>::to_string(i+<span class="number">1</span>) + <span class="string">".png"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qDebug(<span class="string">"ReadOK"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString res_temp = <span class="string">"image-%1: psnr:%2, mssim: B:%3 G:%4 R:%5 "</span>;</span><br><span class="line">    QString res_str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 均值滤波 三种方式的不同</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> TEST = <span class="number">1</span>; <span class="comment">// 使用统一的图进行测试 暂时使用 高 椒盐噪声图像</span></span><br><span class="line">    psnr[TEST] = getPSNR(gSrcImg, gNoiseImg[TEST]);</span><br><span class="line">    mssim[TEST] = getMSSIM(gSrcImg,gNoiseImg[TEST]);</span><br><span class="line"></span><br><span class="line">    res_str = res_temp.arg(<span class="string">"noise"</span>)</span><br><span class="line">            .arg(psnr[TEST])</span><br><span class="line">            .arg(mssim[TEST].val[<span class="number">0</span>])</span><br><span class="line">            .arg(mssim[TEST].val[<span class="number">1</span>])</span><br><span class="line">            .arg(mssim[TEST].val[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 噪声的参数值</span></span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line"></span><br><span class="line">    cv::Mat dst[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    dst[<span class="number">0</span>] = meanFilter(gNoiseImg[TEST]);</span><br><span class="line">    dst[<span class="number">1</span>] = meanFilterByFilter2D(gNoiseImg[TEST]);</span><br><span class="line">    dst[<span class="number">2</span>] = meanFilterByBlur(gNoiseImg[TEST]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别计算三种方式得到的滤波的效果 (结果图与 原始图比较)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        psnr[TEST] = getPSNR(gSrcImg, dst[i]);</span><br><span class="line">        mssim[TEST] = getMSSIM(gSrcImg,dst[i]);</span><br><span class="line"></span><br><span class="line">        res_str = res_temp.arg(i+<span class="number">1</span>)</span><br><span class="line">                .arg(psnr[TEST])</span><br><span class="line">                .arg(mssim[TEST].val[<span class="number">0</span>])</span><br><span class="line">                .arg(mssim[TEST].val[<span class="number">1</span>])</span><br><span class="line">                .arg(mssim[TEST].val[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 噪声的参数值</span></span><br><span class="line">        ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line"></span><br><span class="line">        cv::imwrite(IMAGE_DIR + <span class="string">"dst_"</span> + <span class="built_in">std</span>::to_string(i+<span class="number">1</span>)+<span class="string">".png"</span>,dst[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的参数也能看出来, 后面两种方法得到的结果图像是一模一样的, 我们就不再进行展示, 先看 我们实现的均值滤波与自带的均值滤波的图像区别</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1588391774254.png" alt="自己实现的均值滤波与自带的均值滤波区别"></p><p>其实吧, 总体的结果上是看不出来区别的,  主要是我们的算法上没有进行边界的处理部分, 能在图的中间部分看到稍微的几个噪声点没有处理掉, 这可能也是我们的结果参数要稍微小一点的原因, 总体来说, 我们的算法还是能够进行均值滤波的, 而且跟自带的处理结果也是一致的.</p><p>我这里就有了一个疑问, 为什么我们后面的结果就一模一样了呢,blur 去调用了 filter2D? 然后我去看两个函数的调用图,  感觉问题应该是出在 <code>cv::FilterEngine::apply</code> 函数上,在后面就没去研究了</p><blockquote><p>其实这里看了好久, 看得不是很懂, 就不再叙述了, 给出这两张函数的调用图 有兴趣的自己去看</p></blockquote><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1588391773655.png" alt="filter2D 调用图"></p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/image/1588391773641.png" alt="blur 函数调用图"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实这里原本是计划一起写完的, 但是真的太伤了, 慢慢来吧, 中间容易跑偏, 因为这边还要做比较多的东西, 所以写的越来越慢, 不过至少目前兴致还是很高的 , 昨天发在博客园的文章还被 <a href="https://www.cnblogs.com/Imageshop/" target="_blank" rel="noopener">ImageShop</a> 大佬点赞, 还是很开心的,</p><p>其实越写感觉自己越虚, 很多深入的东西自己都不能说摸透了, 还是要深入去研究了 但是写的深入了看得就少了一点, 其实我尽量写的浅一点, 因为很多人最开始就是搜索 blog 找答案的, 能看懂就行,<br>我会在后面将常用的都给写完的, 尽量更新的快, 现在每天要花大量的时间去查, 去看还要写, 希望我还能坚持下去, 加油.</p><h2 id="广告"><a href="#广告" class="headerlink" title="广告"></a>广告</h2><p>就是我这里还有之前的 函数调用图都是自己使用 doxygen 和graphiz  参考<a href="https://blog.csdn.net/benkaoya/article/details/79763668" target="_blank" rel="noopener">绘制函数调用图（call graph）（4）：doxygen + graphviz</a> 自己重新生成的opencv 的文档图, 至少在用起来还是比较简单的 这个就是一个静态的网页, 我把它放在了我的 服务器上, 这样别人也能访问有需要的可以看下, 基于 opencv 4.3.0 版本的文档图 <a href="http://schen.xyz:89/opencv" target="_blank" rel="noopener">http://schen.xyz:89/opencv</a>   </p><blockquote><p>没有备案, 也没有做防护, 别搞我</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《高斯噪声_百度百科》. 见于 2020年4月30日. <a href="https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0" target="_blank" rel="noopener">https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0</a>.</li><li>《绘制函数调用图（call graph）（4）：doxygen + graphviz_运维_许振坪的专栏-CSDN博客》. 见于 2020年5月2日. <a href="https://blog.csdn.net/benkaoya/article/details/79763668" target="_blank" rel="noopener">https://blog.csdn.net/benkaoya/article/details/79763668</a>.</li><li>知乎专栏. 《【技术综述】一文道尽传统图像降噪方法》. 见于 2020年4月29日. <a href="https://zhuanlan.zhihu.com/p/51403693" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/51403693</a>.</li><li>知乎专栏. 《可复现的图像降噪算法总结》. 见于 2020年4月29日. <a href="https://zhuanlan.zhihu.com/p/32502816" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32502816</a>.</li><li>《图像噪声的成因分类与常见图像去噪算法简介_Java_qq_27606639的博客-CSDN博客》. 见于 2020年4月30日. <a href="https://blog.csdn.net/qq_27606639/article/details/80912071" target="_blank" rel="noopener">https://blog.csdn.net/qq_27606639/article/details/80912071</a>.</li><li>《最小均方滤波器》. 收入 维基百科，自由的百科全书, 2018年3月9日. <a href="https://zh.wikipedia.org/w/index.php?title=%E6%9C%80%E5%B0%8F%E5%9D%87%E6%96%B9%E6%BB%A4%E6%B3%A2%E5%99%A8&amp;oldid=48602322" target="_blank" rel="noopener">https://zh.wikipedia.org/w/index.php?title=%E6%9C%80%E5%B0%8F%E5%9D%87%E6%96%B9%E6%BB%A4%E6%B3%A2%E5%99%A8&amp;oldid=48602322</a>.</li><li>《Computer Vision: Algorithms and Applications, 1st ed.》 见于 2020年5月1日. <a href="http://szeliski.org/Book/" target="_blank" rel="noopener">http://szeliski.org/Book/</a>.</li><li>《OpenCV: Smoothing Images》. 见于 2020年5月1日. <a href="https://docs.opencv.org/4.3.0/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html" target="_blank" rel="noopener">https://docs.opencv.org/4.3.0/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html</a>.</li><li>《openCV之中值滤波&amp;均值滤波（及代码实现）<em>人工智能</em>林小默-CSDN博客》. 见于 2020年5月1日. <a href="https://blog.csdn.net/weixin_37720172/article/details/72627543" target="_blank" rel="noopener">https://blog.csdn.net/weixin_37720172/article/details/72627543</a>.</li></ol><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; title=&quot;开始之前&quot;&gt;&lt;/a&gt;开始之前&lt;/h2&gt;&lt;p&gt;再说上一篇文章中, 我们想按照噪声产生, 然后将降噪的, 但是限于篇幅, 我就放在这一篇里面了,&lt;br&gt;说起图像的噪声问题就又回到了我们上一章的内容, 把噪声当作信号处理, 实际上数字图像处理实际上也是在进行数字信号的处理过程, 我们这一章就是将滤除信号的过程,&lt;/p&gt;
&lt;p&gt;根据上一章的方式, 我们对图像添加噪声, 然后计算 PSNR 与 SSIM 参数, 然后通过降噪, 再从新计算参数值, 比较我们算法的效果 对比我们的算法效果, 看正文吧&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;p&gt;我们在上一章给出了两种噪声的添加方式, 可以根据我们的需求添加椒盐噪声和高斯噪声, 但是由于我们的噪声添加使用了随机数 , 导致我们在每次进行的结果可能不一致, 所以我们提前设计好噪声情况, 将图片存储起来, 后面我们进行滤波的时候, 都使用一样的照片, 这样我们能够保证每次的结果是一致的, 这样就能进行算法的对比了,  &lt;/p&gt;
&lt;h3 id=&quot;生成噪声图像&quot;&gt;&lt;a href=&quot;#生成噪声图像&quot; class=&quot;headerlink&quot; title=&quot;生成噪声图像&quot;&gt;&lt;/a&gt;生成噪声图像&lt;/h3&gt;&lt;p&gt;我们在上一章给出了不同噪声情况下图像结果, 也给出了一个链接, 对比了更多情况下的图像噪声情况, 可以参考, 所以我们考虑五种情况吧 分别是低椒盐噪声, 高椒盐噪声,低高斯噪声, 高高斯噪声,低椒盐混合低高斯噪声, 高椒盐混合高高斯噪声. 我们分别将图片进行存储便能够得到结果&lt;/p&gt;
&lt;p&gt;说明一下: 之前的算法使用的 lena 图像 忘记从那搞来的了, 今天对比了一下, 发现图像不太对, 我现在找到opencv的一个标准图像&lt;a href=&quot;https://raw.githubusercontent.com/opencv/opencv/master/samples/data/lena.jpg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lena.jpg&lt;/a&gt;, 我下载下来了, 转换成了 lena.png 的图像, 可以见&lt;a href=&quot;https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588298950276.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lena.png&lt;/a&gt; 这幅图, 可以直接访问链接 &lt;a href=&quot;https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588298950276.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588298950276.png&lt;/a&gt; 直接下载即可.. &lt;/p&gt;
&lt;p&gt;这里的处理算法比较简单, 我们来看代码&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainWindow::testFunc1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 用于生成 测试图像 一共6幅图像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;cv::Mat&amp;gt; &lt;span class=&quot;title&quot;&gt;noise_img&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 初始化为原始图像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; &amp;amp;m: noise_img)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        m = gSrcImg.clone();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 分别添加 低, 高, 低混合, 高混合 共6幅图像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addSaltNoise(noise_img[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addSaltNoise(noise_img[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],&lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addGaussianNoise(noise_img[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;],&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addGaussianNoise(noise_img[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;],&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addSaltNoise(noise_img[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;],&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addGaussianNoise(noise_img[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;],&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addSaltNoise(noise_img[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;],&lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addGaussianNoise(noise_img[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;],&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 计算 6幅图像的  psnr 和 ssim 然后存储结果值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;&amp;gt; &lt;span class=&quot;title&quot;&gt;psnr&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;cv::Scalar&amp;gt; &lt;span class=&quot;title&quot;&gt;mssim&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QString res_temp = &lt;span class=&quot;string&quot;&gt;&quot;image-%1: psnr:%2, mssim: B:%3 G:%4 R:%5 &quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QString res_str;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 计算每个图像的 参数值, 然后存储起来&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        psnr[i] = getPSNR(gSrcImg, noise_img[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mssim[i] = getMSSIM(gSrcImg, noise_img[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        res_str = res_temp.arg(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            .arg(psnr[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            .arg(mssim[i].val[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            .arg(mssim[i].val[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            .arg(mssim[i].val[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ui-&amp;gt;pt_log-&amp;gt;appendPlainText(res_str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cv::imwrite(&lt;span class=&quot;string&quot;&gt;&quot;../testimages/noise/lena-&quot;&lt;/span&gt; + &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::to_string(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) + &lt;span class=&quot;string&quot;&gt;&quot;.png&quot;&lt;/span&gt;, noise_img[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;我们将图片输出, 然后输出了每幅图的参数, 同时将结果图存储下来, 由于我们在实际进行图像处理的时候会有很多&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;image-1: psnr:29.4922, mssim: B:0.880587 G:0.888243 R:0.944992 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image-2: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image-3: psnr:46.8705, mssim: B:0.991138 G:0.991732 R:0.991185 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image-4: psnr:9.15966, mssim: B:0.492354 G:0.482311 R:0.680167 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image-5: psnr:29.2807, mssim: B:0.874794 G:0.881488 R:0.935624 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image-6: psnr:8.92587, mssim: B:0.392531 G:0.393254 R:0.655795&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;我这里使用之前提到的 图像”拼接” 的方式将图像拼接起来, 这样我们可以更为直观的比较, 图像尺寸都是 $512*512$, 如果需要可以裁剪出来,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CSDN 上传会自己转存图片, 上传资源比较麻烦, 懒得搞, 我这边的图片都存在了 gitee 的图床上, 原图存储的 , 有需要的可以自己取用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1588391819059.png&quot; alt=&quot;噪声图像&amp;quot;拼接&amp;quot;图&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;传统图像降噪算法及其对比&quot;&gt;&lt;a href=&quot;#传统图像降噪算法及其对比&quot; class=&quot;headerlink&quot; title=&quot;传统图像降噪算法及其对比&quot;&gt;&lt;/a&gt;传统图像降噪算法及其对比&lt;/h3&gt;&lt;p&gt;之前提到过的&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51403693&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【技术综述】一文道尽传统图像降噪方法&lt;/a&gt;&lt;br&gt; 这篇文章讲的还比较详细, 大概的给我们讲了一下传统的降噪的方法,&lt;br&gt; 这里我想将各种滤波分开进行实现, 但是比较麻烦, 我就直接在一篇文章中写了吧.. &lt;/p&gt;
&lt;p&gt; 目前常用的降噪的方法主要可以分为空域降噪与频域降噪, 空域滤波也是我们常用的使用空间处理的方式,计算量小, 简单易用. 频域比较难理解,计算量也比较大, 但是在很多情况结果比较有效.. &lt;/p&gt;
&lt;p&gt; 所以我们主要的部分也是空间域处理的方式, 也比较直观. opencv 的例程中&lt;a href=&quot;https://docs.opencv.org/4.3.0/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Smoothing Images&lt;/a&gt; 章节大概讲了一下目前使用的模糊方式, 其实模糊是相对的, 也是进行降噪的一个有利手段, 在处理掉噪声的同时, 会导致原始图像的细节模糊, 进而丢失一部分图像信息,我们之后看下图像测试结果. 同时在例程中还提到了一本书&lt;a href=&quot;http://szeliski.org/Book&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Computer Vision: Algorithms and Applications, 1st ed.&lt;/a&gt; 有中译版本, 内容还不错, 可以学习&lt;/p&gt;
&lt;h3 id=&quot;opencv-核表示的算法操作&quot;&gt;&lt;a href=&quot;#opencv-核表示的算法操作&quot; class=&quot;headerlink&quot; title=&quot;opencv 核表示的算法操作&quot;&gt;&lt;/a&gt;opencv 核表示的算法操作&lt;/h3&gt;&lt;p&gt;在之前的内容中, 我们介绍了 opencv 核操作的方式, 对于图像的每个像素点的领域操作都可以使用 opencv 提供的 &lt;code&gt;filter2D&lt;/code&gt; 方式进行指定核的运算, 我们能够很容易核的操作, 也就是说我们将图像的算法操作都可以转换成图像的矩阵相乘的运算, 可以表示成&lt;br&gt;$$&lt;br&gt;g(x,y) = M \cdot f(x,y)&lt;br&gt;$$&lt;br&gt;$g(x,y)$ 用来表示结果图像, $f(x,y)$ 表示原始图像,  (x,y) 表示 列行座标, M 就是我们的图像运算矩阵,&lt;br&gt;我们后续都不再重复这些默认的操作, 希望能够明白&lt;/p&gt;
&lt;p&gt;一般来说, 我们进行矩阵运算的时候都会选择方阵, 这样不会由于矩阵的方向性导致的处理结果不同, 所以我们在一般情况下都会选择&lt;br&gt;方阵, 比如上面进行的滤波 采用的就是 $3x3$ 尺寸的图像, 而且由于我们的图像都是离散的, 所以 实际山采用的滤波的窗口边长也是奇数值, 类似于 $3,5,7,9…(2k+1)$ 的形式&lt;/p&gt;
&lt;h3 id=&quot;均值滤波及C-代码实现&quot;&gt;&lt;a href=&quot;#均值滤波及C-代码实现&quot; class=&quot;headerlink&quot; title=&quot;均值滤波及C++ 代码实现&quot;&gt;&lt;/a&gt;均值滤波及C++ 代码实现&lt;/h3&gt;&lt;h4 id=&quot;算术均值滤波&quot;&gt;&lt;a href=&quot;#算术均值滤波&quot; class=&quot;headerlink&quot; title=&quot;算术均值滤波&quot;&gt;&lt;/a&gt;算术均值滤波&lt;/h4&gt;&lt;p&gt;均值滤波(Mean Filter)的算法就是对于每一个像素点, 将其设定为取其邻域窗口内的所有像素的平均值&lt;br&gt;我们考虑一般形式的均值滤波器&lt;br&gt;$$&lt;br&gt;g(x,y) = \frac{1}{mn} \sum_{(i,j) \in S_{xy}} f(i,j)&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;那我们开始转换一下, 则可以得到下相应的 均值滤波的矩阵&lt;br&gt;$$&lt;br&gt;M = \frac{1}{9} \left [&lt;br&gt;        \begin{array}{c}&lt;br&gt;            1 &amp;amp; 1 &amp;amp; 1 \ 1&amp;amp; 1 &amp;amp; 1 \ 1 &amp;amp; 1 &amp;amp; 1&lt;br&gt;        \end{array}&lt;br&gt;\right ]&lt;br&gt;$$&lt;/p&gt;
&lt;h4 id=&quot;加权均值滤波&quot;&gt;&lt;a href=&quot;#加权均值滤波&quot; class=&quot;headerlink&quot; title=&quot;加权均值滤波&quot;&gt;&lt;/a&gt;加权均值滤波&lt;/h4&gt;&lt;p&gt;上面给出的均值滤波让人容易的就会想一个问题, 对于不同的像素位置, 应该要赋予不同的权重值, 靠近中间的位置我们必须要考虑权重的问题, 这就是我们使用加权的均值滤波了, 一般来说我们最常用的矩阵为&lt;br&gt;$$&lt;br&gt;M = \frac{1}{16} \left [&lt;br&gt;        \begin{array}{c}&lt;br&gt;            1 &amp;amp; 2 &amp;amp; 1 \ 2&amp;amp; 4 &amp;amp; 2 \ 1 &amp;amp; 2 &amp;amp; 1&lt;br&gt;        \end{array}&lt;br&gt;\right ]&lt;br&gt;$$&lt;br&gt; 这种矩阵对于中心元素的权重更高, 边缘的较弱, 符合人的感觉, 具体的参数值可以自己调整, 前面的系数为矩阵内各个元素的总和, 是为了保证系数的归一.&lt;/p&gt;
&lt;p&gt;其实均值滤波器还有很多, 有兴趣的推荐看&lt;a href=&quot;https://www.cnblogs.com/wangguchangqing/p/6399293.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图像处理基础(3)：均值滤波器及其变种&lt;/a&gt; 这篇文章, 写的很好,介绍的很详细, &lt;/p&gt;
&lt;h5 id=&quot;C-手动实现均值滤波&quot;&gt;&lt;a href=&quot;#C-手动实现均值滤波&quot; class=&quot;headerlink&quot; title=&quot;C++手动实现均值滤波&quot;&gt;&lt;/a&gt;C++手动实现均值滤波&lt;/h5&gt;&lt;p&gt;我们这里还是使用基础的 算术均值滤波, 实现起来简单一点, 边界问题也不考虑, 这样的话,我们处理的图像区域就稍微内缩小一个像素(1,1)- (m-2,n-2), 至于边界问题, 处理起来还是要看&lt;br&gt;看起来还是比较简单的, 我们按照给出的方法写一下&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 默认 尺寸为3的  均值滤波 // 自定义实现 暂时不考虑参数异常等 处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;cv::Mat &lt;span class=&quot;title&quot;&gt;meanFilter&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; cv::Mat src, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ksize = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 边界不处理, 直接忽略掉 使用原始图, 拷贝, 避免直接修改&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat dst = src.clone();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 直接出, 强制向下取整, // 暴力计算每一个 邻域区间的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k0 = ksize/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sum[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] = &amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=k0;i&amp;lt;dst.rows-k0&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=k0;j&amp;lt;dst.cols-k0&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 清空 和数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;memset&lt;/span&gt;(sum,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(sum));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 计算三个通道的结果 和值 并计算 均值写入目标图像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; c = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;c&amp;lt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;c++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; m = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;m&amp;lt;ksize;m++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;n&amp;lt;ksize;n++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        sum[c] += src.at&amp;lt;cv::Vec3b&amp;gt;(i-k0+m,j-k0+n)[c];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// 计算均值写入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                dst.at&amp;lt;cv::Vec3b&amp;gt;(i,j)[c] = cv::saturate_cast&amp;lt;uchar&amp;gt;((&lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt;)sum[c] /(ksize*ksize));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dst;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;中间部分写的比较暴力,直接计算的窗口的和值, 然后进行均值得到的结果, 其实这里如果要考虑窗口的和值, 我们没必要重复计算一次, 每次计我们移动窗口后变化的两个边界差值即可, 这样计算上的一点点速度优化, 我们这里实现的只是一个 小小的demo , 有一定的效果即可&lt;/p&gt;
&lt;h4 id=&quot;opencv-实现均值滤波&quot;&gt;&lt;a href=&quot;#opencv-实现均值滤波&quot; class=&quot;headerlink&quot; title=&quot;opencv 实现均值滤波&quot;&gt;&lt;/a&gt;opencv 实现均值滤波&lt;/h4&gt;&lt;p&gt;我们在之前的章节提到了 使用 &lt;code&gt;filter2D&lt;/code&gt; 代替普通操作的方法,在这里自然而然的想到怎么去实现, 我们还是一样的构造一个核, 然后计算结果即可, 这里使用的核还是 上面提到的 算术均值滤波的核&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// filter2D 实现 meanfilter&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;cv::Mat &lt;span class=&quot;title&quot;&gt;meanFilterByFilter2D&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; cv::Mat src, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ksize = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat kernel = (cv::Mat_&amp;lt;&lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt;&amp;gt;(ksize,ksize) &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kernel = kernel / &lt;span class=&quot;number&quot;&gt;9.0f&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat dst;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::filter2D(src,dst,src.depth(),kernel);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dst;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里实现起来真的很简单, 这里的 &lt;code&gt;Mat&lt;/code&gt; 可以直接进行矩阵的操作, 每个元素都除以了9,这样就简单很多了,  &lt;/p&gt;
&lt;p&gt;接下来呢, opencv 对于这种基础且常见的算法肯定自己去在做了实现呀, 在我们上面也提到了opencv 的例程&lt;a href=&quot;https://docs.opencv.org/4.3.0/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Smoothing Images&lt;/a&gt;, 提到了 一个模糊的函数, &lt;code&gt;cv::blur&lt;/code&gt;, 这个函数可以调用盒式滤波器, 其实也就是均值滤波的通用形式, 前面的系数不一定而已, 我们先实现一下看下效果,  这里跟上面写成一样的形式, 看起来好看一点, 其实只需要一句话便可以实现了 没什么难度,  至于效果, 我们马上来对比&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用 blur 均值滤波&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;cv::Mat &lt;span class=&quot;title&quot;&gt;meanFilterByBlur&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; cv::Mat src, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ksize = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat dst;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::blur(src,dst,cv::Size(ksize,ksize));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dst;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;均值滤波算法对比&quot;&gt;&lt;a href=&quot;#均值滤波算法对比&quot; class=&quot;headerlink&quot; title=&quot;均值滤波算法对比&quot;&gt;&lt;/a&gt;均值滤波算法对比&lt;/h4&gt;&lt;p&gt;我们上面提到了构造噪声图像, 然后我们存储了起来, 这里我们选择了一副图像进行直接给结果,  这里我们选择 高椒盐噪声的图像进行测试, 然后先看结果, 第一行表示噪声图像与原始图像的参数值, 后面的三行依次是我们进行上面提到的三种实现出来的滤波方式得到的图像与原始图像进行的对比分析, 这里还是能看到比较明显的结果的, &lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;image-noise: psnr:19.4727, mssim: B:0.353134 G:0.383638 R:0.629353 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image-1: psnr:26.505, mssim: B:0.603292 G:0.63888 R:0.806963 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image-2: psnr:26.7208, mssim: B:0.605704 G:0.641344 R:0.809115 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image-3: psnr:26.7208, mssim: B:0.605704 G:0.641344 R:0.809115&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们看一下测试的代码, 还是之前的界面里面的第二个按钮执行的函数,  这里我们第一个按钮是去读取我们之前存储的噪声图像, 按名称读取,&lt;br&gt;然后结果的时候, 我们是按照每幅图像进行的, 这里暂时 高椒盐噪声的图像, 可以在上面给出的图中看到&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 全局 噪声图像数组, psnr 数组 mssim 数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; IMAGE_DIR =&lt;span class=&quot;string&quot;&gt;&quot;../testimages/noise/&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;cv::Mat&amp;gt; &lt;span class=&quot;title&quot;&gt;gNoiseImg&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; psnr[&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cv::Scalar mssim[&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainWindow::testFunc1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 用于读取 测试图片&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        gNoiseImg[i] = cv::imread(IMAGE_DIR + &lt;span class=&quot;string&quot;&gt;&quot;lena-&quot;&lt;/span&gt; + &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::to_string(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) + &lt;span class=&quot;string&quot;&gt;&quot;.png&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    qDebug(&lt;span class=&quot;string&quot;&gt;&quot;ReadOK&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainWindow::testFunc2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QString res_temp = &lt;span class=&quot;string&quot;&gt;&quot;image-%1: psnr:%2, mssim: B:%3 G:%4 R:%5 &quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QString res_str;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 测试 均值滤波 三种方式的不同&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; TEST = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 使用统一的图进行测试 暂时使用 高 椒盐噪声图像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    psnr[TEST] = getPSNR(gSrcImg, gNoiseImg[TEST]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mssim[TEST] = getMSSIM(gSrcImg,gNoiseImg[TEST]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res_str = res_temp.arg(&lt;span class=&quot;string&quot;&gt;&quot;noise&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .arg(psnr[TEST])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .arg(mssim[TEST].val[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .arg(mssim[TEST].val[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .arg(mssim[TEST].val[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 噪声的参数值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui-&amp;gt;pt_log-&amp;gt;appendPlainText(res_str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat dst[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dst[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = meanFilter(gNoiseImg[TEST]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dst[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = meanFilterByFilter2D(gNoiseImg[TEST]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dst[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] = meanFilterByBlur(gNoiseImg[TEST]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 分别计算三种方式得到的滤波的效果 (结果图与 原始图比较)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        psnr[TEST] = getPSNR(gSrcImg, dst[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mssim[TEST] = getMSSIM(gSrcImg,dst[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        res_str = res_temp.arg(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .arg(psnr[TEST])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .arg(mssim[TEST].val[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .arg(mssim[TEST].val[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .arg(mssim[TEST].val[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 噪声的参数值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ui-&amp;gt;pt_log-&amp;gt;appendPlainText(res_str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cv::imwrite(IMAGE_DIR + &lt;span class=&quot;string&quot;&gt;&quot;dst_&quot;&lt;/span&gt; + &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::to_string(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)+&lt;span class=&quot;string&quot;&gt;&quot;.png&quot;&lt;/span&gt;,dst[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;从上面的参数也能看出来, 后面两种方法得到的结果图像是一模一样的, 我们就不再进行展示, 先看 我们实现的均值滤波与自带的均值滤波的图像区别&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1588391774254.png&quot; alt=&quot;自己实现的均值滤波与自带的均值滤波区别&quot;&gt;&lt;/p&gt;
&lt;p&gt;其实吧, 总体的结果上是看不出来区别的,  主要是我们的算法上没有进行边界的处理部分, 能在图的中间部分看到稍微的几个噪声点没有处理掉, 这可能也是我们的结果参数要稍微小一点的原因, 总体来说, 我们的算法还是能够进行均值滤波的, 而且跟自带的处理结果也是一致的.&lt;/p&gt;
&lt;p&gt;我这里就有了一个疑问, 为什么我们后面的结果就一模一样了呢,blur 去调用了 filter2D? 然后我去看两个函数的调用图,  感觉问题应该是出在 &lt;code&gt;cv::FilterEngine::apply&lt;/code&gt; 函数上,在后面就没去研究了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其实这里看了好久, 看得不是很懂, 就不再叙述了, 给出这两张函数的调用图 有兴趣的自己去看&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1588391773655.png&quot; alt=&quot;filter2D 调用图&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1588391773641.png&quot; alt=&quot;blur 函数调用图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;其实这里原本是计划一起写完的, 但是真的太伤了, 慢慢来吧, 中间容易跑偏, 因为这边还要做比较多的东西, 所以写的越来越慢, 不过至少目前兴致还是很高的 , 昨天发在博客园的文章还被 &lt;a href=&quot;https://www.cnblogs.com/Imageshop/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ImageShop&lt;/a&gt; 大佬点赞, 还是很开心的,&lt;/p&gt;
&lt;p&gt;其实越写感觉自己越虚, 很多深入的东西自己都不能说摸透了, 还是要深入去研究了 但是写的深入了看得就少了一点, 其实我尽量写的浅一点, 因为很多人最开始就是搜索 blog 找答案的, 能看懂就行,&lt;br&gt;我会在后面将常用的都给写完的, 尽量更新的快, 现在每天要花大量的时间去查, 去看还要写, 希望我还能坚持下去, 加油.&lt;/p&gt;
&lt;h2 id=&quot;广告&quot;&gt;&lt;a href=&quot;#广告&quot; class=&quot;headerlink&quot; title=&quot;广告&quot;&gt;&lt;/a&gt;广告&lt;/h2&gt;&lt;p&gt;就是我这里还有之前的 函数调用图都是自己使用 doxygen 和graphiz  参考&lt;a href=&quot;https://blog.csdn.net/benkaoya/article/details/79763668&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;绘制函数调用图（call graph）（4）：doxygen + graphviz&lt;/a&gt; 自己重新生成的opencv 的文档图, 至少在用起来还是比较简单的 这个就是一个静态的网页, 我把它放在了我的 服务器上, 这样别人也能访问有需要的可以看下, 基于 opencv 4.3.0 版本的文档图 &lt;a href=&quot;http://schen.xyz:89/opencv&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://schen.xyz:89/opencv&lt;/a&gt;   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;没有备案, 也没有做防护, 别搞我&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;《高斯噪声_百度百科》. 见于 2020年4月30日. &lt;a href=&quot;https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《绘制函数调用图（call graph）（4）：doxygen + graphviz_运维_许振坪的专栏-CSDN博客》. 见于 2020年5月2日. &lt;a href=&quot;https://blog.csdn.net/benkaoya/article/details/79763668&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/benkaoya/article/details/79763668&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;知乎专栏. 《【技术综述】一文道尽传统图像降噪方法》. 见于 2020年4月29日. &lt;a href=&quot;https://zhuanlan.zhihu.com/p/51403693&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/51403693&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;知乎专栏. 《可复现的图像降噪算法总结》. 见于 2020年4月29日. &lt;a href=&quot;https://zhuanlan.zhihu.com/p/32502816&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/32502816&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《图像噪声的成因分类与常见图像去噪算法简介_Java_qq_27606639的博客-CSDN博客》. 见于 2020年4月30日. &lt;a href=&quot;https://blog.csdn.net/qq_27606639/article/details/80912071&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_27606639/article/details/80912071&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《最小均方滤波器》. 收入 维基百科，自由的百科全书, 2018年3月9日. &lt;a href=&quot;https://zh.wikipedia.org/w/index.php?title=%E6%9C%80%E5%B0%8F%E5%9D%87%E6%96%B9%E6%BB%A4%E6%B3%A2%E5%99%A8&amp;amp;oldid=48602322&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.wikipedia.org/w/index.php?title=%E6%9C%80%E5%B0%8F%E5%9D%87%E6%96%B9%E6%BB%A4%E6%B3%A2%E5%99%A8&amp;amp;oldid=48602322&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《Computer Vision: Algorithms and Applications, 1st ed.》 见于 2020年5月1日. &lt;a href=&quot;http://szeliski.org/Book/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://szeliski.org/Book/&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《OpenCV: Smoothing Images》. 见于 2020年5月1日. &lt;a href=&quot;https://docs.opencv.org/4.3.0/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.opencv.org/4.3.0/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《openCV之中值滤波&amp;amp;均值滤波（及代码实现）&lt;em&gt;人工智能&lt;/em&gt;林小默-CSDN博客》. 见于 2020年5月1日. &lt;a href=&quot;https://blog.csdn.net/weixin_37720172/article/details/72627543&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/weixin_37720172/article/details/72627543&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="opencv" scheme="https://schen1024.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://schen1024.github.io/tags/opencv/"/>
    
      <category term="c++" scheme="https://schen1024.github.io/tags/c/"/>
    
      <category term="qt" scheme="https://schen1024.github.io/tags/qt/"/>
    
  </entry>
  
  <entry>
    <title>Imagelab-1-QT 工程重构</title>
    <link href="https://schen1024.github.io/2020/04-29/Imagelab-1-QTopencv.html"/>
    <id>https://schen1024.github.io/2020/04-29/Imagelab-1-QTopencv.html</id>
    <published>2020-04-29T16:30:50.000Z</published>
    <updated>2023-01-01T13:25:24.230Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="6a333a986f47f9659f0da474f6ce148376621420a997feb8e710cbd7b08de41c">bd25ed9264b080267271e137e33d0ce1adc3c6b2bac6ceb0572e33f68e974c79e34a7374044cfdd6dd6cda34443dc29b66e05da005317270a00d4a8380d153e8e349bbba3aeb2543391b9b42d90dc286d8beef59fc4f15f66e60c2592e6407fcd70b569c3bf4bdc3deca05f0147db48fa3de3a4bd0627d8b1962354a7914384b7013716b7d75409cb76495fb10ba8fb6308c5415fc0d9f32202ce15c76d37686619cd2daa317f0f2c809bcbdd825d613d770d60e1279c79e72f38e70601a4202436d6cb3c36fb0258e9a7ae3f53cc362ccb44fc0252e566e79b22c339a88760cb9411b05a0e341f4d2f5723e2a6978302d10690b14f2563caad2bbaebe213777008cd30adb77d59881c50258af19b0f914fee20092b45314fffaf3c35e3df9d0550c87b9614c4f565423b74417846c96199a910d1d3a6668019b965e21aeea136dc314b1d5ae675e4cc3e354a06a3bf2bddf9e394bce03c4e7dd316316c71926dc4394f1a114324ca86e84c9d3da824fc8678be694c3fb09366dca0a081d75a9ae81e53b93e297c6a46d2bbcd7038b6739a6964537740201a6b31a1866dbd3041bfe96376dc774fafc07313971f796b2fa8fd5853bd8a2433bb04977d116e7832b80c2505a7bb6ad80ddb0be98ff8a8d7627097d02a04fa7ef4fb4f06a4a7c29d4d622a288ecee895d6f0c97f63cfcff1022ddaee223bc4b18961ed8056d41ba40f3ff107f6b1225877ab73501e73c9c173de941b8cd4261851cbbb882b552083dd93e7bec943d89f81b03e336940891bae5d78973d822d853246dff48654fcdf134a3bcd466ac1e61dc2fe1ea7e2d1532ff6d6e11cfb4461496e163da95b18a3e7fd2cbddb3d569a190cb5cc93a5849c8c1e7b5c7704dead6dd69116dbb42088b8bfb7142aded51c56c53d89aeea6359bb9ed7f518a1ecd87430fc5db6e887401683febcd566a72f778431624b1edd6d4f479de685eaa813b921491c7d6ee60ec29ee2919e249ee0862d3ec105a596db270ad594393dff1cbac04a67cba300f67e3c6167b084203a9f20fe98659b124f0e71431c7ac37fa499e4f65be9e44d268aef90be1784250d94d00d0983dfefdabd0472763f53c3cdb69354c7238f94ee84a18e5a6de5b350ad0b15f49ed7f91cc141e39a9b33d610492347e78eb7eeedc4ee1f3349f49350a662853b37fece120651cef8ffff871f531d0e0457931ee002437cd40c21af8745dfccc564f4731985aa52ba82ccba18c812f10f369ede871864442255e449f8f878e2aa8d624b167079f5332a9703c59bae1e1ddd6462b864d6e15c8962944d6238cb5b3a0f26c5594d7eba5209142d432d965e92797b4b0dc3374eea33f13dc4a9643eb39245bc3612e6e9be0f4b0461103a5df1b91bb9ddd4a16b35abd4f8da02c8c411be50e1e5a4194a7a846ad6a275926ac1c21133d3555ee259f2fcb1d25ae73fcf1eac02b3c62487d84a62ceab540b7fad343f99accf50ff51e9fb5031415831e45641f3e2375fbd816d4066247f8e31e2e25ecc5aa10347bb6bf00dcb48bd9e99e20bf</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码, 查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      这是一篇加密文章，内容可能是个人情感宣泄或者收费技术。暂时不对外进行开放,之后给想看的人看,十分抱歉,如果你确实想看，请与我联系。
    
    </summary>
    
    
      <category term="Technology" scheme="https://schen1024.github.io/categories/Technology/"/>
    
    
      <category term="encrypt" scheme="https://schen1024.github.io/tags/encrypt/"/>
    
      <category term="hide" scheme="https://schen1024.github.io/tags/hide/"/>
    
      <category term="opencv" scheme="https://schen1024.github.io/tags/opencv/"/>
    
      <category term="c++" scheme="https://schen1024.github.io/tags/c/"/>
    
      <category term="qt" scheme="https://schen1024.github.io/tags/qt/"/>
    
      <category term="imagelab" scheme="https://schen1024.github.io/tags/imagelab/"/>
    
  </entry>
  
  <entry>
    <title>opencv-9-图像噪声以及评估指标 PSNR 与SSIM</title>
    <link href="https://schen1024.github.io/2020/04-28/opencv-9-noise.html"/>
    <id>https://schen1024.github.io/2020/04-28/opencv-9-noise.html</id>
    <published>2020-04-28T19:10:26.000Z</published>
    <updated>2023-01-01T13:25:24.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>我们在将 opencv 的图像显示在了 qt 的label 上, 我们能够将图显示在label 上, 用于显示我们的算法,<br>我们在 opencv 上一篇文章中介绍了 opencv 的核操作, 我们这里就要进入一个很重要的章节了,图像滤波操作, 也是图像核操作应用的一个很重要的章节, </p><p>那我们就从降噪的角度完整的讲一下, 并通过 opencv 核的方式进行图像算法操作, <a href="https://zhuanlan.zhihu.com/p/51403693" target="_blank" rel="noopener">【技术综述】一文道尽传统图像降噪方法</a> 这篇文章写的还算比较完整, 也是传统的算法的一个综述过程, </p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数字成像过程中由于电噪声以及其他因素, 导致我们获取到的图像存在噪声,噪声出现在输入部分, 在后续的每个步骤都会受到影响, 所以在数字图像处理的前面必须要进行的一个步骤就是 <a href="https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F%E9%99%8D%E5%99%AA/4136566" target="_blank" rel="noopener">图像降噪</a> </p><p>每个做信号处理的都会接触到一类问题 , 信号降噪, 让人最头疼的一门课,真是感谢老师给过, 但是后面自己用到的时候反而感觉真的好用, 原来是这样, 然后就慢慢学会了怎么使用吧..(感觉还是弱鸡)<br>知乎<a href="https://zhuanlan.zhihu.com/p/32502816" target="_blank" rel="noopener">可复现的图像降噪算法总结</a>这篇文章列出了一个能够复现的图像降噪操作算法列表, 近年来实现了的算法可以见<a href="https://github.com/wenbihan/reproducible-image-denoising-state-of-the-art" target="_blank" rel="noopener">reproducible-image-denoising-state-of-the-art</a>, 之后使用相应的文章进行算法实现吧.( 又立了一个 flag )</p><h2 id="图像降噪理论基础"><a href="#图像降噪理论基础" class="headerlink" title="图像降噪理论基础"></a>图像降噪理论基础</h2><p>图像降噪主要的目的是在进行去除图像噪声的同时保留尽可能多的主要特征, 对于人眼来说, 区分噪声还算比较容易, 但是对于计算机来说,输入的都是数据, 我怎么区分哪个是噪声, 哪个不是噪声呢, 这里就要引入噪声的理论基础了</p><h3 id="图像噪声的产生"><a href="#图像噪声的产生" class="headerlink" title="图像噪声的产生"></a>图像噪声的产生</h3><p>我们在之前的章节介绍了图像的程序系统, 实际上在成像过程中可能由于点噪声, 量化过程等造成噪声,<br>实际上的噪声主要分为三种: </p><ol><li>加性噪声: 与输入无关,  $f(x,y) = g(x,y) +n(x,y)$</li><li>乘性噪声: 与输入信号有关, $f(x,y) =  g(x,y) + n(x,y) \cdot g(x,y)$</li><li>量化噪声: 与输入无关, 在图像量化过程噪声的量化误差导致的噪声, </li></ol><p>实际上后两种很难解决, 目前处理的都是以 加性噪声为主, 属于随机的噪声信号, 根据统计学的观点, 噪声在无限长时间窗内的噪声和为0, 在第一类中的 $n(x,y)$ 随着时间存在正负信号的不确定变化.</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588225720321.png" alt="噪声零和特点"></p><blockquote><p>上图所示虚线代表真实信号，红蓝线表示的就是随机噪声信号，所有的随机噪声信号求和后结果为0。</p></blockquote><p>这里关于噪声的说明可以参考<a href="https://www.cnblogs.com/CCBB/archive/2011/01/06/1929033.html" target="_blank" rel="noopener">图像去噪算法简介</a></p><blockquote><p>噪声在理论上可以定义为“不可预测，只能用概率统计方法来认识的随机误差”。因此将图像噪声看成是多维随机过程是合适的，因而描述噪声的方法完全可以借用随机过程的描述，即用其概率分布函数和概率密度分布函数。但在很多情况下，这样的描述方法是很复杂的，甚至是不可能的。而实际应用往往也不必要。通常是用其数字特征，即均值方差，相关函数等。因为这些数字特征都可以从某些方面反映出噪声的特征。</p></blockquote><p>我认为<a href="https://blog.csdn.net/qq_27606639/article/details/80912071" target="_blank" rel="noopener">图像噪声的成因分类与常见图像去噪算法简介</a>这篇文章关于噪声的分类部分讲的还比较细, 可以参考</p><h3 id="图像噪声的模型"><a href="#图像噪声的模型" class="headerlink" title="图像噪声的模型"></a>图像噪声的模型</h3><p>由于我们认为噪声在时间尺度的随机性, 但是我们可以使用噪声的概率分布与概率密度函数进行描述, 那么我们就能将噪声根据其分布特点进行分类,<br>我们稍微介绍一下常见的噪声模型吧</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588225720295.png" alt="一些重要的噪声概率密度函数"></p><p>噪声模型主要可以分为: </p><ul><li>高斯噪声，高斯噪声模型经常被用于实践中。</li><li>脉冲噪声（椒盐噪声），图像上一个个点，也可称为散粒和尖峰噪声。</li><li>伽马噪声</li><li>瑞利噪声</li><li>指数分布噪声</li><li>均匀分布噪声</li></ul><p>这里能查到的资料很多, 可以看我们的参考部分, 内容都一样, 再写只是浪费时间和精力, 有兴趣的可以自己翻阅</p><h2 id="图像降噪操作"><a href="#图像降噪操作" class="headerlink" title="图像降噪操作"></a>图像降噪操作</h2><p>其实吧, 我就不应该讲那么多, 直接开始图像处理部分就行了, 为了开始进行图像处理, 我们要先进行一点小工作, 我们要按造以下步骤进行降噪算法的比较, </p><ol><li>选择标准图像— lena.png</li><li>添加噪声</li><li>量化噪声</li><li>降噪操作</li><li>量化结果值</li><li>比较结果</li></ol><p>在我们进行算法比对之前, 我们选择的是 lena 的图像, 加入随机噪声, 然后计算出来 一个噪声的比例, 进行降噪操作, 再次计算以下噪声参数, 看下效果值.</p><blockquote><p>如果是进行算法比较的时候, 最好选择现有的降噪的数据集进行比较, 比如, <a href="http://r0k.us/graphics/kodak/" target="_blank" rel="noopener">Kodak</a> , <a href="https://www2.eecs.berkeley.edu/Research/Projects/CS/vision/bsds/" target="_blank" rel="noopener">BSD</a></p></blockquote><h3 id="噪声添加"><a href="#噪声添加" class="headerlink" title="噪声添加"></a>噪声添加</h3><p>我们认为噪声是随机的, 我们生成随机数加在原始图像上便能够得到噪声图像, opencv 没有提供相应的实现, 但是知道原理了, 写起来都比较简单, 我比较喜欢<br><a href="https://www.cnblogs.com/wangguchangqing/p/6372025.html" target="_blank" rel="noopener">图像处理基础(1)：噪声的添加和过滤</a> 使用的方法, 他使用的是 <a href="https://zh.wikipedia.org/zh-hans/%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">梅森旋转算法</a>  来实现的伪随机算法, </p><blockquote><p>其实吧这里我也不懂, 但是随机数能用就行了, 我又不是数学家, 然后看到了 <a href="https://liam.page/2018/01/12/Mersenne-twister/" target="_blank" rel="noopener">谈谈梅森旋转：算法及其爆破</a></p></blockquote><p>这里就不重复造轮子了, 直接复制他给出的代码就好,<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加椒盐噪声 // 生成 随机 num 个 白点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSaltNoise</span><span class="params">(Mat &amp;m, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">true<span class="comment">// 随机数产生器</span></span><br><span class="line">true<span class="built_in">std</span>::random_device rd; <span class="comment">//种子</span></span><br><span class="line">true<span class="function"><span class="built_in">std</span>::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>; <span class="comment">// 随机数引擎</span></span><br><span class="line"></span><br><span class="line">true<span class="keyword">auto</span> cols = m.cols * m.channels();</span><br><span class="line"></span><br><span class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">true&#123;</span><br><span class="line">truetrue<span class="keyword">auto</span> row = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(gen() % m.rows);</span><br><span class="line">truetrue<span class="keyword">auto</span> col = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(gen() % cols);</span><br><span class="line"></span><br><span class="line">truetrue<span class="keyword">auto</span> p = m.ptr&lt;uchar&gt;(row);</span><br><span class="line">truetruep[col++] = <span class="number">255</span>;</span><br><span class="line">truetruep[col++] = <span class="number">255</span>;</span><br><span class="line">truetruep[col] = <span class="number">255</span>;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加Gussia噪声</span></span><br><span class="line"><span class="comment">// 使用指针访问</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addGaussianNoise</span><span class="params">(Mat &amp;m, <span class="keyword">int</span> mu, <span class="keyword">int</span> sigma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">true<span class="comment">// 产生高斯分布随机数发生器</span></span><br><span class="line">true<span class="built_in">std</span>::random_device rd;</span><br><span class="line">true<span class="function"><span class="built_in">std</span>::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="function"><span class="built_in">std</span>::normal_distribution&lt;&gt; <span class="title">d</span><span class="params">(mu, sigma)</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="keyword">auto</span> rows = m.rows; <span class="comment">// 行数</span></span><br><span class="line">true<span class="keyword">auto</span> cols = m.cols * m.channels(); <span class="comment">// 列数</span></span><br><span class="line"></span><br><span class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">true&#123;</span><br><span class="line">truetrue<span class="keyword">auto</span> p = m.ptr&lt;uchar&gt;(i); <span class="comment">// 取得行首指针</span></span><br><span class="line">truetrue<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">truetrue&#123;</span><br><span class="line">truetruetrue<span class="keyword">auto</span> tmp = p[j] + d(gen);</span><br><span class="line">truetruetruetmp = tmp &gt; <span class="number">255</span> ? <span class="number">255</span> : tmp;</span><br><span class="line">truetruetruetmp = tmp &lt; <span class="number">0</span> ? <span class="number">0</span> : tmp;</span><br><span class="line">truetruetruep[j] = tmp;</span><br><span class="line">truetrue&#125;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="噪声量化方法"><a href="#噪声量化方法" class="headerlink" title="噪声量化方法"></a>噪声量化方法</h3><p>这里其实涉及到图像质量评估的领域,可以参考<a href="https://blog.csdn.net/qq_23304241/article/details/80953613" target="_blank" rel="noopener">图像质量评价概述（评估指标、传统检测方法）</a>介绍的方法, 存在太多的计算方式, </p><p>我们必须选择一个量化噪声的方式进行图像质量的评估, 一般进行噪声评估手段就是噪声比(Signal to Noise Ratio,SNR),峰值信噪比(Peak Signal to Noise Ratio, PSNR) , 均方差值(Mean Square Error, MSE), 结构相似性(Structural SIMilarity, SSIM),</p><p>我们一个一个来看, 均方差值是用于比较两幅图像 K, I 的均方差值<br>$$<br>MSE=\frac{1}{mn}\sum_{i=0}^{n-1}\sum_{j=0}^{m-1}\parallel K(i,j)-I(i,j)\parallel^{2}<br>$$</p><p>峰值信噪比PSNR衡量图像失真或是噪声水平的客观标准。2个图像之间PSNR值越大，则越相似。普遍基准为30dB，30dB以下的图像劣化较为明显。定义为，<br>$$<br>PSNR=10log_{10}(\frac{MAX^{2}}{MSE})<br>$$<br>其中$MAX^2$ 为图片可能的最大像素值。如果每个像素都由 8 位二进制来表示，那么就为 255。</p><p>SNR用于描述信号与噪声的比值<br>$$<br>SNR (dB)=10 log_{10}<br>\left[<br>\frac{\sum_{x=0}^{m-1} \sum_{y=0}^{n-1}(f(x, y))^{2}}{\sum_{x=0}^{m-1} \sum_{y=0}^{n-1}(f(x, y)-\hat{f}(x, y))^{2}}\right]<br>$$</p><p>SSIM 描述两个图像的相似性, 通过三个进行比较, 亮度,对比度和结构, 参考<a href="https://zhuanlan.zhihu.com/p/50757421" target="_blank" rel="noopener">图像质量评价指标之 PSNR 和 SSIM</a></p><p>$$l(x, y)=\frac{2 \mu_{x} \mu_{y}+c_{1}}{\mu_{x}^{2}+\mu_{y}^{2}+c_{1}} c(x, y)=\frac{2 \sigma_{x} \sigma_{y}+c_{2}}{\sigma_{x}^{2}+\sigma_{y}^{2}+c_{2}} s(x, y)=\frac{\sigma_{x y}+c_{3}}{\sigma_{x} \sigma_{y}+c_{3}}$$</p><p>$$\operatorname{SSIM}(x, y)=\frac{\left(2 \mu_{x} \mu_{y}+c_{1}\right)\left(2 \sigma_{x y}+c_{2}\right)}{\left(\mu_{x}^{2}+\mu_{y}^{2}+c_{1}\right)\left(\sigma_{x}^{2}+\sigma_{y}^{2}+c_{2}\right)}$$<br>一般取$c_3 = \frac{c_2}{2}$。<br>$u_x$ 为 $x$  的均值<br>$u_y$ 为 $y$ 的均值<br>$\sigma_x^2$ 为$x$ 的方差<br>$\sigma_y^2$ 为$y$ 的方差<br>$\sigma_{xy}$ 为$x$ 和$y$ 的协方差<br>$c_1 = (k_1 L)^2, c_2=(k_2 L)^2$ 为两个常数，避免除零<br>$L$ 为像素值的范围，$(0,255)$<br>$k_1 = 0.01, k_2 = 0.03$ 为默认值<br>默认参数$\alpha = 1, \beta = 1, \gamma = 1$ </p><h3 id="opencv-计算-PSNR-和-SSIM"><a href="#opencv-计算-PSNR-和-SSIM" class="headerlink" title="opencv 计算 PSNR 和 SSIM"></a>opencv 计算 PSNR 和 SSIM</h3><p>本来不想写这么多的, 但是 opencv 给出了一个例程<a href="https://docs.opencv.org/4.3.0/dd/d3d/tutorial_gpu_basics_similarity.html" target="_blank" rel="noopener">Similarity check (PNSR and SSIM) on the GPU</a>, 提供了计算的方法, 自己不用去写了, 岂不是很爽, 所以上面就详细介绍了各个方法的使用.<br>官方给出了普通版本以及 GPU 加速的版本, 我们暂时只使用基础的版本就好,<br>PSNR返回一个浮点数，如果两个输入在30到50之间相似（越高越好）。<br>SSIM返回图像的MSSIM。这也是一个介于零和一之间的浮点数（越高越好），但是每个通道都有一个浮点数。因此，我们返回一个Scalar OpenCV数据结构：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPSNR</span><span class="params">(<span class="keyword">const</span> Mat&amp; I1, <span class="keyword">const</span> Mat&amp; I2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat s1;</span><br><span class="line">    absdiff(I1, I2, s1);       <span class="comment">// |I1 - I2|</span></span><br><span class="line">    s1.convertTo(s1, CV_32F);  <span class="comment">// cannot make a square on 8 bits</span></span><br><span class="line">    s1 = s1.mul(s1);           <span class="comment">// |I1 - I2|^2</span></span><br><span class="line">    Scalar s = sum(s1);         <span class="comment">// sum elements per channel</span></span><br><span class="line">    <span class="keyword">double</span> sse = s.val[<span class="number">0</span>] + s.val[<span class="number">1</span>] + s.val[<span class="number">2</span>]; <span class="comment">// sum channels</span></span><br><span class="line">    <span class="keyword">if</span>( sse &lt;= <span class="number">1e-10</span>) <span class="comment">// for small values return zero</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span>  mse =sse /(<span class="keyword">double</span>)(I1.channels() * I1.total());</span><br><span class="line">        <span class="keyword">double</span> psnr = <span class="number">10.0</span>*<span class="built_in">log10</span>((<span class="number">255</span>*<span class="number">255</span>)/mse);</span><br><span class="line">        <span class="keyword">return</span> psnr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Scalar <span class="title">getMSSIM</span><span class="params">( <span class="keyword">const</span> Mat&amp; i1, <span class="keyword">const</span> Mat&amp; i2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> C1 = <span class="number">6.5025</span>, C2 = <span class="number">58.5225</span>;</span><br><span class="line">    <span class="comment">/***************************** INITS **********************************/</span></span><br><span class="line">    <span class="keyword">int</span> d     = CV_32F;</span><br><span class="line">    Mat I1, I2;</span><br><span class="line">    i1.convertTo(I1, d);           <span class="comment">// cannot calculate on one byte large values</span></span><br><span class="line">    i2.convertTo(I2, d);</span><br><span class="line">    Mat I2_2   = I2.mul(I2);        <span class="comment">// I2^2</span></span><br><span class="line">    Mat I1_2   = I1.mul(I1);        <span class="comment">// I1^2</span></span><br><span class="line">    Mat I1_I2  = I1.mul(I2);        <span class="comment">// I1 * I2</span></span><br><span class="line">    <span class="comment">/*************************** END INITS **********************************/</span></span><br><span class="line">    Mat mu1, mu2;   <span class="comment">// PRELIMINARY COMPUTING</span></span><br><span class="line">    GaussianBlur(I1, mu1, Size(<span class="number">11</span>, <span class="number">11</span>), <span class="number">1.5</span>);</span><br><span class="line">    GaussianBlur(I2, mu2, Size(<span class="number">11</span>, <span class="number">11</span>), <span class="number">1.5</span>);</span><br><span class="line">    Mat mu1_2   =   mu1.mul(mu1);</span><br><span class="line">    Mat mu2_2   =   mu2.mul(mu2);</span><br><span class="line">    Mat mu1_mu2 =   mu1.mul(mu2);</span><br><span class="line">    Mat sigma1_2, sigma2_2, sigma12;</span><br><span class="line">    GaussianBlur(I1_2, sigma1_2, Size(<span class="number">11</span>, <span class="number">11</span>), <span class="number">1.5</span>);</span><br><span class="line">    sigma1_2 -= mu1_2;</span><br><span class="line">    GaussianBlur(I2_2, sigma2_2, Size(<span class="number">11</span>, <span class="number">11</span>), <span class="number">1.5</span>);</span><br><span class="line">    sigma2_2 -= mu2_2;</span><br><span class="line">    GaussianBlur(I1_I2, sigma12, Size(<span class="number">11</span>, <span class="number">11</span>), <span class="number">1.5</span>);</span><br><span class="line">    sigma12 -= mu1_mu2;</span><br><span class="line">    Mat t1, t2, t3;</span><br><span class="line">    t1 = <span class="number">2</span> * mu1_mu2 + C1;</span><br><span class="line">    t2 = <span class="number">2</span> * sigma12 + C2;</span><br><span class="line">    t3 = t1.mul(t2);              <span class="comment">// t3 = ((2*mu1_mu2 + C1).*(2*sigma12 + C2))</span></span><br><span class="line">    t1 = mu1_2 + mu2_2 + C1;</span><br><span class="line">    t2 = sigma1_2 + sigma2_2 + C2;</span><br><span class="line">    t1 = t1.mul(t2);               <span class="comment">// t1 =((mu1_2 + mu2_2 + C1).*(sigma1_2 + sigma2_2 + C2))</span></span><br><span class="line">    Mat ssim_map;</span><br><span class="line">    divide(t3, t1, ssim_map);      <span class="comment">// ssim_map =  t3./t1;</span></span><br><span class="line">    Scalar mssim = mean( ssim_map ); <span class="comment">// mssim = average of ssim map</span></span><br><span class="line">    <span class="keyword">return</span> mssim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="算法噪声数据"><a href="#算法噪声数据" class="headerlink" title="算法噪声数据"></a>算法噪声数据</h3><p>我们完成了噪声添加以及噪声的量化, 我们来试一下, 给图像随机添加一定的噪声, 然后看下相应的参数变化情况对比来看就好</p><h4 id="椒盐噪声测试"><a href="#椒盐噪声测试" class="headerlink" title="椒盐噪声测试"></a>椒盐噪声测试</h4><p>我们先来测试椒盐噪声 分别计算没有噪声的图, 以及添加了 1000个 和10000个噪声的数据结果, 并将后面两个显示出来 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 添加椒盐噪声 并计算 PSNR和 SSIM</span></span><br><span class="line">    cv::Mat salt_img;</span><br><span class="line">    <span class="keyword">double</span> psnr = <span class="number">0</span>;</span><br><span class="line">    cv::Scalar mssim;</span><br><span class="line"></span><br><span class="line">    QString res_temp = <span class="string">"Salt-%1 : psnr:%2, mssim: B:%3 G:%4 R:%5 "</span>;</span><br><span class="line">    QString res_str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算三组图像的参数 0, 1000, 10000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制原始图像, 添加噪声, 计算 psnr和ssim  显示在 ui上</span></span><br><span class="line">    salt_img = gSrcImg.clone();</span><br><span class="line">    addSaltNoise(salt_img,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    psnr = getPSNR(gSrcImg, salt_img);</span><br><span class="line">    mssim = getMSSIM(gSrcImg,salt_img);</span><br><span class="line">    res_str = res_temp.arg(<span class="number">0</span>)</span><br><span class="line">                        .arg(psnr)</span><br><span class="line">                        .arg(mssim.val[<span class="number">0</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">1</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">2</span>]);</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line"></span><br><span class="line">    salt_img = gSrcImg.clone();</span><br><span class="line">    addSaltNoise(salt_img,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    psnr = getPSNR(gSrcImg, salt_img);</span><br><span class="line">    mssim = getMSSIM(gSrcImg,salt_img);</span><br><span class="line">    res_str = res_temp.arg(<span class="number">1000</span>)</span><br><span class="line">                        .arg(psnr)</span><br><span class="line">                        .arg(mssim.val[<span class="number">0</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">1</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">2</span>]);</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左侧显示 1000 噪声 右侧显示 10000 噪声</span></span><br><span class="line">    ShowMatOnQtLabel(salt_img,ui-&gt;lb_src);</span><br><span class="line"></span><br><span class="line">    salt_img = gSrcImg.clone();</span><br><span class="line">    addSaltNoise(salt_img,<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    psnr = getPSNR(gSrcImg, salt_img);</span><br><span class="line">    mssim = getMSSIM(gSrcImg,salt_img);</span><br><span class="line">    res_str = res_temp.arg(<span class="number">10000</span>)</span><br><span class="line">                        .arg(psnr)</span><br><span class="line">                        .arg(mssim.val[<span class="number">0</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">1</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">2</span>]);</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line"></span><br><span class="line">    ShowMatOnQtLabel(salt_img,ui-&gt;lb_dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588225720510.png" alt="1000 和 10000 的椒盐噪声对比"></p><p>我们可以直接计算得到椒盐噪声  psnr 和 ssim 都是越大越好的, 可以明显的看到图像质量退化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Salt-0 : psnr:0, mssim: B:1 G:1 R:1 </span><br><span class="line">Salt-1000 : psnr:27.7528, mssim: B:0.865341 G:0.870555 R:0.914122 </span><br><span class="line">Salt-10000 : psnr:17.8062, mssim: B:0.311999 G:0.327485 R:0.493874</span><br></pre></td></tr></table></figure><h4 id="高斯噪声测试"><a href="#高斯噪声测试" class="headerlink" title="高斯噪声测试"></a>高斯噪声测试</h4><p>高斯噪声我们测试了四组 分别使用参数(0,1) (0,10)(10,1)(10,10) 作为高斯参数, 最终得到后面的图, 然后计算得到的结果, 我们做的结果比较简单, 可以参考<a href="https://blog.csdn.net/u012936765/article/details/53200918" target="_blank" rel="noopener">数字图像处理——添加高斯噪声&amp;椒盐噪声</a>, 给出了很多的图, 可以参考学</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 添加高斯噪声 并计算 PSNR和 SSIM</span></span><br><span class="line">    cv::Mat guass_img;</span><br><span class="line">    <span class="keyword">double</span> psnr = <span class="number">0</span>;</span><br><span class="line">    cv::Scalar mssim;</span><br><span class="line"></span><br><span class="line">    QString res_temp = <span class="string">"gauss-%1- %2 : psnr:%3, mssim: B:%4 G:%5 R:%6 "</span>;</span><br><span class="line">    QString res_str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算三组图像的参数 (0,1) (0,10), (10,1), (10,10)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制原始图像, 添加噪声, 计算 psnr和ssim  显示在 ui上</span></span><br><span class="line">    guass_img = gSrcImg.clone();</span><br><span class="line">    addGaussianNoise(guass_img,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    psnr = getPSNR(gSrcImg, guass_img);</span><br><span class="line">    mssim = getMSSIM(gSrcImg,guass_img);</span><br><span class="line">    res_str = res_temp.arg(<span class="number">0</span>)</span><br><span class="line">                        .arg(<span class="number">1</span>)</span><br><span class="line">                        .arg(psnr)</span><br><span class="line">                        .arg(mssim.val[<span class="number">0</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">1</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">2</span>]);</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line">    guass_img = gSrcImg.clone();</span><br><span class="line">    addGaussianNoise(guass_img,<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    psnr = getPSNR(gSrcImg, guass_img);</span><br><span class="line">    mssim = getMSSIM(gSrcImg,guass_img);</span><br><span class="line">    res_str = res_temp.arg(<span class="number">0</span>)</span><br><span class="line">                        .arg(<span class="number">10</span>)</span><br><span class="line">                        .arg(psnr)</span><br><span class="line">                        .arg(mssim.val[<span class="number">0</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">1</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">2</span>]);</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line"></span><br><span class="line">    guass_img = gSrcImg.clone();</span><br><span class="line">    addGaussianNoise(guass_img,<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    psnr = getPSNR(gSrcImg, guass_img);</span><br><span class="line">    mssim = getMSSIM(gSrcImg,guass_img);</span><br><span class="line">    res_str = res_temp.arg(<span class="number">10</span>)</span><br><span class="line">                        .arg(<span class="number">1</span>)</span><br><span class="line">                        .arg(psnr)</span><br><span class="line">                        .arg(mssim.val[<span class="number">0</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">1</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">2</span>]);</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line"></span><br><span class="line">    guass_img = gSrcImg.clone();</span><br><span class="line">    addGaussianNoise(guass_img,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    psnr = getPSNR(gSrcImg, guass_img);</span><br><span class="line">    mssim = getMSSIM(gSrcImg,guass_img);</span><br><span class="line">    res_str = res_temp.arg(<span class="number">10</span>)</span><br><span class="line">                        .arg(<span class="number">10</span>)</span><br><span class="line">                        .arg(psnr)</span><br><span class="line">                        .arg(mssim.val[<span class="number">0</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">1</span>])</span><br><span class="line">                        .arg(mssim.val[<span class="number">2</span>]);</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(res_str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588226481095.png" alt="四组高斯测试结果对比"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gauss-0- 1 : psnr:46.8791, mssim: B:0.991811 G:0.991622 R:0.992751 </span><br><span class="line">gauss-0- 10 : psnr:28.1229, mssim: B:0.614219 G:0.608773 R:0.648285 </span><br><span class="line">gauss-10- 1 : psnr:28.5293, mssim: B:0.978448 G:0.980308 R:0.987926 </span><br><span class="line">gauss-10- 10 : psnr:25.3511, mssim: B:0.605665 G:0.600491 R:0.646768</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原本想把滤波一起做了的, 但是越写越, 就不做太多的处理了, 我们算是介绍了噪声的来源, 噪声的模型, 以及个噪声的量化方式,<br>然后介绍了图像添加噪声的方法 我们分别给图像添加椒盐噪声与高斯噪声, 然后分别量化了噪声的结果值, 进行对比展示, </p><p>示例的图不是很多, 程序是在代码库里面的, 可以直接去自己实现, 然后进行 进行更多图的展示</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《高斯噪声_百度百科》. 见于 2020年4月30日. <a href="https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0" target="_blank" rel="noopener">https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0</a>.</li><li>知乎专栏. 《【技术综述】一文道尽传统图像降噪方法》. 见于 2020年4月29日. <a href="https://zhuanlan.zhihu.com/p/51403693" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/51403693</a>.</li><li>知乎专栏. 《可复现的图像降噪算法总结》. 见于 2020年4月29日. <a href="https://zhuanlan.zhihu.com/p/32502816" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32502816</a>.</li><li>《梅森旋转算法》. 收入 维基百科，自由的百科全书, 2019年11月4日. <a href="https://zh.wikipedia.org/w/index.php?title=%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95&amp;oldid=56745942" target="_blank" rel="noopener">https://zh.wikipedia.org/w/index.php?title=%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95&amp;oldid=56745942</a>.</li><li>《实现灰度图像峰值信噪比计算<em>人工智能</em>松子茶的专栏-CSDN博客》. 见于 2020年4月30日. <a href="https://blog.csdn.net/songzitea/article/details/17529445" target="_blank" rel="noopener">https://blog.csdn.net/songzitea/article/details/17529445</a>.</li><li>《数字图像处理-噪声 - Mohanson》. 见于 2020年4月30日. <a href="http://accu.cc/content/pil/noise/" target="_blank" rel="noopener">http://accu.cc/content/pil/noise/</a>.</li><li>《图像处理基础(1)：噪声的添加和过滤 - Brook_icv - 博客园》. 见于 2020年4月30日. <a href="https://www.cnblogs.com/wangguchangqing/p/6372025.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangguchangqing/p/6372025.html</a>.</li><li>《图像处理PSNR及其计算（OpenCV和matlab实现）<em>人工智能</em>无机器不学习-加大码的分享-CSDN博客》. 见于 2020年4月30日. <a href="https://blog.csdn.net/laoxuan2011/article/details/51519062" target="_blank" rel="noopener">https://blog.csdn.net/laoxuan2011/article/details/51519062</a>.</li><li>《图像的 SNR 和 PSNR 的计算 - rldts - 博客园》. 见于 2020年4月30日. <a href="https://www.cnblogs.com/qrlozte/p/5340216.html" target="_blank" rel="noopener">https://www.cnblogs.com/qrlozte/p/5340216.html</a>.</li><li>《图像去噪算法简介 - InfantSorrow - 博客园》. 见于 2020年4月29日. <a href="https://www.cnblogs.com/CCBB/archive/2011/01/06/1929033.html" target="_blank" rel="noopener">https://www.cnblogs.com/CCBB/archive/2011/01/06/1929033.html</a>.</li><li>《图像噪声的成因分类与常见图像去噪算法简介_Java_qq_27606639的博客-CSDN博客》. 见于 2020年4月30日. <a href="https://blog.csdn.net/qq_27606639/article/details/80912071" target="_blank" rel="noopener">https://blog.csdn.net/qq_27606639/article/details/80912071</a>.</li><li>《图像质量评估指标 SSIM / PSNR / MSE_人工智能_兔角与禅-CSDN博客》. 见于 2020年4月30日. <a href="https://blog.csdn.net/edogawachia/article/details/78756680" target="_blank" rel="noopener">https://blog.csdn.net/edogawachia/article/details/78756680</a>.</li><li>《图像质量评价概述（评估指标、传统检测方法）_人工智能_qq_23304241的博客-CSDN博客》. 见于 2020年4月30日. <a href="https://blog.csdn.net/qq_23304241/article/details/80953613" target="_blank" rel="noopener">https://blog.csdn.net/qq_23304241/article/details/80953613</a>.</li><li>《影像降噪》. 收入 维基百科，自由的百科全书, 2018年9月20日. <a href="https://zh.wikipedia.org/w/index.php?title=%E5%BD%B1%E5%83%8F%E9%99%8D%E5%99%AA&amp;oldid=51354600" target="_blank" rel="noopener">https://zh.wikipedia.org/w/index.php?title=%E5%BD%B1%E5%83%8F%E9%99%8D%E5%99%AA&amp;oldid=51354600</a>.</li></ol><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; title=&quot;开始之前&quot;&gt;&lt;/a&gt;开始之前&lt;/h2&gt;&lt;p&gt;我们在将 opencv 的图像显示在了 qt 的label 上, 我们能够将图显示在label 上, 用于显示我们的算法,&lt;br&gt;我们在 opencv 上一篇文章中介绍了 opencv 的核操作, 我们这里就要进入一个很重要的章节了,图像滤波操作, 也是图像核操作应用的一个很重要的章节, &lt;/p&gt;
&lt;p&gt;那我们就从降噪的角度完整的讲一下, 并通过 opencv 核的方式进行图像算法操作, &lt;a href=&quot;https://zhuanlan.zhihu.com/p/51403693&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【技术综述】一文道尽传统图像降噪方法&lt;/a&gt; 这篇文章写的还算比较完整, 也是传统的算法的一个综述过程, &lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;数字成像过程中由于电噪声以及其他因素, 导致我们获取到的图像存在噪声,噪声出现在输入部分, 在后续的每个步骤都会受到影响, 所以在数字图像处理的前面必须要进行的一个步骤就是 &lt;a href=&quot;https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F%E9%99%8D%E5%99%AA/4136566&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图像降噪&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;每个做信号处理的都会接触到一类问题 , 信号降噪, 让人最头疼的一门课,真是感谢老师给过, 但是后面自己用到的时候反而感觉真的好用, 原来是这样, 然后就慢慢学会了怎么使用吧..(感觉还是弱鸡)&lt;br&gt;知乎&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32502816&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;可复现的图像降噪算法总结&lt;/a&gt;这篇文章列出了一个能够复现的图像降噪操作算法列表, 近年来实现了的算法可以见&lt;a href=&quot;https://github.com/wenbihan/reproducible-image-denoising-state-of-the-art&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;reproducible-image-denoising-state-of-the-art&lt;/a&gt;, 之后使用相应的文章进行算法实现吧.( 又立了一个 flag )&lt;/p&gt;
&lt;h2 id=&quot;图像降噪理论基础&quot;&gt;&lt;a href=&quot;#图像降噪理论基础&quot; class=&quot;headerlink&quot; title=&quot;图像降噪理论基础&quot;&gt;&lt;/a&gt;图像降噪理论基础&lt;/h2&gt;&lt;p&gt;图像降噪主要的目的是在进行去除图像噪声的同时保留尽可能多的主要特征, 对于人眼来说, 区分噪声还算比较容易, 但是对于计算机来说,输入的都是数据, 我怎么区分哪个是噪声, 哪个不是噪声呢, 这里就要引入噪声的理论基础了&lt;/p&gt;
&lt;h3 id=&quot;图像噪声的产生&quot;&gt;&lt;a href=&quot;#图像噪声的产生&quot; class=&quot;headerlink&quot; title=&quot;图像噪声的产生&quot;&gt;&lt;/a&gt;图像噪声的产生&lt;/h3&gt;&lt;p&gt;我们在之前的章节介绍了图像的程序系统, 实际上在成像过程中可能由于点噪声, 量化过程等造成噪声,&lt;br&gt;实际上的噪声主要分为三种: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加性噪声: 与输入无关,  $f(x,y) = g(x,y) +n(x,y)$&lt;/li&gt;
&lt;li&gt;乘性噪声: 与输入信号有关, $f(x,y) =  g(x,y) + n(x,y) \cdot g(x,y)$&lt;/li&gt;
&lt;li&gt;量化噪声: 与输入无关, 在图像量化过程噪声的量化误差导致的噪声, &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实际上后两种很难解决, 目前处理的都是以 加性噪声为主, 属于随机的噪声信号, 根据统计学的观点, 噪声在无限长时间窗内的噪声和为0, 在第一类中的 $n(x,y)$ 随着时间存在正负信号的不确定变化.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588225720321.png&quot; alt=&quot;噪声零和特点&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上图所示虚线代表真实信号，红蓝线表示的就是随机噪声信号，所有的随机噪声信号求和后结果为0。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里关于噪声的说明可以参考&lt;a href=&quot;https://www.cnblogs.com/CCBB/archive/2011/01/06/1929033.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图像去噪算法简介&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;噪声在理论上可以定义为“不可预测，只能用概率统计方法来认识的随机误差”。因此将图像噪声看成是多维随机过程是合适的，因而描述噪声的方法完全可以借用随机过程的描述，即用其概率分布函数和概率密度分布函数。但在很多情况下，这样的描述方法是很复杂的，甚至是不可能的。而实际应用往往也不必要。通常是用其数字特征，即均值方差，相关函数等。因为这些数字特征都可以从某些方面反映出噪声的特征。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我认为&lt;a href=&quot;https://blog.csdn.net/qq_27606639/article/details/80912071&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图像噪声的成因分类与常见图像去噪算法简介&lt;/a&gt;这篇文章关于噪声的分类部分讲的还比较细, 可以参考&lt;/p&gt;
&lt;h3 id=&quot;图像噪声的模型&quot;&gt;&lt;a href=&quot;#图像噪声的模型&quot; class=&quot;headerlink&quot; title=&quot;图像噪声的模型&quot;&gt;&lt;/a&gt;图像噪声的模型&lt;/h3&gt;&lt;p&gt;由于我们认为噪声在时间尺度的随机性, 但是我们可以使用噪声的概率分布与概率密度函数进行描述, 那么我们就能将噪声根据其分布特点进行分类,&lt;br&gt;我们稍微介绍一下常见的噪声模型吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588225720295.png&quot; alt=&quot;一些重要的噪声概率密度函数&quot;&gt;&lt;/p&gt;
&lt;p&gt;噪声模型主要可以分为: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高斯噪声，高斯噪声模型经常被用于实践中。&lt;/li&gt;
&lt;li&gt;脉冲噪声（椒盐噪声），图像上一个个点，也可称为散粒和尖峰噪声。&lt;/li&gt;
&lt;li&gt;伽马噪声&lt;/li&gt;
&lt;li&gt;瑞利噪声&lt;/li&gt;
&lt;li&gt;指数分布噪声&lt;/li&gt;
&lt;li&gt;均匀分布噪声&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里能查到的资料很多, 可以看我们的参考部分, 内容都一样, 再写只是浪费时间和精力, 有兴趣的可以自己翻阅&lt;/p&gt;
&lt;h2 id=&quot;图像降噪操作&quot;&gt;&lt;a href=&quot;#图像降噪操作&quot; class=&quot;headerlink&quot; title=&quot;图像降噪操作&quot;&gt;&lt;/a&gt;图像降噪操作&lt;/h2&gt;&lt;p&gt;其实吧, 我就不应该讲那么多, 直接开始图像处理部分就行了, 为了开始进行图像处理, 我们要先进行一点小工作, 我们要按造以下步骤进行降噪算法的比较, &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择标准图像— lena.png&lt;/li&gt;
&lt;li&gt;添加噪声&lt;/li&gt;
&lt;li&gt;量化噪声&lt;/li&gt;
&lt;li&gt;降噪操作&lt;/li&gt;
&lt;li&gt;量化结果值&lt;/li&gt;
&lt;li&gt;比较结果&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在我们进行算法比对之前, 我们选择的是 lena 的图像, 加入随机噪声, 然后计算出来 一个噪声的比例, 进行降噪操作, 再次计算以下噪声参数, 看下效果值.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果是进行算法比较的时候, 最好选择现有的降噪的数据集进行比较, 比如, &lt;a href=&quot;http://r0k.us/graphics/kodak/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kodak&lt;/a&gt; , &lt;a href=&quot;https://www2.eecs.berkeley.edu/Research/Projects/CS/vision/bsds/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BSD&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;噪声添加&quot;&gt;&lt;a href=&quot;#噪声添加&quot; class=&quot;headerlink&quot; title=&quot;噪声添加&quot;&gt;&lt;/a&gt;噪声添加&lt;/h3&gt;&lt;p&gt;我们认为噪声是随机的, 我们生成随机数加在原始图像上便能够得到噪声图像, opencv 没有提供相应的实现, 但是知道原理了, 写起来都比较简单, 我比较喜欢&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/wangguchangqing/p/6372025.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图像处理基础(1)：噪声的添加和过滤&lt;/a&gt; 使用的方法, 他使用的是 &lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;梅森旋转算法&lt;/a&gt;  来实现的伪随机算法, &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其实吧这里我也不懂, 但是随机数能用就行了, 我又不是数学家, 然后看到了 &lt;a href=&quot;https://liam.page/2018/01/12/Mersenne-twister/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;谈谈梅森旋转：算法及其爆破&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里就不重复造轮子了, 直接复制他给出的代码就好,&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 添加椒盐噪声 // 生成 随机 num 个 白点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addSaltNoise&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Mat &amp;amp;m, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;comment&quot;&gt;// 随机数产生器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::random_device rd; &lt;span class=&quot;comment&quot;&gt;//种子&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::mt19937 &lt;span class=&quot;title&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(rd())&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 随机数引擎&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; cols = m.cols * m.channels();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; num; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;truetrue&lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; row = &lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;(gen() % m.rows);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;truetrue&lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; col = &lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;(gen() % cols);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;truetrue&lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; p = m.ptr&amp;lt;uchar&amp;gt;(row);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;truetruep[col++] = &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;truetruep[col++] = &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;truetruep[col] = &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 添加Gussia噪声&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用指针访问&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addGaussianNoise&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Mat &amp;amp;m, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mu, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sigma)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;comment&quot;&gt;// 产生高斯分布随机数发生器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::random_device rd;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::mt19937 &lt;span class=&quot;title&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(rd())&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::normal_distribution&amp;lt;&amp;gt; &lt;span class=&quot;title&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(mu, sigma)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; rows = m.rows; &lt;span class=&quot;comment&quot;&gt;// 行数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; cols = m.cols * m.channels(); &lt;span class=&quot;comment&quot;&gt;// 列数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; rows; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;truetrue&lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; p = m.ptr&amp;lt;uchar&amp;gt;(i); &lt;span class=&quot;comment&quot;&gt;// 取得行首指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;truetrue&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; cols; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;truetrue&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;truetruetrue&lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; tmp = p[j] + d(gen);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;truetruetruetmp = tmp &amp;gt; &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt; ? &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt; : tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;truetruetruetmp = tmp &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ? &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; : tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;truetruetruep[j] = tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;truetrue&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;噪声量化方法&quot;&gt;&lt;a href=&quot;#噪声量化方法&quot; class=&quot;headerlink&quot; title=&quot;噪声量化方法&quot;&gt;&lt;/a&gt;噪声量化方法&lt;/h3&gt;&lt;p&gt;这里其实涉及到图像质量评估的领域,可以参考&lt;a href=&quot;https://blog.csdn.net/qq_23304241/article/details/80953613&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图像质量评价概述（评估指标、传统检测方法）&lt;/a&gt;介绍的方法, 存在太多的计算方式, &lt;/p&gt;
&lt;p&gt;我们必须选择一个量化噪声的方式进行图像质量的评估, 一般进行噪声评估手段就是噪声比(Signal to Noise Ratio,SNR),峰值信噪比(Peak Signal to Noise Ratio, PSNR) , 均方差值(Mean Square Error, MSE), 结构相似性(Structural SIMilarity, SSIM),&lt;/p&gt;
&lt;p&gt;我们一个一个来看, 均方差值是用于比较两幅图像 K, I 的均方差值&lt;br&gt;$$&lt;br&gt;MSE=\frac{1}{mn}\sum_{i=0}^{n-1}\sum_{j=0}^{m-1}\parallel K(i,j)-I(i,j)\parallel^{2}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;峰值信噪比PSNR衡量图像失真或是噪声水平的客观标准。2个图像之间PSNR值越大，则越相似。普遍基准为30dB，30dB以下的图像劣化较为明显。定义为，&lt;br&gt;$$&lt;br&gt;PSNR=10log_{10}(\frac{MAX^{2}}{MSE})&lt;br&gt;$$&lt;br&gt;其中$MAX^2$ 为图片可能的最大像素值。如果每个像素都由 8 位二进制来表示，那么就为 255。&lt;/p&gt;
&lt;p&gt;SNR用于描述信号与噪声的比值&lt;br&gt;$$&lt;br&gt;SNR (dB)=10 log_{10}&lt;br&gt;\left[&lt;br&gt;\frac{\sum_{x=0}^{m-1} \sum_{y=0}^{n-1}(f(x, y))^{2}}{\sum_{x=0}^{m-1} \sum_{y=0}^{n-1}(f(x, y)-\hat{f}(x, y))^{2}}\right]&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;SSIM 描述两个图像的相似性, 通过三个进行比较, 亮度,对比度和结构, 参考&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50757421&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图像质量评价指标之 PSNR 和 SSIM&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;$$l(x, y)=\frac{2 \mu_{x} \mu_{y}+c_{1}}{\mu_{x}^{2}+\mu_{y}^{2}+c_{1}} c(x, y)=\frac{2 \sigma_{x} \sigma_{y}+c_{2}}{\sigma_{x}^{2}+\sigma_{y}^{2}+c_{2}} s(x, y)=\frac{\sigma_{x y}+c_{3}}{\sigma_{x} \sigma_{y}+c_{3}}$$&lt;/p&gt;
&lt;p&gt;$$\operatorname{SSIM}(x, y)=\frac{\left(2 \mu_{x} \mu_{y}+c_{1}\right)\left(2 \sigma_{x y}+c_{2}\right)}{\left(\mu_{x}^{2}+\mu_{y}^{2}+c_{1}\right)\left(\sigma_{x}^{2}+\sigma_{y}^{2}+c_{2}\right)}$$&lt;br&gt;一般取$c_3 = \frac{c_2}{2}$。&lt;br&gt;$u_x$ 为 $x$  的均值&lt;br&gt;$u_y$ 为 $y$ 的均值&lt;br&gt;$\sigma_x^2$ 为$x$ 的方差&lt;br&gt;$\sigma_y^2$ 为$y$ 的方差&lt;br&gt;$\sigma_{xy}$ 为$x$ 和$y$ 的协方差&lt;br&gt;$c_1 = (k_1 L)^2, c_2=(k_2 L)^2$ 为两个常数，避免除零&lt;br&gt;$L$ 为像素值的范围，$(0,255)$&lt;br&gt;$k_1 = 0.01, k_2 = 0.03$ 为默认值&lt;br&gt;默认参数$\alpha = 1, \beta = 1, \gamma = 1$ &lt;/p&gt;
&lt;h3 id=&quot;opencv-计算-PSNR-和-SSIM&quot;&gt;&lt;a href=&quot;#opencv-计算-PSNR-和-SSIM&quot; class=&quot;headerlink&quot; title=&quot;opencv 计算 PSNR 和 SSIM&quot;&gt;&lt;/a&gt;opencv 计算 PSNR 和 SSIM&lt;/h3&gt;&lt;p&gt;本来不想写这么多的, 但是 opencv 给出了一个例程&lt;a href=&quot;https://docs.opencv.org/4.3.0/dd/d3d/tutorial_gpu_basics_similarity.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Similarity check (PNSR and SSIM) on the GPU&lt;/a&gt;, 提供了计算的方法, 自己不用去写了, 岂不是很爽, 所以上面就详细介绍了各个方法的使用.&lt;br&gt;官方给出了普通版本以及 GPU 加速的版本, 我们暂时只使用基础的版本就好,&lt;br&gt;PSNR返回一个浮点数，如果两个输入在30到50之间相似（越高越好）。&lt;br&gt;SSIM返回图像的MSSIM。这也是一个介于零和一之间的浮点数（越高越好），但是每个通道都有一个浮点数。因此，我们返回一个Scalar OpenCV数据结构：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getPSNR&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Mat&amp;amp; I1, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Mat&amp;amp; I2)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Mat s1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    absdiff(I1, I2, s1);       &lt;span class=&quot;comment&quot;&gt;// |I1 - I2|&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s1.convertTo(s1, CV_32F);  &lt;span class=&quot;comment&quot;&gt;// cannot make a square on 8 bits&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s1 = s1.mul(s1);           &lt;span class=&quot;comment&quot;&gt;// |I1 - I2|^2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Scalar s = sum(s1);         &lt;span class=&quot;comment&quot;&gt;// sum elements per channel&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sse = s.val[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] + s.val[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] + s.val[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]; &lt;span class=&quot;comment&quot;&gt;// sum channels&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( sse &amp;lt;= &lt;span class=&quot;number&quot;&gt;1e-10&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// for small values return zero&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;  mse =sse /(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;)(I1.channels() * I1.total());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; psnr = &lt;span class=&quot;number&quot;&gt;10.0&lt;/span&gt;*&lt;span class=&quot;built_in&quot;&gt;log10&lt;/span&gt;((&lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;)/mse);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; psnr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Scalar &lt;span class=&quot;title&quot;&gt;getMSSIM&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Mat&amp;amp; i1, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Mat&amp;amp; i2)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; C1 = &lt;span class=&quot;number&quot;&gt;6.5025&lt;/span&gt;, C2 = &lt;span class=&quot;number&quot;&gt;58.5225&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/***************************** INITS **********************************/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; d     = CV_32F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Mat I1, I2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    i1.convertTo(I1, d);           &lt;span class=&quot;comment&quot;&gt;// cannot calculate on one byte large values&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    i2.convertTo(I2, d);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Mat I2_2   = I2.mul(I2);        &lt;span class=&quot;comment&quot;&gt;// I2^2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Mat I1_2   = I1.mul(I1);        &lt;span class=&quot;comment&quot;&gt;// I1^2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Mat I1_I2  = I1.mul(I2);        &lt;span class=&quot;comment&quot;&gt;// I1 * I2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/*************************** END INITS **********************************/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Mat mu1, mu2;   &lt;span class=&quot;comment&quot;&gt;// PRELIMINARY COMPUTING&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GaussianBlur(I1, mu1, Size(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;), &lt;span class=&quot;number&quot;&gt;1.5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GaussianBlur(I2, mu2, Size(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;), &lt;span class=&quot;number&quot;&gt;1.5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Mat mu1_2   =   mu1.mul(mu1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Mat mu2_2   =   mu2.mul(mu2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Mat mu1_mu2 =   mu1.mul(mu2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Mat sigma1_2, sigma2_2, sigma12;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GaussianBlur(I1_2, sigma1_2, Size(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;), &lt;span class=&quot;number&quot;&gt;1.5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sigma1_2 -= mu1_2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GaussianBlur(I2_2, sigma2_2, Size(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;), &lt;span class=&quot;number&quot;&gt;1.5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sigma2_2 -= mu2_2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GaussianBlur(I1_I2, sigma12, Size(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;), &lt;span class=&quot;number&quot;&gt;1.5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sigma12 -= mu1_mu2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Mat t1, t2, t3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t1 = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * mu1_mu2 + C1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t2 = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * sigma12 + C2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t3 = t1.mul(t2);              &lt;span class=&quot;comment&quot;&gt;// t3 = ((2*mu1_mu2 + C1).*(2*sigma12 + C2))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t1 = mu1_2 + mu2_2 + C1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t2 = sigma1_2 + sigma2_2 + C2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t1 = t1.mul(t2);               &lt;span class=&quot;comment&quot;&gt;// t1 =((mu1_2 + mu2_2 + C1).*(sigma1_2 + sigma2_2 + C2))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Mat ssim_map;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    divide(t3, t1, ssim_map);      &lt;span class=&quot;comment&quot;&gt;// ssim_map =  t3./t1;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Scalar mssim = mean( ssim_map ); &lt;span class=&quot;comment&quot;&gt;// mssim = average of ssim map&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mssim;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;算法噪声数据&quot;&gt;&lt;a href=&quot;#算法噪声数据&quot; class=&quot;headerlink&quot; title=&quot;算法噪声数据&quot;&gt;&lt;/a&gt;算法噪声数据&lt;/h3&gt;&lt;p&gt;我们完成了噪声添加以及噪声的量化, 我们来试一下, 给图像随机添加一定的噪声, 然后看下相应的参数变化情况对比来看就好&lt;/p&gt;
&lt;h4 id=&quot;椒盐噪声测试&quot;&gt;&lt;a href=&quot;#椒盐噪声测试&quot; class=&quot;headerlink&quot; title=&quot;椒盐噪声测试&quot;&gt;&lt;/a&gt;椒盐噪声测试&lt;/h4&gt;&lt;p&gt;我们先来测试椒盐噪声 分别计算没有噪声的图, 以及添加了 1000个 和10000个噪声的数据结果, 并将后面两个显示出来 &lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainWindow::testFunc1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 添加椒盐噪声 并计算 PSNR和 SSIM&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat salt_img;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; psnr = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Scalar mssim;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QString res_temp = &lt;span class=&quot;string&quot;&gt;&quot;Salt-%1 : psnr:%2, mssim: B:%3 G:%4 R:%5 &quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QString res_str;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 计算三组图像的参数 0, 1000, 10000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 复制原始图像, 添加噪声, 计算 psnr和ssim  显示在 ui上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    salt_img = gSrcImg.clone();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addSaltNoise(salt_img,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    psnr = getPSNR(gSrcImg, salt_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mssim = getMSSIM(gSrcImg,salt_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res_str = res_temp.arg(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(psnr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(mssim.val[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(mssim.val[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(mssim.val[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui-&amp;gt;pt_log-&amp;gt;appendPlainText(res_str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    salt_img = gSrcImg.clone();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addSaltNoise(salt_img,&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    psnr = getPSNR(gSrcImg, salt_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mssim = getMSSIM(gSrcImg,salt_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res_str = res_temp.arg(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(psnr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(mssim.val[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(mssim.val[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(mssim.val[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui-&amp;gt;pt_log-&amp;gt;appendPlainText(res_str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 左侧显示 1000 噪声 右侧显示 10000 噪声&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ShowMatOnQtLabel(salt_img,ui-&amp;gt;lb_src);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    salt_img = gSrcImg.clone();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addSaltNoise(salt_img,&lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    psnr = getPSNR(gSrcImg, salt_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mssim = getMSSIM(gSrcImg,salt_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res_str = res_temp.arg(&lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(psnr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(mssim.val[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(mssim.val[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(mssim.val[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui-&amp;gt;pt_log-&amp;gt;appendPlainText(res_str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ShowMatOnQtLabel(salt_img,ui-&amp;gt;lb_dst);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588225720510.png&quot; alt=&quot;1000 和 10000 的椒盐噪声对比&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们可以直接计算得到椒盐噪声  psnr 和 ssim 都是越大越好的, 可以明显的看到图像质量退化&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Salt-0 : psnr:0, mssim: B:1 G:1 R:1 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Salt-1000 : psnr:27.7528, mssim: B:0.865341 G:0.870555 R:0.914122 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Salt-10000 : psnr:17.8062, mssim: B:0.311999 G:0.327485 R:0.493874&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;高斯噪声测试&quot;&gt;&lt;a href=&quot;#高斯噪声测试&quot; class=&quot;headerlink&quot; title=&quot;高斯噪声测试&quot;&gt;&lt;/a&gt;高斯噪声测试&lt;/h4&gt;&lt;p&gt;高斯噪声我们测试了四组 分别使用参数(0,1) (0,10)(10,1)(10,10) 作为高斯参数, 最终得到后面的图, 然后计算得到的结果, 我们做的结果比较简单, 可以参考&lt;a href=&quot;https://blog.csdn.net/u012936765/article/details/53200918&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数字图像处理——添加高斯噪声&amp;amp;椒盐噪声&lt;/a&gt;, 给出了很多的图, 可以参考学&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainWindow::testFunc2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 添加高斯噪声 并计算 PSNR和 SSIM&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat guass_img;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; psnr = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Scalar mssim;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QString res_temp = &lt;span class=&quot;string&quot;&gt;&quot;gauss-%1- %2 : psnr:%3, mssim: B:%4 G:%5 R:%6 &quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QString res_str;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 计算三组图像的参数 (0,1) (0,10), (10,1), (10,10)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 复制原始图像, 添加噪声, 计算 psnr和ssim  显示在 ui上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    guass_img = gSrcImg.clone();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addGaussianNoise(guass_img,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    psnr = getPSNR(gSrcImg, guass_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mssim = getMSSIM(gSrcImg,guass_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res_str = res_temp.arg(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(psnr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(mssim.val[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(mssim.val[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(mssim.val[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui-&amp;gt;pt_log-&amp;gt;appendPlainText(res_str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    guass_img = gSrcImg.clone();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addGaussianNoise(guass_img,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    psnr = getPSNR(gSrcImg, guass_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mssim = getMSSIM(gSrcImg,guass_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res_str = res_temp.arg(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(psnr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(mssim.val[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(mssim.val[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(mssim.val[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui-&amp;gt;pt_log-&amp;gt;appendPlainText(res_str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    guass_img = gSrcImg.clone();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addGaussianNoise(guass_img,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    psnr = getPSNR(gSrcImg, guass_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mssim = getMSSIM(gSrcImg,guass_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res_str = res_temp.arg(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(psnr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(mssim.val[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(mssim.val[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(mssim.val[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui-&amp;gt;pt_log-&amp;gt;appendPlainText(res_str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    guass_img = gSrcImg.clone();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addGaussianNoise(guass_img,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    psnr = getPSNR(gSrcImg, guass_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mssim = getMSSIM(gSrcImg,guass_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res_str = res_temp.arg(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(psnr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(mssim.val[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(mssim.val[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .arg(mssim.val[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui-&amp;gt;pt_log-&amp;gt;appendPlainText(res_str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588226481095.png&quot; alt=&quot;四组高斯测试结果对比&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;gauss-0- 1 : psnr:46.8791, mssim: B:0.991811 G:0.991622 R:0.992751 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gauss-0- 10 : psnr:28.1229, mssim: B:0.614219 G:0.608773 R:0.648285 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gauss-10- 1 : psnr:28.5293, mssim: B:0.978448 G:0.980308 R:0.987926 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gauss-10- 10 : psnr:25.3511, mssim: B:0.605665 G:0.600491 R:0.646768&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;原本想把滤波一起做了的, 但是越写越, 就不做太多的处理了, 我们算是介绍了噪声的来源, 噪声的模型, 以及个噪声的量化方式,&lt;br&gt;然后介绍了图像添加噪声的方法 我们分别给图像添加椒盐噪声与高斯噪声, 然后分别量化了噪声的结果值, 进行对比展示, &lt;/p&gt;
&lt;p&gt;示例的图不是很多, 程序是在代码库里面的, 可以直接去自己实现, 然后进行 进行更多图的展示&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;《高斯噪声_百度百科》. 见于 2020年4月30日. &lt;a href=&quot;https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;知乎专栏. 《【技术综述】一文道尽传统图像降噪方法》. 见于 2020年4月29日. &lt;a href=&quot;https://zhuanlan.zhihu.com/p/51403693&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/51403693&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;知乎专栏. 《可复现的图像降噪算法总结》. 见于 2020年4月29日. &lt;a href=&quot;https://zhuanlan.zhihu.com/p/32502816&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/32502816&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《梅森旋转算法》. 收入 维基百科，自由的百科全书, 2019年11月4日. &lt;a href=&quot;https://zh.wikipedia.org/w/index.php?title=%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95&amp;amp;oldid=56745942&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.wikipedia.org/w/index.php?title=%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95&amp;amp;oldid=56745942&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《实现灰度图像峰值信噪比计算&lt;em&gt;人工智能&lt;/em&gt;松子茶的专栏-CSDN博客》. 见于 2020年4月30日. &lt;a href=&quot;https://blog.csdn.net/songzitea/article/details/17529445&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/songzitea/article/details/17529445&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《数字图像处理-噪声 - Mohanson》. 见于 2020年4月30日. &lt;a href=&quot;http://accu.cc/content/pil/noise/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://accu.cc/content/pil/noise/&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《图像处理基础(1)：噪声的添加和过滤 - Brook_icv - 博客园》. 见于 2020年4月30日. &lt;a href=&quot;https://www.cnblogs.com/wangguchangqing/p/6372025.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/wangguchangqing/p/6372025.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《图像处理PSNR及其计算（OpenCV和matlab实现）&lt;em&gt;人工智能&lt;/em&gt;无机器不学习-加大码的分享-CSDN博客》. 见于 2020年4月30日. &lt;a href=&quot;https://blog.csdn.net/laoxuan2011/article/details/51519062&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/laoxuan2011/article/details/51519062&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《图像的 SNR 和 PSNR 的计算 - rldts - 博客园》. 见于 2020年4月30日. &lt;a href=&quot;https://www.cnblogs.com/qrlozte/p/5340216.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/qrlozte/p/5340216.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《图像去噪算法简介 - InfantSorrow - 博客园》. 见于 2020年4月29日. &lt;a href=&quot;https://www.cnblogs.com/CCBB/archive/2011/01/06/1929033.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/CCBB/archive/2011/01/06/1929033.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《图像噪声的成因分类与常见图像去噪算法简介_Java_qq_27606639的博客-CSDN博客》. 见于 2020年4月30日. &lt;a href=&quot;https://blog.csdn.net/qq_27606639/article/details/80912071&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_27606639/article/details/80912071&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《图像质量评估指标 SSIM / PSNR / MSE_人工智能_兔角与禅-CSDN博客》. 见于 2020年4月30日. &lt;a href=&quot;https://blog.csdn.net/edogawachia/article/details/78756680&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/edogawachia/article/details/78756680&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《图像质量评价概述（评估指标、传统检测方法）_人工智能_qq_23304241的博客-CSDN博客》. 见于 2020年4月30日. &lt;a href=&quot;https://blog.csdn.net/qq_23304241/article/details/80953613&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_23304241/article/details/80953613&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;《影像降噪》. 收入 维基百科，自由的百科全书, 2018年9月20日. &lt;a href=&quot;https://zh.wikipedia.org/w/index.php?title=%E5%BD%B1%E5%83%8F%E9%99%8D%E5%99%AA&amp;amp;oldid=51354600&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.wikipedia.org/w/index.php?title=%E5%BD%B1%E5%83%8F%E9%99%8D%E5%99%AA&amp;amp;oldid=51354600&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="opencv" scheme="https://schen1024.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://schen1024.github.io/tags/opencv/"/>
    
      <category term="c++" scheme="https://schen1024.github.io/tags/c/"/>
    
      <category term="qt" scheme="https://schen1024.github.io/tags/qt/"/>
    
  </entry>
  
  <entry>
    <title>Imagelab-0-QT label显示 opencv 图像</title>
    <link href="https://schen1024.github.io/2020/04-27/Imagelab-0-init.html"/>
    <id>https://schen1024.github.io/2020/04-27/Imagelab-0-init.html</id>
    <published>2020-04-27T19:22:38.000Z</published>
    <updated>2023-01-01T13:25:24.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>这其实也是 opencv 处理图像的系列, 只是想我们在进一步复杂化我们的代码之前, 每次给出代码我们都要给出很多, 然后窗口的显示上也有很多不必要的东西, 我们为了后面进行更好的算法效果以及算法执行, 我们先规划一下程序, 写出来一个界面程序出来, 这样的话, 我们之后的程序部分只需要给出一个函数的部分就好, 我们的程序算法在增加的时候, 将功能做到一个一个的菜单里面来, 这样一边处理算法, 一边写出界面图像..</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[toc]</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我们主要将图形界面部分使用代码来实现, 这样不需要进行编译便能够大概知道结果..</p><p>我们在进行复杂的界面之前, 我们先实现一个简单的工程, 能够使用 opencv 读取图片, 然后显示在 qt 的 label 控件 上面,</p><h3 id="QT-图像格式"><a href="#QT-图像格式" class="headerlink" title="QT 图像格式"></a>QT 图像格式</h3><p>在 qt 中提供了几种图像显示的方式,可以看这篇文章<a href="https://blog.csdn.net/zzwdkxx/article/details/39480559" target="_blank" rel="noopener">关于 QPixmap/QImage/QPicture</a>, 详细的介绍了几种格式的使用方法,<br>QT 自带的 <code>QImage</code> 和 <code>QPixmap</code>, 都是支持读取图像的,可以直接用于显示图像, 但是呢, 我们后续还要进行复杂的算法实现, 所以我们还是要转回到 opencv 的怀抱中来, 那么我们不可避免的需要进行数据图像格式之间的互相转换, 目前大多说使用的方式都是 opencv 的 Mat 格式与 QT QPixmap 格式之间的转换, 按后显示到 QT 的 label 上面, 我们先来实现一下:</p><h3 id="UI-界面设计"><a href="#UI-界面设计" class="headerlink" title="UI 界面设计"></a>UI 界面设计</h3><p>这里稍微提一下 QT Designer, 我们可以通过托拽的方式实现界面的设计, 也提供了很多组件让我们选择, 我们先暂时使用这种比较简单的方式进行, 后面逐渐介绍更为复杂的操作.</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588137693125.png" alt="QT UI 设计"></p><p>这里我们使用数字 1,2,3,4, 标记了四个区域, 就是我们常用的区域了</p><ul><li><ol><li>编辑区域, 可以编辑与托拽, 能够预览</li></ol></li><li><ol start="2"><li>控件结构树, 各个控件的从属结构, 名称就是 <code>ObjectName</code> 能够在程序使用控件名进行操控</li></ol></li><li><ol start="3"><li>属性区域,能够直接调整相关的参数, 也可以在程序中进行调整各种属性</li></ol></li><li><ol start="4"><li>控件区域, 不同种类的控件, 可以用于托拽, 直接显示在窗口中..</li></ol></li></ul><p>具体的实现方式不用去深究, 且通过托拽改变 <code>.ui</code> 文件, 实际上就是 一个 xml 格式的文件, QT 通过 <code>uic</code> 会将 <code>xxx.ui</code> 转换成 <code>ui_xxx.h</code> 文件, 我们通过引用即可直接操控控件了,</p><blockquote><p>如果我们改变了 ui, 但是运行之后没有更新, 在工程山强制 qmake 一下就能解决了</p></blockquote><p>在我们这个工程中, 我们托拽了两个 <code>QLabel</code> 组件和两个 <code>QPushButton</code> 组件, 相应的可以在上图的 2 区域看到对象名称..</p><ul><li>MainWindow:<ul><li>geometry: 0,0,960,540 : 我们运行的窗口尺寸</li><li>windowsTitle: “ImageLab”</li></ul></li><li>lb_src:<ul><li>geometry: 20,30,400,400 用于指定控件的左上角位置和 尺寸宽高, 我们使用这个参数指定即可</li><li>frameShape: WinPanel</li></ul></li><li>lb_dst:<ul><li>geometry: 470,30,400,400 用于指定控件的左上角位置和 尺寸宽高, 我们使用这个参数指定即可</li><li>frameShape: WinPanel</li></ul></li><li>btn_test1,btn_test2: 都是默认托拽的 , 尺寸默认, 位置 随意就好, 后面用于我们进行一下测试算法 暂时忽略</li><li>pt_log: 多行文本, 用于显示一些结果信息, 测试过程中的一些输出</li></ul><p>我们这个界面也没有布局, 就是很简单的把东西给显示出来, 在编辑之后 按 <code>Shift+Alt+R</code>能够预览界面,<br>如果有布局之类的需要及时查看, 我们这里就是简单的 ui , 布局什么样 得到的就是什么样子</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588137693113.png" alt="预览 UI 界面"></p><p>我们后面的测试可能就是左边显示原始图像, 右边显示运算之后 的图像, 我们来实现一下</p><p>这里关于 ui 界面的设计 只是稍微提一下, 你们可以直接查看其他的文章介绍的使用方法, 简单点的可以看<a href="https://blog.csdn.net/a10929/article/details/78114261" target="_blank" rel="noopener">使用 Qt Designer 来设计界面</a>和<a href="https://blog.csdn.net/weixin_36340947/article/details/75691506" target="_blank" rel="noopener">使用 Qt Designer 创建界面</a></p><h3 id="信号与槽-实现-UI-点击事件"><a href="#信号与槽-实现-UI-点击事件" class="headerlink" title="信号与槽 实现 UI 点击事件"></a>信号与槽 实现 UI 点击事件</h3><p>在我们进行显示图像之前, 我们稍微介绍一下 QT 的信号与槽的实现方式, QT 最 NB 的地方实现了信号与槽 , 简单理解就是, 我们提前将信号与一个槽(函数)声明连接, 然后我们点击一个按钮 会发射一个信号, 然后经过 QT 的信号处理机制 就能够调用我们提前设定的函数了,</p><blockquote><p>PS: 只是粗略 的这么看就行, 具体还要复杂很多, 后面再说</p></blockquote><p>我们简单实现一下 这个功能, 点击输出我们点击可哪个按钮..<br>我们点击 <code>测试按钮1: btn_test1</code>调用一个函数 <code>testFunc1</code>, 然后在结果框输出<code>点击了按钮1</code> ,</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588137693115.gif" alt="点击输出效果预览"></p><p>,我们只看 核心的代码部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainwindow.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_mainwindow.h"</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">   : QMainWindow(parent)</span><br><span class="line">   , ui(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">   ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设定信号与槽 连接</span></span><br><span class="line">   connect(ui-&gt;btn_test1,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;MainWindow::testFunc1);</span><br><span class="line">   connect(ui-&gt;btn_test2,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;MainWindow::testFunc2);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化 ui</span></span><br><span class="line">   ui-&gt;pt_log-&gt;clear();  <span class="comment">// 清除框内输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ui-&gt;pt_log-&gt;appendPlainText(<span class="string">"你点击了 测试按钮 1 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ui-&gt;pt_log-&gt;appendPlainText(<span class="string">"你点击了 测试按钮 2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// mainwindow.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span>;</span> &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span> <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">   Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">testFunc1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">testFunc2</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   MainWindow(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">   ~MainWindow();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行主窗口 用于显示界面 ui</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">   MainWindow w;</span><br><span class="line">   w.show();</span><br><span class="line">   <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看 代码仓库 <a href="https://github.com/SChen1024/Imagelab/releases/tag/V0.1.0" target="_blank" rel="noopener">SChen1024/ImageLab V0.1.0</a></p><p>我们的程序一直是同步提交到 github 和 gitee 的, 有什么问题可以去看代码</p><h3 id="QImage-和-QPixmap-显示图像"><a href="#QImage-和-QPixmap-显示图像" class="headerlink" title="QImage 和 QPixmap 显示图像"></a>QImage 和 QPixmap 显示图像</h3><p>上面就是在简单的测试一下, 那我们 现在就开始正式的工作 首先看下直接读取文件的方式,<br>我们将上一节中 输出语句的函数部分换成加载图片, 能够得到下面的函数部分, 进而运行就能够得到结果图</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图片路径</span></span><br><span class="line">QString lena_img = <span class="string">"../testimages/lena.png"</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QPixmap pixmap;</span><br><span class="line">    pixmap.load(lena_img);</span><br><span class="line"></span><br><span class="line">    ui-&gt;lb_src-&gt;setPixmap(pixmap);</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(<span class="string">"左侧使用 QPixmap load 图像数据1 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QImage <span class="title">image</span><span class="params">(lena_img)</span></span>;</span><br><span class="line">    ui-&gt;lb_dst-&gt;setPixmap(QPixmap::fromImage(image));</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(<span class="string">"右侧使用 QImage 转换成 QPixmap 进行显示2 "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 label 只能显示 pixmap 图像, 而且十分简单操作, 而 QImage 也是转换成 QPixmap 之后才做的显示, 不过在可以去看<a href="https://blog.csdn.net/feiyangyangfei/article/details/8485797" target="_blank" rel="noopener">QImage 与 QPixmap 加载图片 效果 .</a>中介绍了其他的方式显示图像, 我们就不去深究了,</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588137693563.png" alt="加载图像显示"></p><h3 id="QT-显示-opencv-mat-图像"><a href="#QT-显示-opencv-mat-图像" class="headerlink" title="QT 显示 opencv mat 图像"></a>QT 显示 opencv mat 图像</h3><p>终于终于到了我们这篇文章的重点了, 其实经过上面的铺垫, 我们 opencv 读取图像之后要做的就是 将 mat 图像转换成 QImage 或者 QPixmap 图像就好了, 多一步转换过程, 目前没有找到 mat 直接转换成 QPixmap 的方式 , 目前的实现都是 转换成 QImage 然后再转换的方式,</p><p>直接搜索 opencv Mat 转 QImage 能找到很多结果, 其实呢 原理都很简单, 根据原始图像的通道数目将图像转换成相应的 QImage 格式, 比如 3 通道的 rgb 图像转换 <code>QImage image(mat.data, mat.cols, mat.rows,static_cast&lt;int&gt;(mat.step),QImage::Format_RGB888);</code> 我们能够得到这样的结果, 很简单就能实现, 获取图像的宽度, 高度, 以及最重要的 <code>data</code> 也就是图像的数据指针, 然后依次转换成我们需要的 QImage 图像即可, 值得注意的是, opencv 是 BGR 图像的顺序, 所以最后要进行颜色通道的转换, 转换成 rgb 不然颜色会有点奇怪..</p><p>具体的参数可以参考我之前的博文, 关于 mat 的 step 属性可以参考<a href="https://blog.csdn.net/qianqing13579/article/details/45318279" target="_blank" rel="noopener">OpenCV 中 Mat 属性 step，size，step1，elemSize，elemSize1</a></p><p>这里附上 opencv Mat 与 QImage 的互相转换, 这里没有使用 if 为了更好看</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @fn  QImage CvMat2QImage(const cv::Mat &amp; mat)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   将opencv mat 转换成 QT image</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author  IRIS_Chen</span></span><br><span class="line"><span class="comment"> * @date    2019/12/19</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   mat The matrix</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  A QImage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">QImage <span class="title">CvMat2QImage</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;mat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 图像的通道</span></span><br><span class="line">    <span class="keyword">int</span> channel = mat.channels();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设立一个表 直接查询 其中 0 2 是无效值 1 3 4 对应的转换值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, QImage::Format&gt; img_cvt_map &#123;</span><br><span class="line">        &#123; <span class="number">1</span>, QImage::Format_Grayscale8 &#125;,</span><br><span class="line">        &#123; <span class="number">3</span>, QImage::Format_RGB888 &#125;,</span><br><span class="line">        &#123; <span class="number">4</span>, QImage::Format_ARGB32 &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">QImage <span class="title">image</span><span class="params">(mat.data, mat.cols, mat.rows,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(mat.step),</span></span></span><br><span class="line"><span class="function"><span class="params">                 img_cvt_map.at(channel))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三通道图像 值做 通道转换</span></span><br><span class="line">    <span class="keyword">return</span> channel == <span class="number">3</span> ? image.rgbSwapped() : image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @fn  static cv::Mat QImage2CvMat(const QImage &amp;image);</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @brief   QT Image 转换成 cv Mat 结构</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @author  IRIS_Chen</span></span><br><span class="line"><span class="comment">* @date    2019/12/19</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param   image   The image</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @return  A cv::Mat</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">QImage2CvMat</span><span class="params">(<span class="keyword">const</span> QImage &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat mat;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;QImage::Format, <span class="keyword">int</span>&gt; img_cvt_map&#123;</span><br><span class="line">        &#123; QImage::Format_Grayscale8, <span class="number">1</span> &#125;,</span><br><span class="line">        &#123; QImage::Format_RGB888, <span class="number">3</span> &#125;,</span><br><span class="line">        &#123; QImage::Format_ARGB32, <span class="number">4</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cv::Mat(image.height(), image.width(),img_cvt_map.at(image.format()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了便于区分, 我们在处理图像的时候, 在图上分别显示一个字符串, opencv 的显示图像我们已经介绍过了, QT QPixmap 显示 字符串可以参考<a href="https://www.cnblogs.com/linuxAndMcu/p/11059635.html" target="_blank" rel="noopener">Qt 2D 绘图之三：绘制文字、路径、图像、复合模式</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图片路径</span></span><br><span class="line">QString lena_img = <span class="string">"../testimages/lena.png"</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QPixmap pixmap;</span><br><span class="line">    pixmap.load(lena_img);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在图上绘制文字</span></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(&amp;pixmap)</span></span>;</span><br><span class="line">    painter.setPen(QColor(Qt::yellow));</span><br><span class="line">    painter.drawText(<span class="number">100</span>,<span class="number">100</span>,<span class="string">"QT QPixmap"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ui-&gt;lb_src-&gt;setPixmap(pixmap);</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(<span class="string">"左侧使用 QPixmap load 图像数据1 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::testFunc2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat mat = cv::imread(<span class="string">"../testimages/lena.png"</span>);</span><br><span class="line">    <span class="comment">// 在图上显示文字</span></span><br><span class="line">    cv::putText(mat,<span class="string">"OpenCV Mat"</span>,cv::Point(<span class="number">100</span>,<span class="number">100</span>),cv::FONT_HERSHEY_COMPLEX,<span class="number">1.0</span>, cv::Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">    QImage image = CvMat2QImage(mat);</span><br><span class="line"></span><br><span class="line">    ui-&gt;lb_dst-&gt;setPixmap(QPixmap::fromImage(image));</span><br><span class="line">    ui-&gt;pt_log-&gt;appendPlainText(<span class="string">"右侧使用 Mat --&gt; QImage --&gt; QPixmap 进行显示2 "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行得到的结果图片</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588137693556.png" alt="QT 显示 opencv 图像"></p><p>opencv 就是 使用 mat 读取图像, 然后 转换成 QImage, 转换通道 ,再转换成 QPixmap 最后显示在 QLabel 上,</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; title=&quot;开始之前&quot;&gt;&lt;/a&gt;开始之前&lt;/h2&gt;&lt;p&gt;这其实也是 opencv 处理图像的系列, 只是想我们在进一步复杂化我们的代码之前, 每次给出代码我们都要给出很多, 然后窗口的显示上也有很多不必要的东西, 我们为了后面进行更好的算法效果以及算法执行, 我们先规划一下程序, 写出来一个界面程序出来, 这样的话, 我们之后的程序部分只需要给出一个函数的部分就好, 我们的程序算法在增加的时候, 将功能做到一个一个的菜单里面来, 这样一边处理算法, 一边写出界面图像..&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;p&gt;我们主要将图形界面部分使用代码来实现, 这样不需要进行编译便能够大概知道结果..&lt;/p&gt;
&lt;p&gt;我们在进行复杂的界面之前, 我们先实现一个简单的工程, 能够使用 opencv 读取图片, 然后显示在 qt 的 label 控件 上面,&lt;/p&gt;
&lt;h3 id=&quot;QT-图像格式&quot;&gt;&lt;a href=&quot;#QT-图像格式&quot; class=&quot;headerlink&quot; title=&quot;QT 图像格式&quot;&gt;&lt;/a&gt;QT 图像格式&lt;/h3&gt;&lt;p&gt;在 qt 中提供了几种图像显示的方式,可以看这篇文章&lt;a href=&quot;https://blog.csdn.net/zzwdkxx/article/details/39480559&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;关于 QPixmap/QImage/QPicture&lt;/a&gt;, 详细的介绍了几种格式的使用方法,&lt;br&gt;QT 自带的 &lt;code&gt;QImage&lt;/code&gt; 和 &lt;code&gt;QPixmap&lt;/code&gt;, 都是支持读取图像的,可以直接用于显示图像, 但是呢, 我们后续还要进行复杂的算法实现, 所以我们还是要转回到 opencv 的怀抱中来, 那么我们不可避免的需要进行数据图像格式之间的互相转换, 目前大多说使用的方式都是 opencv 的 Mat 格式与 QT QPixmap 格式之间的转换, 按后显示到 QT 的 label 上面, 我们先来实现一下:&lt;/p&gt;
&lt;h3 id=&quot;UI-界面设计&quot;&gt;&lt;a href=&quot;#UI-界面设计&quot; class=&quot;headerlink&quot; title=&quot;UI 界面设计&quot;&gt;&lt;/a&gt;UI 界面设计&lt;/h3&gt;&lt;p&gt;这里稍微提一下 QT Designer, 我们可以通过托拽的方式实现界面的设计, 也提供了很多组件让我们选择, 我们先暂时使用这种比较简单的方式进行, 后面逐渐介绍更为复杂的操作.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588137693125.png&quot; alt=&quot;QT UI 设计&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里我们使用数字 1,2,3,4, 标记了四个区域, 就是我们常用的区域了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;编辑区域, 可以编辑与托拽, 能够预览&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;控件结构树, 各个控件的从属结构, 名称就是 &lt;code&gt;ObjectName&lt;/code&gt; 能够在程序使用控件名进行操控&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;属性区域,能够直接调整相关的参数, 也可以在程序中进行调整各种属性&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;控件区域, 不同种类的控件, 可以用于托拽, 直接显示在窗口中..&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体的实现方式不用去深究, 且通过托拽改变 &lt;code&gt;.ui&lt;/code&gt; 文件, 实际上就是 一个 xml 格式的文件, QT 通过 &lt;code&gt;uic&lt;/code&gt; 会将 &lt;code&gt;xxx.ui&lt;/code&gt; 转换成 &lt;code&gt;ui_xxx.h&lt;/code&gt; 文件, 我们通过引用即可直接操控控件了,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果我们改变了 ui, 但是运行之后没有更新, 在工程山强制 qmake 一下就能解决了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我们这个工程中, 我们托拽了两个 &lt;code&gt;QLabel&lt;/code&gt; 组件和两个 &lt;code&gt;QPushButton&lt;/code&gt; 组件, 相应的可以在上图的 2 区域看到对象名称..&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MainWindow:&lt;ul&gt;
&lt;li&gt;geometry: 0,0,960,540 : 我们运行的窗口尺寸&lt;/li&gt;
&lt;li&gt;windowsTitle: “ImageLab”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;lb_src:&lt;ul&gt;
&lt;li&gt;geometry: 20,30,400,400 用于指定控件的左上角位置和 尺寸宽高, 我们使用这个参数指定即可&lt;/li&gt;
&lt;li&gt;frameShape: WinPanel&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;lb_dst:&lt;ul&gt;
&lt;li&gt;geometry: 470,30,400,400 用于指定控件的左上角位置和 尺寸宽高, 我们使用这个参数指定即可&lt;/li&gt;
&lt;li&gt;frameShape: WinPanel&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;btn_test1,btn_test2: 都是默认托拽的 , 尺寸默认, 位置 随意就好, 后面用于我们进行一下测试算法 暂时忽略&lt;/li&gt;
&lt;li&gt;pt_log: 多行文本, 用于显示一些结果信息, 测试过程中的一些输出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们这个界面也没有布局, 就是很简单的把东西给显示出来, 在编辑之后 按 &lt;code&gt;Shift+Alt+R&lt;/code&gt;能够预览界面,&lt;br&gt;如果有布局之类的需要及时查看, 我们这里就是简单的 ui , 布局什么样 得到的就是什么样子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588137693113.png&quot; alt=&quot;预览 UI 界面&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们后面的测试可能就是左边显示原始图像, 右边显示运算之后 的图像, 我们来实现一下&lt;/p&gt;
&lt;p&gt;这里关于 ui 界面的设计 只是稍微提一下, 你们可以直接查看其他的文章介绍的使用方法, 简单点的可以看&lt;a href=&quot;https://blog.csdn.net/a10929/article/details/78114261&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;使用 Qt Designer 来设计界面&lt;/a&gt;和&lt;a href=&quot;https://blog.csdn.net/weixin_36340947/article/details/75691506&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;使用 Qt Designer 创建界面&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;信号与槽-实现-UI-点击事件&quot;&gt;&lt;a href=&quot;#信号与槽-实现-UI-点击事件&quot; class=&quot;headerlink&quot; title=&quot;信号与槽 实现 UI 点击事件&quot;&gt;&lt;/a&gt;信号与槽 实现 UI 点击事件&lt;/h3&gt;&lt;p&gt;在我们进行显示图像之前, 我们稍微介绍一下 QT 的信号与槽的实现方式, QT 最 NB 的地方实现了信号与槽 , 简单理解就是, 我们提前将信号与一个槽(函数)声明连接, 然后我们点击一个按钮 会发射一个信号, 然后经过 QT 的信号处理机制 就能够调用我们提前设定的函数了,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PS: 只是粗略 的这么看就行, 具体还要复杂很多, 后面再说&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们简单实现一下 这个功能, 点击输出我们点击可哪个按钮..&lt;br&gt;我们点击 &lt;code&gt;测试按钮1: btn_test1&lt;/code&gt;调用一个函数 &lt;code&gt;testFunc1&lt;/code&gt;, 然后在结果框输出&lt;code&gt;点击了按钮1&lt;/code&gt; ,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588137693115.gif&quot; alt=&quot;点击输出效果预览&quot;&gt;&lt;/p&gt;
&lt;p&gt;,我们只看 核心的代码部分&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// mainwindow.cpp&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&quot;mainwindow.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&quot;ui_mainwindow.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MainWindow::MainWindow(QWidget *parent)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   : QMainWindow(parent)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   , ui(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Ui::MainWindow)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ui-&amp;gt;setupUi(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// 设定信号与槽 连接&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   connect(ui-&amp;gt;btn_test1,&amp;amp;QPushButton::clicked,&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;,&amp;amp;MainWindow::testFunc1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   connect(ui-&amp;gt;btn_test2,&amp;amp;QPushButton::clicked,&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;,&amp;amp;MainWindow::testFunc2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// 初始化 ui&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ui-&amp;gt;pt_log-&amp;gt;clear();  &lt;span class=&quot;comment&quot;&gt;// 清除框内输出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MainWindow::~MainWindow()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;delete&lt;/span&gt; ui;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainWindow::testFunc1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ui-&amp;gt;pt_log-&amp;gt;appendPlainText(&lt;span class=&quot;string&quot;&gt;&quot;你点击了 测试按钮 1 &quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainWindow::testFunc2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ui-&amp;gt;pt_log-&amp;gt;appendPlainText(&lt;span class=&quot;string&quot;&gt;&quot;你点击了 测试按钮 2&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// mainwindow.h&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;ifndef&lt;/span&gt; MAINWINDOW_H&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; MAINWINDOW_H&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;QMainWindow&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;QT_BEGIN_NAMESPACE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; Ui &amp;#123; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainWindow&lt;/span&gt;;&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;QT_END_NAMESPACE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainWindow&lt;/span&gt; :&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; QMainWindow&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Q_OBJECT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; slots:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testFunc1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testFunc2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   MainWindow(QWidget *parent = &lt;span class=&quot;literal&quot;&gt;nullptr&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ~MainWindow();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Ui::MainWindow *ui;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// MAINWINDOW_H&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// main.cpp&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&quot;mainwindow.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;QApplication&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 运行主窗口 用于显示界面 ui&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;QApplication &lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(argc, argv)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   MainWindow w;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   w.show();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a.exec();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里可以看 代码仓库 &lt;a href=&quot;https://github.com/SChen1024/Imagelab/releases/tag/V0.1.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SChen1024/ImageLab V0.1.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们的程序一直是同步提交到 github 和 gitee 的, 有什么问题可以去看代码&lt;/p&gt;
&lt;h3 id=&quot;QImage-和-QPixmap-显示图像&quot;&gt;&lt;a href=&quot;#QImage-和-QPixmap-显示图像&quot; class=&quot;headerlink&quot; title=&quot;QImage 和 QPixmap 显示图像&quot;&gt;&lt;/a&gt;QImage 和 QPixmap 显示图像&lt;/h3&gt;&lt;p&gt;上面就是在简单的测试一下, 那我们 现在就开始正式的工作 首先看下直接读取文件的方式,&lt;br&gt;我们将上一节中 输出语句的函数部分换成加载图片, 能够得到下面的函数部分, 进而运行就能够得到结果图&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 图片路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;QString lena_img = &lt;span class=&quot;string&quot;&gt;&quot;../testimages/lena.png&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainWindow::testFunc1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QPixmap pixmap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pixmap.load(lena_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui-&amp;gt;lb_src-&amp;gt;setPixmap(pixmap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui-&amp;gt;pt_log-&amp;gt;appendPlainText(&lt;span class=&quot;string&quot;&gt;&quot;左侧使用 QPixmap load 图像数据1 &quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainWindow::testFunc2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;QImage &lt;span class=&quot;title&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(lena_img)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui-&amp;gt;lb_dst-&amp;gt;setPixmap(QPixmap::fromImage(image));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui-&amp;gt;pt_log-&amp;gt;appendPlainText(&lt;span class=&quot;string&quot;&gt;&quot;右侧使用 QImage 转换成 QPixmap 进行显示2 &quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其实 label 只能显示 pixmap 图像, 而且十分简单操作, 而 QImage 也是转换成 QPixmap 之后才做的显示, 不过在可以去看&lt;a href=&quot;https://blog.csdn.net/feiyangyangfei/article/details/8485797&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QImage 与 QPixmap 加载图片 效果 .&lt;/a&gt;中介绍了其他的方式显示图像, 我们就不去深究了,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588137693563.png&quot; alt=&quot;加载图像显示&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;QT-显示-opencv-mat-图像&quot;&gt;&lt;a href=&quot;#QT-显示-opencv-mat-图像&quot; class=&quot;headerlink&quot; title=&quot;QT 显示 opencv mat 图像&quot;&gt;&lt;/a&gt;QT 显示 opencv mat 图像&lt;/h3&gt;&lt;p&gt;终于终于到了我们这篇文章的重点了, 其实经过上面的铺垫, 我们 opencv 读取图像之后要做的就是 将 mat 图像转换成 QImage 或者 QPixmap 图像就好了, 多一步转换过程, 目前没有找到 mat 直接转换成 QPixmap 的方式 , 目前的实现都是 转换成 QImage 然后再转换的方式,&lt;/p&gt;
&lt;p&gt;直接搜索 opencv Mat 转 QImage 能找到很多结果, 其实呢 原理都很简单, 根据原始图像的通道数目将图像转换成相应的 QImage 格式, 比如 3 通道的 rgb 图像转换 &lt;code&gt;QImage image(mat.data, mat.cols, mat.rows,static_cast&amp;lt;int&amp;gt;(mat.step),QImage::Format_RGB888);&lt;/code&gt; 我们能够得到这样的结果, 很简单就能实现, 获取图像的宽度, 高度, 以及最重要的 &lt;code&gt;data&lt;/code&gt; 也就是图像的数据指针, 然后依次转换成我们需要的 QImage 图像即可, 值得注意的是, opencv 是 BGR 图像的顺序, 所以最后要进行颜色通道的转换, 转换成 rgb 不然颜色会有点奇怪..&lt;/p&gt;
&lt;p&gt;具体的参数可以参考我之前的博文, 关于 mat 的 step 属性可以参考&lt;a href=&quot;https://blog.csdn.net/qianqing13579/article/details/45318279&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenCV 中 Mat 属性 step，size，step1，elemSize，elemSize1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里附上 opencv Mat 与 QImage 的互相转换, 这里没有使用 if 为了更好看&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * @fn  QImage CvMat2QImage(const cv::Mat &amp;amp; mat)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * @brief   将opencv mat 转换成 QT image&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * @author  IRIS_Chen&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * @date    2019/12/19&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * @param   mat The matrix&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * @return  A QImage&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;QImage &lt;span class=&quot;title&quot;&gt;CvMat2QImage&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; cv::Mat &amp;amp;mat)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 图像的通道&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; channel = mat.channels();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 设立一个表 直接查询 其中 0 2 是无效值 1 3 4 对应的转换值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, QImage::Format&amp;gt; img_cvt_map &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, QImage::Format_Grayscale8 &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, QImage::Format_RGB888 &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, QImage::Format_ARGB32 &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;QImage &lt;span class=&quot;title&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(mat.data, mat.cols, mat.rows,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                 &lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;(mat.step),&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                 img_cvt_map.at(channel))&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 三通道图像 值做 通道转换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; channel == &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; ? image.rgbSwapped() : image;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* @fn  static cv::Mat QImage2CvMat(const QImage &amp;amp;image);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* @brief   QT Image 转换成 cv Mat 结构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* @author  IRIS_Chen&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* @date    2019/12/19&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* @param   image   The image&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* @return  A cv::Mat&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;cv::Mat &lt;span class=&quot;title&quot;&gt;QImage2CvMat&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; QImage &amp;amp;image)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat mat;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&amp;lt;QImage::Format, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; img_cvt_map&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123; QImage::Format_Grayscale8, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123; QImage::Format_RGB888, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123; QImage::Format_ARGB32, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; cv::Mat(image.height(), image.width(),img_cvt_map.at(image.format()));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了便于区分, 我们在处理图像的时候, 在图上分别显示一个字符串, opencv 的显示图像我们已经介绍过了, QT QPixmap 显示 字符串可以参考&lt;a href=&quot;https://www.cnblogs.com/linuxAndMcu/p/11059635.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Qt 2D 绘图之三：绘制文字、路径、图像、复合模式&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 图片路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;QString lena_img = &lt;span class=&quot;string&quot;&gt;&quot;../testimages/lena.png&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainWindow::testFunc1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QPixmap pixmap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pixmap.load(lena_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 在图上绘制文字&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;QPainter &lt;span class=&quot;title&quot;&gt;painter&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&amp;amp;pixmap)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    painter.setPen(QColor(Qt::yellow));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    painter.drawText(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;QT QPixmap&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui-&amp;gt;lb_src-&amp;gt;setPixmap(pixmap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui-&amp;gt;pt_log-&amp;gt;appendPlainText(&lt;span class=&quot;string&quot;&gt;&quot;左侧使用 QPixmap load 图像数据1 &quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainWindow::testFunc2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat mat = cv::imread(&lt;span class=&quot;string&quot;&gt;&quot;../testimages/lena.png&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 在图上显示文字&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::putText(mat,&lt;span class=&quot;string&quot;&gt;&quot;OpenCV Mat&quot;&lt;/span&gt;,cv::Point(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;),cv::FONT_HERSHEY_COMPLEX,&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, cv::Scalar(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QImage image = CvMat2QImage(mat);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui-&amp;gt;lb_dst-&amp;gt;setPixmap(QPixmap::fromImage(image));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui-&amp;gt;pt_log-&amp;gt;appendPlainText(&lt;span class=&quot;string&quot;&gt;&quot;右侧使用 Mat --&amp;gt; QImage --&amp;gt; QPixmap 进行显示2 &quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行得到的结果图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/小书匠/1588137693556.png&quot; alt=&quot;QT 显示 opencv 图像&quot;&gt;&lt;/p&gt;
&lt;p&gt;opencv 就是 使用 mat 读取图像, 然后 转换成 QImage, 转换通道 ,再转换成 QPixmap 最后显示在 QLabel 上,&lt;/p&gt;
&lt;h2 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Technology" scheme="https://schen1024.github.io/categories/Technology/"/>
    
    
      <category term="opencv" scheme="https://schen1024.github.io/tags/opencv/"/>
    
      <category term="c++" scheme="https://schen1024.github.io/tags/c/"/>
    
      <category term="qt" scheme="https://schen1024.github.io/tags/qt/"/>
    
      <category term="imagelab" scheme="https://schen1024.github.io/tags/imagelab/"/>
    
  </entry>
  
  <entry>
    <title>服务器站点列表</title>
    <link href="https://schen1024.github.io/2020/04-26/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%99%E7%82%B9%E5%88%97%E8%A1%A8.html"/>
    <id>https://schen1024.github.io/2020/04-26/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%99%E7%82%B9%E5%88%97%E8%A1%A8.html</id>
    <published>2020-04-26T16:44:49.000Z</published>
    <updated>2023-01-01T13:25:24.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>目前 Aliserver 服务器负责托管 WHUHoude 工程下的所有网站主要分<br>由于网站未进行备案细节, 所以网站无法直接通过80端口访问</p><p>网站的具体配置信息, 可参考博文, 主要是部署了 旧版本的asp 程序和 少量的php 网站</p><h2 id="网站列表"><a href="#网站列表" class="headerlink" title="网站列表"></a>网站列表</h2><p>asp网站使用的是系统自带的 IIS 开启了88 端口, 主要是旧版本的网站可以通过<a href="http://whupmc.cn:88" target="_blank" rel="noopener">whupmc.cn</a> 域名访问, </p><p>php 网站使用的 phpstudy 便携版本搭建的  Apache + MySQL</p><p>主要的网站列表是:</p><p><img src="/2020/04-26/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%99%E7%82%B9%E5%88%97%E8%A1%A8/1587891235527.table.html" alt="表格"></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;目前 Aliserver 服务器负责托管 WHUHoude 工程下的所有网站主要分&lt;br&gt;由于网站未进行备案细节, 所以网站无法直接通过80端口访问&lt;/p&gt;
&lt;p&gt;网站的具体配置信息, 可参考博文, 主要是部署了 旧版本的asp 程序和 少量的php 网站&lt;/p&gt;
&lt;h2 id=&quot;网站列表&quot;&gt;&lt;a href=&quot;#网站列表&quot; class=&quot;headerlink&quot; title=&quot;网站列表&quot;&gt;&lt;/a&gt;网站列表&lt;/h2&gt;&lt;p&gt;asp网站使用的是系统自带的 IIS 开启了88 端口, 主要是旧版本的网站可以通过&lt;a href=&quot;http://whupmc.cn:88&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;whupmc.cn&lt;/a&gt; 域名访问, &lt;/p&gt;
&lt;p&gt;php 网站使用的 phpstudy 便携版本搭建的  Apache + MySQL&lt;/p&gt;
&lt;p&gt;主要的网站列表是:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/04-26/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%99%E7%82%B9%E5%88%97%E8%A1%A8/1587891235527.table.html&quot; alt=&quot;表格&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Person" scheme="https://schen1024.github.io/categories/Person/"/>
    
    
      <category term="blog" scheme="https://schen1024.github.io/tags/blog/"/>
    
      <category term="server" scheme="https://schen1024.github.io/tags/server/"/>
    
      <category term="html" scheme="https://schen1024.github.io/tags/html/"/>
    
      <category term="asp" scheme="https://schen1024.github.io/tags/asp/"/>
    
      <category term="php" scheme="https://schen1024.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>opencv-8-图像核与蒙板操作</title>
    <link href="https://schen1024.github.io/2020/04-25/opencv-8-kernel.html"/>
    <id>https://schen1024.github.io/2020/04-25/opencv-8-kernel.html</id>
    <published>2020-04-25T15:31:42.000Z</published>
    <updated>2023-01-01T13:25:24.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>在准备开始的时候, 我大概列了一个<a href="https://schen1024.github.io/2020/04-20/opencv-bloglist.html">opencv 章节列表</a>, 按照章节进行写, 写到某些部分的时候再具体调整章节内容,  完成了之后, 会将具体的章节链接更新到这个列表中 算是作为一个目录吧.<br>有的章节写到很快, 有的章节写的很慢,  但是我会坚持一直写下去</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[toc]</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>按照我的写作计划, 之前算是完成了前面的大的章节, 我们开始正式进入图像处理的章节了, 在之前的章节中,我们介绍了图像的遍历操作, 我们从一个基础的问题出发, 我们对于每一点的像素值, 每个点减去他上面边的点的值作为结果值, 那我们会得到什么图呢,</p><h3 id="图像下侧差分"><a href="#图像下侧差分" class="headerlink" title="图像下侧差分"></a>图像下侧差分</h3><p>这我们为了简单运算吧, 我们提前将结果初始化为0, 然后将每一行的像素减去它上面的像素, 作为结果当前点的颜色值 我们看下代码以及跑起来看下会是什么结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置 要显示的图像路径</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lena_png = <span class="string">"./TestImages/lena.png"</span>;</span><br><span class="line">    cv::Mat src_img = cv::imread(lena_png);</span><br><span class="line">    cv::Mat res_img = cv::Mat::zeros(src_img.size(), CV_8UC3);</span><br><span class="line">    <span class="comment">// 初始化所有结果为 0 第一行不存在上一行, 默认为0  彩色图像 每个通道都计算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; src_img.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src_img.cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; src_img.channels(); k++)</span><br><span class="line">            &#123;</span><br><span class="line">                res_img.at&lt;cv::Vec3b&gt;(i, j)[k] = src_img.at&lt;cv::Vec3b&gt;(i, j)[k] - src_img.at&lt;cv::Vec3b&gt;(i<span class="number">-1</span>, j)[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::imshow(<span class="string">"src_img"</span>, src_img);</span><br><span class="line">    cv::imshow(<span class="string">"res_img"</span>, res_img);</span><br><span class="line"></span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// return a.exec();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中核心部分就是计算 <code>res_img.at&lt;cv::Vec3b&gt;(i, j)[k] = src_img.at&lt;cv::Vec3b&gt;(i, j)[k] - src_img.at&lt;cv::Vec3b&gt;(i-1, j)[k];</code> 颜色部分, 我们的 i 从第一行开始的 所以不会出现索引出错, 这个操作比较简单, 我们得到了下面的图像结果, </p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587964862334.png" alt="下差分图"></p><h3 id="图像锐化操作"><a href="#图像锐化操作" class="headerlink" title="图像锐化操作"></a>图像锐化操作</h3><p>我们这里说一下, 在之前的章节也都提过, 在图像处理的过程中, 我们一般采用的是灰度图像, 能够有效的获取到图像的细节特征, 而且计算起来比较方便, 所以我们在后续进行一下算法处理的时候会采用灰度图像, 特此说明</p><p>根据opencv 例程<a href="https://docs.opencv.org/4.3.0/d7/d37/tutorial_mat_mask_operations.html" target="_blank" rel="noopener">Mask operations on matrices</a> 中提到的一个案例, 我计算一个点与它四邻域的的差值的 也就是<br>$$<br>g(i,j) = f(i,j) + (f(i,j)-f(i-1,j))+ (f(i,j)-f(i,j-1))+ (f(i,j)-f(i,j+1))+ (f(i,j)-f(i+1,j));<br>$$<br>在线性代数中, 我们的运算都能转换成矩阵的运算, 那么, 我们抽象一下, 我们能够得到这样的一个结果,<br>$$<br>g(i,j) = M\cdot f(i,j),  \quad M = \begin{bmatrix}<br> 0 &amp; -1 &amp; 0 \<br> -1 &amp; 5 &amp; -1 \<br> 0 &amp; -1 &amp; 0<br> \end{bmatrix}<br>$$</p><p>与我们的运算得到的等式是一致的, 我们考虑一下怎么实现, 这里我们也参考 例程里面的实现,<br>我们将算法部分封装起来 这里我们使用<code>cv::Mat res_img = testFunc(src_img);</code> 这样的方法, 然后主要去实现 <code>testFunc</code>函数就行了, 后面我们为了不再重复的贴出代码, 希望之后看到的话 不要有疑问.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="comment">// 引入 opencv 函数头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行 测试 算法</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">testFunc</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;src_img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat res_img = cv::Mat::zeros(src_img.size(), CV_8UC1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; src_img.rows - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; src_img.cols - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            res_img.at&lt;uchar&gt;(i, j) = cv::saturate_cast&lt;uchar&gt;( src_img.at&lt;uchar&gt;(i, j)</span><br><span class="line">                + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i - <span class="number">1</span>, j)</span><br><span class="line">                + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i + <span class="number">1</span>, j)</span><br><span class="line">                + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i, j - <span class="number">1</span>)</span><br><span class="line">                + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i, j + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res_img;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置 要显示的图像路径</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lena_png = <span class="string">"./TestImages/lena.png"</span>;</span><br><span class="line">    cv::Mat src_img = cv::imread(lena_png);</span><br><span class="line">    cv::cvtColor(src_img, src_img, cv::COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">    cv::Mat res_img = testFunc(src_img);</span><br><span class="line"></span><br><span class="line">    cv::imshow(<span class="string">"src_img"</span>, src_img);</span><br><span class="line">    cv::imshow(<span class="string">"res_img"</span>, res_img);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// return a.exec();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们上面提出的算法就是在进行图像的锐化操作,相当于在原始像素的基础上加上了我们原图与四邻域像素的差值, 这样我们能够将边缘梯度过大的区域进行增强, 平滑部分则不会过分处理, 最终得到这样的图像处理结果..</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587964861870.png" alt="锐化增强效果"></p><h3 id="opencv-核操作"><a href="#opencv-核操作" class="headerlink" title="opencv 核操作"></a>opencv 核操作</h3><p>我们在处理的时候实际上没有解决边缘的问题, 在结果图中可以看到四个边缘各有一个像素的黑色边缘, 我们可以考虑计算其他的简化计算方式, 但是太过与繁琐了, 为了优化体验我们就没有处理,  但是 opencv 中提供了 一种通用的方式进行处理 也就是核, 我们先看下实现方式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat kernel = (cv::Mat_&lt;<span class="keyword">char</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">truetruetruetruetruetruetruetruetruetrue<span class="number">-1</span>, <span class="number">5</span>, <span class="number">-1</span>,</span><br><span class="line">truetruetruetruetruetruetruetruetruetrue<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">cv::Mat res_img2;</span><br><span class="line">cv::filter2D(src_img, res_img2, src_img.depth(), kernel);</span><br></pre></td></tr></table></figure><br>我们设定核之后. 可以直接进行操作, 我们可以通过改动核从而进行图像处理,  看下图, 好像得到右侧的图像效果更好</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587964861614.png" alt="锐化效果对比"></p><h3 id="运行时间对比"><a href="#运行时间对比" class="headerlink" title="运行时间对比"></a>运行时间对比</h3><p>两种实现结果是大概一致的, 算法上执行是一样的 , 那时间呢,<br>在之前的章节, 我们介绍了不同的图像遍历的方式进行图像遍历, 时间上差异还是比较大的, 这次我们同样使用了两种方式进行: 索引访问和指针访问进行图像处理, 算法部分的实现是一致的,  我们写了<br><code>testFunc</code>和 <code>testFunc2</code> 两个函数, 相应的代代码可以看下面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="comment">// 引入 opencv 函数头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行 测试 算法</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">testFunc</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;src_img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat res_img = cv::Mat::zeros(src_img.size(), CV_8UC1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; src_img.rows - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; src_img.cols - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            res_img.at&lt;uchar&gt;(i, j) = cv::saturate_cast&lt;uchar&gt;(src_img.at&lt;uchar&gt;(i, j)</span><br><span class="line">                + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i - <span class="number">1</span>, j)</span><br><span class="line">                + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i + <span class="number">1</span>, j)</span><br><span class="line">                + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i, j - <span class="number">1</span>)</span><br><span class="line">                + src_img.at&lt;uchar&gt;(i, j) - src_img.at&lt;uchar&gt;(i, j + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res_img;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用测试 指针函数</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">testFunc2</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;src_img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat res_img = cv::Mat::zeros(src_img.size(), CV_8UC1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; src_img.rows - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> uchar* p_row_pre = src_img.ptr&lt;uchar&gt;(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">const</span> uchar* p_row_cur = src_img.ptr&lt;uchar&gt;(i);</span><br><span class="line">        <span class="keyword">const</span> uchar* p_row_next = src_img.ptr&lt;uchar&gt;(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        uchar* p_row_res = res_img.ptr&lt;uchar&gt;(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; src_img.cols - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            *p_row_res++ = cv::saturate_cast&lt;uchar&gt;(<span class="number">5</span> * p_row_cur[j]</span><br><span class="line">                - p_row_cur[j<span class="number">-1</span>] - p_row_cur[j+<span class="number">1</span>] - p_row_pre[j] - p_row_next[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res_img;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置 要显示的图像路径</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lena_png = <span class="string">"./TestImages/lena.png"</span>;</span><br><span class="line">    cv::Mat src_img = cv::imread(lena_png);</span><br><span class="line">    cv::cvtColor(src_img, src_img, cv::COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试索引方式进行 锐化运算</span></span><br><span class="line">    <span class="keyword">double</span> t = (<span class="keyword">double</span>)cv::getTickCount();</span><br><span class="line">    cv::Mat res_img = testFunc(src_img);</span><br><span class="line">    t = ((<span class="keyword">double</span>)cv::getTickCount() - t) / cv::getTickFrequency();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sharpen-index: \t\t"</span> &lt;&lt; t &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 指针方式进行 锐化运算</span></span><br><span class="line">    t = (<span class="keyword">double</span>)cv::getTickCount();</span><br><span class="line">    res_img = testFunc2(src_img);</span><br><span class="line">    t = ((<span class="keyword">double</span>)cv::getTickCount() - t) / cv::getTickFrequency();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sharpen-pointer: \t"</span> &lt;&lt; t &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    cv::Mat kernel = (cv::Mat_&lt;<span class="keyword">char</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">5</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    cv::Mat res_img2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 filter 2D 算法时间</span></span><br><span class="line">    t = (<span class="keyword">double</span>)cv::getTickCount();</span><br><span class="line">    cv::filter2D(src_img, res_img2, src_img.depth(), kernel);</span><br><span class="line">    t = ((<span class="keyword">double</span>)cv::getTickCount() - t) / cv::getTickFrequency();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sharpen-filter: \t"</span> &lt;&lt; t &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    cv::imshow(<span class="string">"src_img"</span>, src_img);</span><br><span class="line">    cv::imshow(<span class="string">"res_img"</span>, res_img);</span><br><span class="line">    cv::imshow(<span class="string">"res_img2"</span>, res_img2);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// return a.exec();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法实现上很简单, 就是我们上面提到得到方法, 结果以是接近一致的, 但是时间上差的还是比较多,  使用 <code>filter2D</code> 的方式访问得到的图像还是比较好看的, 运行时间也是要比我们自己通过索引方式进行的算法要快很很多的,  但是相比我们使用指针还是有所不如, </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sharpen-index:          0.0747024 s</span><br><span class="line">sharpen-pointer:        0.0040774 s</span><br><span class="line">sharpen-filter:         0.0416613 s</span><br></pre></td></tr></table></figure><p>我们在 <code>modules\imgproc\src\filter.dispatch.cpp:1403</code> 的位置看到了 <code>filter2D</code> 函数的定义<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">filter2D</span><span class="params">(InputArray _src, OutputArray _dst, <span class="keyword">int</span> ddepth,</span></span></span><br><span class="line"><span class="function"><span class="params">              InputArray _kernel, Point anchor0,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">double</span> delta, <span class="keyword">int</span> borderType)</span></span>;</span><br></pre></td></tr></table></figure></p><p>相应的我们去看 调用图</p><p><img src="https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587964861606.png" alt="filter2D 函数调用图"></p><p>函数的主要调用使用了加速层的<code>modules\imgproc\src\filter.dispatch.cpp:1307</code> 处的 <code>hal::filter2D</code> 函数<br>这里涉及的部分还比较多, 可能也是由于调用的更底层的以及做了更多的边缘处理的原因 导致实际上花费的时间也更加的长, </p><p>这里暂时不去深究, 如果有机会再做进一步分析</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; title=&quot;开始之前&quot;&gt;&lt;/a&gt;开始之前&lt;/h2&gt;&lt;p&gt;在准备开始的时候, 我大概列了一个&lt;a href=&quot;https://schen1024.github.io/2020/04-20/opencv-bloglist.html&quot;&gt;opencv 章节列表&lt;/a&gt;, 按照章节进行写, 写到某些部分的时候再具体调整章节内容,  完成了之后, 会将具体的章节链接更新到这个列表中 算是作为一个目录吧.&lt;br&gt;有的章节写到很快, 有的章节写的很慢,  但是我会坚持一直写下去&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h2&gt;&lt;p&gt;按照我的写作计划, 之前算是完成了前面的大的章节, 我们开始正式进入图像处理的章节了, 在之前的章节中,我们介绍了图像的遍历操作, 我们从一个基础的问题出发, 我们对于每一点的像素值, 每个点减去他上面边的点的值作为结果值, 那我们会得到什么图呢,&lt;/p&gt;
&lt;h3 id=&quot;图像下侧差分&quot;&gt;&lt;a href=&quot;#图像下侧差分&quot; class=&quot;headerlink&quot; title=&quot;图像下侧差分&quot;&gt;&lt;/a&gt;图像下侧差分&lt;/h3&gt;&lt;p&gt;这我们为了简单运算吧, 我们提前将结果初始化为0, 然后将每一行的像素减去它上面的像素, 作为结果当前点的颜色值 我们看下代码以及跑起来看下会是什么结果&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 设置 要显示的图像路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; lena_png = &lt;span class=&quot;string&quot;&gt;&quot;./TestImages/lena.png&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat src_img = cv::imread(lena_png);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat res_img = cv::Mat::zeros(src_img.size(), CV_8UC3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 初始化所有结果为 0 第一行不存在上一行, 默认为0  彩色图像 每个通道都计算&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt; src_img.rows; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; src_img.cols; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; k &amp;lt; src_img.channels(); k++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                res_img.at&amp;lt;cv::Vec3b&amp;gt;(i, j)[k] = src_img.at&amp;lt;cv::Vec3b&amp;gt;(i, j)[k] - src_img.at&amp;lt;cv::Vec3b&amp;gt;(i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;, j)[k];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::imshow(&lt;span class=&quot;string&quot;&gt;&quot;src_img&quot;&lt;/span&gt;, src_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::imshow(&lt;span class=&quot;string&quot;&gt;&quot;res_img&quot;&lt;/span&gt;, res_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::waitKey(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// return a.exec();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中核心部分就是计算 &lt;code&gt;res_img.at&amp;lt;cv::Vec3b&amp;gt;(i, j)[k] = src_img.at&amp;lt;cv::Vec3b&amp;gt;(i, j)[k] - src_img.at&amp;lt;cv::Vec3b&amp;gt;(i-1, j)[k];&lt;/code&gt; 颜色部分, 我们的 i 从第一行开始的 所以不会出现索引出错, 这个操作比较简单, 我们得到了下面的图像结果, &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587964862334.png&quot; alt=&quot;下差分图&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;图像锐化操作&quot;&gt;&lt;a href=&quot;#图像锐化操作&quot; class=&quot;headerlink&quot; title=&quot;图像锐化操作&quot;&gt;&lt;/a&gt;图像锐化操作&lt;/h3&gt;&lt;p&gt;我们这里说一下, 在之前的章节也都提过, 在图像处理的过程中, 我们一般采用的是灰度图像, 能够有效的获取到图像的细节特征, 而且计算起来比较方便, 所以我们在后续进行一下算法处理的时候会采用灰度图像, 特此说明&lt;/p&gt;
&lt;p&gt;根据opencv 例程&lt;a href=&quot;https://docs.opencv.org/4.3.0/d7/d37/tutorial_mat_mask_operations.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mask operations on matrices&lt;/a&gt; 中提到的一个案例, 我计算一个点与它四邻域的的差值的 也就是&lt;br&gt;$$&lt;br&gt;g(i,j) = f(i,j) + (f(i,j)-f(i-1,j))+ (f(i,j)-f(i,j-1))+ (f(i,j)-f(i,j+1))+ (f(i,j)-f(i+1,j));&lt;br&gt;$$&lt;br&gt;在线性代数中, 我们的运算都能转换成矩阵的运算, 那么, 我们抽象一下, 我们能够得到这样的一个结果,&lt;br&gt;$$&lt;br&gt;g(i,j) = M\cdot f(i,j),  \quad M = \begin{bmatrix}&lt;br&gt; 0 &amp;amp; -1 &amp;amp; 0 \&lt;br&gt; -1 &amp;amp; 5 &amp;amp; -1 \&lt;br&gt; 0 &amp;amp; -1 &amp;amp; 0&lt;br&gt; \end{bmatrix}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;与我们的运算得到的等式是一致的, 我们考虑一下怎么实现, 这里我们也参考 例程里面的实现,&lt;br&gt;我们将算法部分封装起来 这里我们使用&lt;code&gt;cv::Mat res_img = testFunc(src_img);&lt;/code&gt; 这样的方法, 然后主要去实现 &lt;code&gt;testFunc&lt;/code&gt;函数就行了, 后面我们为了不再重复的贴出代码, 希望之后看到的话 不要有疑问.&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&quot;mainwindow.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;QApplication&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 引入 opencv 函数头文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;opencv2/opencv.hpp&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 进行 测试 算法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;cv::Mat &lt;span class=&quot;title&quot;&gt;testFunc&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; cv::Mat &amp;amp;src_img)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat res_img = cv::Mat::zeros(src_img.size(), CV_8UC1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt; src_img.rows - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j &amp;lt; src_img.cols - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            res_img.at&amp;lt;uchar&amp;gt;(i, j) = cv::saturate_cast&amp;lt;uchar&amp;gt;( src_img.at&amp;lt;uchar&amp;gt;(i, j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                + src_img.at&amp;lt;uchar&amp;gt;(i, j) - src_img.at&amp;lt;uchar&amp;gt;(i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                + src_img.at&amp;lt;uchar&amp;gt;(i, j) - src_img.at&amp;lt;uchar&amp;gt;(i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                + src_img.at&amp;lt;uchar&amp;gt;(i, j) - src_img.at&amp;lt;uchar&amp;gt;(i, j - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                + src_img.at&amp;lt;uchar&amp;gt;(i, j) - src_img.at&amp;lt;uchar&amp;gt;(i, j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res_img;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 设置 要显示的图像路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; lena_png = &lt;span class=&quot;string&quot;&gt;&quot;./TestImages/lena.png&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat src_img = cv::imread(lena_png);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::cvtColor(src_img, src_img, cv::COLOR_BGR2GRAY);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat res_img = testFunc(src_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::imshow(&lt;span class=&quot;string&quot;&gt;&quot;src_img&quot;&lt;/span&gt;, src_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::imshow(&lt;span class=&quot;string&quot;&gt;&quot;res_img&quot;&lt;/span&gt;, res_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::waitKey(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// return a.exec();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;我们上面提出的算法就是在进行图像的锐化操作,相当于在原始像素的基础上加上了我们原图与四邻域像素的差值, 这样我们能够将边缘梯度过大的区域进行增强, 平滑部分则不会过分处理, 最终得到这样的图像处理结果..&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587964861870.png&quot; alt=&quot;锐化增强效果&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;opencv-核操作&quot;&gt;&lt;a href=&quot;#opencv-核操作&quot; class=&quot;headerlink&quot; title=&quot;opencv 核操作&quot;&gt;&lt;/a&gt;opencv 核操作&lt;/h3&gt;&lt;p&gt;我们在处理的时候实际上没有解决边缘的问题, 在结果图中可以看到四个边缘各有一个像素的黑色边缘, 我们可以考虑计算其他的简化计算方式, 但是太过与繁琐了, 为了优化体验我们就没有处理,  但是 opencv 中提供了 一种通用的方式进行处理 也就是核, 我们先看下实现方式&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cv::Mat kernel = (cv::Mat_&amp;lt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;&amp;gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;truetruetruetruetruetruetruetruetruetrue&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;truetruetruetruetruetruetruetruetruetrue&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cv::Mat res_img2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cv::filter2D(src_img, res_img2, src_img.depth(), kernel);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;我们设定核之后. 可以直接进行操作, 我们可以通过改动核从而进行图像处理,  看下图, 好像得到右侧的图像效果更好&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587964861614.png&quot; alt=&quot;锐化效果对比&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;运行时间对比&quot;&gt;&lt;a href=&quot;#运行时间对比&quot; class=&quot;headerlink&quot; title=&quot;运行时间对比&quot;&gt;&lt;/a&gt;运行时间对比&lt;/h3&gt;&lt;p&gt;两种实现结果是大概一致的, 算法上执行是一样的 , 那时间呢,&lt;br&gt;在之前的章节, 我们介绍了不同的图像遍历的方式进行图像遍历, 时间上差异还是比较大的, 这次我们同样使用了两种方式进行: 索引访问和指针访问进行图像处理, 算法部分的实现是一致的,  我们写了&lt;br&gt;&lt;code&gt;testFunc&lt;/code&gt;和 &lt;code&gt;testFunc2&lt;/code&gt; 两个函数, 相应的代代码可以看下面&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&quot;mainwindow.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;QApplication&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 引入 opencv 函数头文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;opencv2/opencv.hpp&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 进行 测试 算法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;cv::Mat &lt;span class=&quot;title&quot;&gt;testFunc&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; cv::Mat &amp;amp;src_img)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat res_img = cv::Mat::zeros(src_img.size(), CV_8UC1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt; src_img.rows - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j &amp;lt; src_img.cols - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            res_img.at&amp;lt;uchar&amp;gt;(i, j) = cv::saturate_cast&amp;lt;uchar&amp;gt;(src_img.at&amp;lt;uchar&amp;gt;(i, j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                + src_img.at&amp;lt;uchar&amp;gt;(i, j) - src_img.at&amp;lt;uchar&amp;gt;(i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                + src_img.at&amp;lt;uchar&amp;gt;(i, j) - src_img.at&amp;lt;uchar&amp;gt;(i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                + src_img.at&amp;lt;uchar&amp;gt;(i, j) - src_img.at&amp;lt;uchar&amp;gt;(i, j - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                + src_img.at&amp;lt;uchar&amp;gt;(i, j) - src_img.at&amp;lt;uchar&amp;gt;(i, j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res_img;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用测试 指针函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;cv::Mat &lt;span class=&quot;title&quot;&gt;testFunc2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; cv::Mat &amp;amp;src_img)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat res_img = cv::Mat::zeros(src_img.size(), CV_8UC1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt; src_img.rows - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; uchar* p_row_pre = src_img.ptr&amp;lt;uchar&amp;gt;(i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; uchar* p_row_cur = src_img.ptr&amp;lt;uchar&amp;gt;(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; uchar* p_row_next = src_img.ptr&amp;lt;uchar&amp;gt;(i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        uchar* p_row_res = res_img.ptr&amp;lt;uchar&amp;gt;(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j &amp;lt; src_img.cols - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            *p_row_res++ = cv::saturate_cast&amp;lt;uchar&amp;gt;(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; * p_row_cur[j]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                - p_row_cur[j&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;] - p_row_cur[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] - p_row_pre[j] - p_row_next[j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res_img;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 设置 要显示的图像路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; lena_png = &lt;span class=&quot;string&quot;&gt;&quot;./TestImages/lena.png&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat src_img = cv::imread(lena_png);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::cvtColor(src_img, src_img, cv::COLOR_BGR2GRAY);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 测试索引方式进行 锐化运算&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; t = (&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;)cv::getTickCount();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat res_img = testFunc(src_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t = ((&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;)cv::getTickCount() - t) / cv::getTickFrequency();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;sharpen-index: \t\t&quot;&lt;/span&gt; &amp;lt;&amp;lt; t &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 测试 指针方式进行 锐化运算&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t = (&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;)cv::getTickCount();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res_img = testFunc2(src_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t = ((&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;)cv::getTickCount() - t) / cv::getTickFrequency();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;sharpen-pointer: \t&quot;&lt;/span&gt; &amp;lt;&amp;lt; t &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat kernel = (cv::Mat_&amp;lt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;&amp;gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::Mat res_img2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 测试 filter 2D 算法时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t = (&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;)cv::getTickCount();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::filter2D(src_img, res_img2, src_img.depth(), kernel);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t = ((&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;)cv::getTickCount() - t) / cv::getTickFrequency();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;sharpen-filter: \t&quot;&lt;/span&gt; &amp;lt;&amp;lt; t &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::imshow(&lt;span class=&quot;string&quot;&gt;&quot;src_img&quot;&lt;/span&gt;, src_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::imshow(&lt;span class=&quot;string&quot;&gt;&quot;res_img&quot;&lt;/span&gt;, res_img);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::imshow(&lt;span class=&quot;string&quot;&gt;&quot;res_img2&quot;&lt;/span&gt;, res_img2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cv::waitKey(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// return a.exec();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;算法实现上很简单, 就是我们上面提到得到方法, 结果以是接近一致的, 但是时间上差的还是比较多,  使用 &lt;code&gt;filter2D&lt;/code&gt; 的方式访问得到的图像还是比较好看的, 运行时间也是要比我们自己通过索引方式进行的算法要快很很多的,  但是相比我们使用指针还是有所不如, &lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sharpen-index:          0.0747024 s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sharpen-pointer:        0.0040774 s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sharpen-filter:         0.0416613 s&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们在 &lt;code&gt;modules\imgproc\src\filter.dispatch.cpp:1403&lt;/code&gt; 的位置看到了 &lt;code&gt;filter2D&lt;/code&gt; 函数的定义&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;filter2D&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(InputArray _src, OutputArray _dst, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ddepth,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;              InputArray _kernel, Point anchor0,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;              &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; delta, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; borderType)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;相应的我们去看 调用图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/小书匠/1587964861606.png&quot; alt=&quot;filter2D 函数调用图&quot;&gt;&lt;/p&gt;
&lt;p&gt;函数的主要调用使用了加速层的&lt;code&gt;modules\imgproc\src\filter.dispatch.cpp:1307&lt;/code&gt; 处的 &lt;code&gt;hal::filter2D&lt;/code&gt; 函数&lt;br&gt;这里涉及的部分还比较多, 可能也是由于调用的更底层的以及做了更多的边缘处理的原因 导致实际上花费的时间也更加的长, &lt;/p&gt;
&lt;p&gt;这里暂时不去深究, 如果有机会再做进一步分析&lt;/p&gt;
    
    </summary>
    
    
      <category term="opencv" scheme="https://schen1024.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://schen1024.github.io/tags/opencv/"/>
    
      <category term="c++" scheme="https://schen1024.github.io/tags/c/"/>
    
      <category term="qt" scheme="https://schen1024.github.io/tags/qt/"/>
    
  </entry>
  
</feed>
